[
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/2023%E5%BC%80%E6%94%BE%E5%8E%9F%E5%AD%90%E5%85%A8%E7%90%83%E5%BC%80%E6%BA%90%E5%B3%B0%E4%BC%9A%EF%BC%8C%E8%9A%82%E8%9A%81%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%BC%80%E6%BA%90%E4%B8%9A%E5%86%85%E9%A6%96%E4%B8%AA%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%B5%81%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E.md",
        "chunks": [
            {
                "content": "# 2023开放原子全球开源峰会，蚂蚁图计算平台开源业内首个工业级流图计算引擎\n\n6月11日，2023开放原子全球开源峰会在北京开幕。本次峰会以“开源赋能，普惠未来”为主题。在高峰论坛上，蚂蚁技术研究院院长、图计算负责人陈文光宣布开源 TuGraph 图计算平台核心成员——工业级流式图计算引擎 TuGraph Analytics。\n\n去年9月，蚂蚁集团开源了 TuGraph 图计算平台中的图数据库 TuGraph DB。这次开源是 TuGraph 图计算平台的又一次开源升级，进一步加大了蚂蚁在图计算基础软件领域的开放力度，也是通过开放协同促进科技创新的实际行动。\n\n图（Graph）是一种抽象的数据结构，由顶点和边构成。图计算是一种以图结构建模的算法模型，可对大规模数据进行关系挖掘和复杂计算，实现知识推理和事件溯源。图计算目前已广泛应用在金融、政务、医疗等领域，备受全球研发机构和顶尖科技公司关注。流式图计算是一种将流式计算和图计算结合的交叉创新，融合了流式计算的高度实效性和图计算的灵活性，攻坚难度极高。据了解，蚂蚁从2015年开始探索图计算，布局了图数据库、流式图计算引擎、图学习等相关技术，打造了世界规模领先的图计算集群，于业界首创了工业级流式图计算引擎，多次问鼎图数据库行业权威测试 LDBC 世界冠军并保持世界纪录。此次开源的工业级流式图计算引擎是蚂蚁从2017年开始布局打造，经过五年多工业级应用大考，流式图计算做到了在千亿数据规模的“图”上秒级延迟计算，是蚂蚁风控的核心基础技术，成功解决了金融场景风险分析难、识别率低、时效性差等业界难题。"
            },
            {
                "content": "图（Graph）是一种抽象的数据结构，由顶点和边构成。图计算是一种以图结构建模的算法模型，可对大规模数据进行关系挖掘和复杂计算，实现知识推理和事件溯源。图计算目前已广泛应用在金融、政务、医疗等领域，备受全球研发机构和顶尖科技公司关注。流式图计算是一种将流式计算和图计算结合的交叉创新，融合了流式计算的高度实效性和图计算的灵活性，攻坚难度极高。据了解，蚂蚁从2015年开始探索图计算，布局了图数据库、流式图计算引擎、图学习等相关技术，打造了世界规模领先的图计算集群，于业界首创了工业级流式图计算引擎，多次问鼎图数据库行业权威测试 LDBC 世界冠军并保持世界纪录。此次开源的工业级流式图计算引擎是蚂蚁从2017年开始布局打造，经过五年多工业级应用大考，流式图计算做到了在千亿数据规模的“图”上秒级延迟计算，是蚂蚁风控的核心基础技术，成功解决了金融场景风险分析难、识别率低、时效性差等业界难题。\n\n图计算是下一代人工智能关键核心技术。中国工程院院士郑纬民曾指出，“高性能图计算是当前全球人工智能竞争的战略性制高点，我们要加快攻克技术、突破产业瓶颈，防止在高性能图计算这一关键技术领域再被卡脖子”。而开源是共享科技成果，加速先进技术落地的最快路径。陈文光强调，开源是蚂蚁的核心技术战略，也是面向数字化未来可持续创新的动力。此次流式图计算引擎开源，是延续蚂蚁开源核心基础技术的实际动作，希望通过开放成熟的图计算技术，服务更广阔的数字化产业，向世界输出中国科技公司的前沿技术影响力。未来，蚂蚁集团也愿意携手行业伙伴共同突破技术创新，繁荣开源生态。据了解，蚂蚁开源聚焦于数据库、云原生、中间件等基础软件领域，积累了近100个社区头部开源项目、近1600个开源仓库、9大核心开源项目，如“2022世界人工智能大会镇馆之宝”隐语隐私计算技术栈、分布式数据库 OceanBase、行业首个通过商用密码产品认证的密码学技术“铜锁”等自研核心技术。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/3%E6%9C%8830%E6%97%A5_TuGraph_%E7%A4%BE%E5%8C%BA_Meetup_%E2%80%9C%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%99%BA%E8%83%BD%E5%8C%96%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%8E%A2%E7%B4%A2%E2%80%9D.md",
        "chunks": [
            {
                "content": "# 3月30日 TuGraph 社区 Meetup “图数据库智能化建设与探索”\n\nTuGraph 社区 Meetup “图数据库智能化建设与探索”在北京顺利举办，探讨大模型时代下的图数据库智能化。\n\n## 01. 技术分享｜TuGraph计算引擎模型推理系统设计与优化\n\n“虽然传统的基于迭代的算法能够解决我们现实生活中的大多数问题，但随着业务需求的不断发展和现实问题的日渐复杂化，这些算法往往难以满足某些具体的需求。尤其是当规模和维度日益增长、数据越发密集时，我们很难利用这种传统的方法去提取到更加关键的一些信息，或者说是我们从人的视角上更难理解的一些信息。因此，由于图结构在表达能力上的优势，结合机器学习分析技术，图算法近年来引起了广泛关注，并在业界落地和取得了较好的商业价值。”\n\n## 02. 技术分享｜TuGraph-DB兼容Neo4j客户端：Bolt协议设计与实现\n\n“兼容Neo4j客户端的最大优势在于生态支持。以客户端为例，Neo4j官方自身支持五种编程语言的客户端，社区又贡献了两种，共计七种语言的客户端得以直接使用。此外，还有一系列与上下游生态相接的组件，如与Apache Spark或Apache Kafka的连接，都有现成的代码可供利用。在编程框架方面，特别是Java，例如OGM（Object-Graph Mapping，对象图映射）以及一些业务开发框架，如Spring，这些所需的相关代码都已现成，无需重新编写。这种做法极大地节约了研发资源，我们可以将这些资源重新投入到提升数据库本身能力上。”\n\n## 03. 技术分享｜知识图谱语义框架SPG及图谱推理\n\n“当前，我们正处于图谱技术发展的第三阶段，这一阶段的核心是将图谱与大型模型相结合。目标转向了知识的标准化、跨领域数据的联通与复用。随着这个阶段的深入，简单地在推理过程中融入文本概念和信息，或者是加入交易与社交的实体关系，已经不能明显提升推理效果了。关键的做法应当是结合实体信息的多元素特征进行深度协作，从而更精准地关联相关性，揭示那些稀疏的实体间关系，并实现意义解释的密集化。”\n\n## 04. 技术分享｜CStore Compaction模块的设计与优化"
            },
            {
                "content": "## 03. 技术分享｜知识图谱语义框架SPG及图谱推理\n\n“当前，我们正处于图谱技术发展的第三阶段，这一阶段的核心是将图谱与大型模型相结合。目标转向了知识的标准化、跨领域数据的联通与复用。随着这个阶段的深入，简单地在推理过程中融入文本概念和信息，或者是加入交易与社交的实体关系，已经不能明显提升推理效果了。关键的做法应当是结合实体信息的多元素特征进行深度协作，从而更精准地关联相关性，揭示那些稀疏的实体间关系，并实现意义解释的密集化。”\n\n## 04. 技术分享｜CStore Compaction模块的设计与优化\n\n“TuGraph Analytics本质上是一款图分析OLAP数据库。CStore作为一个单机版存储引擎，提供了坚实的存储基础。同时，RocksDB也可以作为TuGraph Analytics的存储基础。我们采用LDBC提供的通用社交网络图数据集进行了基准测试，测试涉及让TuGraph Analytics分别连结RocksDB以及我们自有版本的CStore进行分析。在同步与异步compaction（数据压缩整理）两种方式下进行了读写性能测试：同步方式意味着数据写入完成后进行compaction，完成之后再进行读性能测试；异步方式则是写入和compaction同时进行，写入完成后立即测试读性能。在这两种情境下，使用CStore的TuGraph Analytics的读性能超过了使用RocksDB的三倍以上。”\n\n## 05. 社区规划｜TuGraph 社区技术路线\n\n最后是展望未来环节，TuGraph 开源负责人范志东与大家分享了大模型时代的图计算要做些什么，包括Q2即将推出的开源数据分析工具 OSGraph，Q3即将开源的 TuGraph 研发平台 TuGraphMaker，结合大模型的“与图对话”工具 ChatTuGraph 等项目。\n\n## 06. 圆桌讨论｜图技术、图生态、图智能"
            },
            {
                "content": "## 05. 社区规划｜TuGraph 社区技术路线\n\n最后是展望未来环节，TuGraph 开源负责人范志东与大家分享了大模型时代的图计算要做些什么，包括Q2即将推出的开源数据分析工具 OSGraph，Q3即将开源的 TuGraph 研发平台 TuGraphMaker，结合大模型的“与图对话”工具 ChatTuGraph 等项目。\n\n## 06. 圆桌讨论｜图技术、图生态、图智能\n\n在自由讨论环节，TuGraph 布道师戚仕鹏邀请了几位 TuGraph 的老朋友一起聊聊图技术、图生态、图智能。包括中国开源先锋人物、华为产业发展专家、Rust 技术专家马全一老师，北京大学前沿交叉学科研究院数据科学博士庞悦，蚂蚁集团知识图谱专家王少飞，以及TuGraph 开源负责人范志东。各位老师就为什么开源、图技术的未来与学术热点、图与AI等话题进行了精彩讨论。2024年，TuGraph 将努力更贴近客户，更拥抱开源，更关注生态。欢迎大家继续关注！"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/DSL%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.md",
        "chunks": [
            {
                "content": "# DSL原理介绍\n\n## GeaFlow DSL架构\n\nGeaFlow DSL整体架构如下图所示：\n\nDSL层是一个典型的编译器技术架构，即语法分析、语义分析、中间代码生成(IR)、代码优化、目标代码生成（OBJ）的流程。\n\n- **语言设计**：GeaFlow设计了SQL+GQL的融合语法，解决了图+表一体化分析的诉求。\n- **语法分析**：通过扩展Calcite的SqlNode和SqlOperator，实现SQL+GQL的语法解析器，生成统一的语法树信息。\n- **语义分析**：通过扩展Calcite的Scope和Namespace，实现自定义Validator，对语法树进行约束语义检查。\n- **中间代码生成**：通过扩展Calcite的RelNode，实现图上的Logical RelNode，用于GQL语法的中间表示。\n- **代码优化**：优化器实现了大量的优化规则（RBO）用于提升执行性能，未来也会引入CBO。\n- **目标代码生成**：代码生成器Converter负责将Logical RelNode转换为Physical RelNode，即目标代码。Physical RelNode可以直接翻译为Graph/Table上的API调用。\n- **自定义函数**：GeaFlow提供了大量的内置系统函数，用户也可以根据需要注册自定义函数。\n- **自定义插件**：GeaFlow允许用户扩展自己的Connector类型，以支持不同的数据源和数据格式。\n\n## DSL主要执行流程\n\nDSL的主要执行流程如下图所示：\n\nDSL文本首先经过Parser解析生成AST语法树，然后再经过Validator校验器做语义检查和类型推导生成校验后的AST语法树。接着通过Logical Plan转换器生成图表一体的逻辑执行计划。逻辑执行计划通过优化器进行优化处理生成优化后的逻辑执行计划，接下来由物理执行计划转换器转换成物理执行计划，物理执行计划通过DAG Builder生成图表一体的物理执行逻辑。GeaFlow DSL采用有两级DAG结构来描述图表一体的物理执行逻辑。\n\n## 两级DAG物理执行计划\n\n和传统的分布式表数据处理引擎Storm、Flink和Spark的系统不同，GeaFlow是一个流图一体的分布式计算系统。其物理执行计划采用图表两级DAG结构，如下图所示："
            },
            {
                "content": "## DSL主要执行流程\n\nDSL的主要执行流程如下图所示：\n\nDSL文本首先经过Parser解析生成AST语法树，然后再经过Validator校验器做语义检查和类型推导生成校验后的AST语法树。接着通过Logical Plan转换器生成图表一体的逻辑执行计划。逻辑执行计划通过优化器进行优化处理生成优化后的逻辑执行计划，接下来由物理执行计划转换器转换成物理执行计划，物理执行计划通过DAG Builder生成图表一体的物理执行逻辑。GeaFlow DSL采用有两级DAG结构来描述图表一体的物理执行逻辑。\n\n## 两级DAG物理执行计划\n\n和传统的分布式表数据处理引擎Storm、Flink和Spark的系统不同，GeaFlow是一个流图一体的分布式计算系统。其物理执行计划采用图表两级DAG结构，如下图所示：\n\n外层DAG包含表处理相关的算子以及图处理的迭代算子，为物理执行逻辑的主体部分，将图表的计算逻辑链接起来。内层DAG则将图计算的逻辑通过DAG方式展开，代表了图迭代计算具体执行方式."
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/Framework%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.md",
        "chunks": [
            {
                "content": "# Framework原理介绍\n\n## 架构图\nGeaFlow Framework的架构如下图所示：\n\n高阶API：GeaFlow通过Environment接口适配异构的分布式执行环境（K8S、Ray、Local），使用Pipeline封装了用户的数据处理流程，使用Window抽象统一了流处理（无界Window）和批处理（有界Window）。Graph接口提供了静态图和动态图（流图）上的计算API，如append/snapshot/compute/traversal等，Stream接口提供了统一流批处理API，如map/reduce/join/keyBy等。\n\n逻辑执行计划：逻辑执行计划信息统一封装在PipelineGraph对象内，将高阶API对应的算子（Operator）组织在DAG中，算子一共分为5大类：SourceOperator对应数据源加载、OneInputOperator/TwoInputOperator对应传统的数据处理、IteratorOperator对应静态/动态图计算。DAG中的点（PipelineVertex）记录了算子（Operator）的关键信息，如类型、并发度、算子函数等信息，边（PipelineEdge）则记录了数据shuffle的关键信息，如Partition规则（forward/broadcast/key等）、编解码器等。\n\n物理执行计划：物理执行计划信息统一封装在ExecutionGraph对象内，并支持二级嵌套结构，以尽可能将可以流水线执行的子图（ExecutionVertexGroup）结构统一调度。图中示例的物理执行计划DAG被划分为三部分子图结构分别执行。\n\n调度器：GeaFlow设计了基于Cycle的调度器（CycleScheduler）实现对流、批、图的统一调度，调度过程通过事件驱动模型触发。物理执行计划中的每部分子图都会被转换为一个ExecutionCycle对象，调度器会向Cycle的头结点（Head）发送Event，并接收Cycle尾结点（Tail）的发回的Event，形成一个完整的调度闭环。对于流处理，每一轮Cycle调度会完成一个Window的数据的处理，并会一直不停地执行下去。对于批处理，整个Cycle调度仅执行一轮。对于图处理，每一轮Cycle调度会完成一次图计算迭代。"
            },
            {
                "content": "物理执行计划：物理执行计划信息统一封装在ExecutionGraph对象内，并支持二级嵌套结构，以尽可能将可以流水线执行的子图（ExecutionVertexGroup）结构统一调度。图中示例的物理执行计划DAG被划分为三部分子图结构分别执行。\n\n调度器：GeaFlow设计了基于Cycle的调度器（CycleScheduler）实现对流、批、图的统一调度，调度过程通过事件驱动模型触发。物理执行计划中的每部分子图都会被转换为一个ExecutionCycle对象，调度器会向Cycle的头结点（Head）发送Event，并接收Cycle尾结点（Tail）的发回的Event，形成一个完整的调度闭环。对于流处理，每一轮Cycle调度会完成一个Window的数据的处理，并会一直不停地执行下去。对于批处理，整个Cycle调度仅执行一轮。对于图处理，每一轮Cycle调度会完成一次图计算迭代。\n\n## 运行时组件\nGeaFlow运行时会拉起Client、Master、Driver、Container组件。当Client提交Pipeline给Driver后，会触发执行计划构建、分配Task（ResourceManagement提供资源）和调度。每个Container内可以运行多个Worker组件，不同Worker组件之间通过Shuffle模块交换数据，所有的Worker都需要定期向Master上报心跳（HeartbeatManagement），并向时序数据库上报运行时指标信息。另外GeaFlow运行时也提供了故障容忍机制（FailOver），以便在异常/中断后能继续执行。\n\n## 计算引擎\nGeaFlow计算引擎核心模块主要包括执行计划生成和优化、统一Cycle调度以及Worker运行时执行。下面就这几个核心模块进行介绍说明。\n\n### 执行计划\n针对流图场景提交的PipelineTask，构建统一的执行计划模型，并通过将不同的执行模式，以group方式聚合到一起，为调度提供统一执行单元。\n\n**PipelineGraph** 将用户api提交的PipelineTask构建出PipelineGraph: 将用户api转换为算子后对应一个vertex，vertex之间的数据依赖以edge表示。PipelineGraph只是将api构建为结构化的逻辑执行计划，没有物理执行的语义。"
            },
            {
                "content": "## 计算引擎\nGeaFlow计算引擎核心模块主要包括执行计划生成和优化、统一Cycle调度以及Worker运行时执行。下面就这几个核心模块进行介绍说明。\n\n### 执行计划\n针对流图场景提交的PipelineTask，构建统一的执行计划模型，并通过将不同的执行模式，以group方式聚合到一起，为调度提供统一执行单元。\n\n**PipelineGraph** 将用户api提交的PipelineTask构建出PipelineGraph: 将用户api转换为算子后对应一个vertex，vertex之间的数据依赖以edge表示。PipelineGraph只是将api构建为结构化的逻辑执行计划，没有物理执行的语义。\n\n**ExecutionGraph** 将PipelineGraph基于不同的计算模型，将一组可重复执行的vertex聚合到一起，构建对应的ExecutionGroup，每个group表示可以独立调度执行的单元，一个group可以由一个或者多个vertex构建，可以看做一个小的执行计划，group内部数据以pipeline模式交换，group之间数据以batch模式交换。group描述了具体的执行模式，支持嵌套，可以只执行一次，也可只执行多次，可以一次执行一个或者多个窗口的数据。group如下图所示。 ExecutionGroup最终会转换为调度执行的基本单元cycle。\n\n### 调度模型\n调度将基于ExecutionGraph定义的ExecutionGroup生成调度基本单元cycle。cycle描述为可循环执行的基本单元，包含输入，中间计算和数据交换，输出的描述。调度执行过程主要是：\n1. 将执行计划划分为一组cycle，cycle与cycle之间如果没有数据依赖，可以串行执行，也可以并行执行。\n2. 依据cycle调度数据策略，依次调度执行cycle。\n3. 直到所有cycle执行结束，返回调度执行结果。"
            },
            {
                "content": "### 调度模型\n调度将基于ExecutionGraph定义的ExecutionGroup生成调度基本单元cycle。cycle描述为可循环执行的基本单元，包含输入，中间计算和数据交换，输出的描述。调度执行过程主要是：\n1. 将执行计划划分为一组cycle，cycle与cycle之间如果没有数据依赖，可以串行执行，也可以并行执行。\n2. 依据cycle调度数据策略，依次调度执行cycle。\n3. 直到所有cycle执行结束，返回调度执行结果。\n\n每个cycle包含一组可被执行的ExecutionTask，每个task可以被分发到远程执行。一个cycle内的所有execution task可以分为如下：\n- **head task**: cycle数据流的起点，调度向head task发送一轮执行的event，然后从source，或者上一个cycle输出中读取数据，处理后发送给下游。\n- **tail task**: cycle数据流的结尾，处理完数据后，向调度发送event，表示完成一轮计算。\n- **其余非head/tail task**: 中间执行task，接收上游输入数据，处理后直接发送给下游执行。\n\ncycle调度执行的过程，就是不断发送event给head，并从tail收到返回event的过程，整个过程类似一个“循环”。调度根据不同的cycle类型，初始化调度状态，调度的过程也是状态变迁的过程，根据收到的event，决定下一轮要发送给head的event类型。"
            },
            {
                "content": "每个cycle包含一组可被执行的ExecutionTask，每个task可以被分发到远程执行。一个cycle内的所有execution task可以分为如下：\n- **head task**: cycle数据流的起点，调度向head task发送一轮执行的event，然后从source，或者上一个cycle输出中读取数据，处理后发送给下游。\n- **tail task**: cycle数据流的结尾，处理完数据后，向调度发送event，表示完成一轮计算。\n- **其余非head/tail task**: 中间执行task，接收上游输入数据，处理后直接发送给下游执行。\n\ncycle调度执行的过程，就是不断发送event给head，并从tail收到返回event的过程，整个过程类似一个“循环”。调度根据不同的cycle类型，初始化调度状态，调度的过程也是状态变迁的过程，根据收到的event，决定下一轮要发送给head的event类型。\n\n### Runtime执行\n#### 整体介绍\nRuntime模块负责GeaFlow所有模式任务（包括流批、静态/动态图）的具体计算和执行。其整个worker流程如下：\n1. Scheduler调度器负责将各种类型的Event发送给Container处理。\n2. Dispatcher（继承至AbstractTaskRunner）负责接收来自Scheduler发送的Event，然后将Event按照其workerId分发给指定的TaskRunner进行处理。\n3. TaskRunner（也继承至AbstractTaskRunner）负责从taskQueue中获取TASK(Event)，具体Event事件将交由Task进行处理，其整个生命周期包括：创建、处理及结束，对于异常的Task，可以直接中断。\n   - Task创建和初始化会根据CreateTaskEvent事件来完成，Task生命周期结束会根据DestroyTaskEvent事件来完成。\n   - 其它类型的Event，都将通过相应的CommandEvent的execute()来完成具体计算语义层面的逻辑（例如：根据InitCycleEvent事件Worker将进行上下游依赖构建；根据LaunchSourceEvent事件Worker将触发source开始读数据等）。"
            },
            {
                "content": "当前Task中的TaskContext核心数据结构，主要包括：负责执行计算的Worker、负责下游节点从上游异步读取数据的FetchService以及负责将执行Worker产生的数据向下游输出的EmitterService。\n- **Worker**：其主要负责流图数据的对齐处理以及将每批处理结束后相应的DoneEvent callback回Scheduler，Scheduler依据相应的DoneEvent进行后续的调度逻辑。\n- **FetchService**：负责异步的从上游channel中Pull数据，并将其通过worker注册的Listener，将数据放入worker processing队列中。\n- **EmitterService**：负责将Worker产生的数据进行partition写入到对应的Channel中。\n\n#### Command Event\nCommand Event分为两种：\n- 普通的Command Event，不带具体的execute执行逻辑，通常用于Trigger Task或Cycle进行生命周期的开始和结束；\n- 可执行的Command Event，自身具备execute执行逻辑，例如用于Cycle的初始化、Source节点的数据读取、处理节点的计算、Cycle结束后的清理等等。\n\n在调度模块中，会将各种类型的Event构建成一个State Machine，用于整个调度任务的生命周期管理。开发者可以根据设计需要扩展Event以及实现对应的execute计算逻辑，同时加入到State Machine中，Scheduler就可以自动将其按照期望的方式进行调度和执行。\n\n### 容错和异常恢复\n#### 集群组件容错\n对于运行时的所有组件进程，比如master/driver/container,都基于context初始化和运行。在新创建进程时，首先构建进程需要的context，每个进程在初始化时将context做持久化。当进程异常重启后，首先恢复context，然后基于context重新初始化进程。"
            },
            {
                "content": "#### Command Event\nCommand Event分为两种：\n- 普通的Command Event，不带具体的execute执行逻辑，通常用于Trigger Task或Cycle进行生命周期的开始和结束；\n- 可执行的Command Event，自身具备execute执行逻辑，例如用于Cycle的初始化、Source节点的数据读取、处理节点的计算、Cycle结束后的清理等等。\n\n在调度模块中，会将各种类型的Event构建成一个State Machine，用于整个调度任务的生命周期管理。开发者可以根据设计需要扩展Event以及实现对应的execute计算逻辑，同时加入到State Machine中，Scheduler就可以自动将其按照期望的方式进行调度和执行。\n\n### 容错和异常恢复\n#### 集群组件容错\n对于运行时的所有组件进程，比如master/driver/container,都基于context初始化和运行。在新创建进程时，首先构建进程需要的context，每个进程在初始化时将context做持久化。当进程异常重启后，首先恢复context，然后基于context重新初始化进程。\n\n#### 作业异常恢复\n- **作业分布式快照**: 调度器根据当前自身调度状态，确定对运行中的任务发送新的windowId，触发对新窗口的计算。当每个算子对应窗口计算结束后，如果需要对当前窗口上下文做快照，则将算子内对应状态持久化到存储中。最终调度器收到某个窗口的所有任务执行结束的消息后，也会按需要对该调度元信息做一次快照并持久化，才标志这个窗口的处理最终成。当调度和算子恢复到这个窗口上下文时，则可以基于该窗口继续执行。\n\n- **快照持久化**: 在一个window计算完成做一次快照时，可以选择快照存储的方式。目前可选MEMORY，ROCKSDB, JDBC。\n\n- **状态恢复**: 快照存储是分布式的，每个组件，调度和算子之间各自存储并持久化。在恢复时，首先调度先从存储中恢复上一次完成执行的windowId，并调度的上下文恢复到对应windowId对应的快照。然后对所有worker发送rollback指令，每个worker恢复到指定窗口上下文。最后由调度开始继续发送执行任务，从恢复状态基础上继续执行。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/GeaFlow%E7%AE%80%E4%BB%8B.md",
        "chunks": [
            {
                "content": "# GeaFlow简介\n\n## GeaFlow起源\n\n早期的大数据分析主要以离线处理为主，以Hadoop为代表的技术栈很好的解决了大规模数据的分析问题。然而数据处理的时效性不足， 很难满足高实时需求的场景。以Storm为代表的流式计算引擎的出现则很好的解决了数据实时处理的问题，提高了数据处理的时效性。 然而，Storm本身不提供状态管理的能力， 对于聚合等有状态的计算显得无能为力。Flink 的出现很好的弥补了这一短板，通过引入状态管理以及Checkpoint机制，实现了高效的有状态流计算能力。\n\n随着数据实时处理场景的丰富，尤其是在实时数仓场景下，实时关系运算(即Stream Join) 越来越多的成为数据实时化的难点。Flink虽然具备优秀的状态管理能和出色的性能，然而在处理Join运算，尤其是3度以上Join时， 性能瓶颈越来越明显。由于需要在Join两端存放各个输入的数据状态，当Join变多时，状态的数据量急剧扩大，性能也变的难以接受。 产生这个问题的本质原因是Flink等流计算系统以表作为数据模型，而表模型本身是一个二维结构，不包含关系的定义和关系的存储， 在处理关系运算时只能通过Join运算方式实现，成本很高。\n\n在蚂蚁的大数据应用场景中，尤其是金融风控、实时数仓等场景下，存在大量Join运算，如何提高Join 的时效性和性能成为我们面临的重要挑战，为此我们引入了图模型。图模型是一种以点边结构描述实体关系的数据模型，在图模型里面，点代表实体， 边代表关系，数据存储层面点边存放在一起。因此，图模型天然定义了数据的关系同时存储层面物化了点边关系。基于图模型，我们实现了新一代实时计算 引擎GeaFlow，很好的解决了复杂关系运算实时化的问题。目前GeaFlow已广泛应用于数仓加速、金融风控、知识图谱以及社交网络等场景。\n\n## 技术架构"
            },
            {
                "content": "在蚂蚁的大数据应用场景中，尤其是金融风控、实时数仓等场景下，存在大量Join运算，如何提高Join 的时效性和性能成为我们面临的重要挑战，为此我们引入了图模型。图模型是一种以点边结构描述实体关系的数据模型，在图模型里面，点代表实体， 边代表关系，数据存储层面点边存放在一起。因此，图模型天然定义了数据的关系同时存储层面物化了点边关系。基于图模型，我们实现了新一代实时计算 引擎GeaFlow，很好的解决了复杂关系运算实时化的问题。目前GeaFlow已广泛应用于数仓加速、金融风控、知识图谱以及社交网络等场景。\n\n## 技术架构\n\nGeaFlow整体架构如下所示：\n- **DSL层**：即语言层。GeaFlow设计了SQL+GQL的融合分析语言，支持对表模型和图模型统一处理。\n- **Framework层**：即框架层。GeaFlow设计了面向Graph和Stream的两套API支持流、批、图融合计算，并实现了基于Cycle的统一分布式调度模型。\n- **State层**：即存储层。GeaFlow设计了面向Graph和KV的两套API支持表数据和图数据的混合存储，整体采用了Sharing Nothing的设计，并支持将数据持久化到远程存储。\n- **Console平台**：GeaFlow提供了一站式图研发平台，实现了图数据的建模、加工、分析能力，并提供了图作业的运维管控支持。\n- **执行环境**：GeaFlow可以运行在多种异构执行环境，如K8S、Ray以及本地模式。\n\n## 应用场景\n\n### 实时数仓加速\n\n数仓场景存在大量Join运算，在DWD层往往需要将多张表展开成一张大宽表，以加速后续查询。当Join的表数量变多时，传统的实时计算引擎很难保证Join的时效性和性能，这也成为目前实时数仓领域一个棘手的问题。基于GeaFlow的实时图计算引擎，可以很好的解决这方面的问题。 GeaFlow以图作为数据模型，替代DWD层的宽表，可以实现数据实时构图，同时在查询阶段利用图的点边物化特性，可以极大加速关系运算的查询。\n\n### 实时归因分析"
            },
            {
                "content": "## 应用场景\n\n### 实时数仓加速\n\n数仓场景存在大量Join运算，在DWD层往往需要将多张表展开成一张大宽表，以加速后续查询。当Join的表数量变多时，传统的实时计算引擎很难保证Join的时效性和性能，这也成为目前实时数仓领域一个棘手的问题。基于GeaFlow的实时图计算引擎，可以很好的解决这方面的问题。 GeaFlow以图作为数据模型，替代DWD层的宽表，可以实现数据实时构图，同时在查询阶段利用图的点边物化特性，可以极大加速关系运算的查询。\n\n### 实时归因分析\n\n在信息化的大背景下，对用户行为进行渠道归因和路径分析是流量分析领域中的核心所在。通过实时计算用户的有效行为路径，构建出完整的转化路径，能够快速帮助业务看清楚产品的价值，帮助运营及时调整运营思路。实时归因分析的核心要点是准确性和实效性。准确性要求在成本可控下保证用户行为路径分析的准确性;实效性则要求计算的实时性足够高，才能快速帮助业务决策。 基于GeaFlow流图计算引擎的能力可以很好的满足归因分析的准确性和时效性要求。如下图所示：\n\nGeaFlow首先通过实时构图将用户行为日志转换成用户行为拓扑图，以用户作为图中的点，与其相关的每个行为构建成从该用户指向埋点页面的一条边.然后利用流图计算能力分析提前用户行为子图，在子图上基于归因路径匹配的规则进行匹配计算得出该成交行为相应用户的归因路径，并输出到下游系统。\n\n### 实时反套现\n\n在信贷风控的场景下，如何进行信用卡反套现是一个典型的风控诉求。基于现有的套现模式分析，可以看到套现是一个环路子图，如何快速，高效在大图中快速判定套现，将极大的增加风险的识别效率。以下图为例，通过将实时交易流、转账流等输入数据源转换成实时交易图，然后根据风控策略对用户交易行为做图特征分析，比如环路检查等特征计算，实时提供给决策和监控平台进行反套现行为判定。通过GeaFlow实时构图和实时图计算能力，可以快速发现套现等异常交易行为，极大降低平台风险。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/Q%26A.md",
        "chunks": [
            {
                "content": "# Q&A\n\n## Q: TuGraph 的边是否支持索引？\nA: TuGraph 在引擎层支持边索引，可通过存储过程使用。Cypher的边索引功能正在开发支持中。\n\n## Q: TuGraph 单机的QPS是多少？\nA: 不同数据规模，不同查询操作的QPS差异较大，比如LDBC SNB典型图操作超过1.2万，参考测试结果：[TuGraph Blog](https://www.tugraph.org/blog?id=0)。\n\n## Q: 可视化文件 build 后如何更新到 tugraph 服务？\nA: 可视化文件打包后，需要进行以下操作进行替换。\n- 登录 tugraph 服务所在的服务或 docker 容器内。\n- 通过 `lgraph_server --help` 查看服务启动的配置文件所在目录。通常情况：`/usr/local/etc/lgraph.json`。\n- 查看 `/usr/local/etc/lgraph.json` 文件中 web 的配置目录。通常情况：`/usr/local/share/lgraph/resource`。\n- 将可视化打包后生成的文件夹中的内容全部替换到配置目录下 `/usr/local/share/lgraph/resource`。\n- 重新启动 tugraph 服务。\n\n## Q: 如何通过 npm run dev，连接已有的 tugraph 服务？\nA: 启动之前，需要修改文件 `.env.development` 中的 `VUE_APP_REQUESTURL` 的配置项。然后在通过 `npm run dev` 进行启动。\n示例：\n```\nNODE_ENV=development \nVUE_APP_TITLE=TuGraph(dev) \nVUE_APP_REQUESTURL=http://localhost:7070/\n```"
            },
            {
                "content": "## Q: 如何通过 npm run dev，连接已有的 tugraph 服务？\nA: 启动之前，需要修改文件 `.env.development` 中的 `VUE_APP_REQUESTURL` 的配置项。然后在通过 `npm run dev` 进行启动。\n示例：\n```\nNODE_ENV=development \nVUE_APP_TITLE=TuGraph(dev) \nVUE_APP_REQUESTURL=http://localhost:7070/\n```\n\n## Q: client 目前有哪些编程语言，是否支持 node js？\nA: 目前主要支持的编程语言有 c++, python, java；目前不支持 node js。使用 node 作为主要开发语言的用户，可以使用 tugraph 提供的 restful api 来调用。建议使用 Cypher 来封装调用接口。后续版本 restful api 将不再进行更新维护，只会保留登录、登出、刷新 token、cypher 调用这几个常见的 api。\n\n## Q: python client 是否支持 pip install？client 在哪里进行引用？\nA: 目前 python client 不支持 pip 进行安装。client 在目录 [TuGraph GitHub](https://github.com/TuGraph-db/tugraph-db/tree/master/src/client)。\n\n## Q: TuGraph 可以对接那些常用数据库？\nA: TuGraph通过DataX可以实现大部分主流数据库的导入导出，支持的数据库包括MySQL、Oracle、Hive 等。具体参考 [DataX GitHub](https://github.com/TuGraph-db/DataX)。"
            },
            {
                "content": "## Q: python client 是否支持 pip install？client 在哪里进行引用？\nA: 目前 python client 不支持 pip 进行安装。client 在目录 [TuGraph GitHub](https://github.com/TuGraph-db/tugraph-db/tree/master/src/client)。\n\n## Q: TuGraph 可以对接那些常用数据库？\nA: TuGraph通过DataX可以实现大部分主流数据库的导入导出，支持的数据库包括MySQL、Oracle、Hive 等。具体参考 [DataX GitHub](https://github.com/TuGraph-db/DataX)。\n\n## Q: 如何加载存储过程或算法包？\nA: 加载方式有两种：\n- 第一种：通过可视化页面的插件模块，通过交互操作完成加载。\n- 第二种：通过 cypher 语句实现存储过程的加载。\n```\nCALL db.plugin.loadPlugin(plugin_type::STRING, plugin_name::STRING, plugin_content::STRING, code_type::STRING, plugin_description::STRING, read_only::BOOLEAN) :: (::VOID)\n```\n\n## Q: 如何调用或执行存储过程？\nA: 可以使用 cypher 进行存储过程的执行或调用。\n```\nCALL db.plugin.callPlugin(plugin_type::STRING, plugin_name::STRING, param::STRING, timeout::DOUBLE, in_process::BOOLEAN) :: (success::BOOLEAN, result::STRING)\n```\n\n## Q: 开源内置的算法包在哪里？\nA: 代码地址 [TuGraph GitHub](https://github.com/TuGraph-db/tugraph-db/tree/master/plugins)。"
            },
            {
                "content": "## Q: 如何调用或执行存储过程？\nA: 可以使用 cypher 进行存储过程的执行或调用。\n```\nCALL db.plugin.callPlugin(plugin_type::STRING, plugin_name::STRING, param::STRING, timeout::DOUBLE, in_process::BOOLEAN) :: (success::BOOLEAN, result::STRING)\n```\n\n## Q: 开源内置的算法包在哪里？\nA: 代码地址 [TuGraph GitHub](https://github.com/TuGraph-db/tugraph-db/tree/master/plugins)。\n\n## Q: 如何使用 docker 镜像安装？\nA:\n- 确认本地是否有 docker 环境，可使用 `docker -v` 进行验证。如果没有请安装 docker，安装方式见 docker 官网文档 [Docker Install](https://docs.docker.com/install/)。\n- 下载 docker 镜像，下载方式可使用 `docker pull tugraph/tugraph-runtime-centos7`，也可以在官网下载页面进行下载 [TuGraph Download](https://www.tugraph.org/download) [注：下载的文件是 *.tar.gz 的压缩包，不用解压]。\n- 如果使用 `docker pull` 下载的镜像则不用导入镜像。如果使用官网下载的压缩包，则要使用 `docker load -i ./tugraph_x.y.z.tar` [注：x.y.z 是版本号的代替符，具体数值根据自己下载的版本进行改写]。\n- 启动 docker 容器：\n```\ndocker run -d -p 7070:7070 -p 9090:9090 --name tugraph_demo tugraph/tugraph-runtime-centos7 lgraph_server\n```\n[注：具体的镜像名称 tugraph/tugraph-runtime-centos7 要以本地实际镜像名称为准，可用过 `docker images` 命令查看]。"
            },
            {
                "content": "## Q: rpm 包和 deb 包安装后，启动 lgraph_server 服务。提示缺少 'liblgraph.so' 报错？\nA: 此问题主要是环境变量导致，需要配置环境变量。\n示例：\n```\nexport LD_LIBRARY_PATH=/usr/local/lib64\n```\n\n## Q: 是否支持不定长边的条件查询？\n示例：\n```\nMATCH p=(v)-[e:acted_in|:rate*1..3]-(v2) WHERE id(v) IN [3937] AND e.stars = 3 RETURN p\n```\nA: 目前还不支持不定长边的过滤查询。目前的代替方案只能是分开写。上面的示例，就需要从 1 跳到 3 跳都写一遍。\n\n## Q: 如何查询最短路径，shortestPath 函数如何使用？\nA: 使用示例如下（示例图谱：MovieDemo）\n```\nMATCH (n1 {name:'Corin Redgrave'}),(n2 {name:'Liam Neeson'})\nCALL algo.allShortestPaths(n1,n2) YIELD nodeIds,relationshipIds,cost\nRETURN nodeIds,relationshipIds,cost\n```\n详尽使用方案请参考官网文档 [TuGraph Documentation](https://www.tugraph.org/doc?version=V3.3.0&id=10000000000658658)。"
            },
            {
                "content": "## Q: 如何查询最短路径，shortestPath 函数如何使用？\nA: 使用示例如下（示例图谱：MovieDemo）\n```\nMATCH (n1 {name:'Corin Redgrave'}),(n2 {name:'Liam Neeson'})\nCALL algo.allShortestPaths(n1,n2) YIELD nodeIds,relationshipIds,cost\nRETURN nodeIds,relationshipIds,cost\n```\n详尽使用方案请参考官网文档 [TuGraph Documentation](https://www.tugraph.org/doc?version=V3.3.0&id=10000000000658658)。\n\n## Q: 查询语句 Where 后使用 and 进行拼接查询速度较慢，语句应如何优化改进？\n示例：\n```\nMATCH (n1),(n2) CALL algo.allShortestPaths(n1,n2)\nYIELD nodeIds,relationshipIds,cost\nWHERE id(n1) IN [0] AND id(n2) IN [3938]\nRETURN nodeIds,relationshipIds,cost\n```\nA: 目前 cypher 查询引擎正在优化中。现阶段语句改写可以通过 with 向下传递进行优化。\n示例：\n```\nMATCH (n1) WHERE id(n1) IN [0] WITH n1\nMATCH (n2) WHERE id(n2) IN [3938] WITH n1, n2\nCALL algo.allShortestPaths(n1,n2) YIELD nodeIds,relationshipIds,cost\nRETURN nodeIds,relationshipIds,cost\n```\n\n## Q: 如何查询任意跳的边？\nA: 使用 *..  \n示例：\n```\nMATCH p=(a)-[*..]-(b) WHERE id(a) IN [3] AND id(b) IN [19] RETURN p\n```"
            },
            {
                "content": "## Q: 如何查询任意跳的边？\nA: 使用 *..  \n示例：\n```\nMATCH p=(a)-[*..]-(b) WHERE id(a) IN [3] AND id(b) IN [19] RETURN p\n```\n\n## Q: 报错 \"User has reached the maximum number of tokens\" 后，怎么做？\nA: 这表明当前账号 Token 数量已达上限 10000 个。解决方法如下，任选其一：\n1. 登出不使用的 Token。\n2. 重新启动 TuGraph 服务，会清空所有 Token。\n3. Token 有效期默认为 24 小时，24 小时后会自动失效并删除。\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/State%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.md",
        "chunks": [
            {
                "content": "# State原理介绍\n\n## Geaflow 中的状态管理\nGeaflow 中的状态是指图、流计算过程中的直接计算节点的中间计算结果，此中间结果可能是经过组织后的源数据信息，也有可能是计算产生的一些结果。状态管理负责这些数据的存取以及一致性保障，它作为Geaflow数据中枢存在于系统中，它的功能模型、性能和可靠性直接影响着Geaflow的整个使用过程，是作为整个系统的底盘存在。\n\n从功能来看，它支持Geaflow实时、多模的动态图引擎，包括低延迟流图融合计算、高性能长周期图仿真、大规模动态图探索等等。  \n从计算模型来看，Geaflow 中的状态管理属于实时模型和图模型的结合，需要克服实时计算中，带有状态的处理机制，时延低，容错和恢复机制；另外它也需要解决图模型中数据复杂、关联度高，计算由数据驱动、中间结果大等问题。  \n从性能上看，状态管理需要解决在低成本，多场景、大规模数据的前提下实现高吞吐、低延迟的存储和查询能力。包括在万亿边的规模下的存取，较大的属性信息的存取，带有多种下推语义的随机访问和遍历访问等。  \n为此，我们有如下的架构图，整体结构上灵活可变、支持多种可插拔组件。\n\n### 架构图"
            },
            {
                "content": "从功能来看，它支持Geaflow实时、多模的动态图引擎，包括低延迟流图融合计算、高性能长周期图仿真、大规模动态图探索等等。  \n从计算模型来看，Geaflow 中的状态管理属于实时模型和图模型的结合，需要克服实时计算中，带有状态的处理机制，时延低，容错和恢复机制；另外它也需要解决图模型中数据复杂、关联度高，计算由数据驱动、中间结果大等问题。  \n从性能上看，状态管理需要解决在低成本，多场景、大规模数据的前提下实现高吞吐、低延迟的存储和查询能力。包括在万亿边的规模下的存取，较大的属性信息的存取，带有多种下推语义的随机访问和遍历访问等。  \n为此，我们有如下的架构图，整体结构上灵活可变、支持多种可插拔组件。\n\n### 架构图\n\nState API：提供了面向KV存储API，如get/put/delete等。以及面向图存储的API，如V/E/VE，以及点/边的add/update/delete等。  \nState执行层：通过KeyGroup的设计实现数据的Sharding和扩缩容能力，Accessor提供了面向不同读写策略和数据模型的IO抽象，StateOperator抽象了存储层SPI，如finish（刷盘）、archive（Checkpoint）、compact（压缩）、recover（恢复）等。另外，State提供了多种PushDown优化以加速IO访问效率。通过自定义内存管理和面向属性的二级索引也会提供大量的存储访问优化手段。  \nStore层：GeaFlow支持了多种存储系统类型，并通过StoreContext封装了Schema、序列化器，以及数据版本信息。这层涉及到内存数据结构如何真正映射到存储结构上。目前包括Redis、Rocksdb、CStore（GeaFlow自建存储系统）等存储引擎，各种不同的存储引擎通过SPI来提供服务，另外根据存储引擎的特点，他们可支持的数据模型可能不同，例如对Rocksdb所有的数据结构都需要映射到KV，而Redis天生就提供list/map等高阶的数据结构。  \n持久化层：GeaFlow State本身不提供持久化的能力，如果机器发生故障，磁盘损坏可能就会导致数据丢失。因此它需要依赖外部的组件来提供持久化存储，这里组件也是可插拔的，支持 HDFS/OSS/S3等分布式文件存储或对象存储。\n\n## State 运行流程\n在作业运行期间State的生命流程为："
            },
            {
                "content": "## State 运行流程\n在作业运行期间State的生命流程为：\n\n当FailOver的时候，会从最近一个持久化的数据恢复，以下是其详细流程。\n\n### State创建\nState所处理的数据已经是每个分区维度的，也就是已经经过框架层分好片了。\n\n所有的State申请的入口都是StateFactory，可以根据不同的Descriptor申请不同的State。\n\n- buildGraphState(GraphStateDescriptor, Configuration):GraphState\n- buildKeyValueState(KeyValueStateDescriptor, Configuration):KeyValueState\n- buildKeyListState(KeyListDescriptor, Configuration):KeyListState\n- buildKeyMapState(KeyMapStateDescriptor, Configuration):KeyMapState\n\nDescriptor 中需要申明基本的信息，包括State name，Store type等。不同的state name对应的 state 是相互隔离的，可以申请不同的 State 表示不同的场景，例如可以申请一个Memory Store State作为临时存储或者计算中介。\n\nStore type 的选择与存储性能也息息相关，例如对于Key State，如果底层Store支持 KMap 的方式则会直接使用到KMap的功能，可以进行增量的subkey操作；如果不支持则会转为 KV 模型的State，会对 Map 整体进行操作，这样无论读还是写都会放大很多。\n\n在创建完成后，我们还需要对state读写。\n\n### State 读写\n根据上文申请的不同State类型，具有不同的读写方式，文末部分会有介绍。\n\n### State 持久化\n在某一个计算任务中，如果有异常信息发生，例如机器故障，那么磁盘上存储的状态数据都会丢失。为了能够正常回滚，State还需要考虑持久化的能力，这样重新分配的机器可以拉取State数据继续进行计算。"
            },
            {
                "content": "Descriptor 中需要申明基本的信息，包括State name，Store type等。不同的state name对应的 state 是相互隔离的，可以申请不同的 State 表示不同的场景，例如可以申请一个Memory Store State作为临时存储或者计算中介。\n\nStore type 的选择与存储性能也息息相关，例如对于Key State，如果底层Store支持 KMap 的方式则会直接使用到KMap的功能，可以进行增量的subkey操作；如果不支持则会转为 KV 模型的State，会对 Map 整体进行操作，这样无论读还是写都会放大很多。\n\n在创建完成后，我们还需要对state读写。\n\n### State 读写\n根据上文申请的不同State类型，具有不同的读写方式，文末部分会有介绍。\n\n### State 持久化\n在某一个计算任务中，如果有异常信息发生，例如机器故障，那么磁盘上存储的状态数据都会丢失。为了能够正常回滚，State还需要考虑持久化的能力，这样重新分配的机器可以拉取State数据继续进行计算。\n\n在每个计算任务中，用户需要定期做checkpoint，持久化数据来保证状态数据安全。可以在某批任务结束后做，也可以在导数任务完成后，此处的时机应该和source offset保持一致，只有state checkpoint以及source offset都保存完成才说明这个作业的所有状态数据都持久化。\n\n### State 恢复\n当异常发生时，框架层会进行FailOver, state也会自动回滚到最新的状态。根据上述持久层的选择不同，会从相应的分布式文件存储或对象存储拉取State数据并加载。\n\n## State 类型\nState大体可以区分为Graph State 和 Key State，分别对应不同的数据结构，同时映射到Store层的不同存储模型，例如对于rocksdb 的 store type，将会有KV、Graph等不同类型的存储模型。\n\n### Graph State\nGraphState根据是否是动态图，我们又区分 StaticGraph 和 DynamicGraph。 区别在于 StaticGraph将整个图看做是一个完整的，所有操作都在一个完整图上进行。 而DynamicGraph认为图动态变化的，由一个个切片图构成，所有切片构成一个完整的图。"
            },
            {
                "content": "### State 恢复\n当异常发生时，框架层会进行FailOver, state也会自动回滚到最新的状态。根据上述持久层的选择不同，会从相应的分布式文件存储或对象存储拉取State数据并加载。\n\n## State 类型\nState大体可以区分为Graph State 和 Key State，分别对应不同的数据结构，同时映射到Store层的不同存储模型，例如对于rocksdb 的 store type，将会有KV、Graph等不同类型的存储模型。\n\n### Graph State\nGraphState根据是否是动态图，我们又区分 StaticGraph 和 DynamicGraph。 区别在于 StaticGraph将整个图看做是一个完整的，所有操作都在一个完整图上进行。 而DynamicGraph认为图动态变化的，由一个个切片图构成，所有切片构成一个完整的图。\n\n#### Static Graph State\nStaticGraphState API分成不同的几个部分，包括query、upsert、delete、manage。\n\n- query即图查询，允许用户灵活的查询GraphStatte，可以从点、边、点以及出边等多个角度进行查询，可以是随机查询、也可以是全局查询，可以增加不同的pushdown条件等等。最后的返回值也可以是迭代器或者list。\n\n- upsert即增加点或者边。\n\n- delete可以删除某个点或者id。\n\n- manage分成operator以及其他操作，operator是对state的数据操作，可以进行刷盘持久化或者恢复。其他操作包括summary以及metrics等信息的获取。\n\n#### Dynamic Graph State\nDynamicGraphState API 与 StaticGraphState 类似，但是每个点和边都会和一个版本号绑定。\n\n于此同时，DynamicGraphState还增加了版本信息相关的查询，可以获取某些点对应的所有版本或者最新版本，以及可以获取每个版本的具体值。\n\n### Key State\nKeyState API分成几个部分，包括 \n\n- KeyValueState \n- KeyListState \n- KeyMapState。"
            },
            {
                "content": "- query即图查询，允许用户灵活的查询GraphStatte，可以从点、边、点以及出边等多个角度进行查询，可以是随机查询、也可以是全局查询，可以增加不同的pushdown条件等等。最后的返回值也可以是迭代器或者list。\n\n- upsert即增加点或者边。\n\n- delete可以删除某个点或者id。\n\n- manage分成operator以及其他操作，operator是对state的数据操作，可以进行刷盘持久化或者恢复。其他操作包括summary以及metrics等信息的获取。\n\n#### Dynamic Graph State\nDynamicGraphState API 与 StaticGraphState 类似，但是每个点和边都会和一个版本号绑定。\n\n于此同时，DynamicGraphState还增加了版本信息相关的查询，可以获取某些点对应的所有版本或者最新版本，以及可以获取每个版本的具体值。\n\n### Key State\nKeyState API分成几个部分，包括 \n\n- KeyValueState \n- KeyListState \n- KeyMapState。\n\n分别对应不同的用户层数据结构。与GraphState类似，KeyState同样提供 query/upsert/delete/manage的能力，但query没有类似GraphState的接口提供复杂的查询语义信息。不同的State数据结构在查询和存储上有差异，例如kmap允许对单个subkey修改和查询，而kv是是整个value进行修改和查询。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/TuGraph-Analytics_%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E4%B9%8B_PageRank_%E7%AE%97%E6%B3%95.md",
        "chunks": [
            {
                "content": "# TuGraph-Analytics 图计算快速上手之 PageRank 算法\n\n## -TuGraph-Analytics 介绍-\n\nTuGraph-Analytics（下文简称GeaFlow）是蚂蚁集团开源的分布式实时图计算引擎，目前广泛应用于金融风控、社交网络、知识图谱以及数据应用等场景。GeaFlow的核心能力是流式图计算，流式图计算相比离线图计算提供了一种高时效性低延迟的图计算模式，更多详细内容参考GitHub介绍(https://github.com/TuGraph-family/tugraph-analytics).\n\nGeaFlow整体架构如下所示：\n\nGeaFlow整体架构从上往下包含以下几层：\n\n- **GeaFlow DSL**  \n  GeaFlow对用户提供图表融合分析语言，采用SQL + ISO/GQL方式。用户可以通过类似SQL编程的方式编写实时图计算任务。\n\n- **GraphView API**  \n  GeaFlow以GraphView为核心定义的一套图计算的编程接口,包含图构建、图计算以及Stream API接口。\n\n- **GeaFlow Runtime**  \n  GeaFlow运行时，包含GeaFlow图表算子、task调度、failover以及shuffle等核心功能。\n\n- **GeaFlow State**  \n  GeaFlow的图状态存储，用于存储图的点边数据。同时流式计算的状态如聚合状态也存放在State中。\n\n- **K8S Deployment**  \n  GeaFlow支持K8S的方式进行部署运行。\n\n- **GeaFlow Console**  \n  GeaFlow的管控平台，包含作业管理、元数据管理等功能。\n\n## -PageRank算法介绍-\n\nPageRank是图计算领域一个应用广泛的算法，由Google公司创始人之一拉里·佩奇与谢尔盖·布林在1998年发明，主要用于网页的排序。该算法基于网页之间相互引用的关系，将网页评分的思想引入到搜索引擎中，用于计算网页的重要度和排名。\n\nPageRank算法的核心思想是：一个网页的重要度是由其他网页对它的引用数量和质量决定的。如果一个网页被其他网页引用得多，那么它的重要度就越高。同时，如果一个网页的引用来源也很重要，那么它对被引用网页的贡献也会更大。"
            },
            {
                "content": "- **GeaFlow State**  \n  GeaFlow的图状态存储，用于存储图的点边数据。同时流式计算的状态如聚合状态也存放在State中。\n\n- **K8S Deployment**  \n  GeaFlow支持K8S的方式进行部署运行。\n\n- **GeaFlow Console**  \n  GeaFlow的管控平台，包含作业管理、元数据管理等功能。\n\n## -PageRank算法介绍-\n\nPageRank是图计算领域一个应用广泛的算法，由Google公司创始人之一拉里·佩奇与谢尔盖·布林在1998年发明，主要用于网页的排序。该算法基于网页之间相互引用的关系，将网页评分的思想引入到搜索引擎中，用于计算网页的重要度和排名。\n\nPageRank算法的核心思想是：一个网页的重要度是由其他网页对它的引用数量和质量决定的。如果一个网页被其他网页引用得多，那么它的重要度就越高。同时，如果一个网页的引用来源也很重要，那么它对被引用网页的贡献也会更大。\n\n实现PageRank算法的具体步骤包括：首先构建网页之间的链接关系图，然后对图进行迭代计算，直到收敛为止。在每一次迭代中，每个网页的得分都会被重新计算，并更新到下一次迭代中。最后，按照网页得分的大小对搜索结果进行排序，输出排名前几位的网页。如下有4个页面，A, B, C, D：\n\n以A点为例，其每一轮的PageRank值计算方法如下：\n\nPR(A) = d * (PR(D)/ 2 + PR(B)/1 + PR(C)/2) + (1- d)\n\n每一个点的PageRank值等于其入点的PageRank值除以入点出边数的加权和，其中d为0~1之间的修正系数。\n\nPageRank算法在搜索引擎中广泛应用，成为搜索引擎排名的重要算法之一。除此之外，PageRank算法的思想也在社交网络、推荐系统等领域得到了应用。\n\n## -TuGraph-Analytics 实现 PageRank-\n\n### 接口与实现\n\nTuGraph-Analytics支持在图查询里调用图算法，语法形式如下：\n\n```sql\nINSERT INTO tbl_result\nCALL page_rank() YIELD (vid, prValue)\nRETURN vid, prValue;\n```"
            },
            {
                "content": "以A点为例，其每一轮的PageRank值计算方法如下：\n\nPR(A) = d * (PR(D)/ 2 + PR(B)/1 + PR(C)/2) + (1- d)\n\n每一个点的PageRank值等于其入点的PageRank值除以入点出边数的加权和，其中d为0~1之间的修正系数。\n\nPageRank算法在搜索引擎中广泛应用，成为搜索引擎排名的重要算法之一。除此之外，PageRank算法的思想也在社交网络、推荐系统等领域得到了应用。\n\n## -TuGraph-Analytics 实现 PageRank-\n\n### 接口与实现\n\nTuGraph-Analytics支持在图查询里调用图算法，语法形式如下：\n\n```sql\nINSERT INTO tbl_result\nCALL page_rank() YIELD (vid, prValue)\nRETURN vid, prValue;\n```\n\n我们通过CALL语句调用具体的算法，通过YIELD定义算法的返回字段，比如page_rank算法返回点id和page rank值两个字段，则可以通过YIELD(vid, prValue)来表示。\n\nDSL里面实现一个图算法需要实现`AlgorithmUserFunction`接口，其定义如下：\n\n```java\n/**\n * Interface for the User Defined Graph Algorithm.\n * \n * @param  The id type for vertex.\n * @param  The message type for message send between vertices.\n */\npublic interface AlgorithmUserFunction extends Serializable {\n    /**\n     * Init method for the function\n     * @param context The runtime context.\n     * @param params  The parameters for the function.\n     */\n    void init(AlgorithmRuntimeContext context, Object[] params);"
            },
            {
                "content": "DSL里面实现一个图算法需要实现`AlgorithmUserFunction`接口，其定义如下：\n\n```java\n/**\n * Interface for the User Defined Graph Algorithm.\n * \n * @param  The id type for vertex.\n * @param  The message type for message send between vertices.\n */\npublic interface AlgorithmUserFunction extends Serializable {\n    /**\n     * Init method for the function\n     * @param context The runtime context.\n     * @param params  The parameters for the function.\n     */\n    void init(AlgorithmRuntimeContext context, Object[] params);\n\n    /**\n     * Processing method for each vertex and the messages it received.\n     */\n    void process(RowVertex vertex, Iterator messages);\n\n    /**\n     * Returns the output type for the function.\n     */\n    StructType getOutputType();\n}\n```\n\n### init\n\n算法的初始化接口，主要完成算法的一些初始化操作. PageRank的init方法实现如下："
            },
            {
                "content": "/**\n     * Returns the output type for the function.\n     */\n    StructType getOutputType();\n}\n```\n\n### init\n\n算法的初始化接口，主要完成算法的一些初始化操作. PageRank的init方法实现如下：\n\n```java\n@Override\npublic void init(AlgorithmRuntimeContext context, Object[] parameters) {\n    this.context = context;\n\t\n    if (parameters.length > 3) {\n        throw new IllegalArgumentException(\n            \"Only support zero or more arguments, false arguments \"\n                + \"usage: func([alpha, [convergence, [max_iteration]]])\");\n    }\n\t\n    // 修正系数，即前面介绍的参数d.\n    if (parameters.length > 0) {\n        alpha = Double.parseDouble(String.valueOf(parameters[0]));\n    }\n\t\n    // PR值更新阀值，当点的pr差值小于该值时，不再更新pr值.\n    if (parameters.length > 1) {\n        convergence = Double.parseDouble(String.valueOf(parameters[1]));\n    }\n\t\n    // 迭代次数\n    if (parameters.length > 2) {\n        iteration = Integer.parseInt(String.valueOf(parameters[2]));\n    }\n}\n```\n\n### process\n\n算法的主要处理逻辑，入参为当前Active点和要处理的消息，PageRank主要实现如下："
            },
            {
                "content": "```java\n@Override\npublic void process(RowVertex vertex, Iterator messages) {\n    ....\n\t\n    if (context.getCurrentIterationId() == 1L) {\n        // 首轮迭代设置pr初始值,并发送给出边,同时更新当前点的pr值。\n        double initValue = 1.0;\n        sendMessageToNeighbors(outEdges, initValue / outEdges.size());\n        ...\n        context.updateVertexValue(ObjectRow.create(initValue));\n    } else if (context.getCurrentIterationId() < iteration) {\n        double sum = 0.0;\n        while (messages.hasNext()) {\n            double input = (double) messages.next();\n            input = input > 0 ? input : 0.0;\n            sum += input;\n        }\n\t\t\n        // 计算当前迭代的pr值\n        double pr = (1 - alpha) + (sum * alpha);\n        double currentPr = (double) vertex.getValue().getField(0, DoubleType.INSTANCE);\n\t\t\n        if (Math.abs(currentPr - pr) > convergence) {\n            // pr值发送给出边目标点.\n            sendMessageToNeighbors(outEdges, pr / outEdges.size());\n        } \n        context.updateVertexValue(ObjectRow.create(pr));"
            },
            {
                "content": "input = input > 0 ? input : 0.0;\n            sum += input;\n        }\n\t\t\n        // 计算当前迭代的pr值\n        double pr = (1 - alpha) + (sum * alpha);\n        double currentPr = (double) vertex.getValue().getField(0, DoubleType.INSTANCE);\n\t\t\n        if (Math.abs(currentPr - pr) > convergence) {\n            // pr值发送给出边目标点.\n            sendMessageToNeighbors(outEdges, pr / outEdges.size());\n        } \n        context.updateVertexValue(ObjectRow.create(pr));\n    } else { // 到达最大迭代次数，结束本轮迭代，take最终计算结果.\n        double currentPr = (double) vertex.getValue().getField(0, DoubleType.INSTANCE);\n        context.take(ObjectRow.create(vertex.getId(), currentPr));\n        return;\n    }\n}\n```"
            },
            {
                "content": "### getOutputType\n\n定义算法返回类型，PageRank实现如下：\n\n```java\n@Override\npublic StructType getOutputType() {\n    return new StructType(\n        // id\n        new TableField(\"id\", LongType.INSTANCE, false),\n        // pr值\n        new TableField(\"pr\", DoubleType.INSTANCE, false)\n    );\n}\n```\n\n### 算法注册\n\n算法实现通过注解来定义算法名称，如下所示：\n\n```java\n@Description(name = \"page_rank\", description = \"built-in udga for PageRank\")\npublic class PageRank implements AlgorithmUserFunction {\n}\n```\n\n算法和UDF一样，需要注册或者创建后才能使用。DSL内置算法或者UDF在`BuildInSqlFunctionTable`中进行注册。对于非内置算法，可以通过`create function`语句来创建。\n\n```sql\nCreate function page_rank as 'com.antgroup.geaflow.dsl.udf.graph.PageRank';\n```\n\n## -总结-\n\n本文主要介绍实时图计算引擎GeaFlow的基本架构，然后介绍了图算法PageRank的基本原理以及在GeaFlow中的实现细节和使用方式。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/TuGraph_Analytics%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%9B%BE%E6%9F%A5%E8%AF%A2%EF%BC%9A%E8%AE%A9%E5%9B%BE%E6%89%80%E8%A7%81%E5%8D%B3%E6%89%80%E5%BE%97.md",
        "chunks": [
            {
                "content": "# TuGraph Analytics交互式图查询：让图所见即所得\n\nTuGraph Analytics提供了OLAP图分析能力，实现图上的交互式查询，用户在构图并导入数据之后，可以通过输入GQL语句对图查询分析，并以可视化的方式直观地展示点边结果。\n\n## OLAP架构\n\n在TuGraph Analytics OLAP架构中，主要以下组件:\n\n- **Client**: 用户通过Client提交查询语句, Client负责和Coordinator交互，发送查询请求。\n\n- **Coordinator**: 接收来自Client查询请求，将查询中的GQL语句进行解析、优化，构建查询的执行计划（执行计划的生成逻辑可参考《分布式图计算如何实现？带你一窥图计算执行计划》[1]），并将任务调度给Worker执行。\n\n- **Worker**: 具体分布式地执行任务的单元，接收到Coordinator发送的Pipeline，执行具体的计算和查询逻辑。\n\n- **Meta Service**: 服务注册管理，Coordinator启动后，会将服务的地址和端口向MetaService进行注册，Client提交查询时从MetaService获取Coordinator的服务地址，进行连接。目前支持http和rpc两种方式。\n\n组件间执行流程如下：\n\n## OLAP流程\n\n## 操作指南\n\n1. **定义图模型**\n   \n   以下图为例，图中有2种点person和software，以及2种边knows和creates。\n\n   ![图模型](#)\n\n   图模型定义可参考《TuGraph Analytics图建模研发：为图计算业务提速增效》[2]，图定义语法为："
            },
            {
                "content": "- **Worker**: 具体分布式地执行任务的单元，接收到Coordinator发送的Pipeline，执行具体的计算和查询逻辑。\n\n- **Meta Service**: 服务注册管理，Coordinator启动后，会将服务的地址和端口向MetaService进行注册，Client提交查询时从MetaService获取Coordinator的服务地址，进行连接。目前支持http和rpc两种方式。\n\n组件间执行流程如下：\n\n## OLAP流程\n\n## 操作指南\n\n1. **定义图模型**\n   \n   以下图为例，图中有2种点person和software，以及2种边knows和creates。\n\n   ![图模型](#)\n\n   图模型定义可参考《TuGraph Analytics图建模研发：为图计算业务提速增效》[2]，图定义语法为：\n\n   ```sql\n   CREATE GRAPH dy_modern (\n       Vertex person (\n         id bigint ID,\n         name varchar,\n         age int\n       ),\n       Vertex software (\n         id bigint ID,\n         name varchar,\n         lang varchar\n       ),\n       Edge knows (\n         srcId bigint SOURCE ID,\n         targetId bigint DESTINATION ID,\n         weight int\n       ),\n       Edge creates (\n         srcId bigint SOURCE ID,\n         targetId bigint DESTINATION ID,\n         weight int\n       )\n   ) WITH (\n       storeType='rocksdb',\n       shardCount = 2\n   );\n   ```\n\n2. **准备图数据**\n   \n   创建“加工”类型图任务，发布生成图作业。\n\n   ```sql\n   USE GRAPH dy_modern;"
            },
            {
                "content": "2. **准备图数据**\n   \n   创建“加工”类型图任务，发布生成图作业。\n\n   ```sql\n   USE GRAPH dy_modern;\n\n   INSERT INTO dy_modern.person(id, name, age)\n   SELECT 1, 'jim', 20\n   UNION ALL\n   SELECT 2, 'kate', 22\n   UNION ALL\n   SELECT 3, 'tom', 24;\n\n   INSERT INTO dy_modern.software(id, name, lang)\n   SELECT 4, 'software1', 'java'\n   UNION ALL\n   SELECT 5, 'software2', 'java';\n\n   INSERT INTO dy_modern.knows\n   SELECT 1,2,2\n   UNION ALL\n   SELECT 1,3,3\n   UNION ALL\n   SELECT 3,2,3;\n\n   INSERT INTO dy_modern.creates\n   SELECT 2,4,6\n   UNION ALL\n   SELECT 3,5,8\n   UNION ALL\n   SELECT 3,4,8;\n   ```\n\n   图作业需要的worker数为23，在作业界面将参数进行修改，之后提交作业运行。\n\n3. **创建查询服务**\n   \n   创建图查询服务, 任务类型选择“图查询”，目标图选择刚才创建的图。\n\n   发布任务后，使用默认参数即可，提交作业。\n\n4. **执行查询**\n   \n   图查询服务的作业变成RUNNING状态后，可在任务界面点击“查询”进入图查询界面。\n\n   输入相应的gql查询语句，点击“执行”，即可得到查询结果。\n\n5. **图可视化**\n   \n   点击某个点，可以查看点关联的具体信息和属性，以及关联的其他点边。\n\n   除了可视化的方式，也可以json形式看到返回的结果。\n\n至此，我们就成功使用TuGraph Analytics实现了图上的交互式查询！是不是超简单！快来试一试吧！"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/TuGraph_Analytics%E6%96%87%E6%A1%A3%E5%9C%B0%E5%9B%BE.md",
        "chunks": [
            {
                "content": "# TuGraph Analytics文档地图\n\n## 介绍\n\nTuGraph Analytics (别名：GeaFlow) 是蚂蚁集团开源的流图计算引擎，支持万亿级图存储、图表混合处理、实时图计算、交互式图分析等核心能力，目前广泛应用于数仓加速、金融风控、知识图谱以及社交网络等场景。\n\n关于GeaFlow更多介绍请参考：GeaFlow介绍文档\n\nGeaFlow设计论文参考：GeaFlow: A Graph Extended and Accelerated Dataflow System\n\n## 特性\n\n- 分布式实时图计算\n- 图表混合处理（SQL+GQL语言）\n- 统一流批图计算\n- 万亿级图原生存储\n- 交互式图分析\n- 高可用和Exactly Once语义\n- 高阶API算子开发\n- UDF/图算法/Connector插件支持\n- 一站式图研发平台\n- 云原生部署\n\n## 快速上手\n\n1. 准备Git、JDK8、Maven、Docker环境。\n2. 下载源码：git clone https://github.com/TuGraph-family/tugraph-analytics\n3. 项目构建：mvn clean install -DskipTests\n4. 测试任务：./bin/gql_submit.sh --gql geaflow/geaflow-examples/gql/loop_detection.sql\n5. 构建镜像：./build.sh --all\n6. 启动容器：docker run -d --name geaflow-console -p 8888:8888 geaflow-console:0.1\n   \n更多详细内容请参考：快速上手文档。\n\n## 开发手册\n\nGeaFlow支持DSL和API两套编程接口，您既可以通过GeaFlow提供的类SQL扩展语言SQL+ISO/GQL进行流图计算作业的开发，也可以通过GeaFlow的高阶API编程接口通过Java语言进行应用开发。\n\n- DSL应用开发：DSL开发文档\n- API应用开发：API开发文档\n\n## 实时能力\n\n相比传统的流式计算引擎比如Flink、Storm这些以表为模型的实时处理系统而言，GeaFlow以图为数据模型，在处理Join关系运算，尤其是复杂多跳的关系运算如3跳以上的Join、复杂环路查找上具备极大的性能优势。"
            },
            {
                "content": "## 开发手册\n\nGeaFlow支持DSL和API两套编程接口，您既可以通过GeaFlow提供的类SQL扩展语言SQL+ISO/GQL进行流图计算作业的开发，也可以通过GeaFlow的高阶API编程接口通过Java语言进行应用开发。\n\n- DSL应用开发：DSL开发文档\n- API应用开发：API开发文档\n\n## 实时能力\n\n相比传统的流式计算引擎比如Flink、Storm这些以表为模型的实时处理系统而言，GeaFlow以图为数据模型，在处理Join关系运算，尤其是复杂多跳的关系运算如3跳以上的Join、复杂环路查找上具备极大的性能优势。\n\n基于GQL的关联分析Demo：\n\n```roomsql\n--GQL Style\nMatch (s:student)-[sc:selectCource]->(c:cource)\nReturn c.name\n;\n```\n\n基于SQL的关联分析Demo：\n\n```roomsql\n--SQL Style\nSELECT c.name\nFROM course c JOIN selectCourse sc \nON c.id = sc.targetId\nJOIN student s ON sc.srcId = s.id\n;\n```\n\n## 致谢\n\nGeaFlow开发过程中部分模块参考了一些业界优秀的开源项目，包括Apache Flink、Apache Spark以及Apache Calcite等, 这里表示特别的感谢。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/TuGraph%E5%BC%80%E6%BA%90JAVA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7_TuGraph-OGM.md",
        "chunks": [
            {
                "content": "# TuGraph开源JAVA客户端工具 TuGraph-OGM\n\n## 无缝对接JAVA开发生态\n\nTuGraph 图数据库提供了 JAVA、C++、Python 等多种语言的 SDK 支持，方便客户在各种场景下使用。用户使用 SDK 向 TuGraph 服务器发送 Cypher 请求，服务器则以 JSON 形式返回数据。近日，TuGraph 推出了一款面向 JAVA 客户端用户的开发工具 TuGraph-OGM (Object Graph Mapping)，为用户提供了对象操作接口，相较于 Cypher/JSON 接口应用起来更加便捷。\n\nOGM 类似于关系数据库中的 ORM（Object Relational Model），可以将数据库返回的数据自动映射成 JAVA 中的对象，方便用户读取。而用户对这些对象的更新操作也可以被自动翻译成 Cypher 语句发送给服务器。这样，即便是完全不懂 Cypher 的用户，也可以通过操作对象与数据库进行交互，大大降低了图数据库的使用门槛。\n\nTuGraph-OGM 同时也兼容其他开源产品 OGM 工具如 Neo4j-OGM，方便用户将工程在不同数据库与 TuGraph 数据库间无缝迁移。本文将对 TuGraph-OGM 进行全面的介绍。\n\n## 0 映射原理\n\nTuGraph-OGM 将 JAVA 对象映射为图的对象，类映射为点，类的属性映射为图中的属性，类中的方法映射为操作 TuGraph 的查询语句。\n\n以电影场景为例，对演员、电影、导演之间的关系进行数据化，就形成了非常典型的图数据。举一个简单的示例，演员 Alice 在 1990 年和 2019 年分别出演了两部电影《Jokes》和《Speed》，其中《Jokes》的导演是 Frank Darabont。以图的思维来看，演员、导演、电影可以被映射为三种不同的节点，而出演、执导可以被映射为两种边，映射结果如上图所示。将数据存入图数据库后，相关的开发人员就可以使用各类图查询语言对数据进行查询。但对非图数据库相关的开发人员来说，这个例子中的演员、导演、电影作为实体，同样可以映射为类中的对象，而与实体相关联的对象可以通过集合存储，这是大多数开发人员熟悉的领域。\n\n## 1 TuGraph-OGM架构"
            },
            {
                "content": "## 0 映射原理\n\nTuGraph-OGM 将 JAVA 对象映射为图的对象，类映射为点，类的属性映射为图中的属性，类中的方法映射为操作 TuGraph 的查询语句。\n\n以电影场景为例，对演员、电影、导演之间的关系进行数据化，就形成了非常典型的图数据。举一个简单的示例，演员 Alice 在 1990 年和 2019 年分别出演了两部电影《Jokes》和《Speed》，其中《Jokes》的导演是 Frank Darabont。以图的思维来看，演员、导演、电影可以被映射为三种不同的节点，而出演、执导可以被映射为两种边，映射结果如上图所示。将数据存入图数据库后，相关的开发人员就可以使用各类图查询语言对数据进行查询。但对非图数据库相关的开发人员来说，这个例子中的演员、导演、电影作为实体，同样可以映射为类中的对象，而与实体相关联的对象可以通过集合存储，这是大多数开发人员熟悉的领域。\n\n## 1 TuGraph-OGM架构\n\nTuGraph-OGM 可被看做一个 \"翻译器\"，主要功能是将开发人员对 JAVA 对象的一些操作翻译为 TuGraph 可理解的图查询语言 Cypher 请求，并将该操作返回的结果，再次翻译为 JAVA 对象。架构图如下所示：\n\n## 3 使用示例\n\n详细示例请参考 tugraph-ogm-integration-tests 在 pom.xml 中引入依赖。\n\n### 3.1 构建图对象\n\n首先需要通过注解标明图中的实体。\n\n- `@NodeEntity`：该注解标明的类为节点类。\n- `@Relationship`：用于标明边，同时 @Relationship 中可指定 label 与边的指向。\n- `@Id`：用于标明 identity，是 OGM 中数据的唯一标识。\n\n### 3.2 与 TuGraph 建立连接\n\n当前 TuGraph-OGM 提供了 RPC driver 用于连接 TuGraph，具体配置如下所示：\n\n### 3.3 通过 OGM 进行增删改查\n\nOGM 支持对 TuGraph 的实体执行 CRUD 操作，同时支持发送任意 TuGraph 支持的 Cypher 语句，包括通过 CALL 调用存储过程。\n\n#### CREATE"
            },
            {
                "content": "## 3 使用示例\n\n详细示例请参考 tugraph-ogm-integration-tests 在 pom.xml 中引入依赖。\n\n### 3.1 构建图对象\n\n首先需要通过注解标明图中的实体。\n\n- `@NodeEntity`：该注解标明的类为节点类。\n- `@Relationship`：用于标明边，同时 @Relationship 中可指定 label 与边的指向。\n- `@Id`：用于标明 identity，是 OGM 中数据的唯一标识。\n\n### 3.2 与 TuGraph 建立连接\n\n当前 TuGraph-OGM 提供了 RPC driver 用于连接 TuGraph，具体配置如下所示：\n\n### 3.3 通过 OGM 进行增删改查\n\nOGM 支持对 TuGraph 的实体执行 CRUD 操作，同时支持发送任意 TuGraph 支持的 Cypher 语句，包括通过 CALL 调用存储过程。\n\n#### CREATE\n\n在完成图对象的构建后，即可通过类的实例化创建节点。当两个节点互相存储在对方的集合（该集合在构建时被标注为边）中，就形成了一条边。最后使用 `session.save` 方法将数据存入数据库。注意：TuGraph 数据库为强 schema 类型数据库，在创建实体前需要该数据的 label 已经存在，且新建过程中需要提供唯一的主键。\n\n#### DELETE\n\n使用 `session.delete` 方法删除节点，同时会删除与节点相关联的所有边。\n\n#### UPDATE\n\n修改已创建的节点的属性，再次调用 `session.save` 方法会对节点进行更新。\n\n#### MATCH\n\n`session.load` 方法用于根据节点 ID 查找节点。`session.loadAll` 方法用于批量查找节点，支持通过多个节点 ID 查找节点、查找某一类型的所有节点、带有 filter 的查询。filter 查询需要新建 Filter，传入参数 ComparisonOperator，可选为：EQUALS、GREATER_THAN、LESS_THAN。\n\n#### QUERY WITH CYPHER\n\nOGM 支持通过 `queryForObject`、`query` 方法向 TuGraph 发送 Cypher 查询，由于 Cypher 查询的灵活性，需要用户自行指定返回结果格式。"
            },
            {
                "content": "#### DELETE\n\n使用 `session.delete` 方法删除节点，同时会删除与节点相关联的所有边。\n\n#### UPDATE\n\n修改已创建的节点的属性，再次调用 `session.save` 方法会对节点进行更新。\n\n#### MATCH\n\n`session.load` 方法用于根据节点 ID 查找节点。`session.loadAll` 方法用于批量查找节点，支持通过多个节点 ID 查找节点、查找某一类型的所有节点、带有 filter 的查询。filter 查询需要新建 Filter，传入参数 ComparisonOperator，可选为：EQUALS、GREATER_THAN、LESS_THAN。\n\n#### QUERY WITH CYPHER\n\nOGM 支持通过 `queryForObject`、`query` 方法向 TuGraph 发送 Cypher 查询，由于 Cypher 查询的灵活性，需要用户自行指定返回结果格式。\n\n- `session.queryForObject` 方法：需要在方法第一个参数处指定返回类型，可设定为某一实体类或数字类型。\n- `session.query` 方法：Cypher 查询的返回结果被存储为 Result 类型，其内部数据需要用户自行解析。以下方代码为例，传入数据库的 Cypher 为 CREATE 查询，返回结果 `createResult` 可被解析为 `QueryStatistics`，可获取到此次查询被创建的节点与边的数目。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82_TuGraph_Analytics_%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.md",
        "chunks": [
            {
                "content": "# 一张图读懂 TuGraph Analytics 开源技术架构\n\nTuGraph Analytics（内部项目名GeaFlow）是蚂蚁集团开源的分布式实时图计算引擎，即流式图计算。通过SQL+GQL融合分析语言对表模型和图模型进行统一处理，实现了流、批、图一体化计算，并支持了Exactly Once语义、高可用以及一站式图研发平台等生产化能力。\n\n开源项目代码目前托管在GitHub，欢迎业界同仁、大数据/图计算技术爱好者关注我们的项目并参与共建。\n\n## 概览\n\n本文希望通过一张图描述清楚TuGraph Analytics的整体架构脉络和关键设计思路，以帮助大家快速对TuGraph Analytics项目的轮廓有个整体的认识。闲言少叙，直接上图。\n\nTuGraph Analytics开源技术架构一共分为五个部分：\n\n- **DSL层**：即语言层。TuGraph Analytics设计了SQL+GQL的融合分析语言，支持对表模型和图模型统一处理。\n- **Framework层**：即框架层。TuGraph Analytics设计了面向Graph和Stream的两套API支持流、批、图融合计算，并实现了基于Cycle的统一分布式调度模型。\n- **State层**：即存储层。TuGraph Analytics设计了面向Graph和KV的两套API支持表数据和图数据的混合存储，整体采用了Sharing Nothing的设计，并支持将数据持久化到远程存储。\n- **Console平台**：TuGraph Analytics提供了一站式图研发平台，实现了图数据的建模、加工、分析能力，并提供了图作业的运维管控支持。\n- **执行环境**：TuGraph Analytics可以运行在多种异构执行环境，如K8S、Ray以及本地模式。\n\n## DSL层\n\nDSL层是一个典型的编译器技术架构，即语法分析、语义分析、中间代码生成(IR)、代码优化、目标代码生成（OBJ）的流程。"
            },
            {
                "content": "## DSL层\n\nDSL层是一个典型的编译器技术架构，即语法分析、语义分析、中间代码生成(IR)、代码优化、目标代码生成（OBJ）的流程。\n\n- **语言设计**：TuGraph Analytics设计了SQL+GQL的融合语法，解决了图+表一体化分析的诉求。具体语法设计可以参考DSL语法文档[2]\n- **语法分析**：通过扩展Calcite的SqlNode和SqlOperator，实现SQL+GQL的语法解析器，生成统一的语法树信息。\n- **语义分析**：通过扩展Calcite的Scope和Namespace，实现自定义Validator，对语法树进行约束语义检查。\n- **中间代码生成**：通过扩展Calcite的RelNode，实现图上的Logical RelNode，用于GQL语法的中间表示。\n- **代码优化**：优化器实现了大量的优化规则（RBO）用于提升执行性能，未来也会引入CBO。\n- **目标代码生成**：代码生成器Converter负责将Logical RelNode转换为Physical RelNode，即目标代码。Physical RelNode可以直接翻译为Graph/Table上的API调用。\n- **自定义函数**: TuGraph Analytics提供了大量的内置系统函数，用户也可以根据需要注册自定义函数。\n- **自定义插件**: TuGraph Analytics允许用户扩展自己的Connector类型，以支持不同的数据源和数据格式。\n\n## Framework层\n\nFramework层设计与Flink/Spark等同类大数据计算引擎有一定的相似性，即提供了类FlumeJava（FlumeJava: Easy, Efficient Data-Parallel Pipelines[3]）的统一高阶API（简称HLA），用户调用高阶API的过程会被转换为逻辑执行计划，逻辑执行计划执行一定的优化（如ChainCombine、UnionPushUp等）后，被转换为物理执行计划，物理执行计划会被调度器分发到分布式Worker上执行，最终Worker会回调用户传递的高阶API函数逻辑，实现整个分布式计算链路的执行。"
            },
            {
                "content": "- **高阶API**：TuGraph Analytics通过Environment接口适配异构的分布式执行环境（K8S、Ray、Local），使用Pipeline封装了用户的数据处理流程，使用Window抽象统一了流处理（无界Window）和批处理（有界Window）。Graph接口提供了静态图和动态图（流图）上的计算API，如append/snapshot/compute/traversal等，Stream接口提供了统一流批处理API，如map/reduce/join/keyBy等。\n- **逻辑执行计划**：逻辑执行计划信息统一封装在PipelineGraph对象内，将高阶API对应的算子（Operator）组织在DAG中，算子一共分为5大类：SourceOperator对应数据源加载、OneInputOperator/TwoInputOperator对应传统的数据处理、IteratorOperator对应静态/动态图计算。DAG中的点（PipelineVertex）记录了算子（Operator）的关键信息，如类型、并发度、算子函数等信息，边（PipelineEdge）则记录了数据shuffle的关键信息，如Partition规则（forward/broadcast/key等）、编解码器等。\n- **物理执行计划**：物理执行计划信息统一封装在ExecutionGraph对象内，并支持二级嵌套结构，以尽可能将可以流水线执行的子图（ExecutionVertexGroup）结构统一调度。图中示例的物理执行计划DAG被划分为三部分子图结构分别执行。\n- **调度器**：TuGraph Analytics设计了基于Cycle的调度器（CycleScheduler）实现对流、批、图的统一调度，调度过程通过事件驱动模型触发。物理执行计划中的每部分子图都会被转换为一个ExecutionCycle对象，调度器会向Cycle的头结点（Head）发送Event，并接收Cycle尾结点（Tail）的发回的Event，形成一个完整的调度闭环。对于流处理，每一轮Cycle调度会完成一个Window的数据的处理，并会一直不停地执行下去。对于批处理，整个Cycle调度仅执行一轮。对于图处理，每一轮Cycle调度会完成一次图计算迭代。"
            },
            {
                "content": "- **物理执行计划**：物理执行计划信息统一封装在ExecutionGraph对象内，并支持二级嵌套结构，以尽可能将可以流水线执行的子图（ExecutionVertexGroup）结构统一调度。图中示例的物理执行计划DAG被划分为三部分子图结构分别执行。\n- **调度器**：TuGraph Analytics设计了基于Cycle的调度器（CycleScheduler）实现对流、批、图的统一调度，调度过程通过事件驱动模型触发。物理执行计划中的每部分子图都会被转换为一个ExecutionCycle对象，调度器会向Cycle的头结点（Head）发送Event，并接收Cycle尾结点（Tail）的发回的Event，形成一个完整的调度闭环。对于流处理，每一轮Cycle调度会完成一个Window的数据的处理，并会一直不停地执行下去。对于批处理，整个Cycle调度仅执行一轮。对于图处理，每一轮Cycle调度会完成一次图计算迭代。\n- **运行时组件**：TuGraph Analytics运行时会拉起Client、Master、Driver、Container组件。当Client提交Pipeline给Driver后，会触发执行计划构建、分配Task（ResourceManagement提供资源）和调度。每个Container内可以运行多个Worker组件，不同Worker组件之间通过Shuffle模块交换数据，所有的Worker都需要定期向Master上报心跳（HeartbeatManagement），并向时序数据库上报运行时指标信息。另外TuGraph Analytics运行时也提供了故障容忍机制（FailOver），以便在异常/中断后能继续执行。"
            },
            {
                "content": "## State层\n\nState层设计相比于传统的大数据计算引擎，除了提供面向表数据的KV存储抽象，也支持了面向图数据的Graph存储抽象，以更好地支持面向图模型的IO性能优化。\n\n- **State API**：提供了面向KV存储API，如get/put/delete等。以及面向图存储的API，如V/E/VE，以及点/边的add/update/delete等。\n- **State执行层**：通过KeyGroup的设计实现数据的Sharding和扩缩容能力，Accessor提供了面向不同读写策略和数据模型的IO抽象，StateOperator抽象了存储层SPI，如finish（刷盘）、archive（Checkpoint）、compact（压缩）、recover（恢复）等。另外，State提供了多种PushDown优化以加速IO访问效率。通过自定义内存管理和面向属性的二级索引也会提供大量的存储访问优化手段。\n- **Store层**：TuGraph Analytics支持了多种存储系统类型，并通过StoreContext封装了Schema、序列化器，以及数据版本信息。\n- **持久化层**：State的数据支持持久化到远程存储系统，如HDFS、OSS、S3等。\n\n## Console平台\n\nConsole平台提供了一站式图研发、运维的平台能力，同时为引擎运行时提供元数据（Catalog）服务。"
            },
            {
                "content": "## Console平台\n\nConsole平台提供了一站式图研发、运维的平台能力，同时为引擎运行时提供元数据（Catalog）服务。\n\n- **标准化API**：平台提供了标准化的RESTful API和认证机制，同时支持了页面端和应用端的统一API服务能力。\n- **任务研发**：平台支持“关系-实体-属性”的图数据建模。基于字段映射配置，可以定义图数据传输任务，包括数据集成（Import）和数据分发（Export）。基于图表模型的图数据加工任务支持多样化的计算场景，如Traversal、Compute、Mining等。基于数据加速器的图数据服务，提供了多协议的实时分析能力，支持BI、可视化分析工具的接入集成。\n- **构建提交**：平台通过任务和作业的独立抽象，实现研发态与运维态的分离。任务开发完成后执行发布动作，会自动触发构建流水线（Release Builder），生成发布版本。任务提交器（Task Submitter）负责将发布版本的内容提交到执行环境，生成计算作业。\n- **作业运维**：作业属于任务的运行态，平台提供了作业的操纵（启停、重置）、监控（指标、告警、审计）、调优（诊断、伸缩、调参）、调度等运维能力。作业的运行时资源会由资源池统一分配和管理。\n- **元数据服务**：平台同时承载了引擎运行时的元数据服务能力，以实现研发与运维的自动化。元数据以实例维度进行隔离，实例内的研发资源可以根据名字直接访问，如点、边、图、表、视图、函数等。\n- **系统管理**：平台提供了多租户隔离机制、细粒度用户权限控制，以及系统资源的管理能力。\n\n## 执行环境\n\nTuGraph Analytics支持多种异构环境执行，以常见的K8S部署环境为例，其物理部署架构如下：\n\n在TuGraph Analytics作业的全生命周期过程中，涉及的关键数据流程有："
            },
            {
                "content": "## 执行环境\n\nTuGraph Analytics支持多种异构环境执行，以常见的K8S部署环境为例，其物理部署架构如下：\n\n在TuGraph Analytics作业的全生命周期过程中，涉及的关键数据流程有：\n\n- **研发阶段**：Console平台提供了实例下所有的研发资源的管理，用户可以在创建任务前，提前准备所需的研发资源信息，并存储在Catalog。\n- **构建阶段**：任务创建完成后，通过发布动作触发构建流水线，用户的JAR包、任务的ZIP包等会上传到RemoteFileStore。\n- **提交阶段**：作业提交时，Console会根据作业的参数配置、运行时环境信息，以及远程文件地址等创建KubernetesJobClient，既而会拉起Client Pod，Client会拉起Master Pod，Master会拉起Container Pods和Driver Pod。所有的Pod拉起后，Client会把作业的Pipeline发送给Driver执行，Driver最终通过Cycle调度的Events与Containers交互。所有的Pod启动时都会从RemoteFileStore下载版本JAR包、用户JAR包、作业ZIP包等信息。Driver对DSL代码编译时，也需要通过Console提供的Catalog API操作Schema信息。\n- **运行阶段**：作业运行时，各个组件会上报不同的数据和信息。Master会上报作业的心跳汇总信息，Driver会上报作业的Pipeline/Cycle指标以及错误信息，Container会上报作业的Offset、指标定义以及错误信息等。RuntimeMetaStore存储作业的Pipeline/Cycle指标、Offset、心跳汇总、错误等信息。HAMetaStore存储各个运行组件的地址信息。DataStore存储State数据和作业FailOver时所需的元数据信息。MetricStore存储运行时指标信息。\n- **监控阶段**：Console会主要查询RuntimeMetaStore和MetricStore存储的信息用于作业的运行时监控。\n- **清理阶段**：作业重置/删除时，Console会对作业的RuntimeMeta、HAMeta以及部分Data做清理操作。\n\n## 总结"
            },
            {
                "content": "## 总结\n\n希望通过以上的介绍，可以让大家对TuGraph Analytics开源技术架构有个比较清晰的了解，我们非常欢迎开源社区的技术爱好者参与到项目的建设中来。如果您对TuGraph Analytics项目比较感兴趣，欢迎动动手指扫码直达GitHub仓库，为我们的项目加一颗Star。（网络不畅可以尝试使用VPN访问）"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E5%85%B3%E4%BA%8ETuGraph.md",
        "chunks": [
            {
                "content": "# 关于TuGraph\n\n高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db）由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。\n\n历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。\n\n2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。\n\n## 蚂蚁高性能图数据库 TuGraph-DB 的技术思考与实践\n\n在近日举行的 DTCC 2022 第十三届中国数据库技术大会-图数据技术与应用创新专场，蚂蚁集团图数据库负责人洪春涛博士分享了蚂蚁高性能图数据库 TuGraph-DB 的技术思考和实践，以下为演讲内容要点回顾。\n\n### 图计算的优势\n\n图计算是一种高效的抽象计算方法，可以方便地处理复杂的多维数据。我们将员工和公司之间的关系画成图，这样可以快速查询员工的信息，例如员工的工作情况、与其他员工的关系以及与哪些公司有联系。相比之下，在关系数据库中，我们需要分别建立员工信息表、公司信息表以及员工和公司之间的关系表。这就把整个数据切成了很多张二维表，在实际应用系统中经常能够看到几百上千张表。这样会使得系统变得更加复杂，需要基于多张表去做推断，对人或机器来说都会带来挑战。\n\n对比来看什么是简单查询和复杂查询：\n\n图中表格的前两行属于比较简单的查询，比如某个员工的工龄，直接找到对应的那一行然后取出来就可以；比如找出所有的雇员数大于 5 的公司，可能在雇佣关系表中就能找出来，在关系数据库里这些都属于常规的操作。"
            },
            {
                "content": "## 蚂蚁高性能图数据库 TuGraph-DB 的技术思考与实践\n\n在近日举行的 DTCC 2022 第十三届中国数据库技术大会-图数据技术与应用创新专场，蚂蚁集团图数据库负责人洪春涛博士分享了蚂蚁高性能图数据库 TuGraph-DB 的技术思考和实践，以下为演讲内容要点回顾。\n\n### 图计算的优势\n\n图计算是一种高效的抽象计算方法，可以方便地处理复杂的多维数据。我们将员工和公司之间的关系画成图，这样可以快速查询员工的信息，例如员工的工作情况、与其他员工的关系以及与哪些公司有联系。相比之下，在关系数据库中，我们需要分别建立员工信息表、公司信息表以及员工和公司之间的关系表。这就把整个数据切成了很多张二维表，在实际应用系统中经常能够看到几百上千张表。这样会使得系统变得更加复杂，需要基于多张表去做推断，对人或机器来说都会带来挑战。\n\n对比来看什么是简单查询和复杂查询：\n\n图中表格的前两行属于比较简单的查询，比如某个员工的工龄，直接找到对应的那一行然后取出来就可以；比如找出所有的雇员数大于 5 的公司，可能在雇佣关系表中就能找出来，在关系数据库里这些都属于常规的操作。\n\n但如果查询再复杂一点，我想知道员工 A 和员工 C 之间有什么关系，不一定是一跳的关系，可能包含在同一家公司工作，也可能包含参与了同一个项目，甚至还包含他们有一个共同好友，这些关系就是多种多样的，想用 SQL 列举所有可能的关系其实就没有那么容易了。如果确定知道这里可能有几种关系，还能靠 SQL 穷举出来，但随着表越来越多，里面的关系可能有几百上千的时候，再想去穷举就非常难了。\n\n最后还有一种更复杂的查询，比如想找员工 A 和员工 E 的所有关系，可能包括 A 认识 B，B 认识 C，C 认识 E，相当于在做一个不定长跳数的查询，在 SQL 里面就非常难写了，相信绝大多数人都难以写出这种查询。\n\n业界有句话，所谓的关系数据库实际上并不擅长处理关系。例如，员工 A 和 E 之间的所有关系实际上就是我们要查询的关系，但在关系数据库中处理这种关系查询实际上是不够友好的。这是图数据库的优势所在，它们更擅长处理复杂的关系数据。我们发现，大部分浅显的数据信息都可以比较容易地挖掘出来，但要想更深入地利用数据产生更多的价值，就必须挖掘更深层次的信息，这时就一定会遇到这些复杂的关系，这也是为什么图数据库越来越受欢迎的原因。\n\n### 为什么图数据库开始流行"
            },
            {
                "content": "最后还有一种更复杂的查询，比如想找员工 A 和员工 E 的所有关系，可能包括 A 认识 B，B 认识 C，C 认识 E，相当于在做一个不定长跳数的查询，在 SQL 里面就非常难写了，相信绝大多数人都难以写出这种查询。\n\n业界有句话，所谓的关系数据库实际上并不擅长处理关系。例如，员工 A 和 E 之间的所有关系实际上就是我们要查询的关系，但在关系数据库中处理这种关系查询实际上是不够友好的。这是图数据库的优势所在，它们更擅长处理复杂的关系数据。我们发现，大部分浅显的数据信息都可以比较容易地挖掘出来，但要想更深入地利用数据产生更多的价值，就必须挖掘更深层次的信息，这时就一定会遇到这些复杂的关系，这也是为什么图数据库越来越受欢迎的原因。\n\n### 为什么图数据库开始流行\n\n图数据库的概念最早出现在七八十年代初期，但当时为什么人们没有选择使用图数据库，而是选择了关系数据库呢？我认为主要原因是，当时的计算机并不那么强大，使用二维表格形式的关系数据库对计算机来说更友好。我们知道，计算机最擅长的事情就是重复的劳动，重复的任务。如果我们要在一张二维表中找一行数据，我们可以一行一行查找，或者使用二分查找（如果数据是树状有序的）。每一层都是重复的算法在运行，这对计算机来说是一个非常规整的数据，容易处理。但如果把数据抽象成一张图，那么难度就会大很多，对计算机来说会更难处理。\n\n举个例子，一个员工可能与其他人有各种不同的关系，比如朋友关系、雇佣关系、参与项目关系，每种关系的类型都不同，对应的数据也都不同。此外，一个点上的边数也非常不规律，有的人可能只有几个好友，而在微博上，一个普通人可能有两三百个粉丝，而大 V 账号可能有数百万甚至上亿的粉丝。这样一来，存储数据时，普通人和大 V 之间的差距就非常大了，对计算机来说，处理这两种数据的差异也会很大。\n\n我们知道，在七八十年代，计算机相对来说很弱，如果那个时候使用图来表示数据，整个处理和查询的难度就会大很多。所以，人们选择使用关系数据表的形式表示数据。事实上，那个时候有人做过图数据库，但并没有流行起来，原因就是性能相对关系数据库来说差得太多了。"
            },
            {
                "content": "举个例子，一个员工可能与其他人有各种不同的关系，比如朋友关系、雇佣关系、参与项目关系，每种关系的类型都不同，对应的数据也都不同。此外，一个点上的边数也非常不规律，有的人可能只有几个好友，而在微博上，一个普通人可能有两三百个粉丝，而大 V 账号可能有数百万甚至上亿的粉丝。这样一来，存储数据时，普通人和大 V 之间的差距就非常大了，对计算机来说，处理这两种数据的差异也会很大。\n\n我们知道，在七八十年代，计算机相对来说很弱，如果那个时候使用图来表示数据，整个处理和查询的难度就会大很多。所以，人们选择使用关系数据表的形式表示数据。事实上，那个时候有人做过图数据库，但并没有流行起来，原因就是性能相对关系数据库来说差得太多了。\n\n我们知道，所有的事物，尤其是电脑，一直在不断进步。这包括硬件和软件方面的改进。如今的硬件和几十年前的硬件完全不是一个概念，而现在的软件优化也大不相同。随着这些改进，我们会发现对当前的电脑和计算机系统来说，使用图数据库带来的额外开销可能不是很大的问题。\n\n举个例子，我们会发现，过去人们都使用低级编程语言编写程序，但随着时间的推移，有了高级语言。比如最开始、最原始的电脑可能是用纸袋和机器码写程序，后来有了汇编，再后来有 C 语言、C++，现在很多人都直接写 Python。虽然 Python 程序的执行速度可能较慢，但是写的很快，而用 C++或者汇编去写得写半天，对于编写程序到最终得出结果的整个过程来说，使用 Python 会更方便。\n\n计算机编程语言的发展是从低级向高级演变的，数据抽象也是一样。我们认为，未来的数据抽象一定会对人更友好一些，而不是专注于对机器更友好。如图所示，编程语言的发展是从低级语言向高级语言转变的，我们也认为数据抽象层次也会慢慢从低层次表格抽象向高层次图表抽象发展。\n\n### 图计算在蚂蚁的应用\n\n自 2015 年开始，蚂蚁实际上投入了大量资源来研究图计算，研究如何在蚂蚁的业务中使用图计算。例如数据血缘应用。在对业务的处理过程中，我们需要较好地追踪这些数据的流转路径，如果修改了一份源数据会对下游数据产生什么影响，会对最终业务产生什么影响。为了更好地追踪，我们使用图数据库来存储数据。"
            },
            {
                "content": "举个例子，我们会发现，过去人们都使用低级编程语言编写程序，但随着时间的推移，有了高级语言。比如最开始、最原始的电脑可能是用纸袋和机器码写程序，后来有了汇编，再后来有 C 语言、C++，现在很多人都直接写 Python。虽然 Python 程序的执行速度可能较慢，但是写的很快，而用 C++或者汇编去写得写半天，对于编写程序到最终得出结果的整个过程来说，使用 Python 会更方便。\n\n计算机编程语言的发展是从低级向高级演变的，数据抽象也是一样。我们认为，未来的数据抽象一定会对人更友好一些，而不是专注于对机器更友好。如图所示，编程语言的发展是从低级语言向高级语言转变的，我们也认为数据抽象层次也会慢慢从低层次表格抽象向高层次图表抽象发展。\n\n### 图计算在蚂蚁的应用\n\n自 2015 年开始，蚂蚁实际上投入了大量资源来研究图计算，研究如何在蚂蚁的业务中使用图计算。例如数据血缘应用。在对业务的处理过程中，我们需要较好地追踪这些数据的流转路径，如果修改了一份源数据会对下游数据产生什么影响，会对最终业务产生什么影响。为了更好地追踪，我们使用图数据库来存储数据。\n\n另一个比较有趣的应用场景就是程序分析。相信几乎所有互联网公司内部都有大量的程序，因此，我们需要管理这些程序，并在每次提交代码时了解将会对哪些内容产生影响。为此，蚂蚁负责程序分析的团队会分析这里的图数据。例如，定义一个变量 A，然后使用变量 A，“定义”与“使用”之间就会有一条边，使用关系会存储在图数据库中。目前我们的图中已经有超过 200 亿条边，这是一个非常大的数据量。我们需要对这些数据进行存储、查询和分析，这是蚂蚁公司内部非常多的图数据场景之一。\n\n举个例子来说明优惠券反套现的场景：满额返券是一种比较常见的促销方式，比如购物满 2000 元就可以享受 100 元的优惠。这种情况下，如果正常消费，用户花费 2000 元，通过返券省下 100 元。但是有些人会想办法注册假商铺，进行虚假交易，目的是把平台补贴的优惠券套出来。因此当用户去买东西，平台要去付补贴的过程，我们需要去实时检测一下会不会有可疑的资金交易情况。"
            },
            {
                "content": "另一个比较有趣的应用场景就是程序分析。相信几乎所有互联网公司内部都有大量的程序，因此，我们需要管理这些程序，并在每次提交代码时了解将会对哪些内容产生影响。为此，蚂蚁负责程序分析的团队会分析这里的图数据。例如，定义一个变量 A，然后使用变量 A，“定义”与“使用”之间就会有一条边，使用关系会存储在图数据库中。目前我们的图中已经有超过 200 亿条边，这是一个非常大的数据量。我们需要对这些数据进行存储、查询和分析，这是蚂蚁公司内部非常多的图数据场景之一。\n\n举个例子来说明优惠券反套现的场景：满额返券是一种比较常见的促销方式，比如购物满 2000 元就可以享受 100 元的优惠。这种情况下，如果正常消费，用户花费 2000 元，通过返券省下 100 元。但是有些人会想办法注册假商铺，进行虚假交易，目的是把平台补贴的优惠券套出来。因此当用户去买东西，平台要去付补贴的过程，我们需要去实时检测一下会不会有可疑的资金交易情况。\n\n蚂蚁有很多业务需要研究图计算系统和图数据库等技术来满足需求，因为这些业务需要对大量的点边进行分析，数据量超过了 100TB，基本上已经达到了 PB 级别。我们需要对这些图进行实时查询，吞吐率大约在百万级别，延迟要求在 20 毫秒以内。如果我们无法做到实时计算，那么整个业务的流转就会非常缓慢。\n\n随着技术的发展，未来对图计算的需求会越来越高。正是因为这种背景，我们才在 2015 年开始投入大量资源进行研究。\n\n### 图计算系统建设中的问题与挑战\n\n在建立蚂蚁图计算系统的过程中，我们遇到很多问题，也希望与学术界共同合作，在这个过程中，我们合作发表了多篇论文。实际上，图计算仍然处于早期阶段，标准尚未成形，市场也有碎片化的现象，导致现阶段很难形成统一的标准。\n\n我们在图计算的过程中发现，图计算的常见问题有很多。首先，图计算算法的选择非常重要，比如在对图进行切分时，我们如何选择切分点，切分的比例会影响图的计算性能。此外，图计算的下游场景比较复杂，可能包括离线计算、实时计算等不同场景。我们发现大多数的算法对图的流量非常敏感。\n\n### TuGraph 技术优势"
            },
            {
                "content": "蚂蚁有很多业务需要研究图计算系统和图数据库等技术来满足需求，因为这些业务需要对大量的点边进行分析，数据量超过了 100TB，基本上已经达到了 PB 级别。我们需要对这些图进行实时查询，吞吐率大约在百万级别，延迟要求在 20 毫秒以内。如果我们无法做到实时计算，那么整个业务的流转就会非常缓慢。\n\n随着技术的发展，未来对图计算的需求会越来越高。正是因为这种背景，我们才在 2015 年开始投入大量资源进行研究。\n\n### 图计算系统建设中的问题与挑战\n\n在建立蚂蚁图计算系统的过程中，我们遇到很多问题，也希望与学术界共同合作，在这个过程中，我们合作发表了多篇论文。实际上，图计算仍然处于早期阶段，标准尚未成形，市场也有碎片化的现象，导致现阶段很难形成统一的标准。\n\n我们在图计算的过程中发现，图计算的常见问题有很多。首先，图计算算法的选择非常重要，比如在对图进行切分时，我们如何选择切分点，切分的比例会影响图的计算性能。此外，图计算的下游场景比较复杂，可能包括离线计算、实时计算等不同场景。我们发现大多数的算法对图的流量非常敏感。\n\n### TuGraph 技术优势\n\n蚂蚁开发的 TuGraph 系统解决了图数据的存储、流式计算、离线计算和图学习的问题，目前已在超过 100 个业务线和 300 多个场景中应用。图数据是最适合存储在图数据库里的，关系明确且常常能给出一个清晰的图谱，而不同的数据之间的相互关系能在图数据库中很清楚地体现出来。\n\nTuGraph 在 LDBC-SNB 标准测试中仍是世界纪录保持者，支持 TB 级别数据的存储与计算，能够有效帮助用户在复杂数据关系中提取有价值的信息。\n\n## 开源开放，共建发展\n\n我们于 2023 年 9 月在 GitHub 上开源了 TuGraph 中的单机版图数据库和离线图分析引擎 TuGraph Compute，分布式图数据库和流式图计算包含在商业化版本中。\n\n## TuGraph 开源版特色\n\n- **处理能力**：支持 TB 级别的数据，单机版易于部署。\n- **性能**：经过大量优化，LDBC-SNB 测试世界第一。\n- **易用性**：完整系统，提供导入导出工具和查询语言。\n\n## 开源版本的目标\n\n1. 提供免费图数据库产品，让更多人使用。\n2. 促进图数据库标准形成，降低学习成本。\n3. 优化基础研究性问题，为研究提供比较基线。\n\n## TuGraph 企业版特色"
            },
            {
                "content": "TuGraph 在 LDBC-SNB 标准测试中仍是世界纪录保持者，支持 TB 级别数据的存储与计算，能够有效帮助用户在复杂数据关系中提取有价值的信息。\n\n## 开源开放，共建发展\n\n我们于 2023 年 9 月在 GitHub 上开源了 TuGraph 中的单机版图数据库和离线图分析引擎 TuGraph Compute，分布式图数据库和流式图计算包含在商业化版本中。\n\n## TuGraph 开源版特色\n\n- **处理能力**：支持 TB 级别的数据，单机版易于部署。\n- **性能**：经过大量优化，LDBC-SNB 测试世界第一。\n- **易用性**：完整系统，提供导入导出工具和查询语言。\n\n## 开源版本的目标\n\n1. 提供免费图数据库产品，让更多人使用。\n2. 促进图数据库标准形成，降低学习成本。\n3. 优化基础研究性问题，为研究提供比较基线。\n\n## TuGraph 企业版特色\n\n商业版本包含分布式图数据库、离线计算引擎和流式图计算功能。提供私有化部署和云上部署方案。\n\n## 总结\n\n蚂蚁在图计算方面投入了大量资源，已在众多业务场景中磨练出完整的体系。我们已在 GitHub 上开源了单机版（https://github.com/TuGraph-family），同时提供企业版以满足不同用户需求。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E5%90%8D%E7%A7%B0%E8%A7%A3%E9%87%8A.md",
        "chunks": [
            {
                "content": "# # 名称解释\n\n## 图\n图用于展示不同变量之间的关系，通常包括节点（点）和边（线）两部分。节点代表一个个体或对象，边则代表它们之间的关系。图可以用来解释复杂的关系网络和信息流动，如社交网络、交通网络、物流网络等。常见的图形类型包括有向图、无向图、树形图、地图等。\n\n## K8S\nk8s是Kubernetes的简称，是一个开源的容器编排平台，提供了自动化部署、自动扩展、自动管理容器化应用程序的功能。它可以在各种云平台、物理服务器和虚拟机上运行，支持多种容器运行时，可以实现高可用性、负载均衡、自动扩容、自动修复等功能。\n\n## Graph Processing\nGraph Processing是一种计算模型，用于处理图形数据结构的计算问题。图计算模型可以用于解决许多现实世界的问题，例如社交网络分析、网络流量分析、医疗诊断等，典型的系统有 Apache Giraph, Spark GraphX。\n\n## DSL\nDSL是领域特定语言（Domain-Specific Language）的缩写。它是一种针对特定领域或问题的编程语言，与通用编程语言不同，DSL主要关注于解决特定领域的问题，并针对该领域的特定需求进行优化。DSL可以使得编程更加简单、高效，同时也能够提高代码的可读性和可维护性。下面的Gremlin、ISO-GQL就是DSL中的一种。\n\n## HLA\nHLA 是 High level language 的缩写，与DSL不同，它使用通用语言进行编程，Geaflow目前只支持Java程序编写。它主要通过计算引擎SDK进行程序编写，执行方式是将程序整体打包交给引擎执行，对比DSL，它的执行方式更加灵活，但相对应的编程也会更加复杂。\n\n## Gremlin\nGremlin是一种图形遍历语言，用于在图形数据库中进行数据查询和操作。它是一种声明式的、基于图的编程语言，可以用于访问各种类型的图形数据库，如Apache TinkerPop、Neo4j等。它提供了一组灵活的API，可以帮助开发者在图形数据库中执行各种操作，如遍历、过滤、排序、连接、修改等。\n\n## ISO-GQL\nGQL是面向属性图的标准查询语言，全称是“图形查询语言”，其为ISO/IEC国际标准数据库语言。GeaFlow不仅支持了Gremlin查询语言，而且还支持了GQL。"
            },
            {
                "content": "## HLA\nHLA 是 High level language 的缩写，与DSL不同，它使用通用语言进行编程，Geaflow目前只支持Java程序编写。它主要通过计算引擎SDK进行程序编写，执行方式是将程序整体打包交给引擎执行，对比DSL，它的执行方式更加灵活，但相对应的编程也会更加复杂。\n\n## Gremlin\nGremlin是一种图形遍历语言，用于在图形数据库中进行数据查询和操作。它是一种声明式的、基于图的编程语言，可以用于访问各种类型的图形数据库，如Apache TinkerPop、Neo4j等。它提供了一组灵活的API，可以帮助开发者在图形数据库中执行各种操作，如遍历、过滤、排序、连接、修改等。\n\n## ISO-GQL\nGQL是面向属性图的标准查询语言，全称是“图形查询语言”，其为ISO/IEC国际标准数据库语言。GeaFlow不仅支持了Gremlin查询语言，而且还支持了GQL。\n\n## Window\n参考VLDB 2015 Google Dataflow Model，窗口的概念在 Geaflow 中是其数据处理逻辑中的关键要素，用于统一有界和无界的数据处理。数据流统一被看成一个个窗口数据的集合，系统处理批次的粒度也就是窗口的粒度。\n\n## Cycle\nCycle是GeaFlow Scheduler调度模型中的核心数据结构，一个cycle描述为可循环执行的基本单元，包含输入，中间计算和数据交换，输出的描述。由执行计划中的vertex group生成，支持嵌套。\n\n## Event\nEvent是Runtime层调度和计算交互的核心数据结构，Scheduler将一系列Event集合构建成一个State Machine，将其分发到Worker上进行计算执行。其中有些Event是可执行的，即自身具备计算语义，整个调度和计算过程为异步执行。\n\n## Graph Traversal\nGraph Traversal是指遍历图数据结构中所有节点或者部分节点的过程，在特定的顺序下访问所有节点，主要是深度优先搜索（DFS）和广度优先搜索（BFS）。用于解决许多问题，包括查找两个节点之间的最短路径、检测图中的循环等。"
            },
            {
                "content": "## Cycle\nCycle是GeaFlow Scheduler调度模型中的核心数据结构，一个cycle描述为可循环执行的基本单元，包含输入，中间计算和数据交换，输出的描述。由执行计划中的vertex group生成，支持嵌套。\n\n## Event\nEvent是Runtime层调度和计算交互的核心数据结构，Scheduler将一系列Event集合构建成一个State Machine，将其分发到Worker上进行计算执行。其中有些Event是可执行的，即自身具备计算语义，整个调度和计算过程为异步执行。\n\n## Graph Traversal\nGraph Traversal是指遍历图数据结构中所有节点或者部分节点的过程，在特定的顺序下访问所有节点，主要是深度优先搜索（DFS）和广度优先搜索（BFS）。用于解决许多问题，包括查找两个节点之间的最短路径、检测图中的循环等。\n\n## Graph State\nGraphState用来存放Geaflow的图数据或者图迭代计算过程的中间结果，提供Exactly-Once语义，并提供作业级复用的能力。GraphState分为Static和Dynamic两种，Static的GraphState将整个图看做是一个完整的，所有操作都在一张全图上进行；Dynamic的GraphState认为图动态变化的，由一个个时间切片构成，所有切片构成一个完整的图，所有的操作都是在切片上进行。\n\n## Key State\nKeyState用于存放计算过程中的中间结果，通常用于流式处理，例如执行aggregation时在KeyState中记录中间聚合结果。类似GraphState，Geaflow会将KeyState定期持久化，因此KeyState也提供Exactly-Once语义。KeyState根据数据结果不同可以分为KeyValueState、KeyListState、KeyMapState等。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB_I_TuGraph%E6%9F%A5%E8%AF%A2%E5%BC%95%E6%93%8E%E7%AE%80%E6%9E%90.md",
        "chunks": [
            {
                "content": "# 技术解读 I TuGraph查询引擎简析\n\n存储和计算是图数据库的两个重要组成部分。TuGraph的计算层包括图分析引擎、图查询引擎和图学习引擎。我们之前已经介绍了图分析引擎，现在我们将分享一下图查询引擎。\n\n图查询引擎是一种用于查询图数据库的工具，它使用特定的查询语言（如Cypher或ISO GQL）来执行和操作图数据库。这些查询语言允许用户描述图模式并查询图数据，例如查找特定节点或查找节点之间的路径。\n\n目前，TuGraph支持使用Open Cypher作为查询语言，即将支持ISO GQL查询语言。与关系型数据库的SQL类似，Open Cypher和ISO GQL都是声明式查询语言。它们需要转换成高效的命令式执行计划，以便计算机系统能够理解和执行。查询引擎需要完成理解用户查询意图和转换执行计划的功能。\n\n在本文中，我们将概述Open Cypher/ISO GQL查询如何执行，但不会详细探讨其中的技术细节，以帮助用户从整体上理解TuGraph查询引擎的工作原理。\n\n## 01 TuGraph查询引擎架构\n\nTuGraph在不断演进，将图查询和图分析引擎融合在一起，旨在提供混合查询和分析能力，并保持一致的使用体验。其架构如下图所示：\n\n## 02 查询引擎工作流程\n\nTuGraph查询引擎的主要步骤包括：\n\n1. 将输入的查询字符串转换为抽象语法树（AST）。\n2. 优化并归一化AST，生成通用语法中间表示（GST）。\n3. 使用GST创建查询图并提取符号表，创建逻辑执行计划。\n4. 优化逻辑执行计划。\n5. 根据逻辑执行计划创建（物理）执行计划。\n6. 校验schema约束、访问权限等。\n7. 执行上述执行计划，得到查询结果。\n\n### 将输入的查询字符串转换为抽象语法树（AST）\n\n将用户输入的（Open Cypher或者ISO GQL）查询字符串转换为抽象语法树（AST）。在此过程中，任何语法错误都会被捕获并返回给用户，但我们在此阶段不进行语义检查。\n\n### 优化并归一化AST，生成通用语法中间表示（GST）\n\n在将查询字符串转换为抽象语法树（AST）后，我们仍需要解决一些问题。首先，原始AST层次较高，分支较为繁杂。更重要的是，AST与查询语言相关，不同的查询语言（如Open Cypher和ISO GQL）会生成完全不同的AST，这不利于后续的统一处理。"
            },
            {
                "content": "## 02 查询引擎工作流程\n\nTuGraph查询引擎的主要步骤包括：\n\n1. 将输入的查询字符串转换为抽象语法树（AST）。\n2. 优化并归一化AST，生成通用语法中间表示（GST）。\n3. 使用GST创建查询图并提取符号表，创建逻辑执行计划。\n4. 优化逻辑执行计划。\n5. 根据逻辑执行计划创建（物理）执行计划。\n6. 校验schema约束、访问权限等。\n7. 执行上述执行计划，得到查询结果。\n\n### 将输入的查询字符串转换为抽象语法树（AST）\n\n将用户输入的（Open Cypher或者ISO GQL）查询字符串转换为抽象语法树（AST）。在此过程中，任何语法错误都会被捕获并返回给用户，但我们在此阶段不进行语义检查。\n\n### 优化并归一化AST，生成通用语法中间表示（GST）\n\n在将查询字符串转换为抽象语法树（AST）后，我们仍需要解决一些问题。首先，原始AST层次较高，分支较为繁杂。更重要的是，AST与查询语言相关，不同的查询语言（如Open Cypher和ISO GQL）会生成完全不同的AST，这不利于后续的统一处理。\n\n为了解决这些问题，我们将在此步骤中完成以下任务：\n\n- 进行语义检查。\n- 根据语义生成通用语法表示（GST），对AST进行压缩，以便按相同语义进行处理。\n\n无论使用哪种查询语言，生成的GST都是相同的。\n\n### 使用GST创建查询图并提取符号表，创建逻辑执行计划\n\n我们使用通用语法中间表示（GST）来创建查询图，它是查询的更抽象、更高级的表示。使用查询图而不是直接在GST上操作，可以更有效地计算成本和执行优化。\n\n逻辑计划是一棵多叉树，由类似于关系数据库逻辑计划所使用的运算符组成。为每个查询图生成一个逻辑计划（根据查询，查询图可能由子查询图组成）。这是按照自下而上的方法逐步完成的。优化逻辑执行计划在传统的关系型数据库中，关系代数（以及等价的元组关系演算和域关系演算）构成了数据库查询理论的基础。它们也是执行计划优化的理论基础。\n\nTuGraph总结了图代数是SQL关系代数的扩展，如下图所示：\n\n因此，TuGraph的优化器包含了许多优化，例如filter安置、dedup安置、traversal规划、lazy materialization等等。在后续的文章中，我们将详细介绍这些优化。\n\n### 由逻辑执行计划创建（物理）执行计划"
            },
            {
                "content": "- 进行语义检查。\n- 根据语义生成通用语法表示（GST），对AST进行压缩，以便按相同语义进行处理。\n\n无论使用哪种查询语言，生成的GST都是相同的。\n\n### 使用GST创建查询图并提取符号表，创建逻辑执行计划\n\n我们使用通用语法中间表示（GST）来创建查询图，它是查询的更抽象、更高级的表示。使用查询图而不是直接在GST上操作，可以更有效地计算成本和执行优化。\n\n逻辑计划是一棵多叉树，由类似于关系数据库逻辑计划所使用的运算符组成。为每个查询图生成一个逻辑计划（根据查询，查询图可能由子查询图组成）。这是按照自下而上的方法逐步完成的。优化逻辑执行计划在传统的关系型数据库中，关系代数（以及等价的元组关系演算和域关系演算）构成了数据库查询理论的基础。它们也是执行计划优化的理论基础。\n\nTuGraph总结了图代数是SQL关系代数的扩展，如下图所示：\n\n因此，TuGraph的优化器包含了许多优化，例如filter安置、dedup安置、traversal规划、lazy materialization等等。在后续的文章中，我们将详细介绍这些优化。\n\n### 由逻辑执行计划创建（物理）执行计划\n\n我们为逻辑运算符选择物理实现并缓存执行计划，从而根据逻辑计划创建执行计划。物理执行计划是一棵由运算符组成的树，它与逻辑执行计划同构。其中的每个物理运算符都准确地完成逻辑运算符规定的操作，接收逻辑运算符规定的输入输出。\n\n### 校验schema约束、访问权限等\n\n在此步骤中，我们会对执行计划的有效性进行校验，包括schema约束、访问权限等。如果校验不通过，我们将报错并返回给用户。\n\n### 执行上述执行计划得到查询结果\n\n通过校验的执行计划将被实际执行，执行的结果将作为查询结果返回给用户。\n\n## 03 小结\n\n一款卓越的图查询引擎通常具备如下特质：功能强大、快速执行查询、易于使用、并且能够扩展到更大型的图数据库以提供卓越的性能。TuGraph查询引擎的设计恰是基于这些特质而进行的。我们将在未来用更多文章详细介绍TuGraph查询引擎的设计和每一步的工作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB_%7C_TuGraph_%E5%9B%BE%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90.md",
        "chunks": [
            {
                "content": "# 技术解读 | TuGraph 图分析引擎技术剖析\n\n图分析引擎又称图计算框架，主要用于进行复杂图分析，是一种能够全量数据集运行快速循环迭代的技术，适用场景包括社区发现、基因序列预测、重要性排名等，典型算法有 PageRank、WCC、BFS、LPA、SSSP。\n\nTuGraph 图数据管理平台社区版已于 2022 年 9 月在 Github 开源，本文将对 TuGraph 图分析引擎的技术进行剖析。\n\n## 1 TuGraph 图分析引擎概览\n\nTuGraph 的图分析引擎面向的场景主要是全图/全量数据分析类的任务。借助 TuGraph 的 C++ 图分析引擎 API，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如 BFS、PageRank、LPA、WCC 等迭代式图算法，最后根据运行结果做出相应的对策。在 TuGraph 中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析。与传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。\n\n根据数据来源及实现不同，可分为 **Procedure**、**Embed** 和 **Standalone** 三种运行模式。其中，Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。\n\nStandalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。\n\nTuGraph 图计算系统社区版内置 6 个基础算法，商业版内置了共 34 种算法，涵盖了图结构、社区发现、路径查询、重要性分析、模式挖掘和关联性分析的六大类常用方法，可以满足多种业务场景需要，因此用户几乎不需要自己实现具体的图计算过程。"
            },
            {
                "content": "| 算法类型               | 中文算法名                      | 英文算法名                           | 程序名                   |\n|----------------------|-----------------------------|-----------------------------------|-----------------------|\n| 路径查询               | 广度优先搜索                  | Breadth-First Search              | bfs                   |\n|                       | 单源最短路径                  | Single-Source Shortest Paths      | sssp                  |\n|                       | 全对最短路径                  | All-Pair Shortest Path            | apsp                  |\n|                       | 多源最短路径                  | Multiple-source Shortest Paths     | mssp                  |\n|                       | 两点间最短路径                | Single-Pair Shortest Paths        | psp                   |\n| 重要性分析            | 网页排序                       | Pagerank                          | pagerank              |\n|                       | 介数中心度                    | Betweenness Centrality            | bc                    |"
            },
            {
                "content": "|                       | 多源最短路径                  | Multiple-source Shortest Paths     | mssp                  |\n|                       | 两点间最短路径                | Single-Pair Shortest Paths        | psp                   |\n| 重要性分析            | 网页排序                       | Pagerank                          | pagerank              |\n|                       | 介数中心度                    | Betweenness Centrality            | bc                    |\n|                       | 置信度传播                    | Belief Propagation                | bp                    |\n|                       | 距离中心度                    | Closeness Centrality              | clc                   |\n|                       | 个性化网页排序                | Personalized PageRank             | ppr                   |\n|                       | 带权重的网页排序              | Weighted Pagerank Algorithm       | wpagerank             |\n|                       | 信任指数排名                  | Trustrank                         | trustrank             |"
            },
            {
                "content": "|                       | 距离中心度                    | Closeness Centrality              | clc                   |\n|                       | 个性化网页排序                | Personalized PageRank             | ppr                   |\n|                       | 带权重的网页排序              | Weighted Pagerank Algorithm       | wpagerank             |\n|                       | 信任指数排名                  | Trustrank                         | trustrank             |\n|                       | 超链接主题搜索                | Hyperlink-Induced Topic Search    | hits                  |\n| 关联性分析            | 平均集聚系数                  | Local Clustering Coefficient      | lcc                   |\n|                       | 共同邻居                      | Common Neighborhood                | cn                    |\n|                       | 度数关联度                    | Degree Correlation                 | dc                    |\n|                       | 杰卡德系数                    | Jaccard Index                      | ji                    |"
            },
            {
                "content": "| 关联性分析            | 平均集聚系数                  | Local Clustering Coefficient      | lcc                   |\n|                       | 共同邻居                      | Common Neighborhood                | cn                    |\n|                       | 度数关联度                    | Degree Correlation                 | dc                    |\n|                       | 杰卡德系数                    | Jaccard Index                      | ji                    |\n| 图结构                | 直径估计                      | Dimension Estimation               | de                    |\n|                       | K核算法                      | K-core                             | kcore                 |\n|                       | k阶团计数算法                | Kcliques                          | kcliques              |\n|                       | k阶桁架计数算法              | Ktruss                            | ktruss                |\n|                       | 最大独立集算法                | Maximal independent set           | mis                   |"
            },
            {
                "content": "|                       | K核算法                      | K-core                             | kcore                 |\n|                       | k阶团计数算法                | Kcliques                          | kcliques              |\n|                       | k阶桁架计数算法              | Ktruss                            | ktruss                |\n|                       | 最大独立集算法                | Maximal independent set           | mis                   |\n| 社区发现              | 弱连通分量                    | Weakly Connected Components        | wcc                   |\n|                       | 标签传播                      | Label Propagation Algorithm       | lpa                   |\n|                       | EgoNet算法                   | EgoNet                            | en                    |\n|                       | 鲁汶社区发现                  | Louvain                           | louvain               |\n|                       | 强连通分量                    | Strongly Connected Components      | scc                   |"
            },
            {
                "content": "|                       | 标签传播                      | Label Propagation Algorithm       | lpa                   |\n|                       | EgoNet算法                   | EgoNet                            | en                    |\n|                       | 鲁汶社区发现                  | Louvain                           | louvain               |\n|                       | 强连通分量                    | Strongly Connected Components      | scc                   |\n|                       | 监听标签传播                  | Speaker-listener Label Propagation | lpa                   |\n|                       | 莱顿算法                      | Leiden                            | leiden                |\n|                       | 带权重的标签传播              | Weighted Label Propagation Algorithm | wlpa                  |\n| 模式挖掘              | 三角计数                      | Triangle Counting                  | triangle              |\n|                       | 子图匹配算法                  | Subgraph Isomorphism              | subgraph_isomorphism   |"
            },
            {
                "content": "|                       | 莱顿算法                      | Leiden                            | leiden                |\n|                       | 带权重的标签传播              | Weighted Label Propagation Algorithm | wlpa                  |\n| 模式挖掘              | 三角计数                      | Triangle Counting                  | triangle              |\n|                       | 子图匹配算法                  | Subgraph Isomorphism              | subgraph_isomorphism   |\n|                       | 模式匹配算法                  | Motif                             | motif                 |"
            },
            {
                "content": "## 2 功能介绍\n\n### 2.1 图分析框架\n\n图分析框架作为图分析引擎的“骨架”，可以联合多种模块有效的耦合协同工作。一般分为预处理、算法过程、结果分析三个阶段。\n\n预处理部分用于读入数据及参数进行图构建及相关信息的存储统计，并整理出算法过程所需的参数及数据。\n\n算法过程会根据得到的数据通过特定的算法进行逻辑计算，并得到结果数据。 结果分析部分根据得到的结果数据进行个性化处理（如取最值等），并将重要的信息写回和打印输出操作。\n\n### 2.2 点边筛选器\n\n点边筛选器作用于图分析引擎中的 Procedure 和 Embed 模式。对于图存储数据源可根据用户需要和实际业务场景对图数据进行筛查，选择有效的点边进行图结构的构建。\n\n### 2.3 一致性快照\n\nTuGraph 中的 Procedure 和 Embed 模式能够提供数据“快照”，即建立一个对指定数据集的完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的镜像。由于 OLAP 的操作仅涉及读操作而不涉及写操作，OlapOnDB 会以一种更紧凑的方式对数据进行排布，在节省空间的同时，提高数据访问的局部性。\n\n### 2.4 块状读写模块\n\n块状读写模块作用于图分析引擎中的 Standalone 模式，用于对不同外部数据源的数据进行高效读入，同时也包含对内部算法处理后的图数据结果写回。\n\n### 2.5 参数模块\n\n参数模块作用于分析引擎中的 Standalone 模式，用于对图的一般信息（如数据来源、算法名称、数据输入、输出路径、顶点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数进行接受和整理，传输给图算法及各个模块，同时将最终结果模块化展示。\n\n## 3 使用示例\n\n由前文所述可知，图分析引擎分为 Standalone、Embed 和 Procedure 模式，现在以 BFS 算法为例分别介绍它们的使用方式。\n\n### 3.1 Procedure 模式\n\nProcedure 模式主要用于 Client/Server 的 TuGraph 运行时，图算法的加载和调用。在 TuGraph/plugins 目录下执行以下命令即可在 TuGraph/plugins 目录下得到 bfs.so 文件：\n\n```bash\nbash make_so.sh bfs\n```"
            },
            {
                "content": "### 2.4 块状读写模块\n\n块状读写模块作用于图分析引擎中的 Standalone 模式，用于对不同外部数据源的数据进行高效读入，同时也包含对内部算法处理后的图数据结果写回。\n\n### 2.5 参数模块\n\n参数模块作用于分析引擎中的 Standalone 模式，用于对图的一般信息（如数据来源、算法名称、数据输入、输出路径、顶点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数进行接受和整理，传输给图算法及各个模块，同时将最终结果模块化展示。\n\n## 3 使用示例\n\n由前文所述可知，图分析引擎分为 Standalone、Embed 和 Procedure 模式，现在以 BFS 算法为例分别介绍它们的使用方式。\n\n### 3.1 Procedure 模式\n\nProcedure 模式主要用于 Client/Server 的 TuGraph 运行时，图算法的加载和调用。在 TuGraph/plugins 目录下执行以下命令即可在 TuGraph/plugins 目录下得到 bfs.so 文件：\n\n```bash\nbash make_so.sh bfs\n```\n\n将该文件以插件形式上传至 TuGraph-web，输入参数后即可执行。\n\n#### 示例\n\n在 TuGraph/plugins 编译.so 算法文件\n\n```bash\nbash make_so.sh bfs\n```\n\n将 bfs.so 文件以插件形式加载至 TuGraph-web 后，输入如下 JSON 参数：\n\n```json\n{\n\t\"root_id\": \"0\",\n\t\"label\": \"node\",\n\t\"field\": \"id\"\n}\n```\n\n即可得到返回结果。\n\n```json\n{\n  \"core_cost\": 0.013641119003295898,\n  \"found_vertices\": 3829,\n  \"num_edges\": 88234,\n  \"num_vertices\": 4039,\n  \"output_cost\": 8.821487426757813e-06,\n  \"prepare_cost\": 0.03479194641113281,\n  \"total_cost\": 0.04844188690185547\n}\n```"
            },
            {
                "content": "```bash\nbash make_so.sh bfs\n```\n\n将该文件以插件形式上传至 TuGraph-web，输入参数后即可执行。\n\n#### 示例\n\n在 TuGraph/plugins 编译.so 算法文件\n\n```bash\nbash make_so.sh bfs\n```\n\n将 bfs.so 文件以插件形式加载至 TuGraph-web 后，输入如下 JSON 参数：\n\n```json\n{\n\t\"root_id\": \"0\",\n\t\"label\": \"node\",\n\t\"field\": \"id\"\n}\n```\n\n即可得到返回结果。\n\n```json\n{\n  \"core_cost\": 0.013641119003295898,\n  \"found_vertices\": 3829,\n  \"num_edges\": 88234,\n  \"num_vertices\": 4039,\n  \"output_cost\": 8.821487426757813e-06,\n  \"prepare_cost\": 0.03479194641113281,\n  \"total_cost\": 0.04844188690185547\n}\n```\n\n#### 输出内容解释：\n- `num_edges`：表示该图数据的边数量\n- `num_vertices`：表示该图数据顶点的数量\n- `prepare_cost`：表示预处理阶段所需要的时间。\n- `core_cost`：表示算法运行所需要的时间。\n- `found_vertices`：表示查找到顶点的个数。\n- `output_cost`：表示算法结果写回 db 所需要的时间。\n- `total_cost`：表示执行该算法整体运行时间。\n\n### 3.2 Embed 模式\n\n该种方式主要用于TuGraph在后台程序中对预加载的图存储数据进行算法分析，多用于快速调试。在TuGraph/plugins目录下对embed_main.cpp文件完善，补充数据名称、输入参数、数据路径等信息，示例如下：\n\n#### C++ 示例代码\n\n以下是一个使用 TuGraph 数据库的 C++ 示例代码，展示如何打开数据库并处理请求。\n\n```cpp\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/olap_base.h\"\n\nusing namespace std;"
            },
            {
                "content": "### 3.2 Embed 模式\n\n该种方式主要用于TuGraph在后台程序中对预加载的图存储数据进行算法分析，多用于快速调试。在TuGraph/plugins目录下对embed_main.cpp文件完善，补充数据名称、输入参数、数据路径等信息，示例如下：\n\n#### C++ 示例代码\n\n以下是一个使用 TuGraph 数据库的 C++ 示例代码，展示如何打开数据库并处理请求。\n\n```cpp\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/olap_base.h\"\n\nusing namespace std;\n\nextern \"C\" bool Process(lgraph_api::GraphDB &db, const std::string &request, std::string &response);\n\nint main(int argc, char **argv) {\n    // db_path表示预加载图数据存放的路径\n    std::string db_path = \"./fb_db/\";\n    \n    if (argc > 1) {\n        db_path = argv[1];\n    }\n    \n    lgraph_api::Galaxy g(db_path);\n    g.SetCurrentUser(\"admin\", \"730TuGraph\");\n    // 指定图数据的名称\n    lgraph_api::GraphDB db = g.OpenGraph(\"fb_db\");\n    \n    std::string resp;\n    // 以json形式输入算法参数\n    bool r = Process(db, \"{\\\"root_id\\\": \\\"0\\\", \\\"label\\\": \\\"node\\\", \\\"field\\\": \\\"id\\\"}\", resp);\n    \n    cout << r << endl;\n    cout << resp << endl;\n    \n    return 0;\n}"
            },
            {
                "content": "保存后在TuGraph/plugins目录下执行 bash make_so.sh bfs 即可在TuGraph/plugins/cpp目录下的到bfs_procedure文件，bash make_embed.sh bfs\n\n在TuGraph/plugins文件夹下执行./cpp/bfs_procedure即可得到返回结果。\n\n```json\n{\"root_id\":\"0\", \"label\":\"node\", \"field\":\"id\"}\n```\n\nfound_vertices = 3829\n\n```json\n{\n    \"core_cost\": 0.025603055953979492,\n    \"found_vertices\": 3829,\n    \"num_edges\": 88234,\n    \"num_vertices\": 4039,\n    \"output_cost\": 9.059906005859375e-06,\n    \"prepare_cost\": 0.056738853454589844,\n    \"total_cost\": 0.0823509693145752\n}\n```\n\n### 3.3 Standalone 模式"
            },
            {
                "content": "found_vertices = 3829\n\n```json\n{\n    \"core_cost\": 0.025603055953979492,\n    \"found_vertices\": 3829,\n    \"num_edges\": 88234,\n    \"num_vertices\": 4039,\n    \"output_cost\": 9.059906005859375e-06,\n    \"prepare_cost\": 0.056738853454589844,\n    \"total_cost\": 0.0823509693145752\n}\n```\n\n### 3.3 Standalone 模式\n\nStandalone 模式可以独立于图存储运行，直接从文本文件或 ODPS 读取 Edgelist 形式的图数据。在 TuGraph/build 目录下执行 make bfs_standalone 即可得到 bfs_standalone 文件,该文件生成与 TuGraph/build/output/algo 文件夹下。运行：在 TuGraph/build 目录下执行./output/algo/bfs_standalone -–type [type] –-input_dir [input_dir] -–vertices [vertices] --root [root] –-output_dir [output_dir]\n\t•[type]：表示输入图文件的类型来源，包含 text 文本文件、BINARY_FILE 二进制文件和 ODPS 源。\n\t•[input_dir]：表示输入图文件的文件夹路径，文件夹下可包含一个或多个输入文件。TuGraph 在读取输入文件时会读取[input_dir]下的所有文件，要求[input_dir]下只能包含输入文件，不能包含其它文件。参数不可省略。\n\t•[vertices]：表示图的顶点个数，为 0 时表示用户希望系统自动识别顶点数量；为非零值时表示用户希望自定义顶点个数，要求用户自定义顶点个数需大于最大的顶点 ID。参数可省略，默认值为 0。\n\t•[root]：表示进行 bfs 的起始顶点 id。参数不可省略。\n\t•[output_dir]：表示输出数据保存的文件夹路径，将输出内容保存至该文件中，参数不可省略。\n\n示例：在 TuGraph/build 编译 standalone 算法程序"
            },
            {
                "content": "示例：在 TuGraph/build 编译 standalone 算法程序\n\nmake bfs_standalone\n\n在 TuGraph/build/output 目录下运行 text 源文件\n\n/output/algo/bfs_standalone --type text --\ninput_dir ../test/integration/data/algo/fb_unweighted --root 0\n\n得到运行结果：\n\n- **prepare_cost**: 0.10 s\n- **core_cost**: 0.02 s\n- **found_vertices**: 3829\n- **output_cost**: 0.00 s\n- **total_cost**: 0.11 s\n**DONE.**\n\n\n结果参数解释同上。\n\n## 4 小结\n\n综上，图分析引擎可以高效、快速地处理多种来源的数据，其并行的图构建方式保证了内存占用小的特点。此外，图分析引擎也具有易于安装部署、灵活性高、耦合程度低、易于上手等对用户友好的特性，可以帮助用户结合具体业务解决问题。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E6%8E%A8%E5%8A%A8%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%8C%96%E8%BF%9B%E7%A8%8B%EF%BC%8CTuGraph_%E5%BC%80%E6%BA%90_ISO_GQL_Antlr4_%E8%AF%AD%E6%B3%95%E6%96%87%E4%BB%B6.md",
        "chunks": [
            {
                "content": "# 推动图数据库查询语言标准化进程，TuGraph 开源 ISO GQL Antlr4 语法文件\n\nTuGraph 团队开源了基于最新的图数据库标准查询语言 ISO GQL（草案）实现的 Antlr4 语法文件，并对表达式等语法定义进行了大量重构，大幅提升了 Antlr4 解析阶段的性能。使用者可以通过 Antlr4 快速接入到现有的图数据库产品之中，快速适配和体验 ISO GQL 最新的语法能力。\n\nGitHub代码仓库：[https://github.com/TuGraph-family/gql-grammar](https://github.com/TuGraph-family/gql-grammar)\n\n在图数据库领域，通常使用 Antlr4 将不同开发语言的语法结构映射到图数据库中的节点和边，转化为图数据。我们基于2023年3月版本草案中的语法规范，编写了 ISO GQL 的 Antlr4 语法文件，并进行了大量的优化工作，提高了 Antlr4 解析 ISO GQL 语句的性能。Antlr4已在蚂蚁集团内部系统和业务中实际投入使用，平均可以提升解析速度数十倍，在一些复杂查询语句场景下，甚至可以提升至上百倍。\n\n为了降低现有的图数据库快速接入图数据库标准查询语言 ISO GQL 的门槛，推进共建 ISO GQL 标准化的进程，TuGraph 团队于近期开源了最新版本 ISO GQL（2023.3版本）的 Antlr4 语法文件。现有的图数据库及其他系统能以此开源语法文件为基础，更快、更准确地在查询引擎中增加对 ISO GQL 语句的解析与支持。我们期待越来越多的图数据库接入 ISO GQL，共同促进图数据库查询语言的应用与发展。\n\n未来，我们会持续跟进 ISO GQL 的发展，及时更新迭代我们的语法文件，发布更多关于 ISO GQL 的实际使用案例和文档，推动 ISO GQL 在更多产品和业务场景中的使用。\n\n## 关于 Antlr4"
            },
            {
                "content": "为了降低现有的图数据库快速接入图数据库标准查询语言 ISO GQL 的门槛，推进共建 ISO GQL 标准化的进程，TuGraph 团队于近期开源了最新版本 ISO GQL（2023.3版本）的 Antlr4 语法文件。现有的图数据库及其他系统能以此开源语法文件为基础，更快、更准确地在查询引擎中增加对 ISO GQL 语句的解析与支持。我们期待越来越多的图数据库接入 ISO GQL，共同促进图数据库查询语言的应用与发展。\n\n未来，我们会持续跟进 ISO GQL 的发展，及时更新迭代我们的语法文件，发布更多关于 ISO GQL 的实际使用案例和文档，推动 ISO GQL 在更多产品和业务场景中的使用。\n\n## 关于 Antlr4\n\nAntlr4 是一款备受欢迎的语法分析器生成工具，能够根据语法规则快速生成自定义解析器。其支持 LL(*) 解析，拥有更强大的错误处理能力和更快的解析速度。不仅如此，Antlr4 还支持 Java、Python、C++、JavaScript、Go 等10种目标语言，广泛应用于多种开发语言生态中。简单易用的 API 和文档使得开发人员能够快速上手。无论是编程语言、数据格式、编译器还是解释器等领域，Antlr4 都发挥着重要作用。著名的开源项目如 Apache Spark、Eclipse IDE 和 MongoDB 等都使用了 Antlr4 进行语法分析。\n\n## 关于ISO GQL\n\nISO GQL（ISO/IEC 39075）是一种标准化的图数据库查询语言，由监管 SQL 标准的同一个国际工作组开发和维护，同时也是自 SQL 之后的第一个 ISO/IEC 国际标准数据库语言项目。ISO GQL 图查询语言将结构化数据建模为图，并在图数据库或其他图存储中存储、查询和修改这些数据。目前 ISO GQL 处于草案阶段，蚂蚁集团也是其主要贡献者之一。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E6%9D%83%E5%A8%81%E6%8A%A5%E5%91%8A%EF%BC%9A%E8%9A%82%E8%9A%81%E9%9B%86%E5%9B%A2TuGraph%E8%B7%BB%E8%BA%AB%E4%B8%AD%E5%9B%BD%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%82%E5%9C%BA%E2%80%9C%E9%A2%86%E5%AF%BC%E8%80%85%E2%80%9D%E8%B1%A1%E9%99%90.md",
        "chunks": [
            {
                "content": "# 权威报告：蚂蚁集团TuGraph跻身中国图数据库市场“领导者”象限\n\n7月15日，全球领先的IT市场研究和咨询公司IDC发布了最新的市场研究报告《IDC MarketScape：中国图数据库市场厂商评估，2023》。报告显示，蚂蚁集团自研的企业级图数据管理平台TuGraph跻身\"领导者\"象限。\n\nIDC在报告中列举了蚂蚁集团TuGraph的五大优势。第一，TuGraph研发七年多来支持了蚂蚁集团300多种应用，在大量不同场景中长时间使用，产品成熟度、丰富度等方面具有优势。第二，具备业界鲜有的在线、流式、离线\"三线一致\"计算能力，覆盖了毫秒级延迟、分钟级和小时级等不同引擎，满足不同场景的性能需求。第三，支持每秒千万级查询的超高吞吐，毫秒级超低延迟。第四，生态工具“一站式图研发及可视化平台 TuGraph-Platform”降低了用户使用门槛。第五，在其他非金融场景，如社交推荐、数据血缘管理、故障归因分析等场景广泛使用，应用体系成熟。\n\n本次报告IDC主要评估了中国市场上12家典型的企业级图数据库厂商，类型覆盖互联网厂商、云服务厂商、大数据厂商等。IDC针对入选图数据库厂商的产品能力（Capabilities）和技术战略（Strategies）两个维度，考察了目前的产品技术能力、市场和生态以及未来发展战略等，评估了16个细分能力指标和4个细分战略指标，包含72个指标评估项，并配以不同权重。该报告为企业发展图计算和投资选型提供了有力支持。\n\n图数据库，即以图（Graph）数据结构来进行存储和分析的数据库。与传统数据库相比，图数据库擅长关系分析，能更好地管理和组织数据，开发上层智能模型，同时也能实现海量数据的高并发、低延迟分析处理，提高数据变现的商业价值。当前图数据库应用主要集中在欺诈检测、人际关系分析和预测分析等领域。\n\nIDC调研发现，数字经济、产业数字化转型进入深化发展阶段，企业对于业务逻辑开发和关系挖掘需求增强，图数据库市场受大型央国企数字化转型政策的推动明显。95%的企业认为图数据库是重要的数据管理工具，超过 65%的厂商认为在业务上图数据库优于其他选择。整体来看，图数据库的使用仍处于早期阶段，仍然缺乏统一标准范式，技术生态环境弱势，低操作门槛的图计算平台仍有较大缺口。"
            },
            {
                "content": "图数据库，即以图（Graph）数据结构来进行存储和分析的数据库。与传统数据库相比，图数据库擅长关系分析，能更好地管理和组织数据，开发上层智能模型，同时也能实现海量数据的高并发、低延迟分析处理，提高数据变现的商业价值。当前图数据库应用主要集中在欺诈检测、人际关系分析和预测分析等领域。\n\nIDC调研发现，数字经济、产业数字化转型进入深化发展阶段，企业对于业务逻辑开发和关系挖掘需求增强，图数据库市场受大型央国企数字化转型政策的推动明显。95%的企业认为图数据库是重要的数据管理工具，超过 65%的厂商认为在业务上图数据库优于其他选择。整体来看，图数据库的使用仍处于早期阶段，仍然缺乏统一标准范式，技术生态环境弱势，低操作门槛的图计算平台仍有较大缺口。\n\n蚂蚁集团从2015年开始布局图技术，与清华大学合作研发了高性能图数据库TuGraph，扛住了蚂蚁万亿级业务的高性能要求。TuGraph在功能完整性、吞吐率、响应时间等技术指标上处于全球领先水平，两次打破国际图数据库基准性能测试世界纪录，成为LDBC-SNB世界纪录保持者。TuGraph在2021年帮助支付宝实现了资产损失率小于亿分之0.98的目标。\n\n目前，蚂蚁集团已经开源了TuGraph系统中的单机版图数据TuGraph-DB和流式图计算引擎TuGraph-Analytics。TuGraph-DB提供了完备的图数据库基础功能和成熟的产品设计，具备完整的事务支持和丰富的系统特性，可在单机上部署，使用成本低，支持TB级别的数据规模。而TuGraph-Analytics是业界首个工业级流式图计算引擎，能够在超大规模图上进行流式复杂计算。\n\n未来，蚂蚁将持续加强技术开放，为业界带来先进的图计算技术能力，与行业携手建设图计算技术生态。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBTuGraph%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E7%B3%BB%E7%BB%9F.md",
        "chunks": [
            {
                "content": "# 深入解读TuGraph计算引擎模型推理系统\n\nTuGraph计算引擎模型推理系统将基于迭代计算的图计算框架与模型推理系统相结合，推理系统可自定义推理依赖环境，图迭代计算与推理链路实现隔离。基于共享内存的跨进程通信方式，提高了推理数据交换效率，满足流图近线推理的时效性。在蚂蚁集团内部的实际应用场景中，大幅缩短了模型推理上线的链路与开发时间，用户迭代模型版本更方便快捷。\n\n## 1. 图算法概述\n\n在计算机科学中，图是一种表示实体（节点或顶点）以及实体之间关系（边）的数据结构。图模型可以天然地描述网络结构，能更清晰地表达复杂的数据关系和依赖，简化关联数据的理解和分析。在不同的场景下，图中点边具备不同的语义信息。例如，在资金交易场景下，每个人可以抽象成一个点表示，人与人之间的转账关系可以抽象成一条边表示。如下图，通过图数据模型反映出各个实体之间的资金往来关系，让数据的关联分析更加直观和高效。\n\n### 资金交易图谱示例\n\n在图数据模型上可以执行多种图算法，如社区检测、最短路径匹配、环路检测算法等。通过点边上的迭代计算，探索图模型中各个实体之间的关系。探索过程不依赖于数据的线性结构，从而便于识别隐藏的模式和关联关系。在主流迭代图算法中，节点通过消息传递的方式进行通信。每次迭代，节点可以接收来自它们邻居的消息，处理这些消息，然后决定是否发送新的消息给其他节点。迭代算法中，每个节点有一个状态，每次迭代它们都有可能更新这个状态直至收敛。例如，在PageRank算法中，每个节点的状态是其PageRank值，这个值在迭代过程中会随着邻居的值的更新而更新。"
            },
            {
                "content": "## 1. 图算法概述\n\n在计算机科学中，图是一种表示实体（节点或顶点）以及实体之间关系（边）的数据结构。图模型可以天然地描述网络结构，能更清晰地表达复杂的数据关系和依赖，简化关联数据的理解和分析。在不同的场景下，图中点边具备不同的语义信息。例如，在资金交易场景下，每个人可以抽象成一个点表示，人与人之间的转账关系可以抽象成一条边表示。如下图，通过图数据模型反映出各个实体之间的资金往来关系，让数据的关联分析更加直观和高效。\n\n### 资金交易图谱示例\n\n在图数据模型上可以执行多种图算法，如社区检测、最短路径匹配、环路检测算法等。通过点边上的迭代计算，探索图模型中各个实体之间的关系。探索过程不依赖于数据的线性结构，从而便于识别隐藏的模式和关联关系。在主流迭代图算法中，节点通过消息传递的方式进行通信。每次迭代，节点可以接收来自它们邻居的消息，处理这些消息，然后决定是否发送新的消息给其他节点。迭代算法中，每个节点有一个状态，每次迭代它们都有可能更新这个状态直至收敛。例如，在PageRank算法中，每个节点的状态是其PageRank值，这个值在迭代过程中会随着邻居的值的更新而更新。\n\n图迭代算法解决了经典的图计算问题，但随着业务需求的复杂度提升，基于迭代的图算法存在着表达能力不足、自适应性能力差、异质图处理难度大等缺点。近年来随着深度学习的研究和应用的发展，以图神经网络（Graph Neural Networks，GNNs）为代表的一类神经网络算法，被设计用来捕获图中实体（节点）和关系（边）间的复杂模式。图神经网络能够结合节点特征和图的结构来学习节点和边的表示，相比之下，传统的迭代图算法通常不会直接从原始特征中学习，而更多地专注于结构特征。依赖于深度学习的天然优势，GNNs具有更强的表示学习能力，可以自动从数据中学习复杂的模式，这使得GNNs能够更好地处理多任务学习和迁移学习等问题。在社交网络分析、知识图谱、生物分子网络、推荐系统以及交通网络等领域，得到广泛应用。\n\n## 2. 流图推理简介"
            },
            {
                "content": "图迭代算法解决了经典的图计算问题，但随着业务需求的复杂度提升，基于迭代的图算法存在着表达能力不足、自适应性能力差、异质图处理难度大等缺点。近年来随着深度学习的研究和应用的发展，以图神经网络（Graph Neural Networks，GNNs）为代表的一类神经网络算法，被设计用来捕获图中实体（节点）和关系（边）间的复杂模式。图神经网络能够结合节点特征和图的结构来学习节点和边的表示，相比之下，传统的迭代图算法通常不会直接从原始特征中学习，而更多地专注于结构特征。依赖于深度学习的天然优势，GNNs具有更强的表示学习能力，可以自动从数据中学习复杂的模式，这使得GNNs能够更好地处理多任务学习和迁移学习等问题。在社交网络分析、知识图谱、生物分子网络、推荐系统以及交通网络等领域，得到广泛应用。\n\n## 2. 流图推理简介\n\nTuGraph计算引擎（TuGraph Analytics）是蚂蚁集团开源的大规模分布式实时图计算引擎（流图引擎），实现了流批一体的图计算模型，支持丰富的图计算算法。TuGraph Analytics的流图计算能力，能处理连续输入的数据流，并支持增量的计算模式，极大提高了数据的计算效率和实时性。TuGraph Analytics解决了业界大规模数据关联分析的实时计算问题，已广泛应用于数仓加速、金融风控、知识图谱以及社交推荐等场景。\n\n随着业务场景中问题复杂度的提升，基于传统的迭代图算法已无法满足业务的实际需求。例如在反洗钱场景中，利用图神经网络算法处理复杂的交易关系，能够捕获到节点的局部图结构信息。通过聚合邻接节点的特征信息，每个交易节点都可以感知到周边图网络结构的信息。类似的图神经网络等AI模型的推理逻辑，无法基于传统的图迭代计算模式直接高效地表达。\n\n受上述问题启发，我们思考是否可以将TuGraph Analytics的流图计算能力与图神经网络等深度学习模型相结合，开发一套基于流图计算的模型推理系统。最终期望的推理系统具备如下能力：\n\n- 对于图算法工程师，在图迭代计算过程中，能够方便地使用机器学习模型的推理能力。\n- 对于AI算法工程师，可以通过TuGraph Analytics分布式流式计算的能力实现实时的模型推理。"
            },
            {
                "content": "随着业务场景中问题复杂度的提升，基于传统的迭代图算法已无法满足业务的实际需求。例如在反洗钱场景中，利用图神经网络算法处理复杂的交易关系，能够捕获到节点的局部图结构信息。通过聚合邻接节点的特征信息，每个交易节点都可以感知到周边图网络结构的信息。类似的图神经网络等AI模型的推理逻辑，无法基于传统的图迭代计算模式直接高效地表达。\n\n受上述问题启发，我们思考是否可以将TuGraph Analytics的流图计算能力与图神经网络等深度学习模型相结合，开发一套基于流图计算的模型推理系统。最终期望的推理系统具备如下能力：\n\n- 对于图算法工程师，在图迭代计算过程中，能够方便地使用机器学习模型的推理能力。\n- 对于AI算法工程师，可以通过TuGraph Analytics分布式流式计算的能力实现实时的模型推理。\n\n众所周知，在深度学习为代表的数据科学领域，Python已经成为数据分析、模型训练和推理框架的主流开发语言，并提供了丰富的开发库和框架生态。而以Hadoop全家桶为代表的大数据计算引擎领域，基于Java语言开发的系统仍占据一席之地，当然TuGraph Analytics也在其中。这种语言差异带来的“互操作性”成本，使得相当一部分大数据和AI生态组件无法轻松地融合，这也是TuGraph Analytics支持图推理需要亟待解决的问题。\n\n## 3. 系统设计\n\n我们对业内的跨Python & Java语言的方案进行了充分的调研，通过深入对比现有的跨语言交互方案的性能与效率，最终决定将模型推理任务运行于Python原生环境中以发挥出最佳的性能。\n\n### 1. OONX\n\nOONX是一个开发的生态系统，为不同的机器学习框架之间提供一个标准的模型表示格式。它使得开发人员能够在不同的框架、工具、运行时环境之间以一种标准方式交换模型，从而简化了模型的迁移和部署。\n\n**优点**\n\n- 框架互操作性\n- 规范化模型格式\n- 优化推理\n- 生态系统支持\n\n**缺点**\n\n- 更新滞后\n- 版本兼容性\n- 转换成本高\n- 性能不一致\n\n### 2. Jython\n\n以Jython为代表的方式，主要思想是在运行的宿主虚拟机上，使用宿主语言重新编写实现。\n\n**优点**\n\n- Java集成\n- 跨平台\n- 线程\n\n**缺点**\n\n- 版本管理复杂\n- 支持库有限\n- 更新滞后\n- 支持Python3有限\n\n### 3. Py4j"
            },
            {
                "content": "## 3. 系统设计\n\n我们对业内的跨Python & Java语言的方案进行了充分的调研，通过深入对比现有的跨语言交互方案的性能与效率，最终决定将模型推理任务运行于Python原生环境中以发挥出最佳的性能。\n\n### 1. OONX\n\nOONX是一个开发的生态系统，为不同的机器学习框架之间提供一个标准的模型表示格式。它使得开发人员能够在不同的框架、工具、运行时环境之间以一种标准方式交换模型，从而简化了模型的迁移和部署。\n\n**优点**\n\n- 框架互操作性\n- 规范化模型格式\n- 优化推理\n- 生态系统支持\n\n**缺点**\n\n- 更新滞后\n- 版本兼容性\n- 转换成本高\n- 性能不一致\n\n### 2. Jython\n\n以Jython为代表的方式，主要思想是在运行的宿主虚拟机上，使用宿主语言重新编写实现。\n\n**优点**\n\n- Java集成\n- 跨平台\n- 线程\n\n**缺点**\n\n- 版本管理复杂\n- 支持库有限\n- 更新滞后\n- 支持Python3有限\n\n### 3. Py4j\n\nPy4j桥接库为代表的方式，以Socket通信模型为基础，实现Python和Java互相访问对象，方法，提供两个程序相互通信的能力。\n\n**优点**\n\n- 跨语言交互\n- 动态代理\n- 支持复杂类型\n- API使用简易\n\n**缺点**\n\n- 网络传输\n- 部署分发难度大\n- 版本难兼容\n- 运行时环境依赖复杂\n\n### 4. Web服务化\n\nWeb服务化是一种将机器学习模型部署成网络服务，调用者通过相应的API获取模型推理结果。\n\n**优点**\n\n- 扩展性好\n- 简易且轻量\n- 社区支持\n- 机器学习类库易集成\n\n**缺点**\n\n- 性能差\n- 不适合计算密集型场景\n- 无状态管理\n- 并发连接有限\n\n在TuGraph Analytics模型推理系统的架构设计中，核心部分是通过C++原生语言建立起来的一座桥梁，实现Python环境和Java虚拟机之间高效的数据交互和操作指令的传递。通过使用C++作为媒介语言，我们不仅能够利用其接近硬件的执行效率，确保数据交互的性能，还能够保证在两个虚拟环境之间数据交换的计算精度和稳定性。基于共享内存的设计允许Python和JVM进程各自独立运行，既保证了运行环境的安全隔离，又能实现数据的高效共享。\n\n## 4. 技术原理"
            },
            {
                "content": "**优点**\n\n- 跨语言交互\n- 动态代理\n- 支持复杂类型\n- API使用简易\n\n**缺点**\n\n- 网络传输\n- 部署分发难度大\n- 版本难兼容\n- 运行时环境依赖复杂\n\n### 4. Web服务化\n\nWeb服务化是一种将机器学习模型部署成网络服务，调用者通过相应的API获取模型推理结果。\n\n**优点**\n\n- 扩展性好\n- 简易且轻量\n- 社区支持\n- 机器学习类库易集成\n\n**缺点**\n\n- 性能差\n- 不适合计算密集型场景\n- 无状态管理\n- 并发连接有限\n\n在TuGraph Analytics模型推理系统的架构设计中，核心部分是通过C++原生语言建立起来的一座桥梁，实现Python环境和Java虚拟机之间高效的数据交互和操作指令的传递。通过使用C++作为媒介语言，我们不仅能够利用其接近硬件的执行效率，确保数据交互的性能，还能够保证在两个虚拟环境之间数据交换的计算精度和稳定性。基于共享内存的设计允许Python和JVM进程各自独立运行，既保证了运行环境的安全隔离，又能实现数据的高效共享。\n\n## 4. 技术原理\n\nTuGraph Analytics模型推理系统工作流中，Driver端（即控制节点）发挥着至关重要的角色。该节点运行在Java虚拟机进程，是整个推理流程的控制中心。Driver端初始化了一个非常关键的组件——InferenceContext对象，InferenceContext对象被设计为模型推理流程的核心，在JVM环境中创建并负责加载和预处理用户提供的模型文件和环境依赖信息。在模型推理任务之前，InferenceContext会详细检查并准备好模型文件，确保能够正确加载到预期的执行环境中。InferenceContext也负责初始化和配置与模型推理相关的虚拟环境，确保正确的Python环境或其他必要的运行时库得以安装和配置。\n\n如图所示，由流式数据源源不断的触发图迭代计算与模型推理工作。TuGraph计算引擎提供了DeltaGraphCompute计算接口，用户可自主定义增量图数据的处理逻辑，并更新历史的图存储(Graph Store)。通过TuGraph计算引擎模型推理系统，增量图迭代的中间计算结果，经过推理前置数据处理接口，并基于共享内存的跨进程通信方式，将处理后的数据流输入到推理进程，完成推理工作后的结果参与后续图迭代计算逻辑。下文将详细介绍各个数据接口的使用。"
            },
            {
                "content": "如图所示，由流式数据源源不断的触发图迭代计算与模型推理工作。TuGraph计算引擎提供了DeltaGraphCompute计算接口，用户可自主定义增量图数据的处理逻辑，并更新历史的图存储(Graph Store)。通过TuGraph计算引擎模型推理系统，增量图迭代的中间计算结果，经过推理前置数据处理接口，并基于共享内存的跨进程通信方式，将处理后的数据流输入到推理进程，完成推理工作后的结果参与后续图迭代计算逻辑。下文将详细介绍各个数据接口的使用。\n\n### 4.1 计算推理隔离\n\n在TuGraph Analytics模型推理系统的架构中，集群的工作负载分配给多个worker节点。每个worker节点上运行着两个关键进程：负责图数据迭代计算的Java进程，以及执行模型推理的Python进程。为了充分利用计算系统的资源，推理进程在没有接收到推理请求时，会进入睡眠状态。这样的设计不仅减少了系统资源的占用，而且降低了系统的整体能耗。当推理请求到达时，推理进程会被立即唤醒，接收和执行新的推理任务。借助睡眠与唤醒机制以及智能的任务调度策略，可以保证系统能够以高效、稳定、节能的方式运行，同时满足了大规模图数据处理和实时推理的需求。\n\n在每个worker工作节点下，按照不同的推理作业级别划分基础的虚拟环境，从而保证一个worker节点也可以支持不同推理任务，支持标准的requirements.txt管理推理依赖库。\n\n在图迭代计算进程和推理进程之间通过数据队列实现双边数据的交互，通过在数据包的头文件中插入参数个数，长度等信息，推理进程在连续若干次收到空消息包后，将自动进入睡眠状态，释放CPU等资源。图迭代计算进程调用推理接口时，推理进程将快速退出睡眠状态，接收输入数据并完成推理流程。\n\n### 4.2 跨进程数据交换\n\n对于推理数据的交换部分，底层通过C++开发共享内存管理模块，实现两个进程之间的数据交互。在推理初始化阶段，由InferenceContext对象开辟进程共享内存，Java进程负责创建并初始化推理（Python）进程，通知推理进程共享内存的地址信息，并映射到相应的进程。如图，Java进程和推理进程均采用C++作为桥梁语言，实现共享内存中数据的流动操作。"
            },
            {
                "content": "在每个worker工作节点下，按照不同的推理作业级别划分基础的虚拟环境，从而保证一个worker节点也可以支持不同推理任务，支持标准的requirements.txt管理推理依赖库。\n\n在图迭代计算进程和推理进程之间通过数据队列实现双边数据的交互，通过在数据包的头文件中插入参数个数，长度等信息，推理进程在连续若干次收到空消息包后，将自动进入睡眠状态，释放CPU等资源。图迭代计算进程调用推理接口时，推理进程将快速退出睡眠状态，接收输入数据并完成推理流程。\n\n### 4.2 跨进程数据交换\n\n对于推理数据的交换部分，底层通过C++开发共享内存管理模块，实现两个进程之间的数据交互。在推理初始化阶段，由InferenceContext对象开辟进程共享内存，Java进程负责创建并初始化推理（Python）进程，通知推理进程共享内存的地址信息，并映射到相应的进程。如图，Java进程和推理进程均采用C++作为桥梁语言，实现共享内存中数据的流动操作。\n\n在推理系统的性能测试阶段，我们发现推理进程读写进程时，接口的调用开销不容忽视。常规的理解认为C++能够优化Python的执行效率，但前提是Python的执行内存足够复杂，优化执行内容的收益远大于接口的调用开销。然而，在我们系统设计中，共享内存的读写接口只是操作了内存地址，实现读写指针的移动。因此，接口的调用开销也是影响推理性能的关键因素，为此，我们充分调研了业界主流的方案。\n\n如图所示，我们对比了多种Python调用C链接库的方案，性能是第一要素，因此选择Cython作为推理进程和底层内存交互的工具。Cython是一个编程语言，是Python语言的一个超集，它将/C++的静态类型系统融合在了Python中，允许开发者可以在Python代码中直接使用C语言的特性，从而提高程序的执行效率。Cython将Python源代码翻译为C或C++代码，然后将其编译为二进制代码，能够显著提高数值计算和循环场景的代码执行性能。\n\n### 4.3 推理接口设计\n\n上文介绍了采用Cython作为推理进程内存管理的链接工具，如下为TuGraph Analytics模型推理系统的内存管理接口设计，提供了初始化、读和写三个接口。"
            },
            {
                "content": "在推理系统的性能测试阶段，我们发现推理进程读写进程时，接口的调用开销不容忽视。常规的理解认为C++能够优化Python的执行效率，但前提是Python的执行内存足够复杂，优化执行内容的收益远大于接口的调用开销。然而，在我们系统设计中，共享内存的读写接口只是操作了内存地址，实现读写指针的移动。因此，接口的调用开销也是影响推理性能的关键因素，为此，我们充分调研了业界主流的方案。\n\n如图所示，我们对比了多种Python调用C链接库的方案，性能是第一要素，因此选择Cython作为推理进程和底层内存交互的工具。Cython是一个编程语言，是Python语言的一个超集，它将/C++的静态类型系统融合在了Python中，允许开发者可以在Python代码中直接使用C语言的特性，从而提高程序的执行效率。Cython将Python源代码翻译为C或C++代码，然后将其编译为二进制代码，能够显著提高数值计算和循环场景的代码执行性能。\n\n### 4.3 推理接口设计\n\n上文介绍了采用Cython作为推理进程内存管理的链接工具，如下为TuGraph Analytics模型推理系统的内存管理接口设计，提供了初始化、读和写三个接口。\n\n1. 初始化接口：负责共享内存地址的映射和读指针的初始化。\n2. 读接口：数据bytes的长度作为输入参数，直接在内存端上移动相应长度返回数据段，并移动到读指针。\n3. 写接口：将bytes和bytes长度写入到共享内存，并移动至写指针。\n\n```cython\n@cython.final\ncdef class InferIpc:\n    cdef MmapIPC * ipc_bridge;\n    cdef uint8_t* read_ptr;\n\n    def __cinit__(self, r, w):\n        self.ipc_bridge = new MmapIPC(r, w)\n        self.read_ptr = self.ipc_bridge.getReadBufferPtr()"
            },
            {
                "content": "### 4.3 推理接口设计\n\n上文介绍了采用Cython作为推理进程内存管理的链接工具，如下为TuGraph Analytics模型推理系统的内存管理接口设计，提供了初始化、读和写三个接口。\n\n1. 初始化接口：负责共享内存地址的映射和读指针的初始化。\n2. 读接口：数据bytes的长度作为输入参数，直接在内存端上移动相应长度返回数据段，并移动到读指针。\n3. 写接口：将bytes和bytes长度写入到共享内存，并移动至写指针。\n\n```cython\n@cython.final\ncdef class InferIpc:\n    cdef MmapIPC * ipc_bridge;\n    cdef uint8_t* read_ptr;\n\n    def __cinit__(self, r, w):\n        self.ipc_bridge = new MmapIPC(r, w)\n        self.read_ptr = self.ipc_bridge.getReadBufferPtr()\n\n    cpdef inline bytes readBytes(self, bytesSize):\n        if bytesSize == 0:\n            return b\"\"\n        cdef int readSize\n        cdef int len_ = bytesSize\n        with nogil:\n            readSize = self.ipc_bridge.readBytes(len_)\n        if readSize == 0:\n            return b\"\"\n        cdef unsigned char * binary_data = self.read_ptr\n        return binary_data[:len_]"
            },
            {
                "content": "def __cinit__(self, r, w):\n        self.ipc_bridge = new MmapIPC(r, w)\n        self.read_ptr = self.ipc_bridge.getReadBufferPtr()\n\n    cpdef inline bytes readBytes(self, bytesSize):\n        if bytesSize == 0:\n            return b\"\"\n        cdef int readSize\n        cdef int len_ = bytesSize\n        with nogil:\n            readSize = self.ipc_bridge.readBytes(len_)\n        if readSize == 0:\n            return b\"\"\n        cdef unsigned char * binary_data = self.read_ptr\n        return binary_data[:len_]\n\n    cpdef inline bool writeBytes(self, bytesBuf, length):\n        cdef bool writeFlag\n        cdef int len_ = length\n        cdef char* buf_ = bytesBuf\n        with nogil:\n            writeFlag = self.ipc_bridge.writeBytes(buf_, len_)\n        return writeFlag\n\n    def __dealloc__(self):\n        del self.ipc_bridge\n```\n\n如下为用户实现推理的Java接口，同其它图迭代计算接口一样，需要推理的时候直接调用该接口，将图迭代的中间结果inputs发送到推理进程并返回模型结果。\n\n```java\npublic interface GraphInferContext extends Closeable {\n    OUT infer(Object... inputs);\n}\n```"
            },
            {
                "content": "cpdef inline bool writeBytes(self, bytesBuf, length):\n        cdef bool writeFlag\n        cdef int len_ = length\n        cdef char* buf_ = bytesBuf\n        with nogil:\n            writeFlag = self.ipc_bridge.writeBytes(buf_, len_)\n        return writeFlag\n\n    def __dealloc__(self):\n        del self.ipc_bridge\n```\n\n如下为用户实现推理的Java接口，同其它图迭代计算接口一样，需要推理的时候直接调用该接口，将图迭代的中间结果inputs发送到推理进程并返回模型结果。\n\n```java\npublic interface GraphInferContext extends Closeable {\n    OUT infer(Object... inputs);\n}\n```\n\n## 5. 最佳实践\n\n我们以PageRank任务结合群组打分模型推理流程为例，演示具体的操作流程。\n\n### 5.1 数据处理\n\n定义推理数据前后置处理逻辑如下：\n\n```python\nimport abc\nimport json\nimport sys\nimport os\nimport torch\n\nclass MyInference(TransFormFunction):\n    def __init__(self):\n        super().__init__(2)\n\n    def transform_pre(self, *args):\n        return args[0], args[1]\n\n    def transform_post(self, *args):\n        return args[0]\n```\n\n### 5.2 图迭代推理\n\n定义图迭代计算结合推理逻辑如下：\n\n```java\npublic static class PRVertexCentricComputeFunction implements\n        IncVertexCentricComputeFunction {"
            },
            {
                "content": "我们以PageRank任务结合群组打分模型推理流程为例，演示具体的操作流程。\n\n### 5.1 数据处理\n\n定义推理数据前后置处理逻辑如下：\n\n```python\nimport abc\nimport json\nimport sys\nimport os\nimport torch\n\nclass MyInference(TransFormFunction):\n    def __init__(self):\n        super().__init__(2)\n\n    def transform_pre(self, *args):\n        return args[0], args[1]\n\n    def transform_post(self, *args):\n        return args[0]\n```\n\n### 5.2 图迭代推理\n\n定义图迭代计算结合推理逻辑如下：\n\n```java\npublic static class PRVertexCentricComputeFunction implements\n        IncVertexCentricComputeFunction {\n\n    private IncGraphComputeContext graphContext;\n    private IncGraphInferContext inferContext;\n\n    @Override\n    public void init(IncGraphComputeContext graphContext) {\n        this.graphContext = graphContext;\n        this.inferContext = (IncGraphInferContext) graphContext;\n    }"
            },
            {
                "content": "def transform_post(self, *args):\n        return args[0]\n```\n\n### 5.2 图迭代推理\n\n定义图迭代计算结合推理逻辑如下：\n\n```java\npublic static class PRVertexCentricComputeFunction implements\n        IncVertexCentricComputeFunction {\n\n    private IncGraphComputeContext graphContext;\n    private IncGraphInferContext inferContext;\n\n    @Override\n    public void init(IncGraphComputeContext graphContext) {\n        this.graphContext = graphContext;\n        this.inferContext = (IncGraphInferContext) graphContext;\n    }\n\n    @Override\n    public void evolve(Integer vertexId,\n                       TemporaryGraph temporaryGraph) {\n        long lastVersionId = 0L;\n        IVertex vertex = temporaryGraph.getVertex();\n        HistoricalGraph historicalGraph = graphContext\n                .getHistoricalGraph();\n        if (vertex == null) {\n            vertex = historicalGraph.getSnapShot(lastVersionId).vertex().get();\n        }"
            },
            {
                "content": "@Override\n    public void evolve(Integer vertexId,\n                       TemporaryGraph temporaryGraph) {\n        long lastVersionId = 0L;\n        IVertex vertex = temporaryGraph.getVertex();\n        HistoricalGraph historicalGraph = graphContext\n                .getHistoricalGraph();\n        if (vertex == null) {\n            vertex = historicalGraph.getSnapShot(lastVersionId).vertex().get();\n        }\n\n        if (vertex != null) {\n            List> newEs = temporaryGraph.getEdges();\n            List> oldEs = historicalGraph.getSnapShot(lastVersionId)\n                    .edges().getOutEdges();\n            if (newEs != null) {\n                for (IEdge edge : newEs) {\n                    graphContext.sendMessage(edge.getTargetId(), vertexId);\n                }\n            }\n            if (oldEs != null) {\n                for (IEdge edge : oldEs) {\n                    graphContext.sendMessage(edge.getTargetId(), vertexId);\n                }\n            }\n        }\n    }"
            },
            {
                "content": "@Override\n    public void compute(Integer vertexId, Iterator messageIterator) {\n        int max = 0;\n        while (messageIterator.hasNext()) {\n            int value = messageIterator.next();\n            max = max > value ? max : value;\n        }\n        I\n\nVertex vertex = graphContext.getVertex(vertexId);\n        if (vertex != null) {\n            inferContext.infer(max, \"1.0\");\n        }\n    }\n}\n```\n\n### 5.3 创建作业\n\n在Console作业管理平台创建一个HLA任务，上传图迭代计算jar包，模型文件和依赖管理文件。\n\n### 5.4 配置参数\n\n配置相关参数，启动运行作业即可。\n\n- `\"geaflow.infer.env.enable\": \"true\"`  // 初始化虚拟环境等待时间\n- `\"geaflow.infer.env.init.timeout.sec\": 120`  // 是否接收日志\n- `\"geaflow.infer.env.suppress.log.enable\": \"true\"`\n\n\n## 6. 总结\n\n通过将AI模型推理引入TuGraph Analytics流图计算系统，让我们能够对图数据进行深度地分析和预测。利用最新的机器学习和深度学习技术，TuGraph Analytics图计算引擎不仅可以对图数据进行分类和回归分析，还可以预测未来趋势，从而在多个维度上提供决策支持。\n\n希望通过以上的介绍，可以让大家对TuGraph Analytics模型推理系统有个比较清晰的了解，非常欢迎大家加入我们社区（https://github.com/TuGraph-family/tugraph-analytics），一起构建图数据上的智能化分析能力！"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BD%9CTuGraph_Schema.md",
        "chunks": [
            {
                "content": "# 源码解读｜TuGraph Schema\n\n## 什么是schema\n\nTuGraph作为强schema的图数据库，在插入数据之前要求数据一定归属于某个schema，即创建某个类型的点边模型之后，才可以插入数据，那么什么是schema呢？schema是一种约束和规定，它有两个方面的作用：\n\n- 它规定了某个类型的点边拥有哪些属性，这些属性是什么类型的，属性是如何存储在磁盘中的，是否可以为空，它有多少定长的属性，多少变长的属性。\n- 如何从一个点或边数据中解析出某个属性值等等功能。\n\n总而言之，schema指导了如何根据磁盘中的一段二进制数据解析出某个点或边的属性内容和属性值，用于后续的计算。\n\n## TuGraph Schema\n\n### schema的定义\n\nschema的定义具体表现为一种约束，它指定了一个点或者边有哪些属性，属性大小，以及如何排布。它的定义主要由如下类提供：\n\n### schema的应用\n\nschema的应用具体表现为一种格式，它指定了一个点或边的数据(即点或边的属性值)如何存储在磁盘中。下文中所说的点或边的属性值的二进制即指磁盘中的点或边数据。\n\n## 点的存储格式\n\n点的存储格式一共包含如下几部分内容：\n\n- **Label Id**：schema的唯一标示，uint16_t类型，因此一个子图(即一个LightningGraph)中的点或边的个数不能超过65535个，超过将会无法区分。\n- **Null-Array**：值可以为空(即optional)类型的属性数组，每个optional的field占一位，以字节对齐，第一个optional的属性标记位于Null-Array第一字节的最后一位，第七个optional的属性标记位于Null-Array第一字节的最前面一位，用于指示某个点或边optional属性对应的数据是否为空。\n- **Fixed-fields**：定长属性列，属性值紧挨着保存，定长属性的长度确定，因此只要知道开始位置就可以正确取出内容，起始位置保存在FieldExtractor类的成员data_off中。\n- **Variable-Offsets**：变长属性偏移列表，记录变长属性开始的位置，变长属性通过当前属性开始位置和下一个属性开始位置的差值计算长度，通过开始位置和长度可以正确取出内容。\n- **Variable-Data**：变长属性内容列表，记录变长属性的值。"
            },
            {
                "content": "- **Label Id**：schema的唯一标示，uint16_t类型，因此一个子图(即一个LightningGraph)中的点或边的个数不能超过65535个，超过将会无法区分。\n- **Null-Array**：值可以为空(即optional)类型的属性数组，每个optional的field占一位，以字节对齐，第一个optional的属性标记位于Null-Array第一字节的最后一位，第七个optional的属性标记位于Null-Array第一字节的最前面一位，用于指示某个点或边optional属性对应的数据是否为空。\n- **Fixed-fields**：定长属性列，属性值紧挨着保存，定长属性的长度确定，因此只要知道开始位置就可以正确取出内容，起始位置保存在FieldExtractor类的成员data_off中。\n- **Variable-Offsets**：变长属性偏移列表，记录变长属性开始的位置，变长属性通过当前属性开始位置和下一个属性开始位置的差值计算长度，通过开始位置和长度可以正确取出内容。\n- **Variable-Data**：变长属性内容列表，记录变长属性的值。\n\n## 边的存储格式\n\n边的存储格式一共包含如下几部分，LabelId作为key的一部分，因此不需要保存在数据中：\n\n- **Null-Array**：值可以为空(即optional)类型的属性数组，每个optional的field占一位，以字节对齐，第一个optional的属性标记位于Null-Array第一字节的最后一位，第七个optional的属性标记位于Null-Array第一字节的最前面一位，用于指示某个点或边optional属性对应的数据是否为空。\n- **Fixed-fields**：定长属性列，每种属性紧挨着保存，定长属性的长度确定，因此只要知道开始位置就可以正确取出内容，起始位置保存在FieldExtractor类的成员data_off中。\n- **Variable-Offsets**：变长属性偏移列表，记录变长属性开始的位置，变长属性通过当前属性开始位置和下一个属性开始位置的差值计算长度，通过开始位置和长度可以正确取出内容。\n- **Variable-Data**：变长属性内容列表，记录变长属性的值。\n\n## schema使用场景"
            },
            {
                "content": "## 边的存储格式\n\n边的存储格式一共包含如下几部分，LabelId作为key的一部分，因此不需要保存在数据中：\n\n- **Null-Array**：值可以为空(即optional)类型的属性数组，每个optional的field占一位，以字节对齐，第一个optional的属性标记位于Null-Array第一字节的最后一位，第七个optional的属性标记位于Null-Array第一字节的最前面一位，用于指示某个点或边optional属性对应的数据是否为空。\n- **Fixed-fields**：定长属性列，每种属性紧挨着保存，定长属性的长度确定，因此只要知道开始位置就可以正确取出内容，起始位置保存在FieldExtractor类的成员data_off中。\n- **Variable-Offsets**：变长属性偏移列表，记录变长属性开始的位置，变长属性通过当前属性开始位置和下一个属性开始位置的差值计算长度，通过开始位置和长度可以正确取出内容。\n- **Variable-Data**：变长属性内容列表，记录变长属性的值。\n\n## schema使用场景\n\n通过schema可以将一段磁盘中的二进制数据解析成某种类型的点或边，可以获取点边属性，也可以将一些值拼接成某个类型的点或边属性的二进制值，存入磁盘中。\n\n### 获取点索引\n\n通过transaction类获取某个label_name对应点的schema，就可以通过schema获取到具体的索引信息：\n\n```cpp\nSchema* schema = Transaction::curr_schema_->v_schema_manager->GetSchema(label_name);\nfor (auto& fid : schema->indexed_fields_) {\n    _detail::FieldExtractor* fe = schema->fields_[fid];\n    VertexIndex* index = fe->vertex_index_;\n}\n```\n\n### 获取边索引\n\n通过transaction类获取某个label_name对应边的schema，就可以通过schema获取到具体的索引信息："
            },
            {
                "content": "## schema使用场景\n\n通过schema可以将一段磁盘中的二进制数据解析成某种类型的点或边，可以获取点边属性，也可以将一些值拼接成某个类型的点或边属性的二进制值，存入磁盘中。\n\n### 获取点索引\n\n通过transaction类获取某个label_name对应点的schema，就可以通过schema获取到具体的索引信息：\n\n```cpp\nSchema* schema = Transaction::curr_schema_->v_schema_manager->GetSchema(label_name);\nfor (auto& fid : schema->indexed_fields_) {\n    _detail::FieldExtractor* fe = schema->fields_[fid];\n    VertexIndex* index = fe->vertex_index_;\n}\n```\n\n### 获取边索引\n\n通过transaction类获取某个label_name对应边的schema，就可以通过schema获取到具体的索引信息：\n\n```cpp\nSchema* schema = Transaction::curr_schema_->e_schema_manager->GetSchema(label_name);\nfor (auto& fid : schema->indexed_fields_) {\n    _detail::FieldExtractor* fe = schema->fields_[fid];\n    VertexIndex* index = fe->edge_index_;\n}\n```\n\n### 解析LabelId\n\n获取到一段代表点或边属性的二进制之后，通过读取前2字节就可以获取到label id：\n\n```cpp\nchar* p = value.Data();  // 表示一个点或边属性值的二进制形式\nLabelId id = *(uint16_t*) value;\n```\n\n### 解析定长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到定长属性的值："
            },
            {
                "content": "通过transaction类获取某个label_name对应边的schema，就可以通过schema获取到具体的索引信息：\n\n```cpp\nSchema* schema = Transaction::curr_schema_->e_schema_manager->GetSchema(label_name);\nfor (auto& fid : schema->indexed_fields_) {\n    _detail::FieldExtractor* fe = schema->fields_[fid];\n    VertexIndex* index = fe->edge_index_;\n}\n```\n\n### 解析LabelId\n\n获取到一段代表点或边属性的二进制之后，通过读取前2字节就可以获取到label id：\n\n```cpp\nchar* p = value.Data();  // 表示一个点或边属性值的二进制形式\nLabelId id = *(uint16_t*) value;\n```\n\n### 解析定长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到定长属性的值：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + 定长属性的偏移位置与属性长度可以获取属性值\nType val = *((Type*)(p + fe.data_off));\n```\n\n### 解析变长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到变长属性的值："
            },
            {
                "content": "### 解析LabelId\n\n获取到一段代表点或边属性的二进制之后，通过读取前2字节就可以获取到label id：\n\n```cpp\nchar* p = value.Data();  // 表示一个点或边属性值的二进制形式\nLabelId id = *(uint16_t*) value;\n```\n\n### 解析定长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到定长属性的值：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + 定长属性的偏移位置与属性长度可以获取属性值\nType val = *((Type*)(p + fe.data_off));\n```\n\n### 解析变长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到变长属性的值：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + fe.v_offs获取Variable-Offsets的位置，记为 pos\n// 通过pos + fe.idx * sizeof(int32_t)可以获取到指向该可变属性值的起始位置的指针\nType val = *((Type*)(*(p + fe.v_offs + fe.idx * sizeof(int32_t))));\n```\n\n### 解析属性是否为optional\n\n对于optional的属性，值可以为空，当值为空时，该属性将不会保存任何值。如何判断该属性值是否为空，需要借助于Null-Array："
            },
            {
                "content": "### 解析变长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到变长属性的值：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + fe.v_offs获取Variable-Offsets的位置，记为 pos\n// 通过pos + fe.idx * sizeof(int32_t)可以获取到指向该可变属性值的起始位置的指针\nType val = *((Type*)(*(p + fe.v_offs + fe.idx * sizeof(int32_t))));\n```\n\n### 解析属性是否为optional\n\n对于optional的属性，值可以为空，当值为空时，该属性将不会保存任何值。如何判断该属性值是否为空，需要借助于Null-Array：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + fe.nullable_array_off_可以得到Null-Array数组\n// 如果对应的位为1，则为空，否则不为空\nbool is_nul = (p + fe.nullable_array_off_)[fe.null_bit_off_] & (0x1 << (fe.null_bit_off_% 8));\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BD%9CTuGraph_key-val%E5%AD%98%E5%82%A8.md",
        "chunks": [
            {
                "content": "# 源码解读｜TuGraph key-val存储\n\n## 存储模型\n\nTuGraph存储层采用开源的lmdb实现，底层存储采用了B+树，在B+树之上抽象出了一层key-val存储。它与基于hash的key-val存储有着本质的区别，基于hash的key-val存储在无hash碰撞的情况下，一次key-val的查询只需要一次hash计算和一次内存寻址，时间复杂度是O(1)，但在TuGraph的实现中，key-val层是基于B+树来实现的，key-val查找的本质还是基于B+树的范围查找，因此一次key-val的查询是要在树中进行二分查找的，性能是O(log(n))。\n\nTuGraph基于lmdb的存储模型，对由点边数据组成的key-val进行了包装，将点边数据打包保存在一起，对于非大点，通过一次key-val的查询就可以查找到点以及该点的出边和入边，减少了在B+树中进行二分查找的次数，将基于全图完整数据的查找限定在某个key对应的value中，提升了TuGraph在适用场景下的查找性能。对于大点来说，为了避免某个key对应的value过大，影响写入或修改性能，权衡之下将点和边数据以阀值按类型切分为多个value，分别保存在不同的类型的key中，既提升了查找性能，也降低了大点带来的写入性能损失。\n\n## key的类型\n\n```cpp\nenum PackType {\n    PACKED_DATA = 0, \n    VERTEX_ONLY = 1, \n    OUT_EDGE = 2,    \n    IN_EDGE = 3     \n};\n```\n\n### PACKED_DATA\n\nPACKED_DATA类型的key共计6字节，由5字节的点id和1字节的类型组成，此类key对应的是混合存储的val。将某个点和与之关联的边数据打包在一起保存，适用于非大点的存储，新插入的点也属于此类型。\n\n### VERTEX_ONLY"
            },
            {
                "content": "## key的类型\n\n```cpp\nenum PackType {\n    PACKED_DATA = 0, \n    VERTEX_ONLY = 1, \n    OUT_EDGE = 2,    \n    IN_EDGE = 3     \n};\n```\n\n### PACKED_DATA\n\nPACKED_DATA类型的key共计6字节，由5字节的点id和1字节的类型组成，此类key对应的是混合存储的val。将某个点和与之关联的边数据打包在一起保存，适用于非大点的存储，新插入的点也属于此类型。\n\n### VERTEX_ONLY\n\nVERTEX_ONLY类型key共6字节，由5字节的点id和1字节的类型组成，此类key对应的val中只保存了单点的属性，当一个PACKED_DATA类型的key对应的value长度超过阀值::lgraph::_detail::NODE_SPLIT_THRESHOLD(1000字节)时，会被拆分成VERTEX_ONLY，OUT_EDGE，IN_EDGE三种类型，分别表示一个单独的点，一组从该点出发的边，和一组目标点为该点的边。\n\n### OUT_EDGE\n\nOUT_EDGE类型key共计25字节，由5字节的源点id，1字节的类型，2字节的边label id，8字节的tid，5字节的目标点id，以及4字节的eid组成。此类key对应的val中保存了由src_vertex_id点出发，按label_id和tid以及目标点id排序好的一组出边。适用于大点切分后保存出边。其中key中的源点id和类型对于value中的所有值都是一致的，label id，tid以及目标点id是取了这组边中最后一个边的属性。\n\n### IN_EDGE\n\nIN_EDGE类型key共计25字节，由5字节的目标点id，1字节的类型，2字节的边label id，8字节的tid，5字节的最大源点id，以及4字节的eid组成，此类key对应的val中保存了指向dst_vertex_id，按label_id和tid以及源点id排序好的一组出边。适用于大点切分后保存出边。其中key中的目标点id和类型对于value中的所有值都是一致的，label id，tid以及目标点id是取了这组边中最后一个边的属性。\n\n## 获取key中对应的属性\n\n可以通过key的地址加上对应属性的字节偏移获取对应的值。"
            },
            {
                "content": "OUT_EDGE类型key共计25字节，由5字节的源点id，1字节的类型，2字节的边label id，8字节的tid，5字节的目标点id，以及4字节的eid组成。此类key对应的val中保存了由src_vertex_id点出发，按label_id和tid以及目标点id排序好的一组出边。适用于大点切分后保存出边。其中key中的源点id和类型对于value中的所有值都是一致的，label id，tid以及目标点id是取了这组边中最后一个边的属性。\n\n### IN_EDGE\n\nIN_EDGE类型key共计25字节，由5字节的目标点id，1字节的类型，2字节的边label id，8字节的tid，5字节的最大源点id，以及4字节的eid组成，此类key对应的val中保存了指向dst_vertex_id，按label_id和tid以及源点id排序好的一组出边。适用于大点切分后保存出边。其中key中的目标点id和类型对于value中的所有值都是一致的，label id，tid以及目标点id是取了这组边中最后一个边的属性。\n\n## 获取key中对应的属性\n\n可以通过key的地址加上对应属性的字节偏移获取对应的值。\n\n```cpp\nstatic const size_t FID_OFF = 0;                  // first vid  0\nstatic const size_t PT_OFF = FID_OFF + 5;          // pair type  5\nstatic const size_t LID_OFF = PT_OFF + 1;         // label      6\nstatic const size_t TID_OFF = LID_OFF + 2;        // primary id 8\nstatic const size_t SID_OFF = TID_OFF + 8;        // second vid 16\nstatic const size_t EID_OFF = SID_OFF + 5;        // edge id    21\nstatic const size_t EDGE_KEY_SIZE = EID_OFF + 4;  //      25\n```\n\n## val的类型\n\n### VertexValue"
            },
            {
                "content": "```cpp\nstatic const size_t FID_OFF = 0;                  // first vid  0\nstatic const size_t PT_OFF = FID_OFF + 5;          // pair type  5\nstatic const size_t LID_OFF = PT_OFF + 1;         // label      6\nstatic const size_t TID_OFF = LID_OFF + 2;        // primary id 8\nstatic const size_t SID_OFF = TID_OFF + 8;        // second vid 16\nstatic const size_t EID_OFF = SID_OFF + 5;        // edge id    21\nstatic const size_t EDGE_KEY_SIZE = EID_OFF + 4;  //      25\n```\n\n## val的类型\n\n### VertexValue\n\nVertexValue类型的值用于保存key为VERTEX_ONLY的值，代表单个的点数据，数据格式按照预定义好的schema来保存，存储格式如下：\n\n### EdgeValue\n\nEdgeValue类型的值用于保存key为OUT_EDGE与IN_EDGE的值，代表从某个点出发，或者指向某个点的一组边数据。存储格式如下，绿色部分是EdgeValue，它包含三部分内容，第一部分是1字节的边个数，因此一个EdgeValue类型的数据中最多只能保存255条边，第二部分是一个偏移数组，代表了每条边在value中的偏移位置，第三部分是边的内容数组，每个成员代表了一条边。\n\n边的内容包含edge header和edge value两部分。edge header由一字节的指示器开始，它的作用是标识后面紧跟着的几个字段长度。edge value保存的是按照edge schema序列化好的数据。这里为了节省磁盘空间，对edge_label_id, temporal_id, vertex_id以及edge_id进行了压缩，采用的压缩算法如下："
            },
            {
                "content": "## val的类型\n\n### VertexValue\n\nVertexValue类型的值用于保存key为VERTEX_ONLY的值，代表单个的点数据，数据格式按照预定义好的schema来保存，存储格式如下：\n\n### EdgeValue\n\nEdgeValue类型的值用于保存key为OUT_EDGE与IN_EDGE的值，代表从某个点出发，或者指向某个点的一组边数据。存储格式如下，绿色部分是EdgeValue，它包含三部分内容，第一部分是1字节的边个数，因此一个EdgeValue类型的数据中最多只能保存255条边，第二部分是一个偏移数组，代表了每条边在value中的偏移位置，第三部分是边的内容数组，每个成员代表了一条边。\n\n边的内容包含edge header和edge value两部分。edge header由一字节的指示器开始，它的作用是标识后面紧跟着的几个字段长度。edge value保存的是按照edge schema序列化好的数据。这里为了节省磁盘空间，对edge_label_id, temporal_id, vertex_id以及edge_id进行了压缩，采用的压缩算法如下：\n\n- **edge_label_id**：如果edge_label_id为0则不占用存储空间，如果edge_label_id < 0x100(十进制256)则占用1字节，如果0x100 <= edge_label_id < 0xFF则占用两字节。\n- **temporal_id**：如果temporal_id为0则不占用存储空间，不为0则占用8字节存储空间。\n- **vertex_id**：去除vertex_id中前导的0，按8位对齐。\n- **edge_id**：去除edge_id中前导的0，按8位对齐。\n\n### PackedDataValue"
            },
            {
                "content": "边的内容包含edge header和edge value两部分。edge header由一字节的指示器开始，它的作用是标识后面紧跟着的几个字段长度。edge value保存的是按照edge schema序列化好的数据。这里为了节省磁盘空间，对edge_label_id, temporal_id, vertex_id以及edge_id进行了压缩，采用的压缩算法如下：\n\n- **edge_label_id**：如果edge_label_id为0则不占用存储空间，如果edge_label_id < 0x100(十进制256)则占用1字节，如果0x100 <= edge_label_id < 0xFF则占用两字节。\n- **temporal_id**：如果temporal_id为0则不占用存储空间，不为0则占用8字节存储空间。\n- **vertex_id**：去除vertex_id中前导的0，按8位对齐。\n- **edge_id**：去除edge_id中前导的0，按8位对齐。\n\n### PackedDataValue\n\nPackedDataValue类型的值用于保存key为PACKED_DATA的value，代表将某个点与其出边、入边一起打包后保存，因为将点和边打包在同一段存储结构中，因此结构复杂，它包含两个int32_t类型的偏移，分别指向这个点的出边和入边的首地址，以及一个VertexValue表示一个点和两个EdgeValue，分别表示这个点的出边和入边。存储格式如下，其中红色部分是PackedDataValue，绿色部分是EdgeValue，紫色部分是VertexValue（保存的是按照vertex schema序列化好的点数据），蓝色部分是按照edge schema序列化好的边数据。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E6%BC%94%E8%AE%B2%E5%9B%9E%E9%A1%BE%EF%BD%9CTuGraph-DB%E5%85%BC%E5%AE%B9Neo4j%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9ABolt_%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.md",
        "chunks": [
            {
                "content": "# 演讲回顾｜TuGraph-DB兼容Neo4j客户端：Bolt 协议设计与实现\n\n今天要和大家分享的是关于TuGraph-DB近期新添加的一个功能——兼容Neo4j客户端。这个兼容性工作本质上是实现了Neo4j客户端与服务器之间的通讯协议，即Bolt协议。首先介绍下Bolt协议的基本情况，之后阐述下我们是如何实现这一协议的，然后展示下使用Bolt协议客户端连接TuGraph-DB的效果，最后会说明下目前还有哪些功能尚未实现。\n\n## 背景\n\nBolt协议是在Neo4j 3.0版本中引入的，时间大约是2016年。在此之前，Neo4j使用的通讯方式主要是HTTP和WebSocket。自从引入Bolt协议后，已经过去了7到8年，目前它已经成为了Neo4j应用与服务器之间通信的首选方式。\n\nBolt协议在设计上具有以下几个特点：首先，它是二进制的，与之对应的HTTP协议是基于文本的；其次，Bolt协议支持事务、会话以及集群模式，并且提供了用户身份验证和数据加密功能；最后，Bolt协议中所有的数据传输都是基于流式传输的。\n\nTuGraph-DB的客户端也经历了不断的演进和发展。最初我们仅支持HTTP方式，后来开发了自己的RPC客户端，现在我们开始支持兼容Neo4j的客户端。\n\n兼容Neo4j客户端的最大好处在于生态系统的兼容。单就客户端而言，Neo4j官方开发了五种语言的客户端，加上社区开发的两种，总共有七种语言的客户端可供使用。这些客户端可以直接拿来使用，同时还有一些对接上下游生态系统的组件，比如访问Apache Spark或Apache Kafka，这些都有现成的代码。此外，还有一些开源项目，比如DataX，对Neo4j的适配的代码也是现成的。另外，还有一些编程框架相关的，特别是在Java领域，例如OGM、Spring等开发框架，这些相关的代码也无需重写，可以直接使用。这样就节约了大量的研发资源，周围组件直接用生态内的，我们可以将更多精力投入到数据库自身能力的提升上去。\n\n## Bolt协议介绍"
            },
            {
                "content": "TuGraph-DB的客户端也经历了不断的演进和发展。最初我们仅支持HTTP方式，后来开发了自己的RPC客户端，现在我们开始支持兼容Neo4j的客户端。\n\n兼容Neo4j客户端的最大好处在于生态系统的兼容。单就客户端而言，Neo4j官方开发了五种语言的客户端，加上社区开发的两种，总共有七种语言的客户端可供使用。这些客户端可以直接拿来使用，同时还有一些对接上下游生态系统的组件，比如访问Apache Spark或Apache Kafka，这些都有现成的代码。此外，还有一些开源项目，比如DataX，对Neo4j的适配的代码也是现成的。另外，还有一些编程框架相关的，特别是在Java领域，例如OGM、Spring等开发框架，这些相关的代码也无需重写，可以直接使用。这样就节约了大量的研发资源，周围组件直接用生态内的，我们可以将更多精力投入到数据库自身能力的提升上去。\n\n## Bolt协议介绍\n\nBolt协议主要由三大部分构成。首先是数据结构的编码和解码，它作为一种通信协议，核心功能就是数据传输。传输过程中，数据首先需要被编码，然后在网络上进行传输，接收端再对数据进行解码。其次是消息类型，这个比较常规，每个通讯协议都会定义自己的消息类型集合，主要用于控制和管理通讯过程。最后是消息处理机制，即以状态机的运作方式来处理Bolt协议中的消息，它不是简单的Ping-Pong模式。\n\n### 数据编解码\n\n在Bolt协议的数据编解码部分，有一个关键词是PackStream。它是Bolt协议中的一种数据序列化方式，源自于MessagePack。MessagePack也是一种数据序列化方案，类似于我们常用的Protobuf。\n\nMessagePack在Redis里面有被使用到，大家都知道Redis是一种内存数据库，它对性能的要求非常高，所以MessagePack有一个特点是序列化和反序列化速度很快。但Bolt协议并没有直接使用MessagePack，而是根据其需求在MessagePack基础上定制了一套名为PackStream的序列化方式。在PackStream序列化方式中，包含几种核心的数据类型，如常用的布尔、整型、浮点型、二进制数组，和类似于字典（dictionary或map structure）的结构体。"
            },
            {
                "content": "### 数据编解码\n\n在Bolt协议的数据编解码部分，有一个关键词是PackStream。它是Bolt协议中的一种数据序列化方式，源自于MessagePack。MessagePack也是一种数据序列化方案，类似于我们常用的Protobuf。\n\nMessagePack在Redis里面有被使用到，大家都知道Redis是一种内存数据库，它对性能的要求非常高，所以MessagePack有一个特点是序列化和反序列化速度很快。但Bolt协议并没有直接使用MessagePack，而是根据其需求在MessagePack基础上定制了一套名为PackStream的序列化方式。在PackStream序列化方式中，包含几种核心的数据类型，如常用的布尔、整型、浮点型、二进制数组，和类似于字典（dictionary或map structure）的结构体。\n\n由于Bolt协议主要用于传输Cypher查询语句及其响应结果的，所以Cypher的数据类型必然是构建在上述基础数据类型之上的。例如，Cypher数据类型中的节点（Node）、关系（Relationship）和路径（Path），都属于PackStream中的结构体，空间类型和时间类型也是。\n\n左下角的小图解释了PackStream的序列化方式：数据序列化完成后，它的大致结构是。第一个字节表示数据类型，用以标记当前数据是哪种类型。紧接着是size字段，表示数据大小，然后是数据内容本身。这只是一个通用的表示方法，大部分数据序列化后形态都类似，但许多场景下是可以进行优化的。例如，某些数据类型在编码后仅为一个字节，因为它与前面的标识字节合并在一起了。对于一些数值小的整数，如只需一个字节就可以表示的数字，虽然数据类型本身占8个字节，但最终编码完成同样只有一个字节大小，它们的类型和数据本身均被压缩在一个字节中。\n\n### 消息类型\n\nBolt协议中的消息主要分为三大类。第一类是Request消息，这类消息是由客户端发送给服务端的；第二类是Summary消息，这是服务端发给客户端的消息；第三类是Detail消息，目前只有一个Record消息，Record消息就是服务端返回给客户端的一行行数据，接下来简要介绍下每种消息。"
            },
            {
                "content": "左下角的小图解释了PackStream的序列化方式：数据序列化完成后，它的大致结构是。第一个字节表示数据类型，用以标记当前数据是哪种类型。紧接着是size字段，表示数据大小，然后是数据内容本身。这只是一个通用的表示方法，大部分数据序列化后形态都类似，但许多场景下是可以进行优化的。例如，某些数据类型在编码后仅为一个字节，因为它与前面的标识字节合并在一起了。对于一些数值小的整数，如只需一个字节就可以表示的数字，虽然数据类型本身占8个字节，但最终编码完成同样只有一个字节大小，它们的类型和数据本身均被压缩在一个字节中。\n\n### 消息类型\n\nBolt协议中的消息主要分为三大类。第一类是Request消息，这类消息是由客户端发送给服务端的；第二类是Summary消息，这是服务端发给客户端的消息；第三类是Detail消息，目前只有一个Record消息，Record消息就是服务端返回给客户端的一行行数据，接下来简要介绍下每种消息。\n\nHello消息是TCP连接建立后需要发送的第一条消息，它会携带客户端自身的信息，比如客户端是什么语言的，版本号是多少，以及运行平台是什么，还有进行身份验证所需的用户名和密码。Reset消息用于重置会话状态，因为Bolt协议是有会话的，会话就有会话状态，有时候会话会处于失败状态，这时候就需要用Reset消息来复位一下。\n\nRun消息用于执行Cypher查询语句，它携带了查询语句的具体内容。Pull消息是客户端请求服务端拉取数据，一般后面会跟个数字，例如Pull 1000，代表客户端希望拉取1000条数据。服务端接收到这个请求后，会返回不多于1000条数据。如果服务端在返回数据后发现还有更多数据可供返回，它会发送个Success消息，Success消息里面的has_more字段会置1，提示客户端还有更多的数据待发送。客户端收到后会继续发送Pull消息，如此循环，直到服务端返回的Success消息中has_more字段不为1，表示所有数据都拉取完了。Discard消息用于告诉服务端忽略后续特定数量的数据。"
            },
            {
                "content": "Hello消息是TCP连接建立后需要发送的第一条消息，它会携带客户端自身的信息，比如客户端是什么语言的，版本号是多少，以及运行平台是什么，还有进行身份验证所需的用户名和密码。Reset消息用于重置会话状态，因为Bolt协议是有会话的，会话就有会话状态，有时候会话会处于失败状态，这时候就需要用Reset消息来复位一下。\n\nRun消息用于执行Cypher查询语句，它携带了查询语句的具体内容。Pull消息是客户端请求服务端拉取数据，一般后面会跟个数字，例如Pull 1000，代表客户端希望拉取1000条数据。服务端接收到这个请求后，会返回不多于1000条数据。如果服务端在返回数据后发现还有更多数据可供返回，它会发送个Success消息，Success消息里面的has_more字段会置1，提示客户端还有更多的数据待发送。客户端收到后会继续发送Pull消息，如此循环，直到服务端返回的Success消息中has_more字段不为1，表示所有数据都拉取完了。Discard消息用于告诉服务端忽略后续特定数量的数据。\n\nPull和Discard消息可以交替使用，例如客户端可以轮流提取和忽略1000条数据。Begin、Commit和Rollback消息用于显示事务，而Route消息则用于获取集群的路由信息。Goodbye消息用于断开当前的连接。Ignore消息在服务端无法处理任何请求时使用，这时候服务端将回复一个Ignore消息，表示上一个请求没处理，直接丢掉了。Failed消息表示标准的失败响应，而Record消息则用于传输真实数据，例如传输1000行数据时，就会连续发送1000个Record消息给客户端。\n\n### 服务端状态\n\nBolt协议消息是按照状态机的方式进行处理的，状态机就涉及到有哪些状态以及这些状态是怎么转换的。右侧的图表是从官方协议文档中摘录的，描述了状态转换的过程。由于图表较长，只截取了一部分，这里仅简要介绍几个最常用的状态。\n\n首先是Connect状态，这是当TCP连接刚建立后的初始状态。随后，客户端发送Hello消息，一旦服务端处理成功，会话进入Ready状态。如果客户端发送Run消息，即执行Cypher语句，服务端随后会进入Streaming状态，此时会话涉及到数据传输。如果服务端的数据尚未发送完毕，它将持续保持在Streaming状态，直至数据完全发送完成后回到Ready状态。"
            },
            {
                "content": "### 服务端状态\n\nBolt协议消息是按照状态机的方式进行处理的，状态机就涉及到有哪些状态以及这些状态是怎么转换的。右侧的图表是从官方协议文档中摘录的，描述了状态转换的过程。由于图表较长，只截取了一部分，这里仅简要介绍几个最常用的状态。\n\n首先是Connect状态，这是当TCP连接刚建立后的初始状态。随后，客户端发送Hello消息，一旦服务端处理成功，会话进入Ready状态。如果客户端发送Run消息，即执行Cypher语句，服务端随后会进入Streaming状态，此时会话涉及到数据传输。如果服务端的数据尚未发送完毕，它将持续保持在Streaming状态，直至数据完全发送完成后回到Ready状态。\n\nTx_Ready和Tx_Streaming状态是处理显式事务时使用的。其中，Tx Ready是在客户端发送Begin请求开启显式事务后达到的状态；Tx Streaming与上面的Streaming类似，只不过它发生在显式事务中。Failed状态则意味着当前会话处于失败状态，这种情况很容易发生，例如客户端不小心发送了一个有语法错误的Cypher语句，服务端报错后，会话将进入Failed状态。根据协议的状态机规则，在Failed状态下，服务端无法处理任何消息，如果客户端继续发送语句，服务端会直接忽略并回复Ignore消息。为了继续使用当前会话，客户端需要发送Reset消息，以重置失败状态并让会话回到Ready状态，继续提供服务。\n\n\n## 交互举例\n\n以执行一条Cypher语句为例，下面列出了相关的Bolt消息。首先，TCP连接建立后，客户端会发送固定四个字节的数据，这是Bolt协议的标识。紧随其后是发送16个字节的版本号数据，总共4个版本，这是因为Bolt协议存在多个版本。客户端发送支持的版本号给服务端，服务端选择一个共同支持的版本后回复给客户端，这个过程称为版本协商。成功后，客户端和服务端间的通信将在选定的协议版本下进行。\n\n接着客户端发送Hello消息，包含其身份信息以及用户名和密码。服务端验证成功后返回Success消息，并且会提供服务器的信息以及分配的连接ID。然后客户端发送Begin消息来请求开启一个显式事务，其中包括多个参数，如事务模式和数据库名称等。服务端确认后发送Success消息，客户端随后开始发送Run消息执行Cypher查询，并接收由服务端返回的结果。"
            },
            {
                "content": "## 交互举例\n\n以执行一条Cypher语句为例，下面列出了相关的Bolt消息。首先，TCP连接建立后，客户端会发送固定四个字节的数据，这是Bolt协议的标识。紧随其后是发送16个字节的版本号数据，总共4个版本，这是因为Bolt协议存在多个版本。客户端发送支持的版本号给服务端，服务端选择一个共同支持的版本后回复给客户端，这个过程称为版本协商。成功后，客户端和服务端间的通信将在选定的协议版本下进行。\n\n接着客户端发送Hello消息，包含其身份信息以及用户名和密码。服务端验证成功后返回Success消息，并且会提供服务器的信息以及分配的连接ID。然后客户端发送Begin消息来请求开启一个显式事务，其中包括多个参数，如事务模式和数据库名称等。服务端确认后发送Success消息，客户端随后开始发送Run消息执行Cypher查询，并接收由服务端返回的结果。\n\n这里，客户端请求只读取两条数据，那么服务端接着连续发送两个Record消息。随后服务端发送附带has_more字段的Success消息提醒客户端还有未发送的数据，但是客户端选择发送Discard消息来告诉服务端忽略余下数据并继续处理。\n\n最后，客户端提交事务，如果成功，服务端会返回Success消息。\n\n另一个例子说明了Bolt协议的另一个特性，即pipeline流水式处理。客户端可以连续发送多条Cypher查询语句，而不需要等待前一条语句执行完成。例如，客户端连续发送两条“Run”消息，然后使用Pull消息来指定拉取某个特定查询语句的结果，这需要在消息中明确指出语句的ID，以便服务端知道客户端希望获取哪一条查询的结果，但这也要求服务端也必须具备相应的能力，即在一个会话中可以同时执行多条语句。\n\n## Bolt协议实现\n\n接下来，我将简要描述TuGraph-DB是如何实现Bolt协议的。起初我们当然会进行搜索，看是否已经有现成的开源实现可以利用。是有一个C语言版本的，但这个C语言实现版本相当陈旧，已经很多年未更新，这个是社区贡献的，并且只支持到Bolt协议的3.0版本，而目前Bolt协议已经发展到了5.0版本，3.0版本可能很快就会被淘汰。因此，我们没有采用这个版本，Neo4j自己是没有没有开发C++版本的客户端的。"
            },
            {
                "content": "最后，客户端提交事务，如果成功，服务端会返回Success消息。\n\n另一个例子说明了Bolt协议的另一个特性，即pipeline流水式处理。客户端可以连续发送多条Cypher查询语句，而不需要等待前一条语句执行完成。例如，客户端连续发送两条“Run”消息，然后使用Pull消息来指定拉取某个特定查询语句的结果，这需要在消息中明确指出语句的ID，以便服务端知道客户端希望获取哪一条查询的结果，但这也要求服务端也必须具备相应的能力，即在一个会话中可以同时执行多条语句。\n\n## Bolt协议实现\n\n接下来，我将简要描述TuGraph-DB是如何实现Bolt协议的。起初我们当然会进行搜索，看是否已经有现成的开源实现可以利用。是有一个C语言版本的，但这个C语言实现版本相当陈旧，已经很多年未更新，这个是社区贡献的，并且只支持到Bolt协议的3.0版本，而目前Bolt协议已经发展到了5.0版本，3.0版本可能很快就会被淘汰。因此，我们没有采用这个版本，Neo4j自己是没有没有开发C++版本的客户端的。\n\n后来我们研究了官方的Bolt Golang语言的驱动代码。经过阅读后，我们发现Golang驱动里面Bolt协议这块代码写得比较清晰，于是决定以此为参考，使用C++语言来实现Bolt协议。\n\n在网络框架方面，因为Neo4j是使用Java编写的，Neo4j自己在实现Bolt Server的时候用的是Java里面的Netty框架，Netty是一个NIO网络编程框架，在C++中则可以使用有类似功能的Boost.Asio网络框架来实现。至于消息处理部分，我们严格按照官方文档中描述的状态机规则来构建。\n\n在线程模型的设计上，核心理念是每个连接对应一个线程。主要是因为会话是有状态的，将每个会话绑定在一个固定的线程上，处理起来比较方便。类似地，MySQL也是采用这种方式，为每个连接直接启动一个线程来处理。\n\n关于协议的版本，我们目前采用的是Bolt的4.4版本。Bolt协议有多个主要版本，包括1.0、2.0、3.0、4.0和5.0，每个大版本下还有多个子版本号。而4.4版本是官方的长期支持版本，支持到2026年。\n\n## 数据编解码"
            },
            {
                "content": "后来我们研究了官方的Bolt Golang语言的驱动代码。经过阅读后，我们发现Golang驱动里面Bolt协议这块代码写得比较清晰，于是决定以此为参考，使用C++语言来实现Bolt协议。\n\n在网络框架方面，因为Neo4j是使用Java编写的，Neo4j自己在实现Bolt Server的时候用的是Java里面的Netty框架，Netty是一个NIO网络编程框架，在C++中则可以使用有类似功能的Boost.Asio网络框架来实现。至于消息处理部分，我们严格按照官方文档中描述的状态机规则来构建。\n\n在线程模型的设计上，核心理念是每个连接对应一个线程。主要是因为会话是有状态的，将每个会话绑定在一个固定的线程上，处理起来比较方便。类似地，MySQL也是采用这种方式，为每个连接直接启动一个线程来处理。\n\n关于协议的版本，我们目前采用的是Bolt的4.4版本。Bolt协议有多个主要版本，包括1.0、2.0、3.0、4.0和5.0，每个大版本下还有多个子版本号。而4.4版本是官方的长期支持版本，支持到2026年。\n\n## 数据编解码\n\n数据编解码这块的实现，主要方法是参考官方Bolt Golang驱动的代码，然后用C++进行翻译。这里举了个例子：Bolt协议里面int64数字的编码实现，左边是Go版本的，右边是C++版本的，可以看到几乎是逐行把Go的语法转换成了C++的语法。\n\n数据编解码它是纯粹的计算逻辑，也可以选择参考官方的协议文档自己编写，但这样效率相对较低，而且枯燥，并且出错的概率也大，对着已有的版本翻译是最快的。但是相应的测试代码也得翻译过来，并且跑通，确保逻辑正确。\n\n## Bolt Server 网络模型\n\n这张图是Bolt server的网络模型，最左边是监听线程，中间是一堆的Bolt IO线程，每个线程处理一些Bolt连接的IO读写，每个连接固定对应右边的一个状态机线程。当消息从Bolt连接里面读出来后，会放到状态机线程的消息队列里面去，然后发个信号唤醒状态机去处理消息。消息的处理是按顺序的，如果没有消息。状态机线程处于休眠状态。\n\n## 不兼容的点"
            },
            {
                "content": "## 数据编解码\n\n数据编解码这块的实现，主要方法是参考官方Bolt Golang驱动的代码，然后用C++进行翻译。这里举了个例子：Bolt协议里面int64数字的编码实现，左边是Go版本的，右边是C++版本的，可以看到几乎是逐行把Go的语法转换成了C++的语法。\n\n数据编解码它是纯粹的计算逻辑，也可以选择参考官方的协议文档自己编写，但这样效率相对较低，而且枯燥，并且出错的概率也大，对着已有的版本翻译是最快的。但是相应的测试代码也得翻译过来，并且跑通，确保逻辑正确。\n\n## Bolt Server 网络模型\n\n这张图是Bolt server的网络模型，最左边是监听线程，中间是一堆的Bolt IO线程，每个线程处理一些Bolt连接的IO读写，每个连接固定对应右边的一个状态机线程。当消息从Bolt连接里面读出来后，会放到状态机线程的消息队列里面去，然后发个信号唤醒状态机去处理消息。消息的处理是按顺序的，如果没有消息。状态机线程处于休眠状态。\n\n## 不兼容的点\n\n我们也注意到了一些与官方Neo4j客户端的兼容性问题。Bolt协议是Neo4j自己设计的，服务与自家的产品，并不是一个通用的标准，所以Bolt协议里面不可避免的会有一些Neo4j独有的特性。比如在新版本Neo4j中点的结构体中有一个element_id的字段，是字符串类型，这个在TuGraph-DB中没有这个东西，如用Neo4j客户端连TuGraph-DB，在客户端代码中去获取这个字段，目前返回是空的，而上面的三个字段是有的。同理，右边RUN消息里面红框标出来的都是目前TuGraph-DB没有的。\n\n## 使用效果"
            },
            {
                "content": "## Bolt Server 网络模型\n\n这张图是Bolt server的网络模型，最左边是监听线程，中间是一堆的Bolt IO线程，每个线程处理一些Bolt连接的IO读写，每个连接固定对应右边的一个状态机线程。当消息从Bolt连接里面读出来后，会放到状态机线程的消息队列里面去，然后发个信号唤醒状态机去处理消息。消息的处理是按顺序的，如果没有消息。状态机线程处于休眠状态。\n\n## 不兼容的点\n\n我们也注意到了一些与官方Neo4j客户端的兼容性问题。Bolt协议是Neo4j自己设计的，服务与自家的产品，并不是一个通用的标准，所以Bolt协议里面不可避免的会有一些Neo4j独有的特性。比如在新版本Neo4j中点的结构体中有一个element_id的字段，是字符串类型，这个在TuGraph-DB中没有这个东西，如用Neo4j客户端连TuGraph-DB，在客户端代码中去获取这个字段，目前返回是空的，而上面的三个字段是有的。同理，右边RUN消息里面红框标出来的都是目前TuGraph-DB没有的。\n\n## 使用效果\n\n我们编写了一段简单的Java代码来展示使用Bolt客户端连TuGraph-DB的效果，与关系型数据库里面的JDBC非常类似，整体的使用体验很好。此外，我们还开发了一个Console 客户端，通过Bolt协议与服务端通信，也可以用这个CLI客户端实现在线流式导出数据。在性能对比方面，我们发现新实现的Bolt客户端在性能上略优于我们之前自己编写的RPC客户端，原因可能有多方面，例如编码方式的不同或是PackStream的序列化速度更快。暂未实现的功能目前尚未实现的功能包括显式事务、集群模式、加密传输和高级身份认证。尽管官方Bolt协议支持这些功能，但由于支持它们需要一些改造，且成本与收益比并不高，因此我们当前只支持基本的事务和身份认证。不过，我们计划在今年适配集群模式。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E7%A4%BE%E5%8C%BA%E8%B4%A1%E7%8C%AE_%7C_%E6%96%B0Feature%E5%8F%91%E5%B8%83%EF%BC%9ATuGraph-DB%E6%94%AF%E6%8C%81%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md",
        "chunks": [
            {
                "content": "# 社区贡献 | 新Feature发布：TuGraph-DB支持空间数据类型\n\n本文介绍了来自北京大学的TuGraph开源社区开发者孙同学的工作，孙同学基于开源图数据库TuGraph-DB的开发，支持了空间数据类型。文章将从空间数据类型的应用、在TuGraph-DB中的实现以及使用三个方面进行介绍。孙同学的工作丰富了TuGraph-DB功能，因此获得“TuGraph社区年度优秀贡献者”，再次感谢孙同学的贡献，项目功能正在持续完善中，也欢迎更多伙伴加入TuGraph社区一起共建。\n\n近年来，地理数据类型/空间数据类型（Spatial Data Type）在图数据库中的应用价值显著，它不仅增强了数据的表达能力，还促进了跨领域数据的融合分析，尤其在社交网络、地图探索、城市规划等关键领域展现了强大的实用价值。\n\n## 空间数据类型在图数据库中的应用案例\n\n空间地理数据也是天然适合使用图数据库的一种场景，我们先来看看在图数据库中使用空间数据的几个经典场景:\n\n### 场景案例一：判断某空间类型内的坐标\n\n如上图1和图2所示，日常生活中我们通常需要在地图中查询距离自己一定距离内的景点/美食信息。对应的在图数据库中，即为判断哪些坐标在以某点为中心的圆形或矩形区域内，对应的Cypher查询语句如下:\n\n#### 判断在圆形区域内\n\n```cypher\nWITH point({latitude: $latitude, longitude:$longitude}) AS radiusCenter\n\nMATCH (p:Point)-[:HAS_GEOMETRY]-(poi:PointOfInterest)-[:HAS_TAGS]->(t:Tags)\n    WHERE point.distance(p.location, radiusCenter) < $radius\nRETURN p {\n    latitude: p.location.latitude,\n    longitude: p.location.longitude,\n    name: poi.name,\n    categories: labels(poi),\n    tags: t{.*}                       \n} AS point\n```\n\n#### 判断在矩形区域内"
            },
            {
                "content": "#### 判断在圆形区域内\n\n```cypher\nWITH point({latitude: $latitude, longitude:$longitude}) AS radiusCenter\n\nMATCH (p:Point)-[:HAS_GEOMETRY]-(poi:PointOfInterest)-[:HAS_TAGS]->(t:Tags)\n    WHERE point.distance(p.location, radiusCenter) < $radius\nRETURN p {\n    latitude: p.location.latitude,\n    longitude: p.location.longitude,\n    name: poi.name,\n    categories: labels(poi),\n    tags: t{.*}                       \n} AS point\n```\n\n#### 判断在矩形区域内\n\n```cypher\nMATCH (p:Point)-[:HAS_GEOMETRY]-(poi:PointOfInterest)-[:HAS_TAGS]->(t:Tags)\n   WHERE point.withinBBox(\n        p.location,\n        point({longitude: $lowerLeftLon, latitude: $lowerLeftLat}),\n        point({longitude: $upperRightLon, latitude: $upperRightLat})\n   )\nRETURN p {\n  latitude: p.location.latitude,\n  longitude: p.location.longitude,\n  name: poi.name,\n  categories: labels(poi),\n  tags: t{.*}\n} AS point\n```\n\n### 场景案例二：判断路径与某空间类型是否重合\n\n如上图3所示，移动物体的行动轨迹可以被抽象成一条线，这条轨迹往往伴随着时序信息。日常生活中，有时候我们想知道哪部分行动轨迹和给定区域有重合。对应在图数据库中，即判断一系列坐标中哪些坐标落在在空间类型内。对应的Cypher查询语句如下:"
            },
            {
                "content": "### 场景案例二：判断路径与某空间类型是否重合\n\n如上图3所示，移动物体的行动轨迹可以被抽象成一条线，这条轨迹往往伴随着时序信息。日常生活中，有时候我们想知道哪部分行动轨迹和给定区域有重合。对应在图数据库中，即判断一系列坐标中哪些坐标落在在空间类型内。对应的Cypher查询语句如下:\n\n```cypher\nWITH point({latitude: $latitude, longitude: $longitude}) AS radiusCenter\n\nMATCH (g: Geometry)\n    WHERE any(\n        p IN g.coordiates WHERE point.distance(p, radiusCenter) < $radius\n    )\nRETURN [n IN g.coordinates | [n.latitude, n.longitude]] AS route\n```\n\n## 空间数据类型在TuGraph-DB中的实现\n\n### 需求分析\n\n结合上述案例，我们可以分析总结出对空间数据类型的需求:\n\n- 支持不同坐标系下（包括地球地理坐标系，平面几何坐标系等）不同空间数据类型（包括Point、LineString、Polygon）的存储与创建\n- 支持不同坐标系下的常见空间查询操作, 包括Distance、BoundingBox、Disjoint（判断两个数据是否相交）的查询等\n- 支持空间数据索引（R-Tree）\n- 支持常见空间数据格式的导入（ESRI Shapefile data / OpenStreetMap）\n- 支持空间数据的可视化\n\n### 空间数据类型的表示\n\n空间数据类型可以用不同的坐标系来表示，EPSG[1]是一个标准化的地理空间参考系统标识符集合，用于标识不同的地理空间参考系统，包括坐标系统、地理坐标系、投影坐标系等。通常使用EPSG编码表示数据的坐标系。行业内一般采用\n\n- WGS84坐标系（没错，就是GPS系统的坐标系），标识符为EPSG 4326\n- Cartesian（笛卡尔）坐标系（没错，就是你高中数学学的直角坐标系），标识符为EPSG 7203"
            },
            {
                "content": "### 需求分析\n\n结合上述案例，我们可以分析总结出对空间数据类型的需求:\n\n- 支持不同坐标系下（包括地球地理坐标系，平面几何坐标系等）不同空间数据类型（包括Point、LineString、Polygon）的存储与创建\n- 支持不同坐标系下的常见空间查询操作, 包括Distance、BoundingBox、Disjoint（判断两个数据是否相交）的查询等\n- 支持空间数据索引（R-Tree）\n- 支持常见空间数据格式的导入（ESRI Shapefile data / OpenStreetMap）\n- 支持空间数据的可视化\n\n### 空间数据类型的表示\n\n空间数据类型可以用不同的坐标系来表示，EPSG[1]是一个标准化的地理空间参考系统标识符集合，用于标识不同的地理空间参考系统，包括坐标系统、地理坐标系、投影坐标系等。通常使用EPSG编码表示数据的坐标系。行业内一般采用\n\n- WGS84坐标系（没错，就是GPS系统的坐标系），标识符为EPSG 4326\n- Cartesian（笛卡尔）坐标系（没错，就是你高中数学学的直角坐标系），标识符为EPSG 7203\n\nWGS84是全球定位系统(GPS)的基础，允许全球的GPS接收器确定精确位置。几乎所有现代GPS设备都是基于WGS84坐标系来提供位置信息。在地图制作和GIS（地图制作和地理信息系统）领域，WGS84被广泛用于定义地球上的位置。这包括各种类型的地图创建、空间数据分析和管理等。\n\nCartesian（笛卡尔）坐标系，又称直角坐标系，是一种最基本、最广泛应用的坐标系统。它通过两条数轴定义一个平面，三条数轴定义一个空间，这些轴互相垂直，在数学、物理、工程、天文和许多其他领域中有着广泛的应用。\n\n### 空间数据类型的实现\n\nOGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为EWKT(extended well known text)与EWKB(extended well known binary)格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。\n\n#### EWKT\n\nEWKT格式数据如下所示，先指定空间数据类型，再在括号内指定具体的坐标，一个坐标对表示一个点，每个坐标对之间用逗号隔开。其中，对于Polygon类型的数据，第一个坐标对需要与最后一个坐标对相同，形成闭合的面。"
            },
            {
                "content": "Cartesian（笛卡尔）坐标系，又称直角坐标系，是一种最基本、最广泛应用的坐标系统。它通过两条数轴定义一个平面，三条数轴定义一个空间，这些轴互相垂直，在数学、物理、工程、天文和许多其他领域中有着广泛的应用。\n\n### 空间数据类型的实现\n\nOGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为EWKT(extended well known text)与EWKB(extended well known binary)格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。\n\n#### EWKT\n\nEWKT格式数据如下所示，先指定空间数据类型，再在括号内指定具体的坐标，一个坐标对表示一个点，每个坐标对之间用逗号隔开。其中，对于Polygon类型的数据，第一个坐标对需要与最后一个坐标对相同，形成闭合的面。\n\n```\nSRID=s;POINT ( )\nSRID=s;LINESTRING( ,  , …)\n```\n注: SRID默认为4326, 可以不指定\n\n#### EWKB\n\nEWKB格式数据如下图所示，\n\n- 第0-1位: 表示编码方式 00表示大端法，01表示小端法\n- 第2 - 5位: 空间数据类型\n  - 0100: point\n  - 0200: linestring\n  - 0300: polygon\n- 第6 - 9位: 数据维度\n  - 0020: 二维\n  - 0030: 三维\n- 第10 - 17位: 坐标系的EPSG编码\n- 第18 - n位: double类型的坐标对的16进制表示\n\n注: 对于POINT类型，其EWKB格式为定长存储，固定长度为50，而对于其他类型，则为不定长。\n\n### 实现思路\n\n在TuGraph-DB的实现，基于boost geometry库的基础上进行封装，用EWKB格式存储数据，其中Point类型为定长存储50，其余皆为变长存储。我们支持了Point, Linestring与Polygon三种类型，同时支持了WGS84, CARTESIAN两种坐标系，数据类型与坐标系均可根据需要拓展。\n\n## 在TuGraph-DB中使用空间数据类型\n\n### 定义空间数据类型\n\nTuGraph-DB当前已经支持Point、Linestring与Polygon三种类型"
            },
            {
                "content": "- 第0-1位: 表示编码方式 00表示大端法，01表示小端法\n- 第2 - 5位: 空间数据类型\n  - 0100: point\n  - 0200: linestring\n  - 0300: polygon\n- 第6 - 9位: 数据维度\n  - 0020: 二维\n  - 0030: 三维\n- 第10 - 17位: 坐标系的EPSG编码\n- 第18 - n位: double类型的坐标对的16进制表示\n\n注: 对于POINT类型，其EWKB格式为定长存储，固定长度为50，而对于其他类型，则为不定长。\n\n### 实现思路\n\n在TuGraph-DB的实现，基于boost geometry库的基础上进行封装，用EWKB格式存储数据，其中Point类型为定长存储50，其余皆为变长存储。我们支持了Point, Linestring与Polygon三种类型，同时支持了WGS84, CARTESIAN两种坐标系，数据类型与坐标系均可根据需要拓展。\n\n## 在TuGraph-DB中使用空间数据类型\n\n### 定义空间数据类型\n\nTuGraph-DB当前已经支持Point、Linestring与Polygon三种类型\n\n- Point：点，创建方式例如POINT(2.0, 2.0, 7203)\n- Linestring：折线，创建方式例如LINESTRING(0 2,1 1,2 0)\n- Polygon：多边形，创建方式例如POLYGON((0 0,0 7,4 2,2 0,0 0))\n\n其中坐标点都是double型\n\n### 相关函数介绍\n\n创建空间数据相关函数，以Point为例："
            },
            {
                "content": "注: 对于POINT类型，其EWKB格式为定长存储，固定长度为50，而对于其他类型，则为不定长。\n\n### 实现思路\n\n在TuGraph-DB的实现，基于boost geometry库的基础上进行封装，用EWKB格式存储数据，其中Point类型为定长存储50，其余皆为变长存储。我们支持了Point, Linestring与Polygon三种类型，同时支持了WGS84, CARTESIAN两种坐标系，数据类型与坐标系均可根据需要拓展。\n\n## 在TuGraph-DB中使用空间数据类型\n\n### 定义空间数据类型\n\nTuGraph-DB当前已经支持Point、Linestring与Polygon三种类型\n\n- Point：点，创建方式例如POINT(2.0, 2.0, 7203)\n- Linestring：折线，创建方式例如LINESTRING(0 2,1 1,2 0)\n- Polygon：多边形，创建方式例如POLYGON((0 0,0 7,4 2,2 0,0 0))\n\n其中坐标点都是double型\n\n### 相关函数介绍\n\n创建空间数据相关函数，以Point为例：\n\n| 函数名      | 描述                              | 输入参数                                 | 返回值类型 |\n|-------------|-----------------------------------|------------------------------------------|------------|\n| `Point()`   | 根据坐标或EWKB创建Point            | 坐标对 (double, double) / EWKB format(string) | point      |\n| `PointWKB()`| 根据WKB与指定SRID创建Point         | WKB format(string), SRID(int)            | point      |\n| `PointWKT()`| 根据WKT与指定SRID创建Point         | WKT format(string), SRID(int)            | point      |\n\n\n### 查询用相关函数："
            },
            {
                "content": "### 查询用相关函数：\n\n| 函数名      | 描述                              | 输入参数                                 | 返回值类型 |\n|-------------|-----------------------------------|------------------------------------------|------------|\n| `Distance()`   | 计算两个空间数据间的距离\t           | 注：要求坐标系相同| Spatial data1, Spatial data2         | double\t    |\n| `Disjoint()`| 判断两个空间数据是否相交\t         | 注：开发中| Spatial data1, Spatial data2        | bool\t    |\n| `WithinBBox()`| 判断某个空间数据是否在给定的长方形区域内\t       | 注：开发中| Spatial data, Point1       | bool\t    |\n\n### 使用实例如下：\n\n#### 创建包含空间数据类型的点模型\n\nCALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true) \n\n#### 插入标记美食点的数据\n\nCREATE (n:food {id:10001, name: 'aco Bell',pointTest:point(3.0,4.0,7203)}) RETURN n\n\n#### 创建具有折线属性的点模型\n\nCALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)\n\n#### 插入具有折线属性的点数据"
            },
            {
                "content": "### 使用实例如下：\n\n#### 创建包含空间数据类型的点模型\n\nCALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true) \n\n#### 插入标记美食点的数据\n\nCREATE (n:food {id:10001, name: 'aco Bell',pointTest:point(3.0,4.0,7203)}) RETURN n\n\n#### 创建具有折线属性的点模型\n\nCALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)\n\n#### 插入具有折线属性的点数据\n\nCREATE (n:lineTest {id:102, name: 'Tom',linestringTest:linestringwkt('LINESTRING(0 2,1 1,2 0)', 7203)}) RETURN n\n\n#### 创建具有多边型属性的点模型\n\nCALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)\n\n#### 插入具有多边型属性的点数据\n\nCREATE (n:polygonTest {id:103, name: 'polygonTest',polygonTest:polygonwkt('POLYGON((0 0,0 7,4 2,2 0,0 0))', 7203)}) RETURN n\n\n## Demo演示：基于地理位置个性化推荐的美食探索\n\n在本章节中，我们将探索如何利用TuGraph-DB图数据库的地理空间功能，构建一个生动有趣的美食探索应用，“人”与“美食”通过地理位置紧密相连，实现个性化美食推荐。\n\n### 数据模型设计\n\n定义两种核心节点类型："
            },
            {
                "content": "#### 创建具有多边型属性的点模型\n\nCALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)\n\n#### 插入具有多边型属性的点数据\n\nCREATE (n:polygonTest {id:103, name: 'polygonTest',polygonTest:polygonwkt('POLYGON((0 0,0 7,4 2,2 0,0 0))', 7203)}) RETURN n\n\n## Demo演示：基于地理位置个性化推荐的美食探索\n\n在本章节中，我们将探索如何利用TuGraph-DB图数据库的地理空间功能，构建一个生动有趣的美食探索应用，“人”与“美食”通过地理位置紧密相连，实现个性化美食推荐。\n\n### 数据模型设计\n\n定义两种核心节点类型：\n\n- **Food（美食）点**：每一家餐厅或小吃店都可以作为一个Food节点，其属性包括但不限于名称、地址、评分、美食类别等。特别地，我们将在每个Food节点上附加地理坐标信息，用以精确记录其地理位置。\n\n- **Person（人物）点**：代表应用的用户，属性包含用户名、当前位置等。用户的当前位置同样通过地理坐标表示，便于后续的地理空间查询。\n\n### 创建Schema\n\nCALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true,'mark',double,true)\n\nCALL db.createVertexLabel('person', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true)\n\n### 插入示例数据 food\n\nCREATE (n:food {id:10001, name: 'Starbucks',pointTest:point(1.0,1.0,7203),mark:4.8}) RETURN n"
            },
            {
                "content": "- **Person（人物）点**：代表应用的用户，属性包含用户名、当前位置等。用户的当前位置同样通过地理坐标表示，便于后续的地理空间查询。\n\n### 创建Schema\n\nCALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true,'mark',double,true)\n\nCALL db.createVertexLabel('person', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true)\n\n### 插入示例数据 food\n\nCREATE (n:food {id:10001, name: 'Starbucks',pointTest:point(1.0,1.0,7203),mark:4.8}) RETURN n\n\nCREATE (n:food {id:10002, name: 'KFC',pointTest:point(2.0,1.0,7203),mark:4.5}) RETURN n\n\nCREATE (n:food {id:10003, name: 'Pizza Hut',pointTest:point(2.0,5.0,7203),mark:4.5}) RETURN n\n\nCREATE (n:food {id:10004, name: 'Taco Bell',pointTest:point(3.0,4.0,7203),mark:4.7}) RETURN n\n\nCREATE (n:food {id:10005, name: 'Pizza Fusion',pointTest:point(5.0,3.0,7203),mark:4.9}) RETURN n\n\nCREATE (n:food {id:10006, name: 'HaiDiLao Hot Pot',pointTest:point(2.0,2.0,7203),mark:4.8}) RETURN n\n\nCREATE (n:food {id:10007, name: 'Lao Sze Chuan',pointTest:point(4.0,3.0,7203),mark:4.7}) RETURN n"
            },
            {
                "content": "CREATE (n:food {id:10003, name: 'Pizza Hut',pointTest:point(2.0,5.0,7203),mark:4.5}) RETURN n\n\nCREATE (n:food {id:10004, name: 'Taco Bell',pointTest:point(3.0,4.0,7203),mark:4.7}) RETURN n\n\nCREATE (n:food {id:10005, name: 'Pizza Fusion',pointTest:point(5.0,3.0,7203),mark:4.9}) RETURN n\n\nCREATE (n:food {id:10006, name: 'HaiDiLao Hot Pot',pointTest:point(2.0,2.0,7203),mark:4.8}) RETURN n\n\nCREATE (n:food {id:10007, name: 'Lao Sze Chuan',pointTest:point(4.0,3.0,7203),mark:4.7}) RETURN n\n\n### 插入示例数据 person\n\nCREATE (n:person {id:1, name: 'Tom',pointTest:point(3.0,3.0,7203)}) RETURN n\n\n### 构建美食探索查询\n\n能够根据用户的当前位置，寻找距离2.5以内的美食，根据距离进行升序排列，返回距离和评分。\n\nMATCH (n:person{id:1}), (m:food)\n\nWITH n.pointTest AS p1, m.pointTest AS p2, m.name AS food, m.mark AS mark\n\nCALL spatial.distance(p1,p2) YIELD distance \n\nWHERE distance < 2.5\n\nRETURN food,distance,mark\n\nORDER BY distance\n\n此查询首先匹配特定的Person节点，然后找到所有Food节点，利用自定义的distance函数计算Person节点当前位置与每个Food节点之间的直线距离，筛选出距离在2.5之内的美食。最后，按照美食的距离升序排列结果，附带评分参考，为用户提供最优质的推荐。\n\n### 未来展望"
            },
            {
                "content": "CREATE (n:person {id:1, name: 'Tom',pointTest:point(3.0,3.0,7203)}) RETURN n\n\n### 构建美食探索查询\n\n能够根据用户的当前位置，寻找距离2.5以内的美食，根据距离进行升序排列，返回距离和评分。\n\nMATCH (n:person{id:1}), (m:food)\n\nWITH n.pointTest AS p1, m.pointTest AS p2, m.name AS food, m.mark AS mark\n\nCALL spatial.distance(p1,p2) YIELD distance \n\nWHERE distance < 2.5\n\nRETURN food,distance,mark\n\nORDER BY distance\n\n此查询首先匹配特定的Person节点，然后找到所有Food节点，利用自定义的distance函数计算Person节点当前位置与每个Food节点之间的直线距离，筛选出距离在2.5之内的美食。最后，按照美食的距离升序排列结果，附带评分参考，为用户提供最优质的推荐。\n\n### 未来展望\n\n孙同学的工作，让TuGraph-DB具备了处理地理空间数据的能力。未来，TuGraph-DB将来会继续实现Disjoint() 、WithinBBox()等更多的函数，以及实现更高级的索引、数据导入、可视化等功能，丰富更多的使用场景。作为开源项目，TuGraph社区也欢迎大家一起参与共建开发地理空间功能。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E8%9A%82%E8%9A%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E8%8E%B7LDBC%E6%9D%83%E5%A8%81%E6%B5%8B%E8%AF%95%E4%B8%96%E7%95%8C%E7%AC%AC%E4%B8%80.md",
        "chunks": [
            {
                "content": "# 蚂蚁图数据库再获LDBC权威测试世界第一\n\n近日，国际权威图数据库测试机构国际关联数据基准委员会（LDBC）公布了行业通用的社交网络基准测试（LDBC SNB）最新结果。蚂蚁集团图数据库TuGraph打破官方审计测试纪录，再次拿到世界第一，这一纪录较LDBC早前公布的最高纪录吞吐量提升了52%，也超过了两年前由TuGraph保持的世界纪录1倍以上。\n\n据LDBC官方发布的报告，在本次测试中，TuGraph在不同规模的数据集下均表现优异，在最大数据规模300G的数据集（8亿个结点，53亿条边）上，TuGraph的吞吐率较上一次官方纪录提升了52%，在系统事务性、可恢复性、正确性、稳定性等方面均达到官方标准，体现了TuGraph高并发低延迟的强大性能优势。\n\n为了更加贴近真实场景使测试更加严谨，TuGraph还采用了Client/Server部署，将客户端和服务器分别部署在两台服务器上，在更严苛的条件下（固有网络延迟与网络波动）完成了本次测试。\n\n蚂蚁集团也是LDBC最新的金融图数据测试基准Finbench的发起人和主要建设者。\n\n## 关于LDBC和SNB测试\n\nLDBC，即“关联数据基准测评委员会”（Linked Data Benchmark Council），是全球公认的图数据库领域基准指南制定者与测试机构，与TPC并称为国际数据库行业两大权威技术组织。\n\nSNB，即社交网络基准测试（Social Network Benchmark），是由LDBC开发的面向图数据库的基准测试（Benchmark）之一。SNB测试由于更贴近现实系统，同时包含了读写任务，简单和复杂查询，规定了系统的响应时间，更能体现系统的综合性能，是目前图数据行业最成熟和通用的性能测试。\n\nLDBC SNB测试由指定的第三方机构进行，从数据导入到结果验证均由第三方在云平台上执行，最终结果由LDBC执行委员会进行审计并公布，最大限度的保证了结果的可信性。同时，SNB还公布了测试过程所用的程序和脚本，以及测试过程中产生的详细结果，进一步确保了测试的可复现性。\n\n## 关于TuGraph\n\n蚂蚁集团图数据库TuGraph是基于图模型的一站式数据存储和分析系统，擅长处理大规模关联数据的管理和分析，如社交关系、物流服务、设备管网、金融交易等场景，数千倍优化分析性能，天然具备数据可视化展示。"
            },
            {
                "content": "LDBC，即“关联数据基准测评委员会”（Linked Data Benchmark Council），是全球公认的图数据库领域基准指南制定者与测试机构，与TPC并称为国际数据库行业两大权威技术组织。\n\nSNB，即社交网络基准测试（Social Network Benchmark），是由LDBC开发的面向图数据库的基准测试（Benchmark）之一。SNB测试由于更贴近现实系统，同时包含了读写任务，简单和复杂查询，规定了系统的响应时间，更能体现系统的综合性能，是目前图数据行业最成熟和通用的性能测试。\n\nLDBC SNB测试由指定的第三方机构进行，从数据导入到结果验证均由第三方在云平台上执行，最终结果由LDBC执行委员会进行审计并公布，最大限度的保证了结果的可信性。同时，SNB还公布了测试过程所用的程序和脚本，以及测试过程中产生的详细结果，进一步确保了测试的可复现性。\n\n## 关于TuGraph\n\n蚂蚁集团图数据库TuGraph是基于图模型的一站式数据存储和分析系统，擅长处理大规模关联数据的管理和分析，如社交关系、物流服务、设备管网、金融交易等场景，数千倍优化分析性能，天然具备数据可视化展示。\n\nTuGraph拥有业界领先的集群规模和性能，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，提供了稳定的决策支持能力，其中，支撑支付宝的重要风险识别能力提升了近10倍，风险审理分析效率提升90%。TuGraph已被成熟应用于安全风控、信贷风控、知识图谱、数据血缘、资金分析、流量归因分析、会员关系等场景，并面向金融、工业、政务服务等行业客户。\n\n## TuGraph：从清华到蚂蚁\n\n蚂蚁集团图计算TuGraph（原名GeaGraph），是蚂蚁集团与清华大学联合研发的大规模图计算系统，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，是图数据库基准性能测试LDBC-SNB世界纪录保持者。TuGraph是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。\n\n### 清华时期"
            },
            {
                "content": "TuGraph拥有业界领先的集群规模和性能，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，提供了稳定的决策支持能力，其中，支撑支付宝的重要风险识别能力提升了近10倍，风险审理分析效率提升90%。TuGraph已被成熟应用于安全风控、信贷风控、知识图谱、数据血缘、资金分析、流量归因分析、会员关系等场景，并面向金融、工业、政务服务等行业客户。\n\n## TuGraph：从清华到蚂蚁\n\n蚂蚁集团图计算TuGraph（原名GeaGraph），是蚂蚁集团与清华大学联合研发的大规模图计算系统，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，是图数据库基准性能测试LDBC-SNB世界纪录保持者。TuGraph是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。\n\n### 清华时期\n\n早在2010年前后，清华大学计算机系高性能所就开始图计算相关技术及系统研究。于2016年成功研发的双子星图计算系统比业界常用的开源图计算引擎GraphX性能提高了约100倍，获得了业界的广泛关注。\n\n### 费马时期\n\n为了推动技术的广泛应用，2016年从事图计算研究的清华师生成立了费马科技有限公司。费马科技在推进双子星系统应用的同时，进一步开发出了具有国际领先性能的图数据库产品TuGraph，能够支持完整的图数据库事务，服务了搜狗搜索、京东金融、以及大型国有银行、国家级能源企业在内的不同行业用户，并在2020年通过了国际图数据库标准组织LDBC的认证测试，认证成绩是第二名的7.6倍。\n\n### 蚂蚁时期\n\n蚂蚁集团在很多领域具有科技领先能力，国内乃至全球最大的用户量和峰值交易量使得蚂蚁集团对图计算有着丰富的应用需求，利用图计算技术处理支付宝的反欺诈、反套现等难题，可以比传统技术更加适用。从2015年起，蚂蚁集团开始自主研发分布式图数据库、流式图计算等图计算技术系统，并在内部应用中获得了良好的效果。"
            },
            {
                "content": "### 清华时期\n\n早在2010年前后，清华大学计算机系高性能所就开始图计算相关技术及系统研究。于2016年成功研发的双子星图计算系统比业界常用的开源图计算引擎GraphX性能提高了约100倍，获得了业界的广泛关注。\n\n### 费马时期\n\n为了推动技术的广泛应用，2016年从事图计算研究的清华师生成立了费马科技有限公司。费马科技在推进双子星系统应用的同时，进一步开发出了具有国际领先性能的图数据库产品TuGraph，能够支持完整的图数据库事务，服务了搜狗搜索、京东金融、以及大型国有银行、国家级能源企业在内的不同行业用户，并在2020年通过了国际图数据库标准组织LDBC的认证测试，认证成绩是第二名的7.6倍。\n\n### 蚂蚁时期\n\n蚂蚁集团在很多领域具有科技领先能力，国内乃至全球最大的用户量和峰值交易量使得蚂蚁集团对图计算有着丰富的应用需求，利用图计算技术处理支付宝的反欺诈、反套现等难题，可以比传统技术更加适用。从2015年起，蚂蚁集团开始自主研发分布式图数据库、流式图计算等图计算技术系统，并在内部应用中获得了良好的效果。\n\n2020年，蚂蚁集团进一步整合了自有的图计算技术系统GeaBase，以及清华大学和费马科技的产品和技术，升级形成了一套完整的图计算系统GeaGraph（后统一采用TuGraph命名）。这套系统集成了各方原有优势，经过多年技术积累和大规模实战打磨，无论从功能的完整性，还是吞吐率、响应时间等性能指标，都达到了世界领先水平。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E8%9A%82%E8%9A%81%E5%BC%80%E6%BA%90%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93_TuGraph-DB_%E5%8D%87%E7%BA%A7%E5%88%B0_v4.0%EF%BC%8C%E5%85%A8%E6%96%B0%E6%94%AF%E6%8C%81_GQL_%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80.md",
        "chunks": [
            {
                "content": "# 蚂蚁开源图数据库 TuGraph-DB 升级到 v4.0，全新支持 GQL 国际标准查询语言\n\n在2022年9月的世界人工智能大会上，蚂蚁自研图数据库TuGraph-DB正式开源。正值开源一周年之际，迎来了开源TuGraph-DB v4.0版，期间经历了10次重要迭代，重大更新的功能包括云上部署、POG（Procedure On Graph query language）、Python算法接口、图学习引擎、高可用、ISO GQL等，在功能完备性、上手易用性、设计先进性等方面做了大量的工作。\n\nTuGraph-DB v4.0主要支持了ISO GQL国际标准查询语言、企业级高可用能力以及图学习引擎。\n\n## TuGraph-DB v4.0 核心新功能介绍\n\n1. **ISO GQL**\n\n   关系型图数据库之所以能够顺利发展，一个重要的原因是标准化查询语言SQL的广泛使用，既降低了数据库用户的操作门槛，同时抹平了不同数据库间的实现细节，形成了分工合作的生态。\n\n   GQL（Graph Query Language）是一种用于图查询语言的国际标准，是图数据库领域的“SQL”，参与方包括国际标准机构、高校、图数据库厂商、非盈利组织等，是图生态中非常重要的一环。\n\n   新版本遵循GQL的最新标准，在查询引擎进行了支持，为用户提供了丰富多样的查询语言选择，也对图数据库领域查询语言的标准化起到了推动作用。\n\n2. **企业级高可用**\n\n   TuGraph-DB开源了企业级高可用能力，能够实现多活热备。支持用户便捷使用客户端来操作高可用功能，自动负载均衡，数据库不需要额外配置就可以支持更高的读负载。\n\n   在TuGraph-DB高可用集群模式中，服务器中有一个leader和多个follower，可以并发提供读写能力。在任一单个节点故障时，基于RAFT协议可以秒级切换leader，持续为业务提供读写服务，RPO=0，RTO<10秒。\n\n   TuGraph-DB高可用后续还将支持Witness、Learner等更多的功能角色。\n\n3. **图学习引擎**"
            },
            {
                "content": "GQL（Graph Query Language）是一种用于图查询语言的国际标准，是图数据库领域的“SQL”，参与方包括国际标准机构、高校、图数据库厂商、非盈利组织等，是图生态中非常重要的一环。\n\n   新版本遵循GQL的最新标准，在查询引擎进行了支持，为用户提供了丰富多样的查询语言选择，也对图数据库领域查询语言的标准化起到了推动作用。\n\n2. **企业级高可用**\n\n   TuGraph-DB开源了企业级高可用能力，能够实现多活热备。支持用户便捷使用客户端来操作高可用功能，自动负载均衡，数据库不需要额外配置就可以支持更高的读负载。\n\n   在TuGraph-DB高可用集群模式中，服务器中有一个leader和多个follower，可以并发提供读写能力。在任一单个节点故障时，基于RAFT协议可以秒级切换leader，持续为业务提供读写服务，RPO=0，RTO<10秒。\n\n   TuGraph-DB高可用后续还将支持Witness、Learner等更多的功能角色。\n\n3. **图学习引擎**\n\n   TuGraph-DB v4.0深度集成了图学习引擎，兼容DGL、PyG等常见图学习框架。TuGraph-DB提供两种典型的图采样算子，包括对最新数据进行实时图采样，和基于快照进行批量图采用。学习引擎的实时图采样和查询引擎的图查询使用同一份存储数据。TuGraph-DB用户能够在图数据库上直接进行图学习训练。\n\n   用图数据库作为图学习引擎的后端，最显著的一个优势是可以支持充分利用硬盘空间，即图学习涉及的数据不用全部放到内存。相比较传统的大数据引擎的解决方案（比如Spark），TuGraph-DB的图学习引擎可以在单机进行超大规模的图学习，大大降低了部署成本。\n\n## 结语\n\n在过去的一年里，不论是接口的丰富性还是学习引擎的支持，TuGraph-DB都致力于在简单易用性和功能完备性方面取得更好的表现。在未来的规划中，TuGraph-DB将持续进行架构演进，努力打造更活跃的图生态。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E8%9A%82%E8%9A%81%E9%9B%86%E5%9B%A2%E5%BC%80%E6%BA%90%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93_TuGraph%EF%BC%8C%E6%88%90%E7%AB%8B%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%BC%80%E6%BA%90%E5%A7%94%E5%91%98%E4%BC%9A.md",
        "chunks": [
            {
                "content": "# 蚂蚁集团开源图数据库 TuGraph，成立图计算开源委员会\n\n9 月 1 日，2022 世界人工智能大会“新一代图智能技术发展与实践论坛”上，蚂蚁集团图计算负责人陈文光宣布开源蚂蚁集团高性能图数据库 TuGraph 单机版，并成立图计算开源技术委员会，中国工程院院士郑纬民、陈纯分别担任主席、副主席，5 位业界知名专家担任委员。\n\nTuGraph 由蚂蚁集团和清华大学共同研发，是图数据库权威测试世界纪录保持者，也是世界上有测试纪录的“最快”的图数据库。\n\n随着 TuGraph 的开源，图数据领域将迎来一款性能卓越、功能丰富、生态完备的开源产品。\n\n开发者可以聚焦应用层，轻松打造属于自己的图数据，从而提升行业整体技术应用水位。TuGraph 开源采用 Apache2.0 协议，在 Github 和 Gitee 上进行托管。\n\n图数据库区别于关系型数据库，基于图模型，使用点边来表示、存储、处理数据，拥有灵活的数据抽象模型，能够更好地表达出“关系”的概念。\n\n蚂蚁 TuGraph 是一套分布式图数据库系统，可以支持万亿级边上的实时查询。此次开源的 TuGraph 单机版，同样具备完备的图数据库基础功能和成熟的产品设计，可以轻松支持 TB 级别数据和百亿级别大图，足以满足大多数业务场景需求。相较于市场上常见的开源产品，TuGraph 单机版的性能高 10 倍以上。\n\n蚂蚁集团 2015 年开始自主研发分布式图数据库、流式图计算等图相关技术，2016 年发布自研分布式图数据库，并应用于支付宝。至今 TuGraph 已应用于蚂蚁内部 150 多个场景，包括在线支付的实时链路，以支付宝风险识别能力提升近 10 倍、风险审理分析效率提升 90%的成绩，验证了其高可靠性。\n\n就在上个月，LDBC（关联数据基准委员会）发布最新图数据库 SNB 测试结果，TuGraph 在功能完整性、吞吐率、响应速度等层面全球领先。\n\n目前，蚂蚁集团已形成了一套以图数据库为底座、同时包含流式图计算，离线图学习的大规模图计算系统。\n\n蚂蚁集团图数据库负责人洪春涛表示，图技术是未来大数据、人工智能和高性能计算产业发展的关键所在，它很有可能会成为下一代的数据底座。蚂蚁集团愿意通过开源持续输出核心技术优势，推动图数据库更广泛的应用生态，携手行业抢占技术高地，不断探索技术的可能性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E8%9A%82%E8%9A%81%E9%AB%98%E6%80%A7%E8%83%BD%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93TuGraph-DB%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83%E4%B8%8E%E5%AE%9E%E8%B7%B5.md",
        "chunks": [
            {
                "content": "# 蚂蚁高性能图数据库TuGraph-DB的技术思考与实践\n\n在近日举行的 DTCC 2022 第十三届中国数据库技术大会-图数据技术与应用创新专场，蚂蚁集团图数据库负责人洪春涛博士分享了蚂蚁高性能图数据库TuGraph-DB的技术思考和实践，以下为演讲内容要点回顾。\n\n## 图计算的优势\n\n图计算是一种高效的抽象计算方法，可以方便地处理复杂的多维数据。我们将员工和公司之间的关系画成图，这样可以快速查询员工的信息，例如员工的工作情况、与其他员工的关系以及与哪些公司有联系。相比之下，在关系数据库中，我们需要分别建立员工信息表、公司信息表以及员工和公司之间的关系表。这就把整个数据切成了很多张二维表，在实际应用系统中经常能够看到几百上千张表。这样会使得系统变得更加复杂，需要基于多张表去做推断，对人或机器来说都会带来挑战。\n\n对比来看什么是简单查询和复杂查询：\n\n图中表格的前两行属于比较简单的查询，比如某个员工的工龄，直接找到对应的那一行然后取出来就可以；比如找出所有的雇员数大于5的公司，可能在雇佣关系表中就能找出来，在关系数据库里这些都属于常规的操作。\n\n但如果查询再复杂一点，我想知道员工A和员工C之间有什么关系，不一定是一跳的关系，可能包含在同一家公司工作，也可能包含参与了同一个项目，甚至还包含他们有一个共同好友，这些关系就是多种多样的，想用SQL列举所有可能的关系其实就没有那么容易了。如果确定知道这里可能有几种关系，还能靠SQL穷举出来，但随着表越来越多，里面的关系可能有几百上千的时候，再想去穷举就非常难了。\n\n最后还有一种更复杂的查询，比如想找员工A和员工E的所有关系，可能包括A认识B，B认识C，C认识E，相当于在做一个不定长跳数的查询，在SQL里面就非常难写了，相信绝大多数人都难以写出这种查询。\n\n业界有句话，所谓的关系数据库实际上并不擅长处理关系。例如，员工A和E之间的所有关系实际上就是我们要查询的关系，但在关系数据库中处理这种关系查询实际上是不够友好的。这是图数据库的优势所在，它们更擅长处理复杂的关系数据。我们发现，大部分浅显的数据信息都可以比较容易地挖掘出来，但要想更深入地利用数据产生更多的价值，就必须挖掘更深层次的信息，这时就一定会遇到这些复杂的关系，这也是为什么图数据库越来越受欢迎的原因。\n\n## 为什么图数据库开始流行"
            },
            {
                "content": "但如果查询再复杂一点，我想知道员工A和员工C之间有什么关系，不一定是一跳的关系，可能包含在同一家公司工作，也可能包含参与了同一个项目，甚至还包含他们有一个共同好友，这些关系就是多种多样的，想用SQL列举所有可能的关系其实就没有那么容易了。如果确定知道这里可能有几种关系，还能靠SQL穷举出来，但随着表越来越多，里面的关系可能有几百上千的时候，再想去穷举就非常难了。\n\n最后还有一种更复杂的查询，比如想找员工A和员工E的所有关系，可能包括A认识B，B认识C，C认识E，相当于在做一个不定长跳数的查询，在SQL里面就非常难写了，相信绝大多数人都难以写出这种查询。\n\n业界有句话，所谓的关系数据库实际上并不擅长处理关系。例如，员工A和E之间的所有关系实际上就是我们要查询的关系，但在关系数据库中处理这种关系查询实际上是不够友好的。这是图数据库的优势所在，它们更擅长处理复杂的关系数据。我们发现，大部分浅显的数据信息都可以比较容易地挖掘出来，但要想更深入地利用数据产生更多的价值，就必须挖掘更深层次的信息，这时就一定会遇到这些复杂的关系，这也是为什么图数据库越来越受欢迎的原因。\n\n## 为什么图数据库开始流行\n\n图数据库的概念最早出现在七八十年代初期，但当时为什么人们没有选择使用图数据库，而是选择了关系数据库呢？我认为主要原因是，当时的计算机并不那么强大，使用二维表格形式的关系数据库对计算机来说更友好。我们知道，计算机最擅长的事情就是重复的劳动，重复的任务。如果我们要在一张二维表中找一行数据，我们可以一行一行查找，或者使用二分查找（如果数据是树状有序的）。每一层都是重复的算法在运行，这对计算机来说是一个非常规整的数据，容易处理。但如果把数据抽象成一张图，那么难度就会大很多，对计算机来说会更难处理。\n\n举个例子，一个员工可能与其他人有各种不同的关系，比如朋友关系、雇佣关系、参与项目关系，每种关系的类型都不同，对应的数据也都不同。此外，一个点上的边数也非常不规律，有的人可能只有几个好友，而在微博上，一个普通人可能有两三百个粉丝，而大V账号可能有数百万甚至上亿的粉丝。这样一来，存储数据时，普通人和大V之间的差距就非常大了，对计算机来说，处理这两种数据的差异也会很大。"
            },
            {
                "content": "## 为什么图数据库开始流行\n\n图数据库的概念最早出现在七八十年代初期，但当时为什么人们没有选择使用图数据库，而是选择了关系数据库呢？我认为主要原因是，当时的计算机并不那么强大，使用二维表格形式的关系数据库对计算机来说更友好。我们知道，计算机最擅长的事情就是重复的劳动，重复的任务。如果我们要在一张二维表中找一行数据，我们可以一行一行查找，或者使用二分查找（如果数据是树状有序的）。每一层都是重复的算法在运行，这对计算机来说是一个非常规整的数据，容易处理。但如果把数据抽象成一张图，那么难度就会大很多，对计算机来说会更难处理。\n\n举个例子，一个员工可能与其他人有各种不同的关系，比如朋友关系、雇佣关系、参与项目关系，每种关系的类型都不同，对应的数据也都不同。此外，一个点上的边数也非常不规律，有的人可能只有几个好友，而在微博上，一个普通人可能有两三百个粉丝，而大V账号可能有数百万甚至上亿的粉丝。这样一来，存储数据时，普通人和大V之间的差距就非常大了，对计算机来说，处理这两种数据的差异也会很大。\n\n我们知道，在七八十年代，计算机相对来说很弱，如果那个时候使用图来表示数据，整个处理和查询的难度就会大很多。所以，人们选择使用关系数据表的形式表示数据。事实上，那个时候有人做过图数据库，但并没有流行起来，原因就是性能相对关系数据库来说差得太多了。\n\n我们知道，所有的事物，尤其是电脑，一直在不断进步。这包括硬件和软件方面的改进。如今的硬件和几十年前的硬件完全不是一个概念，而现在的软件优化也大不相同。随着这些改进，我们会发现对当前的电脑和计算机系统来说，使用图数据库带来的额外开销可能不是很大的问题。\n\n举个例子，我们会发现，过去人们都使用低级编程语言编写程序，但随着时间的推移，有了高级语言。比如最开始、最原始的电脑可能是用纸袋和机器码写程序，后来有了汇编，再后来有C语言、C++，现在很多人都直接写Python。虽然 Python 程序的执行速度可能较慢，但是写的很快，而用用C++或者汇编去写得写半天，对于编写程序到最终得出结果的整个过程来说，使用 Python 会更方便。\n\n计算机编程语言的发展是从低级向高级演变的，数据抽象也是一样。我们认为，未来的数据抽象一定会对人更友好一些，而不是专注于对机器更友好。如图所示，编程语言的发展是从低级语言向高级语言转变的，我们也认为数据抽象层次也会慢慢从低层次表格抽象向高层次图表抽象发展。"
            },
            {
                "content": "我们知道，所有的事物，尤其是电脑，一直在不断进步。这包括硬件和软件方面的改进。如今的硬件和几十年前的硬件完全不是一个概念，而现在的软件优化也大不相同。随着这些改进，我们会发现对当前的电脑和计算机系统来说，使用图数据库带来的额外开销可能不是很大的问题。\n\n举个例子，我们会发现，过去人们都使用低级编程语言编写程序，但随着时间的推移，有了高级语言。比如最开始、最原始的电脑可能是用纸袋和机器码写程序，后来有了汇编，再后来有C语言、C++，现在很多人都直接写Python。虽然 Python 程序的执行速度可能较慢，但是写的很快，而用用C++或者汇编去写得写半天，对于编写程序到最终得出结果的整个过程来说，使用 Python 会更方便。\n\n计算机编程语言的发展是从低级向高级演变的，数据抽象也是一样。我们认为，未来的数据抽象一定会对人更友好一些，而不是专注于对机器更友好。如图所示，编程语言的发展是从低级语言向高级语言转变的，我们也认为数据抽象层次也会慢慢从低层次表格抽象向高层次图表抽象发展。\n\n## 图计算在蚂蚁的应用\n\n自2015年开始，蚂蚁实际上投入了大量资源来研究图计算，研究如何在蚂蚁的业务中使用图计算。例如数据血缘应用。在对业务的处理过程中，我们需要较好地追踪这些数据的流转路径，如果修改了一份源数据会对下游数据产生什么影响，会对最终业务产生什么影响。为了更好地追踪，我们使用图数据库来存储数据。\n\n另一个比较有趣的应用场景就是程序分析。相信几乎所有互联网公司内部都有大量的程序，因此，我们需要管理这些程序，并在每次提交代码时了解将会对哪些内容产生影响。为此，蚂蚁负责程序分析的团队会分析这里的图数据。例如，定义一个变量A，然后使用变量A，“定义”与“使用”之间就会有一条边，使用关系会存储在图数据库中。目前我们的图中已经有超过200亿条边，这是一个非常大的数据量。我们需要对这些数据进行存储、查询和分析，这是蚂蚁公司内部非常多的图数据场景之一。\n\n举个例子来说明优惠券反套现的场景：满额返券是一种比较常见的促销方式，比如购物满2000元就可以享受100元的优惠。这种情况下，如果正常消费，用户花费2000元，通过返券省下100元。但是有些人会想办法注册假商铺，进行虚假交易，目的是把平台补贴的优惠券套出来。因此当用户去买东西，平台要去付补贴的过程，我们需要去实时检测一下会不会有可疑的资金交易情况。"
            },
            {
                "content": "另一个比较有趣的应用场景就是程序分析。相信几乎所有互联网公司内部都有大量的程序，因此，我们需要管理这些程序，并在每次提交代码时了解将会对哪些内容产生影响。为此，蚂蚁负责程序分析的团队会分析这里的图数据。例如，定义一个变量A，然后使用变量A，“定义”与“使用”之间就会有一条边，使用关系会存储在图数据库中。目前我们的图中已经有超过200亿条边，这是一个非常大的数据量。我们需要对这些数据进行存储、查询和分析，这是蚂蚁公司内部非常多的图数据场景之一。\n\n举个例子来说明优惠券反套现的场景：满额返券是一种比较常见的促销方式，比如购物满2000元就可以享受100元的优惠。这种情况下，如果正常消费，用户花费2000元，通过返券省下100元。但是有些人会想办法注册假商铺，进行虚假交易，目的是把平台补贴的优惠券套出来。因此当用户去买东西，平台要去付补贴的过程，我们需要去实时检测一下会不会有可疑的资金交易情况。\n\n蚂蚁有很多业务需要研究图计算系统和图数据库等技术来满足需求，因为这些业务需要对大量的点边进行分析，数据量超过了100TB，基本上已经达到了PB级别。我们需要对这些图进行实时查询，吞吐率大约在百万级别。由于需要对用户的付款进行实时判断，所以需要比较低的延迟，大约在20毫秒的级别。如果延迟太长，会导致用户体验很差，比如付款需要等待5秒才能完成，这样就会非常麻烦。\n\n## 图计算系统建设中的问题与挑战\n\n在建立蚂蚁图计算系统的过程中，我们遇到了各种各样的问题。为了解决这些问题，我们与学术界和许多研究界的同事一起合作，并发表了许多相关的学术论文，包括EuroSys等。然而，我们在建立系统的过程中发现，目前的图计算仍处于较早期的阶段，因此许多标准尚未成形。这对我们来说是一个棘手的问题。例如，在关系型数据库中，查询语言基本上就是SQL，但在图数据库中，仅查询语言就有许多种，包括Gremlin、G-SQL等等。这导致了市场的碎片化，人们学习和使用的成本也很高。"
            },
            {
                "content": "蚂蚁有很多业务需要研究图计算系统和图数据库等技术来满足需求，因为这些业务需要对大量的点边进行分析，数据量超过了100TB，基本上已经达到了PB级别。我们需要对这些图进行实时查询，吞吐率大约在百万级别。由于需要对用户的付款进行实时判断，所以需要比较低的延迟，大约在20毫秒的级别。如果延迟太长，会导致用户体验很差，比如付款需要等待5秒才能完成，这样就会非常麻烦。\n\n## 图计算系统建设中的问题与挑战\n\n在建立蚂蚁图计算系统的过程中，我们遇到了各种各样的问题。为了解决这些问题，我们与学术界和许多研究界的同事一起合作，并发表了许多相关的学术论文，包括EuroSys等。然而，我们在建立系统的过程中发现，目前的图计算仍处于较早期的阶段，因此许多标准尚未成形。这对我们来说是一个棘手的问题。例如，在关系型数据库中，查询语言基本上就是SQL，但在图数据库中，仅查询语言就有许多种，包括Gremlin、G-SQL等等。这导致了市场的碎片化，人们学习和使用的成本也很高。\n\n在建立图计算系统的过程中，我们也遇到了许多挑战。为了分担较大的通信量，需要将图数据分布到多台机器上，但这会导致边的信息在不同机器之间传递，造成大量的通信。此外，单次查询所涉及的数据量也比较大，例如五跳查询涉及的点数就已达到10的五次方，图中还存在一些非常大的点。同时，用户对图计算系统的需求也十分多样，既有快速查询的需求，也有对复杂算法（如社区发现）的需求，单一系统很难满足这些不同的需求。\n\n## TuGraph技术优势\n\n蚂蚁自己开发了一套图计算系统TuGraph，既能解决图数据的存储问题，也能解决流式计算、离线计算和图学习的问题。目前，超过100个业务线和300多个场景都在使用这套系统。这套系统在2021年获得了世界互联网大会领先科技成果奖。\n\n在TuGraph中，性能是一个重要的因素，因为图数据集的体积很大，如果性能不佳就会浪费机器资源，导致许多情况下无法完成任务。比如，希望业务的查询能在几十毫秒内返回结果，但是如果做的性能不好，几秒钟才能返回结果，就无法作为在线查询使用。因此，我们是非常对性能是很重视的，其中在 LDBC-SNB 标准测试中（类似于数据库领域性能标准测试TPC-C），TuGraph仍然是世界纪录的保持者。"
            },
            {
                "content": "## TuGraph技术优势\n\n蚂蚁自己开发了一套图计算系统TuGraph，既能解决图数据的存储问题，也能解决流式计算、离线计算和图学习的问题。目前，超过100个业务线和300多个场景都在使用这套系统。这套系统在2021年获得了世界互联网大会领先科技成果奖。\n\n在TuGraph中，性能是一个重要的因素，因为图数据集的体积很大，如果性能不佳就会浪费机器资源，导致许多情况下无法完成任务。比如，希望业务的查询能在几十毫秒内返回结果，但是如果做的性能不好，几秒钟才能返回结果，就无法作为在线查询使用。因此，我们是非常对性能是很重视的，其中在 LDBC-SNB 标准测试中（类似于数据库领域性能标准测试TPC-C），TuGraph仍然是世界纪录的保持者。\n\nTuGraph 的整个图存储是建立在完美哈希的基础上的，这是我们与其他图系统的一个重要区别。目前，大多数图系统使用的是基于数的存储，但数的问题在于永远存在一个 LogN 的查找操作。然而，在图中可以看到，不同的顶点之间实际上是无序的，不需要有顺序，所以顶点这个级别实际上是基于哈希的，理论上，顶点的读取是最优的。\n\n此外，TuGraph 还参与了许多标准的定制，整个系统在尽量往标准化的方向去做。\n\n除了为内部提供服务，我们还向外提供服务，主要是因为，作为一个系统，如果只为有限的客户提供服务，就很容易构建成一个专有系统。我们希望这是一个标准化、开放的系统，所以我们也在对外提供图计算系统的产品和服务。目前，我们也有很多外部客户，包括金融、工业、互联网以及政企领域。\n\n整个图计算系统目前仍处于较早期的阶段，我们认为还有很多工作要做，包括提升应用性、性能和降低成本。所有的系统都会有这些问题。但是，如果希望普及，我们认为最重要的是有健康的生态，来推动图计算系统的发展，需要有更多的用户和更多的场景使用这个系统。\n\n所有的计算机系统都需要去有一个更开放、更大的生态才能促进发展。蚂蚁有一句话叫做“成熟一个、开放一个”，一个系统成熟以后，我们就会试着开放出去，让更多的人去用。今年9月，我们已经在GitHub上开源了TuGraph中的单机版图数据库，以及一个离线图分析引擎TuGraph Compute。分布式图数据库和流式图计算现在已经包含在我们的商业化版本中，包括一站式图研发平台。我们计划在未来迭代更多更丰富的系统功能，希望能做得更好。\n\n## TuGraph开源版特色"
            },
            {
                "content": "除了为内部提供服务，我们还向外提供服务，主要是因为，作为一个系统，如果只为有限的客户提供服务，就很容易构建成一个专有系统。我们希望这是一个标准化、开放的系统，所以我们也在对外提供图计算系统的产品和服务。目前，我们也有很多外部客户，包括金融、工业、互联网以及政企领域。\n\n整个图计算系统目前仍处于较早期的阶段，我们认为还有很多工作要做，包括提升应用性、性能和降低成本。所有的系统都会有这些问题。但是，如果希望普及，我们认为最重要的是有健康的生态，来推动图计算系统的发展，需要有更多的用户和更多的场景使用这个系统。\n\n所有的计算机系统都需要去有一个更开放、更大的生态才能促进发展。蚂蚁有一句话叫做“成熟一个、开放一个”，一个系统成熟以后，我们就会试着开放出去，让更多的人去用。今年9月，我们已经在GitHub上开源了TuGraph中的单机版图数据库，以及一个离线图分析引擎TuGraph Compute。分布式图数据库和流式图计算现在已经包含在我们的商业化版本中，包括一站式图研发平台。我们计划在未来迭代更多更丰富的系统功能，希望能做得更好。\n\n## TuGraph开源版特色\n\n为什么要去开源单机版而不是分布式版本？主要是考虑到它的部署和使用成本比分布式版本要低得多，同时功能也很完整、独立。我们希望这样可以让许多刚开始使用图数据库或有使用图数据库解决问题的想法的人，可以先尝试用我们的单机版图数据库。因为它的部署非常简单，如果跑起来没有问题，那么再考虑是否需要分布式版本。如果确实需要，我们可以再跟进这个问题。\n\n我们的单机版图数据库已经能够支持TB级别的数据，我们内部也有很多情况使用单机版图数据库。在单台机器上，我们最大的数据量也达到了2TB多，在线上运行，能够处理百亿级别的点边。事实上，大多数用户使用单机版图数据库都是足够的。由于单机版的图数据库很容易优化，我们对它进行了极致的优化，因此单机版图数据库在性能上可以满足绝大多数场景的需求。此外，它的系统特性也很全面，包括高可用性、多图支持、权限管理、日志记录等，它可以被看作是一个成熟、易用的图数据库，类似于MySQL。\n\n图中所列出的开源版TuGraph几个特性包括：\n\n单机版图数据库能够处理数据量几个TB的数据，前提是磁盘足够大。\n\n成本很低，因为是单机版，部署和运维都很容易。"
            },
            {
                "content": "## TuGraph开源版特色\n\n为什么要去开源单机版而不是分布式版本？主要是考虑到它的部署和使用成本比分布式版本要低得多，同时功能也很完整、独立。我们希望这样可以让许多刚开始使用图数据库或有使用图数据库解决问题的想法的人，可以先尝试用我们的单机版图数据库。因为它的部署非常简单，如果跑起来没有问题，那么再考虑是否需要分布式版本。如果确实需要，我们可以再跟进这个问题。\n\n我们的单机版图数据库已经能够支持TB级别的数据，我们内部也有很多情况使用单机版图数据库。在单台机器上，我们最大的数据量也达到了2TB多，在线上运行，能够处理百亿级别的点边。事实上，大多数用户使用单机版图数据库都是足够的。由于单机版的图数据库很容易优化，我们对它进行了极致的优化，因此单机版图数据库在性能上可以满足绝大多数场景的需求。此外，它的系统特性也很全面，包括高可用性、多图支持、权限管理、日志记录等，它可以被看作是一个成熟、易用的图数据库，类似于MySQL。\n\n图中所列出的开源版TuGraph几个特性包括：\n\n单机版图数据库能够处理数据量几个TB的数据，前提是磁盘足够大。\n\n成本很低，因为是单机版，部署和运维都很容易。\n\n性能很好，我们对其进行了大量优化。TuGraph的LDBC-SNB测试目前是世界第一，大家可以在GitHub上获取测试SNB的条款并进行测试。\n\n单机版图数据库是一个非常易用的完整系统，我们提供了导入导出工具和查询语言。此外，还提供了底层API，用户可以使用它来编写复杂的程序。\n\n我们的开源版本的目标主要有三点：\n\n首先，我们希望提供一个免费的图数据库产品，能够让更多的人使用图数据库，尝试用它来解决问题。\n\n其次，我们希望促进图数据库标准的成形。目前图数据库的差异太大，每个数据库都有所不同，我们希望通过提供一个参考答案来帮助大家达成趋同。这样大家就可以根据我们提供的设计来判断哪些特征合理，如果觉得合理就可以遵循这个设计，慢慢地大家就会逐渐靠近。假如所有产品在主要特征上保持一致，这样所有人的学习成本就会降低。\n\n最后，基础研究性问题可以不断优化发展，包括存储方面的问题，例如哈希可能是理论上最优的，但是是否还有其他需要调整的东西？目前没有一个很好的研究性平台让大家去进行这些尝试和研究，我们希望提供的开源TuGraph-DB能成为这些研究人员的对比基线，促进研究的发展。\n\n## TuGraph企业版特色"
            },
            {
                "content": "性能很好，我们对其进行了大量优化。TuGraph的LDBC-SNB测试目前是世界第一，大家可以在GitHub上获取测试SNB的条款并进行测试。\n\n单机版图数据库是一个非常易用的完整系统，我们提供了导入导出工具和查询语言。此外，还提供了底层API，用户可以使用它来编写复杂的程序。\n\n我们的开源版本的目标主要有三点：\n\n首先，我们希望提供一个免费的图数据库产品，能够让更多的人使用图数据库，尝试用它来解决问题。\n\n其次，我们希望促进图数据库标准的成形。目前图数据库的差异太大，每个数据库都有所不同，我们希望通过提供一个参考答案来帮助大家达成趋同。这样大家就可以根据我们提供的设计来判断哪些特征合理，如果觉得合理就可以遵循这个设计，慢慢地大家就会逐渐靠近。假如所有产品在主要特征上保持一致，这样所有人的学习成本就会降低。\n\n最后，基础研究性问题可以不断优化发展，包括存储方面的问题，例如哈希可能是理论上最优的，但是是否还有其他需要调整的东西？目前没有一个很好的研究性平台让大家去进行这些尝试和研究，我们希望提供的开源TuGraph-DB能成为这些研究人员的对比基线，促进研究的发展。\n\n## TuGraph企业版特色\n\n除了开源版本，我们也继续提供商业版本。这个版本包含一个分布式图数据库，以及离线计算引擎和流式图计算功能。此外，我们还提供了TuGraph Platform一站式图平台，包括运维、可视化等功能。在这个平台上，用户可以在图数据库中执行流式计算，并在线写回数据库。这种方式通常用于实时查询结果，因为流式计算的时间可能比较长，但用户可以立即查询到较早的结果。这对于在线业务来说非常重要。\n\n商业化产品还提供私有化部署，也可以通过一体机的方式部署硬件，并将很快推出云上部署方案，这样大家就可以在云上体验我们的产品。\n\n## 总结\n\n蚂蚁在图计算方面投入了大量资源，并在众多业务场景中磨练出了一整套在线查询、流式计算、离线分析以及图学习的体系。目前，我们已经在GitHub上开源了单机版（https://github.com/TuGraph-db），同时也提供企业版来满足不同用户需求。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E8%AE%A4%E8%AF%86%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%92%8C%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93.md",
        "chunks": [
            {
                "content": "# 认识图计算和图数据库\n\n## 什么是图\n\n图（Graph）是一种非常直观表达事物及其关联关系的数据结构，基本元素是“点”和“边”。点表示一个事物，边表示它们之间具有一定关系。\n\n比如下面这张图，它的点有公司、员工、项目，边即他们之间的关系——公司和员工之间是雇佣关系、员工和员工之间可以有好友关系、项目和员工之间也可以有参与关系。也就是说我们可以用图的方式来把事物和它们的关系抽象出来。\n\n这是一张结构比较简单的图。随着点和边不断增加，图数据越来越多越来越复杂，逐渐形成更丰富的网状结构。比如一些金融交易图，它的规模可能会非常大，超过 10 亿个点，有千亿甚至万亿边。可以想象，要真正处理这些图还是很有挑战的。\n\n## 为什么需要图计算\n\n把计算机想象成大脑，我们要解决两个关键问题：数据的存储和分析。\n\n传统的数据存储采用关系型数据库，其结构是“表结构”（想象一下 Excel 表格）。比如一家银行的客户转账信息可能包含交易人员、交易金额、交易时间，记录在一张表格里。假如交易人 A 和 B 之间有直接转账关系，这种直接关系用关系型数据库是不难发现的。但对于非直接关系，关系型数据库就较难“穿透”多个点来发现了，即便可以处理，查询速度也可能非常慢。我们用信用卡套现来举例。\n\n首先是简单的直接套现模式。如左侧图显示，一个人办了一张信用卡，他其实不是真的想去还款，他找了一个商店，这个商店提供一个非法的服务就是信用卡套现。那么他通过信用卡付款，把 2020 元钱转到这个商店。这个商店直接就把其中的 2000 元钱返回给付款人，就完成了一次套现。这样的一种套现是非常简单的，我们通过对这个个体、这个商店的收款记录和付款记录做分析，就可以识别出套现行为。\n\n但右边这张图就复杂了很多。我们可以看到，右上角的这个人，他还是通过信用卡付款，付了 2020 元钱给了商店。这个时候，商店没有直接把钱退给付款的人，而是由一个个人付了 2000 元钱给到一个第三人。这个个人和商店之间，我们可以通过一些分析发现，他实际上拥有这个商店，所以我们把这种关系叫做同人关系。就是店和人虽然看起来是不同的实体，但其实他们之间有一个非常强的关联。那么他付款给的第三人也不是最开始刷卡的人，而是刷卡人的一个亲友，店主付款到了刷卡人亲友的银行卡上。那这样的一个套现模式就比左边的复杂很多了。我们把这种模式叫做多跳闭环模式。"
            },
            {
                "content": "首先是简单的直接套现模式。如左侧图显示，一个人办了一张信用卡，他其实不是真的想去还款，他找了一个商店，这个商店提供一个非法的服务就是信用卡套现。那么他通过信用卡付款，把 2020 元钱转到这个商店。这个商店直接就把其中的 2000 元钱返回给付款人，就完成了一次套现。这样的一种套现是非常简单的，我们通过对这个个体、这个商店的收款记录和付款记录做分析，就可以识别出套现行为。\n\n但右边这张图就复杂了很多。我们可以看到，右上角的这个人，他还是通过信用卡付款，付了 2020 元钱给了商店。这个时候，商店没有直接把钱退给付款的人，而是由一个个人付了 2000 元钱给到一个第三人。这个个人和商店之间，我们可以通过一些分析发现，他实际上拥有这个商店，所以我们把这种关系叫做同人关系。就是店和人虽然看起来是不同的实体，但其实他们之间有一个非常强的关联。那么他付款给的第三人也不是最开始刷卡的人，而是刷卡人的一个亲友，店主付款到了刷卡人亲友的银行卡上。那这样的一个套现模式就比左边的复杂很多了。我们把这种模式叫做多跳闭环模式。\n\n要分析这种多跳闭环模式，就需要找出复杂的关联关系，而不能只对这个个体进行分析。但是大家可能会说，你画的这张图很简单呀，我一眼就能看出来，这是一个闭环，这个坏人我很快就能抓住。  \n但实际生活中情况可能会更加复杂，有更多其它交易和关系，就没那么容易看出来了。如下图所示，右边这张图可能会有千亿条甚至万亿条边，怎么很快地在这个图上把环找出来，这就对整个分析技术——复杂的关联分析技术提出了非常高的要求，性能成为了关键。\n\n## 什么时候要用图计算\n\n随着数据量和深度的增加，如果我们用传统的关系数据库的方法去分析，那就可能非常非常慢，难以在有效的时间内计算出结果。而图计算技术直接将事物与其关系像制作地图一样定位存储下来，直接支撑对事物和关系的各种查询和计算——这与我们大脑对信息的处理模式很像，大脑本身也可以建模成一个图。由于提供了对关联数据最直接的表达，以及图模型对异构数据天然的包容力，可以很好地解决目前遇到的关联数据分析问题。\n\n由此可见，关系型数据库的设计擅长回答“已知”的问题，而图数据库可以回答超出设想的“未知”问题。相较于关系型数据库，图数据库是真正注重“关系”的数据库。"
            },
            {
                "content": "要分析这种多跳闭环模式，就需要找出复杂的关联关系，而不能只对这个个体进行分析。但是大家可能会说，你画的这张图很简单呀，我一眼就能看出来，这是一个闭环，这个坏人我很快就能抓住。  \n但实际生活中情况可能会更加复杂，有更多其它交易和关系，就没那么容易看出来了。如下图所示，右边这张图可能会有千亿条甚至万亿条边，怎么很快地在这个图上把环找出来，这就对整个分析技术——复杂的关联分析技术提出了非常高的要求，性能成为了关键。\n\n## 什么时候要用图计算\n\n随着数据量和深度的增加，如果我们用传统的关系数据库的方法去分析，那就可能非常非常慢，难以在有效的时间内计算出结果。而图计算技术直接将事物与其关系像制作地图一样定位存储下来，直接支撑对事物和关系的各种查询和计算——这与我们大脑对信息的处理模式很像，大脑本身也可以建模成一个图。由于提供了对关联数据最直接的表达，以及图模型对异构数据天然的包容力，可以很好地解决目前遇到的关联数据分析问题。\n\n由此可见，关系型数据库的设计擅长回答“已知”的问题，而图数据库可以回答超出设想的“未知”问题。相较于关系型数据库，图数据库是真正注重“关系”的数据库。\n\n我们刚才举的是金融方面的例子，但图计算的用途远远不限于金融行业。在互联网、工业领域、医药、公共卫生、公共安全等领域都有很多应用。如绘制用户社交关系图谱进行社交影响力排名、好友推荐；构建设备关系网络图谱实现物联网建模分析、供电网络建模分析等。\n\n随着互联网和 5G 时代数据指数级增长，数据之间的关系越来越复杂，企业管理和分析数据面临更高难度。越来越多的企业管理者们开始关注以图为代表的技术来更智能地使用数据，Google、Facebook 等科技巨头也早就在通过图数据库的力量来支撑主要业务应用。\n\n国际知名咨询公司 Gartner 每年都会发布各种技术趋势的报告。在 2021 年的《十大数据分析技术趋势》报告中，Gartner 提到了“Graph relates everything”。这是一个非常有趣的双关，即图连接万物，一方面表示了图的本质，就是把各种事物连起来，另一方面也表达了图会在数据分析的各个领域得到广泛应用。Gartner 预测到 2025 年，图技术在数据和分析创新中的占比将从 2021 年的 10%上升到 80%。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E9%87%8D%E7%A3%85%E5%8F%91%E5%B8%83%EF%BC%81TuGraph%E5%BC%80%E6%BA%90%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E7%94%9F%E5%9B%BE%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FCStore.md",
        "chunks": [
            {
                "content": "# 重磅发布！TuGraph开源高性能原生图存储系统CStore\n\nCStore已在蚂蚁集团内部具备多年大规模生产化经验。目前，CStore系统已全部开源到TuGraph Analytics仓库（geaflow-cstore模块），未来我们将不断迭代升级，提升系统性能。也非常欢迎图计算和图存储的开发者一起参与进来，共同推进CStore的开源和演进。\n\nCStore是一款专门为图分析场景而设计的原生图存储引擎，它采用了Rust语言编写，使用基于图的存储结构，针对图分析场景进行特定优化。CStore可以存储包含千亿级点和万亿级边的图数据，在蚂蚁集团内部的多场景使用中，已经积累了多年的经验，存储容量达到了PB级别。\n\n## 图存储系统\n\n在设计数据存储引擎时，需要考虑众多因素。例如，所应用的具体场景，是联机分析处理(OLAP)还是联机事务处理(OLTP)；再如，数据存储方式的选择，内存、本地硬盘或分布式存储；还有就是存储数据的格式，像是文档、JSON，宽表，对象，键值对等。图存储引擎是诸多数据存储引擎中的一种，它专门用于图数据的存储。从DB-Engines网站的统计来看，Graph DBMS的热度从2014后一直领先其他类型数据库。\n\n根据图数据存储方式的不同，现有的图存储引擎主要分为下面几大类：\n\n1. 基于链表，例如Neo4j。\n2. 基于Hash+链表，例如ArangoDB。\n3. 基于Key-Value键值，例如Titan/JanusGraph/HugeGraph。\n4. 基于传统关系型数据库，例如AgensGraph。\n\nCStore基于Array+链表的方式存储数据，支持实时读写能力。为了提供更好的图分析能力，CStore把图元数据和属性分离存储，单独对元数据构建多级索引。CStore在存储方式和索引设计上都充分考虑到图语义，有效地结合图数据访问的特点，充分利用计算机硬件的优势，在蚂蚁内部多个场景中得到验证，取得很好的业务效果。接下来从建模、存储、索引三个方面来介绍CStore作为原生图存储引擎的特点。\n\n## 原生图建模"
            },
            {
                "content": "根据图数据存储方式的不同，现有的图存储引擎主要分为下面几大类：\n\n1. 基于链表，例如Neo4j。\n2. 基于Hash+链表，例如ArangoDB。\n3. 基于Key-Value键值，例如Titan/JanusGraph/HugeGraph。\n4. 基于传统关系型数据库，例如AgensGraph。\n\nCStore基于Array+链表的方式存储数据，支持实时读写能力。为了提供更好的图分析能力，CStore把图元数据和属性分离存储，单独对元数据构建多级索引。CStore在存储方式和索引设计上都充分考虑到图语义，有效地结合图数据访问的特点，充分利用计算机硬件的优势，在蚂蚁内部多个场景中得到验证，取得很好的业务效果。接下来从建模、存储、索引三个方面来介绍CStore作为原生图存储引擎的特点。\n\n## 原生图建模\n\n图形数据非常适用于描述复杂的网络关系。与其他存储格式相比较，图形数据具有自身的独特之处。举例来说，在 NoSQL 数据库中，Key-Value 数据库只包含 Key 和 Value 这两种元素，用户更容易理解和操作，并且存储引擎的设计也可以遵循一定的规则。另外，对于 DBMS（数据库管理系统）来说，实体关系模型必须按照一定的规范来进行设计，通常情况下，要求业务表的设计至少要符合第三范式，以此来消除数据冗余现象。CStore基于属性图来建模，属性图是由点，边，以及点和边上的属性组成的图，点数据中记录了起始点ID和图元数据（标签，时间戳），边数据记录了起始点ID和图元数据（终点ID，方向，标签，时间戳），每个起始点ID唯一确定一组点边数据。\n\n点边数据进入到CStore之后，把点边起始点ID转化为从0开始的ID，这个过程称之为ID化。由于用户定义的起始点ID格式不固定，蚂蚁内部使用的起始点通常大于20bytes，转化为4个bytes ID后，可以极大减少索引内存消耗；另外规范化ID之后，CStore使用array来做主键索引，array的index为ID，查询效率为O(1)。\n\n## ID字典\n\nID化之后，点边数据被序列化为PrimaryKey和GraphData，GraphData由SecondKey和Property组成。PrimaryKey记录点边ID，SecondKey记录图元数据，Property记录点边属性数据。"
            },
            {
                "content": "点边数据进入到CStore之后，把点边起始点ID转化为从0开始的ID，这个过程称之为ID化。由于用户定义的起始点ID格式不固定，蚂蚁内部使用的起始点通常大于20bytes，转化为4个bytes ID后，可以极大减少索引内存消耗；另外规范化ID之后，CStore使用array来做主键索引，array的index为ID，查询效率为O(1)。\n\n## ID字典\n\nID化之后，点边数据被序列化为PrimaryKey和GraphData，GraphData由SecondKey和Property组成。PrimaryKey记录点边ID，SecondKey记录图元数据，Property记录点边属性数据。\n\nSecondKey编码格式如下，target id大小不固定，其他部分消耗20 bytes。write ts字段记录数据写入时间，被用于数据淘汰，sequence id记录了数据写入顺序，transaction和compaction都会用到。graph info记录是否是点，是否是入边，是否包含属性，标签，其他meta, 点边时间属性等信息。\n\n## 图数据编码\n\n这样编码有两点好处：\n\n1. 点边数据变成CStore内部具有固定格式的二进制数据，有效减少内存消耗，方便后续数据写入磁盘；\n2. 图元数据被压缩到8字节，这样可以把更多的图信息放到索引侧，能够提前在索引侧过滤掉用户不需要的数据。\n\n许多图形数据库会选择将点边数据编码为键值对的形式存储。相比之下，CStore是一款针对图分析场景而设计的存储引擎，目的是提供更快的分析能力。为了实现这一点，CStore会对经过编码后的图形信息建立多级索引。在下面的内容里，我们将讨论如何存储数据以及构建多级索引。\n\n\n## 友好图存储\n\n蚂蚁内部图数据的访问有以下几个特点。\n\n1. 通常相同起始点ID的点边数据大概率一起被访问；\n2. 相同类型, 时间的数据通常被一起访问；\n3. 用户点边数据的属性非常大，而点边元数据信息为固定结构且数据量不大；\n4. 点数据查询频率大于边数据。"
            },
            {
                "content": "## 图数据编码\n\n这样编码有两点好处：\n\n1. 点边数据变成CStore内部具有固定格式的二进制数据，有效减少内存消耗，方便后续数据写入磁盘；\n2. 图元数据被压缩到8字节，这样可以把更多的图信息放到索引侧，能够提前在索引侧过滤掉用户不需要的数据。\n\n许多图形数据库会选择将点边数据编码为键值对的形式存储。相比之下，CStore是一款针对图分析场景而设计的存储引擎，目的是提供更快的分析能力。为了实现这一点，CStore会对经过编码后的图形信息建立多级索引。在下面的内容里，我们将讨论如何存储数据以及构建多级索引。\n\n\n## 友好图存储\n\n蚂蚁内部图数据的访问有以下几个特点。\n\n1. 通常相同起始点ID的点边数据大概率一起被访问；\n2. 相同类型, 时间的数据通常被一起访问；\n3. 用户点边数据的属性非常大，而点边元数据信息为固定结构且数据量不大；\n4. 点数据查询频率大于边数据。\n\nCStore在设计存储结构的时候，结合上述特点，对特定场景进行优化。针对第一个特点，CStore尽可能的把具有相同的起始点ID的点边数据存储到物理上连续的存储空间。点边数据被序列化之后，数据首先被写入GraphData Segment，它为内存数据结构，使用跳表来组成数据，维护了起始点ID到GraphData List的结构。GraphData Segment主要有两个功能：\n\n1. 数据聚合。把相同的src_id的点边数据聚合到一起存储。\n2. 排序。按照用户指定顺序把相同src_id的点边数据排序，用于构建二级索引。\n\n### GraphData Segment数据结构\n\nGraphData Segment到达阈值之后被刷入到磁盘，数据被刷入到磁盘之前，把具有相同类型，写入时间（通常以天为单位）的数据作为一个分区写入到连续的物理存储空间，每个分区之间数据互相独立。\n\n### GraphData Segment分区\n\n再者根据点边数据属性大而元数据固定的特点，CStore采用了属性分离的架构，把图属性和图元数据分离存储到不同的物理存储空间。一方面对于图元数据单独加索引能够加速图查询性能，另外一方面属性分离也能够减少数据compaction的读写放大开销。"
            },
            {
                "content": "1. 数据聚合。把相同的src_id的点边数据聚合到一起存储。\n2. 排序。按照用户指定顺序把相同src_id的点边数据排序，用于构建二级索引。\n\n### GraphData Segment数据结构\n\nGraphData Segment到达阈值之后被刷入到磁盘，数据被刷入到磁盘之前，把具有相同类型，写入时间（通常以天为单位）的数据作为一个分区写入到连续的物理存储空间，每个分区之间数据互相独立。\n\n### GraphData Segment分区\n\n再者根据点边数据属性大而元数据固定的特点，CStore采用了属性分离的架构，把图属性和图元数据分离存储到不同的物理存储空间。一方面对于图元数据单独加索引能够加速图查询性能，另外一方面属性分离也能够减少数据compaction的读写放大开销。\n\n另外CStore还支持用户配置点边数据存储到不同的存储介质，点边数据在物理上隔离。点边数据的访问频率在不同的场景有所不同，分离存储能够进一步优化数据访问性能，提前过滤掉不需要的数据，减少数据读放大。\n\n## 高效图索引\n\nCStore具有高效的图数据检索能力，支持多维度索引，不仅提供针对图元数据的分区索引，主键索引和二级索引，还支持针对点边属性的全文索引，可以根据指定的条件快速定位和返回数据。\n\n### 图索引架构\n\nGraphData Segment写入到磁盘之前，把相同起始点ID的GraphData根据用户指定的顺序排序，然后把排序好的SecondKey构建索引，把排序好的Property直接写入到属性文件（记为vs文件）。\n\nCStore的分区索引对应到磁盘中某个目录，不同的分区数据落在不同的目录。主键索引是稀疏索引，默认索引间隔为2048，目前仅支持以起始点ID构建主键，主键索引常驻内存。通过主键索引，可以快速定位到属性存储的文件id和offset。\n\n### 主键索引\n\n二级索引包括min max索引，bloom filter索引等，用于快速判断某个稀疏索引块是否包含某个主键。min max索引记录某个索引块的上界和下界，bloom filter记录索引块的主键。"
            },
            {
                "content": "## 高效图索引\n\nCStore具有高效的图数据检索能力，支持多维度索引，不仅提供针对图元数据的分区索引，主键索引和二级索引，还支持针对点边属性的全文索引，可以根据指定的条件快速定位和返回数据。\n\n### 图索引架构\n\nGraphData Segment写入到磁盘之前，把相同起始点ID的GraphData根据用户指定的顺序排序，然后把排序好的SecondKey构建索引，把排序好的Property直接写入到属性文件（记为vs文件）。\n\nCStore的分区索引对应到磁盘中某个目录，不同的分区数据落在不同的目录。主键索引是稀疏索引，默认索引间隔为2048，目前仅支持以起始点ID构建主键，主键索引常驻内存。通过主键索引，可以快速定位到属性存储的文件id和offset。\n\n### 主键索引\n\n二级索引包括min max索引，bloom filter索引等，用于快速判断某个稀疏索引块是否包含某个主键。min max索引记录某个索引块的上界和下界，bloom filter记录索引块的主键。\n\n对于热点数据，二级索引做了特殊支持，比如一个起始点ID对应了10亿条边，如果没有索引，需要把满足min max和bloom filter索引的所有边读到内存过滤一次，返回用户指定的数据。为了加速这种场景，CStore对点边类型，指向，写入时间加了二级索引。比如用户只想要读取label为student，dt为2023-10-1数据，通过二级索引，首先过滤掉所有label非student的数据，然后过滤掉dt非2023-10-1的数据，可以极大减少数据读开销，提升用户查询性能。\n\n## 二级索引\n\n构建完索引，数据写入到索引文件（记为is文件），is文件按照LSM-Tree结构组织，key为主键索引中的index，value为索引block压缩后的数据。is文件内部对于key有序，第0层单个文件内部对于key有序，其他层文件间对于key有序。\n\n## 并发Compaction\n\n为了加快 LSM-Tree compact的性能，CStore 支持单层的多线程compact。在示意图中，每一个单独的compactor都代表一个compact工作线程。不同的compactor线程和compact清理线程（负责清理被compact的文件)将会并行执行。\n\n以下是单个compactor内部运作过程的示意图，其中包括四个关键步骤："
            },
            {
                "content": "## 二级索引\n\n构建完索引，数据写入到索引文件（记为is文件），is文件按照LSM-Tree结构组织，key为主键索引中的index，value为索引block压缩后的数据。is文件内部对于key有序，第0层单个文件内部对于key有序，其他层文件间对于key有序。\n\n## 并发Compaction\n\n为了加快 LSM-Tree compact的性能，CStore 支持单层的多线程compact。在示意图中，每一个单独的compactor都代表一个compact工作线程。不同的compactor线程和compact清理线程（负责清理被compact的文件)将会并行执行。\n\n以下是单个compactor内部运作过程的示意图，其中包括四个关键步骤：\n\n1. 计算各层次得分并选择其中最高的；\n2. 收集需要compact的文件；\n3. 将上述收集到的文件进行compact并生成新的文件；\n4. 最后一步是将新的文件更新至 LSM-Tree及内存索引中。\n\n\n## Compaction管理\n\n### 编译构建\n\n单独编译CStore代码需要提前准备Rust和C++工具链。\n\n#### 安装Rust\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n#### 安装nightly工具链\n\n```bash\nrustup update && rustup toolchain install nightly && rustc --version\n```\n\n#### 安装其他依赖\n\n```bash\nyum install make gcc gcc-c++ protobuf-devel protobuf clang\n```\n\n下载TuGraph Analytics代码后，执行以下命令编译CStore源代码：\n\n```bash\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/geaflow-cstore && make build\n```\n\n执行`make help`可以查看makefile提供的功能，当前版本的功能和对应描述如下：\n\n#### geaflow-cstore 0.1.0"
            },
            {
                "content": "```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n#### 安装nightly工具链\n\n```bash\nrustup update && rustup toolchain install nightly && rustc --version\n```\n\n#### 安装其他依赖\n\n```bash\nyum install make gcc gcc-c++ protobuf-devel protobuf clang\n```\n\n下载TuGraph Analytics代码后，执行以下命令编译CStore源代码：\n\n```bash\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/geaflow-cstore && make build\n```\n\n执行`make help`可以查看makefile提供的功能，当前版本的功能和对应描述如下：\n\n#### geaflow-cstore 0.1.0\n\nUsage: make ``\n\n##### Targets:"
            },
            {
                "content": "- **build-dev**: Build the geaflow-cstore with dev version. Both `` and `` work.\n- **build-release**: Build the geaflow-cstore with release version.\n- **fmt**: Format the code by rustfmt.toml.\n- **clippy**: Check statically code with clippy.\n- **test-all**: Run all integration tests and unit tests, include ignored tests.\n- **test**: Execute all the unit tests.\n- **test-fn**: Use \"make test-fn mod=\" to specify which function of test to run.\n- **test-in**: Use \"make test-in mod=\" to specify which target of integration tests to run.\n- **bench-all**: Run all benches.\n- **bench**: Use \"make bench mod=\" to specify which bench of mod to run.\n- **doc**: Generate the document of geaflow-cstore and open it in html.\n- **all**: Execute code style and static checks, release version compilation and tests in sequence.\n- **update**: Update all the dependences to the newest version, include rust analyzer.\n- **gen**: Generate the code described by proto."
            },
            {
                "content": "- **test-in**: Use \"make test-in mod=\" to specify which target of integration tests to run.\n- **bench-all**: Run all benches.\n- **bench**: Use \"make bench mod=\" to specify which bench of mod to run.\n- **doc**: Generate the document of geaflow-cstore and open it in html.\n- **all**: Execute code style and static checks, release version compilation and tests in sequence.\n- **update**: Update all the dependences to the newest version, include rust analyzer.\n- **gen**: Generate the code described by proto.\n- **features**: Use \"make features mod=\" {0->[default] 1->[hdfs]} to set the env in ~/.cstore_buildrc.\n- **clean**: Clean up the cargo cache.\n- **version**: Show the version of geaflow-cstore.\n- **help**: List optional commands."
            },
            {
                "content": "## 未来规划\n\nCStore已在蚂蚁集团内部具备多年大规模生产化经验，未来我们将不断迭代升级，提升系统性能。然而，在一些特定的情况下，我们认识到CStore还有进步的空间。在未来一至两年内，我们计划更加深入地探索优化图分析场景，支持图数据列式存储，图融合以及物化视图能力。同时，为了提高用户的体验度，我们也将引入remote compactor功能，以解决因compact而导致的资源竞争问题。\n\n目前，CStore系统已全部开源到TuGraph Analytics仓库（geaflow-cstore模块），当前推送的代码涵盖了CStore的核心功能特性，仍有大量的增强功能还在整合中。TuGraph团队将持续投入图存储系统CStore的建设工作，也非常欢迎图计算和图存储的开发者一起参与进来，共同推进CStore的开源和演进。\n\n## 总结\n\n当下TuGraph Analytics项目已经内置了CStore JNI的依赖，你可以在高阶API任务中使用并体验CStore静态图存储系统，CStore动态图能力正在建设中，敬请期待。同时我们也非常欢迎图存储系统/Rust爱好者加入到CStore开源项目的建设中来。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/%E9%99%88%E6%96%87%E5%85%89%EF%BC%9AAI%E6%97%B6%E4%BB%A3%E9%9C%80%E8%A6%81%E6%80%8E%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%EF%BC%9F.md",
        "chunks": [
            {
                "content": "# 陈文光：AI时代需要怎样的数据处理技术？\n\n大家好，我是清华大学/蚂蚁技术研究院陈文光，今天为大家带来《AI 时代的数据处理技术》主题分享。\n\n我们身处一个以信息技术为核心驱动力的大数据时代。从下面这张图，我们可以看出，数据量和数据生成的速度在飞速增长。与此同时，新的产生数据的形式在产生，数据模态也在不断增长，不仅包括自然语言，还有声音、图像、视频等等多种形式。最近非常流行的多模态大模型包括具身智能、触觉等新的数据形态。\n\n丰富的数据形态要求我们要对数据做有效处理。模仿“马斯洛需求层次理论”，数据处理也有一个层次，从最底下的收集数据、存储数据到做一般的数据查询处理，更上面的层次是现在越来越接近于用 AI 方式处理数据，甚至最后还能生成很多内容。\n\n## 1. AI时代数据处理新需求\n\n这样的大模型崛起的时代也引发了对数据处理的新需求。最近，Meta 出了一个新模型 LLaMA-3，效果非常好，它实现了在十几万亿的 Token 上面做的训练，而我们之前很多模型可能只是在 4T 的或者几个 T 的 Token上面做训练。\n\n那么，如何获得增加的这部分 Token？实际上，这需要从很多网上低质量的数据中做大量的数据处理，清洗出来可用的高质量数据，如果想让大模型的能力进一步增长，实际上需要数据处理做很多的工作。\n\n另一方面，大模型直接应用在生产服务场景下，本身还存在很多缺陷，比如幻觉问题、上下文长度的问题。目前的多数超长上下文大模型并不能完整记录真正领域的知识。为了满足需求，向量数据库和大语言模型结合起来，提供高质量的服务。  \n从数据服务的角度来讲，向量数据库是一种使用嵌入的方式表达知识，再用另外索引的方式快速找到相应知识的方式，它和大模型配合才能获得很好的效果。所以大模型的发展和崛起，对数据库领域也提出了很多新需求。\n\n## 2. AI时代数据库发展趋势\n\n在这样的趋势下，我今天想分享三个观点，也是未来的数据库面临的三个比较重要的发展趋势：\n\n### （一）在线离线一体化\n\n这张图是企业常见的在线、离线两个链路。\n\n- 上面是在线链路，一个数据请求会先经过预处理，再通过训练好的模型做推理，比如风控、分类等等，再把结果反馈到 KV 里，直接服务用户的请求。\n- 下面是离线链路，收到数据请求后，我们要想办法处理，去更新模型。经过一段时间后再把模型更新到在线链路上。"
            },
            {
                "content": "另一方面，大模型直接应用在生产服务场景下，本身还存在很多缺陷，比如幻觉问题、上下文长度的问题。目前的多数超长上下文大模型并不能完整记录真正领域的知识。为了满足需求，向量数据库和大语言模型结合起来，提供高质量的服务。  \n从数据服务的角度来讲，向量数据库是一种使用嵌入的方式表达知识，再用另外索引的方式快速找到相应知识的方式，它和大模型配合才能获得很好的效果。所以大模型的发展和崛起，对数据库领域也提出了很多新需求。\n\n## 2. AI时代数据库发展趋势\n\n在这样的趋势下，我今天想分享三个观点，也是未来的数据库面临的三个比较重要的发展趋势：\n\n### （一）在线离线一体化\n\n这张图是企业常见的在线、离线两个链路。\n\n- 上面是在线链路，一个数据请求会先经过预处理，再通过训练好的模型做推理，比如风控、分类等等，再把结果反馈到 KV 里，直接服务用户的请求。\n- 下面是离线链路，收到数据请求后，我们要想办法处理，去更新模型。经过一段时间后再把模型更新到在线链路上。\n\n在线、离线两个链路分开，在生产中会遇到一些比较严重的问题，主要就是在线、离线不一致。\n\n比如在离线链路上做了各种仿真模拟，但是当把策略、模型上传到在线链路时，会出现与离线链路仿真效果不一样的情况。造成这种现象的根本原因，就是我们通过不同的数据链路把新数据接入进来，离线链路处理的数据与在线链路不一致。\n\n怎么解决这个问题？最好的解决方案，就是只有一套数据。如果能够做到一个系统既能够做事务处理，可以支持事务在数据上面原子化地做更新，同时还可以在这一批数据上做后续分析型的业务。也就是说用一份数据给在线离线链路的一致性打下基础。  \n这里面也有非常多的技术问题。一般来说，事务处理行存会比较好，分析一般是列存比较好，当一套系统需要同时支持行存和列存的时候，需要什么样的存储结构？另外，事务处理对于优先级、延迟/尾延迟、吞吐率要求比较高。那么在系统里如何调度不同优先级的请求，这里涉及到很多相关技术。"
            },
            {
                "content": "在线、离线两个链路分开，在生产中会遇到一些比较严重的问题，主要就是在线、离线不一致。\n\n比如在离线链路上做了各种仿真模拟，但是当把策略、模型上传到在线链路时，会出现与离线链路仿真效果不一样的情况。造成这种现象的根本原因，就是我们通过不同的数据链路把新数据接入进来，离线链路处理的数据与在线链路不一致。\n\n怎么解决这个问题？最好的解决方案，就是只有一套数据。如果能够做到一个系统既能够做事务处理，可以支持事务在数据上面原子化地做更新，同时还可以在这一批数据上做后续分析型的业务。也就是说用一份数据给在线离线链路的一致性打下基础。  \n这里面也有非常多的技术问题。一般来说，事务处理行存会比较好，分析一般是列存比较好，当一套系统需要同时支持行存和列存的时候，需要什么样的存储结构？另外，事务处理对于优先级、延迟/尾延迟、吞吐率要求比较高。那么在系统里如何调度不同优先级的请求，这里涉及到很多相关技术。\n\n在蚂蚁的图风控中，也有另外一个场景。刚才我们讲到，可以通过数据库本身的 HTAP 引擎解决在线/离线一致性的问题，如果没有这样的混合系统，应该如何实现两份数据达到在线离线一致性？下面以图风控方案中的在线离线一体化为例，给大家介绍。  \nTuGraph DB（分布式图数据库），是一个支持事务处理的图数据库。TuGraph Dataflow（流图计算系统），可以看作是一个支持图语义的 Flink。\n\n在我们原来的方案中，这两个系统采用不同的查询语言，一个是我们自定义的 GQuery 语言，另外一个是基于 Java 的支持 Gremlin 语言。这两个系统的数据通过 TuGraph Dataflow 处理完成后，一条线通过 TuGraph DB 去做在线链路，另外一个经过存储去完成后续的离线分析，这时就会出现数据不一致的情况。"
            },
            {
                "content": "在蚂蚁的图风控中，也有另外一个场景。刚才我们讲到，可以通过数据库本身的 HTAP 引擎解决在线/离线一致性的问题，如果没有这样的混合系统，应该如何实现两份数据达到在线离线一致性？下面以图风控方案中的在线离线一体化为例，给大家介绍。  \nTuGraph DB（分布式图数据库），是一个支持事务处理的图数据库。TuGraph Dataflow（流图计算系统），可以看作是一个支持图语义的 Flink。\n\n在我们原来的方案中，这两个系统采用不同的查询语言，一个是我们自定义的 GQuery 语言，另外一个是基于 Java 的支持 Gremlin 语言。这两个系统的数据通过 TuGraph Dataflow 处理完成后，一条线通过 TuGraph DB 去做在线链路，另外一个经过存储去完成后续的离线分析，这时就会出现数据不一致的情况。\n\n这个问题如何解决呢？首先需要让数据保持一致性。数据虽然是两份，但是在TuGraph DB 和存储之间新增了一条数据同步链路，就是通过从 Binlog 中读取数据，保证两份数据的一致性，防止出现两边写，一边写成功、一边写失败，而导致的数据不一致。当把在线数据里已经处理完成的数据同步至离线数据，这时数据的一致性是有保证的。  \n另外，我们把这两个系统的查询语言和语义都统一起来，都使用国际标准图查询语言 ISO-GQL，同样一套查询语言在两个系统上用同一个语义支持，在进行后续的策略分析时，数据和查询语言的语义是一致的，可以达到更好的一致性。\n\n这里也存在非常复杂的情况。图数据库的基本功能是从一个点扩出去很多点，但是有些点的邻居非常多，可能有几十万、上百万个，所以我们会限制每个点扩展的点数，比如只扩两百个。但同时还需要在两个系统中保证不仅只扩两百个点，这两百个点都是一样的，才能保证数据一致性。所以想要在两个系统中要保证数据一致性，需要花费相当大的精力。\n\n### （二）向量数据库和关系型数据库一体化\n\n向量数据库和大语言模型的结合有非常重要的作用，如果一个企业要用大语言模型做服务，既要部署语言模型又要部署向量数据库，同时企业的很多数据又保存在关系型数据库中。"
            },
            {
                "content": "这里也存在非常复杂的情况。图数据库的基本功能是从一个点扩出去很多点，但是有些点的邻居非常多，可能有几十万、上百万个，所以我们会限制每个点扩展的点数，比如只扩两百个。但同时还需要在两个系统中保证不仅只扩两百个点，这两百个点都是一样的，才能保证数据一致性。所以想要在两个系统中要保证数据一致性，需要花费相当大的精力。\n\n### （二）向量数据库和关系型数据库一体化\n\n向量数据库和大语言模型的结合有非常重要的作用，如果一个企业要用大语言模型做服务，既要部署语言模型又要部署向量数据库，同时企业的很多数据又保存在关系型数据库中。\n\n这样一个多系统复杂混合的部署，开发、部署、维护非常困难。因为涉及到多个系统之间的依赖性，软件版本、系统之间的交互也会存在很多的问题。如果能够把这些功能做到一起，就能够实现一致性的管理。  \n在关系型数据库中，可以通过一些插件支持向量数据库的语义，同时在调用查询引擎的时候，将数据分到不同的链路上执行，从用户的角度就可以实现只部署一个系统，使用一套语言，完成相关工作。\n\n蚂蚁集团有一套内部的 VSAG 的向量库，实现了主流向量数据库的相关功能，而且在实际生产中已经得到应用。向量数据库最有名的是 FaceBook 开源的 FAISS 系统。\n\nVSAG 和 FAISS 之间有什么区别？FAISS 功能非常强大、性能非常好，对 GPU 也做了很多优化，但是相对来说提供了很多底层功能，这就需要通过调整各种参数、配置，从中得到一个对应用比较合适的配置。\n\n而蚂蚁集团的 VSAG 库更多从开发者和产品应用性的角度出发，默认把很多基础配置的事情都做好了，而且在 CPU 上也实现了很多优化，提供了近似于开箱即用的功能。  \n在 OceanBase 里，以插件的方式集成了 VSAG 功能，可以在 OceanBase 里使用 VSAG 向量化的功能，用一套系统达到这样的效果。\n\n### （三）数据处理与 AI 计算一体化"
            },
            {
                "content": "蚂蚁集团有一套内部的 VSAG 的向量库，实现了主流向量数据库的相关功能，而且在实际生产中已经得到应用。向量数据库最有名的是 FaceBook 开源的 FAISS 系统。\n\nVSAG 和 FAISS 之间有什么区别？FAISS 功能非常强大、性能非常好，对 GPU 也做了很多优化，但是相对来说提供了很多底层功能，这就需要通过调整各种参数、配置，从中得到一个对应用比较合适的配置。\n\n而蚂蚁集团的 VSAG 库更多从开发者和产品应用性的角度出发，默认把很多基础配置的事情都做好了，而且在 CPU 上也实现了很多优化，提供了近似于开箱即用的功能。  \n在 OceanBase 里，以插件的方式集成了 VSAG 功能，可以在 OceanBase 里使用 VSAG 向量化的功能，用一套系统达到这样的效果。\n\n### （三）数据处理与 AI 计算一体化\n\n有人可能会问，数据处理不就是 SQL 吗？AI 是神经网络层面的东西，AI 与 SQL 为什么会结合到一起？我举一个例子。大家知道世界上有很多的网页，网页上面有很多内容，内容量非常大，远超几十 T、几百 T。但是在这些海量内容中，很多内容质量很低，如何从中提取出高质量的内容？FaceBook 提出了一套 CCNet 的流程，下图的 CCNet 流程展示了数据处理和 AI 的模型在这一过程中的融合试用。\n\n第一步，CCNet 对网页的原始数据进行解析，在 HTML 的网页中抓取内容，这里涉及到解析等工作。\n\n第二步是删冗，删冗也可以被认为是一个 JOIN，因为抓取网页内容中可能用到了别的网页内容，语料里面有冗余不利于最后的训练，即对每段话都做一个哈希，和过去已有的内容对比，是相同还是不相同。解析与删冗是非常典型的数据处理过程。\n\n第三步，做语言分类，需要经过神经网络模型判断网页的语言。\n\n接下来，通过一些 AI 模型对数据做分词、质量评估，后面的过滤、分桶工作，又回到数据处理。\n\n在这个应用里，数据处理和 AI 计算处于交叠的状态，不是一次数据处理之后都交给AI完成后续的处理，这是一个复杂的来回交互的链路。\n\n那这种情况下，什么样的系统可以支撑这样复杂交互的服务？现在的 AI 和大数据生态基本是割裂的生态：\n\n- AI 用 Python，主要用 GPU；\n- 大数据基本上是用 CPU，用基于 Java 的 Spark 实现。"
            },
            {
                "content": "第一步，CCNet 对网页的原始数据进行解析，在 HTML 的网页中抓取内容，这里涉及到解析等工作。\n\n第二步是删冗，删冗也可以被认为是一个 JOIN，因为抓取网页内容中可能用到了别的网页内容，语料里面有冗余不利于最后的训练，即对每段话都做一个哈希，和过去已有的内容对比，是相同还是不相同。解析与删冗是非常典型的数据处理过程。\n\n第三步，做语言分类，需要经过神经网络模型判断网页的语言。\n\n接下来，通过一些 AI 模型对数据做分词、质量评估，后面的过滤、分桶工作，又回到数据处理。\n\n在这个应用里，数据处理和 AI 计算处于交叠的状态，不是一次数据处理之后都交给AI完成后续的处理，这是一个复杂的来回交互的链路。\n\n那这种情况下，什么样的系统可以支撑这样复杂交互的服务？现在的 AI 和大数据生态基本是割裂的生态：\n\n- AI 用 Python，主要用 GPU；\n- 大数据基本上是用 CPU，用基于 Java 的 Spark 实现。\n\n另一方面，在很多小数据的处理上，Python 已经展现出非常强大的性能，像 Pandas 这样的系统，在单机数据的处理上提供了非常方便的接口。\n\n当 AI 逐渐成为主流计算形态的时候，数据应该如何与 AI 融合？\n\n由于 Spark 是基于 Java 的生态，当我们如果把大模型处理交给 Spark 去做，它产出的结果要通过文件系统、或者其他传输方式交给 AI 的 Python 程序，Python 处理完之后可能还有一些后续处理。在刚才的例子里面，数据处理和 AI 计算之间会有多次的交互，对整个系统的开发、调试、部署、维护带来非常大的问题。\n\n有人尝试把数据处理和 AI 结合起来。2019 年，英特尔出了一个系统“BigDL”，在 Spark 里面把神经网络的描述、优化器、训练方式把这些东西加进去。当时只支持了 CPU，而且是基于 Java 的。我们可以认为，这种方式是试图把 AI 融入到大数据的生态里面。\n\n我们反过来看，如何把大数据的生态往 AI 的方向牵引？这其实是 Spark 的 Python 化。"
            },
            {
                "content": "另一方面，在很多小数据的处理上，Python 已经展现出非常强大的性能，像 Pandas 这样的系统，在单机数据的处理上提供了非常方便的接口。\n\n当 AI 逐渐成为主流计算形态的时候，数据应该如何与 AI 融合？\n\n由于 Spark 是基于 Java 的生态，当我们如果把大模型处理交给 Spark 去做，它产出的结果要通过文件系统、或者其他传输方式交给 AI 的 Python 程序，Python 处理完之后可能还有一些后续处理。在刚才的例子里面，数据处理和 AI 计算之间会有多次的交互，对整个系统的开发、调试、部署、维护带来非常大的问题。\n\n有人尝试把数据处理和 AI 结合起来。2019 年，英特尔出了一个系统“BigDL”，在 Spark 里面把神经网络的描述、优化器、训练方式把这些东西加进去。当时只支持了 CPU，而且是基于 Java 的。我们可以认为，这种方式是试图把 AI 融入到大数据的生态里面。\n\n我们反过来看，如何把大数据的生态往 AI 的方向牵引？这其实是 Spark 的 Python 化。\n\n上图是 2022 年在 DataBricks Summit上讲的。这是一个分布式的 PySpark，就是 Python 接口的 Spark系统。当时 PySpark 的使用率已经达到了整个 Spark 使用率的近 50%，很多人已经愿意用 PySpark 了。但是 PySpark 还存在一个问题：它的性能很差。\n\nPython 是一个动态语言，在编译时不知道它的类型，动态时才知道，所以它的性能很差，比 Java 的 Spark 还要慢一半。所以虽然 PySpark 对编程非常友好，很多人也习惯用，但是性能不太好。因此我们在处理大量数据的时候，希望能够避免这一问题。\n\n所以，我们提出一个愿景，融合数据处理和 AI 生态。\n\n我认为还是要基于 Python，因为 AI 是主要的计算形式，所以整个数据处理应该围绕 AI 建设。从编译优化的角度来讲，我们希望把 PySpark 做很多的优化。这件事是可以做的，我们最近也有了一些成果。在删冗部分，通过把 PySpark 做相关优化，基本上性能可以提升一倍多，可以达到我们的性能预期。\n\n未来，这个生态不只是编程要融合，底层的硬件也要融合，数据和 AI 结合以后，底层的硬件生态也要支持 GPU、弹性任务调度，最后可以达到“一次编写到处执行”的效果。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/c_api.md",
        "chunks": [
            {
                "content": "# C++存储过程接口\r\n\r\n## base64_encode\r\nBase64编码和解码。简单实现，用于BLOB字段。如果性能很重要，请寻找优化后的实现。\r\n\r\n### namespace lgraph_api\r\n### namespace base64\r\n\r\n#### Functions\r\n\r\n```cpp\r\ninline std::string Encode(const char *p, size_t s)\r\n```\r\nEncodes a string to Base64.  \r\n将字符串编码为Base64。\r\n\r\n**参数**  \r\np – 要编码的字符串。  \r\ns – 字符串的大小。  \r\n\r\n**返回**  \r\nThe encoded string.  \r\n编码后的字符串。\r\n\r\n```cpp\r\ninline std::string Encode(const std::string &str)\r\n```\r\nEncodes a string to Base64.  \r\n将字符串编码为Base64。\r\n\r\n**参数**  \r\nstr – 要编码的字符串。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n编码后的字符串。\r\n\r\n```cpp\r\ninline bool TryDecode(const char *p, size_t s, std::string &ret)\r\n```\r\nTries to decode a Base64 string.  \r\n尝试解码Base64字符串。\r\n\r\n**参数**  \r\np – 要解码的字符串。  \r\ns – 字符串的大小。  \r\nret – [out] 解码后的字符串。  \r\n\r\n**返回**  \r\nTrue if the string was decoded successfully, false otherwise.  \r\n如果字符串成功解码则返回true，否则返回false。\r\n\r\n```cpp\r\ninline bool TryDecode(const std::string &str, std::string &out)\r\n```\r\nTries to decode a Base64 string.  \r\n尝试解码Base64字符串。\r\n\r\n**参数**  \r\nstr – 要解码的字符串。"
            },
            {
                "content": "**返回**  \r\nThe decoded string.  \r\n编码后的字符串。\r\n\r\n```cpp\r\ninline bool TryDecode(const char *p, size_t s, std::string &ret)\r\n```\r\nTries to decode a Base64 string.  \r\n尝试解码Base64字符串。\r\n\r\n**参数**  \r\np – 要解码的字符串。  \r\ns – 字符串的大小。  \r\nret – [out] 解码后的字符串。  \r\n\r\n**返回**  \r\nTrue if the string was decoded successfully, false otherwise.  \r\n如果字符串成功解码则返回true，否则返回false。\r\n\r\n```cpp\r\ninline bool TryDecode(const std::string &str, std::string &out)\r\n```\r\nTries to decode a Base64 string.  \r\n尝试解码Base64字符串。\r\n\r\n**参数**  \r\nstr – 要解码的字符串。  \r\nout – [out] 解码后的字符串。  \r\n\r\n**返回**  \r\nTrue if the string was decoded successfully, false otherwise.  \r\n如果字符串成功解码则返回true，否则返回false。\r\n\r\n```cpp\r\ninline std::string Decode(const char *p, size_t s)\r\n```\r\nDecode a Base64 string and throw exception if fails.  \r\n解码Base64字符串，如果失败则抛出异常。\r\n\r\n**抛出**  \r\nInputError – 如果字符串不是有效的Base64字符串，则抛出。\r\n\r\n**参数**  \r\np – 要解码的字符串。  \r\ns – 字符串的大小。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n解码后的字符串。\r\n\r\n```cpp\r\ninline std::string Decode(const std::string &str)\r\n```"
            },
            {
                "content": "**参数**  \r\nstr – 要解码的字符串。  \r\nout – [out] 解码后的字符串。  \r\n\r\n**返回**  \r\nTrue if the string was decoded successfully, false otherwise.  \r\n如果字符串成功解码则返回true，否则返回false。\r\n\r\n```cpp\r\ninline std::string Decode(const char *p, size_t s)\r\n```\r\nDecode a Base64 string and throw exception if fails.  \r\n解码Base64字符串，如果失败则抛出异常。\r\n\r\n**抛出**  \r\nInputError – 如果字符串不是有效的Base64字符串，则抛出。\r\n\r\n**参数**  \r\np – 要解码的字符串。  \r\ns – 字符串的大小。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n解码后的字符串。\r\n\r\n```cpp\r\ninline std::string Decode(const std::string &str)\r\n```\r\nDecode a Base64 string and throw exception if fails.  \r\n解码Base64字符串，如果失败则抛出异常。\r\n\r\n**抛出**  \r\nInputError – 如果字符串不是有效的Base64字符串，则抛出。\r\n\r\n**参数**  \r\nstr – 要解码的字符串。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n解码后的字符串。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph\r\n\r\n### Defines\r\n\r\n#### LGAPI\r\nnamespace lgraph_api\r\n\r\n### Typedefs\r\n\r\n```cpp\r\ntypedef bool GetSignature(SigSpec &sig_spec) \r\n```\r\n这行代码定义了一个函数指针类型 `GetSignature`，它接受一个 `SigSpec` 类型的引用作为参数，并返回一个布尔值。\r\n\r\n```cpp"
            },
            {
                "content": "```cpp\r\ninline std::string Decode(const std::string &str)\r\n```\r\nDecode a Base64 string and throw exception if fails.  \r\n解码Base64字符串，如果失败则抛出异常。\r\n\r\n**抛出**  \r\nInputError – 如果字符串不是有效的Base64字符串，则抛出。\r\n\r\n**参数**  \r\nstr – 要解码的字符串。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n解码后的字符串。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph\r\n\r\n### Defines\r\n\r\n#### LGAPI\r\nnamespace lgraph_api\r\n\r\n### Typedefs\r\n\r\n```cpp\r\ntypedef bool GetSignature(SigSpec &sig_spec) \r\n```\r\n这行代码定义了一个函数指针类型 `GetSignature`，它接受一个 `SigSpec` 类型的引用作为参数，并返回一个布尔值。\r\n\r\n```cpp\r\ntypedef bool Process(lgraph_api::GraphDB &db, const std::string &input, std::string &output) \r\n```\r\n这行代码定义了一个函数指针类型 `Process`，它接受一个 `lgraph_api::GraphDB` 的引用、一个常量字符串和一个字符串的引用作为参数，并返回一个布尔值。\r\n\r\n```cpp\r\ntypedef bool ProcessInTxn(lgraph_api::Transaction &txn, const std::string &input, lgraph_api::Result &output) \r\n```\r\n这行代码定义了一个函数指针类型 `ProcessInTxn`，它接受一个 `lgraph_api::Transaction` 的引用、一个常量字符串和一个 `lgraph_api::Result` 的引用作为参数，并返回一个布尔值。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_atomic"
            },
            {
                "content": "```cpp\r\ntypedef bool Process(lgraph_api::GraphDB &db, const std::string &input, std::string &output) \r\n```\r\n这行代码定义了一个函数指针类型 `Process`，它接受一个 `lgraph_api::GraphDB` 的引用、一个常量字符串和一个字符串的引用作为参数，并返回一个布尔值。\r\n\r\n```cpp\r\ntypedef bool ProcessInTxn(lgraph_api::Transaction &txn, const std::string &input, lgraph_api::Result &output) \r\n```\r\n这行代码定义了一个函数指针类型 `ProcessInTxn`，它接受一个 `lgraph_api::Transaction` 的引用、一个常量字符串和一个 `lgraph_api::Result` 的引用作为参数，并返回一个布尔值。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_atomic\r\nImplementation of atomic operations, used in lgraph_traversal.\r\n实现原子操作，用于 lgraph_traversal。\r\n\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n```cpp\r\ntemplate\r\ninline bool cas(T *ptr, T oldv, T newv) \r\n```\r\n这个模板函数定义了一个原子 Compare-And-Swap 操作，接受指针 `ptr`、旧值 `oldv` 和新值 `newv` 作为参数。\r\n\r\n```cpp\r\ntemplate\r\ninline bool write_min(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子最小写操作，接受指针 `a` 和一个值 `b`，将 `a` 的值更新为 `b` 和 `*a` 中的较小值。\r\n\r\n```cpp\r\ntemplate\r\ninline bool write_max(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子最大写操作，接受指针 `a` 和一个值 `b`，将 `a` 的值更新为 `b` 和 `*a` 中的较大值。"
            },
            {
                "content": "实现原子操作，用于 lgraph_traversal。\r\n\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n```cpp\r\ntemplate\r\ninline bool cas(T *ptr, T oldv, T newv) \r\n```\r\n这个模板函数定义了一个原子 Compare-And-Swap 操作，接受指针 `ptr`、旧值 `oldv` 和新值 `newv` 作为参数。\r\n\r\n```cpp\r\ntemplate\r\ninline bool write_min(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子最小写操作，接受指针 `a` 和一个值 `b`，将 `a` 的值更新为 `b` 和 `*a` 中的较小值。\r\n\r\n```cpp\r\ntemplate\r\ninline bool write_max(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子最大写操作，接受指针 `a` 和一个值 `b`，将 `a` 的值更新为 `b` 和 `*a` 中的较大值。\r\n\r\n```cpp\r\ntemplate\r\ninline void write_add(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(uint64_t *a, uint64_t b) \r\n```\r\n这个函数定义了一个针对 `uint64_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(uint32_t *a, uint32_t b) \r\n```\r\n这个函数定义了一个针对 `uint32_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(int64_t *a, int64_t b) \r\n```\r\n这个函数定义了一个针对 `int64_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(int32_t *a, int32_t b) \r\n```"
            },
            {
                "content": "inline void write_add(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(uint64_t *a, uint64_t b) \r\n```\r\n这个函数定义了一个针对 `uint64_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(uint32_t *a, uint32_t b) \r\n```\r\n这个函数定义了一个针对 `uint32_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(int64_t *a, int64_t b) \r\n```\r\n这个函数定义了一个针对 `int64_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(int32_t *a, int32_t b) \r\n```\r\n这个函数定义了一个针对 `int32_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ntemplate\r\ninline void write_sub(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子减法操作，将值 `b` 从指针 `a` 指向的值中减去。\r\n\r\n```cpp\r\ninline void write_sub(uint64_t *a, uint64_t b) \r\n```\r\n这个函数定义了一个针对 `uint64_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(uint32_t *a, uint32_t b) \r\n```\r\n这个函数定义了一个针对 `uint32_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(int64_t *a, int64_t b) \r\n```\r\n这个函数定义了一个针对 `int64_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。"
            },
            {
                "content": "```cpp\r\ntemplate\r\ninline void write_sub(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子减法操作，将值 `b` 从指针 `a` 指向的值中减去。\r\n\r\n```cpp\r\ninline void write_sub(uint64_t *a, uint64_t b) \r\n```\r\n这个函数定义了一个针对 `uint64_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(uint32_t *a, uint32_t b) \r\n```\r\n这个函数定义了一个针对 `uint32_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(int64_t *a, int64_t b) \r\n```\r\n这个函数定义了一个针对 `int64_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(int32_t *a, int32_t b) \r\n```\r\n这个函数定义了一个针对 `int32_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_date_time\r\nImplements the DateTime, Date and TimeZone classes. \r\n// 实现了 DateTime，Date 和 TimeZone 类。\r\n\r\n### namespace lgraph_api\r\n// 命名空间 lgraph_api\r\n\r\n### Functions\r\n// 函数\r\n\r\n```cpp\r\nstatic inline constexpr int32_t MinDaysSinceEpochForDate()\r\n```\r\nmin and max values that Date can hold\r\n// Date 可以持有的最小值和最大值\r\n\r\n```cpp\r\nstatic inline constexpr int32_t MaxDaysSinceEpochForDate()\r\n```\r\nMaximum days since epoch for date"
            },
            {
                "content": "```\r\n这个函数定义了一个针对 `int32_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_date_time\r\nImplements the DateTime, Date and TimeZone classes. \r\n// 实现了 DateTime，Date 和 TimeZone 类。\r\n\r\n### namespace lgraph_api\r\n// 命名空间 lgraph_api\r\n\r\n### Functions\r\n// 函数\r\n\r\n```cpp\r\nstatic inline constexpr int32_t MinDaysSinceEpochForDate()\r\n```\r\nmin and max values that Date can hold\r\n// Date 可以持有的最小值和最大值\r\n\r\n```cpp\r\nstatic inline constexpr int32_t MaxDaysSinceEpochForDate()\r\n```\r\nMaximum days since epoch for date\r\n// Date 的最大纪元天数\r\n\r\n```cpp\r\nstatic inline constexpr int64_t MinMicroSecondsSinceEpochForDateTime()\r\n```\r\nmin and max values that Date can hold\r\n// DateTime 可以持有的最小值和最大值\r\n\r\n```cpp\r\nstatic inline constexpr int64_t MaxMicroSecondsSinceEpochForDateTime()\r\n```\r\nMaximum microseconds since epoch for date time\r\n// DateTime 的最大纪元微秒数\r\n\r\n### class Date\r\n```cpp\r\n#include \r\n```\r\nImplements the Date class. Range of dates is from 0/1/1 to 12/31/9999.\r\n// 实现了 Date 类。日期范围为 0/1/1 到 12/31/9999。\r\n\r\n#### Public Functions\r\n// 公共函数"
            },
            {
                "content": "```cpp\r\nstatic inline constexpr int64_t MinMicroSecondsSinceEpochForDateTime()\r\n```\r\nmin and max values that Date can hold\r\n// DateTime 可以持有的最小值和最大值\r\n\r\n```cpp\r\nstatic inline constexpr int64_t MaxMicroSecondsSinceEpochForDateTime()\r\n```\r\nMaximum microseconds since epoch for date time\r\n// DateTime 的最大纪元微秒数\r\n\r\n### class Date\r\n```cpp\r\n#include \r\n```\r\nImplements the Date class. Range of dates is from 0/1/1 to 12/31/9999.\r\n// 实现了 Date 类。日期范围为 0/1/1 到 12/31/9999。\r\n\r\n#### Public Functions\r\n// 公共函数\r\n\r\n```cpp\r\nDate()\r\n```\r\nConstruct a new Date object with the date set to 1970/1/1.\r\n// 构造一个新的 Date 对象，日期设置为 1970/1/1。\r\n\r\n```cpp\r\nexplicit Date(const std::chrono::system_clock::time_point &tp)\r\n```\r\nConstruct a new Date object with date set to the specified time. The time point must be in the range of 0/1/1 to 12/31/9999.\r\n// 使用指定的时间构造一个新的 Date 对象。时间点必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**"
            },
            {
                "content": "// 公共函数\r\n\r\n```cpp\r\nDate()\r\n```\r\nConstruct a new Date object with the date set to 1970/1/1.\r\n// 构造一个新的 Date 对象，日期设置为 1970/1/1。\r\n\r\n```cpp\r\nexplicit Date(const std::chrono::system_clock::time_point &tp)\r\n```\r\nConstruct a new Date object with date set to the specified time. The time point must be in the range of 0/1/1 to 12/31/9999.\r\n// 使用指定的时间构造一个新的 Date 对象。时间点必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ntp – Time point to set the date to.\r\n// **参数** tp – 要设置日期的时间点。\r\n\r\n```cpp\r\nexplicit Date(const YearMonthDay &ymd)\r\n```\r\nConstruct a new Date object with date set to the specified date. The date must be in the range of 0/1/1 to 12/31/9999.\r\n// 使用指定的日期构造一个新的 Date 对象。日期必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nymd – Date in the form of year, month and day.\r\n// **参数** ymd – 以年、月、日形式表示的日期。\r\n\r\n```cpp"
            },
            {
                "content": "tp – Time point to set the date to.\r\n// **参数** tp – 要设置日期的时间点。\r\n\r\n```cpp\r\nexplicit Date(const YearMonthDay &ymd)\r\n```\r\nConstruct a new Date object with date set to the specified date. The date must be in the range of 0/1/1 to 12/31/9999.\r\n// 使用指定的日期构造一个新的 Date 对象。日期必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nymd – Date in the form of year, month and day.\r\n// **参数** ymd – 以年、月、日形式表示的日期。\r\n\r\n```cpp\r\nexplicit Date(int32_t days_since_epoch)\r\n```\r\nConstruct a new Date object with date set to an offset from epoch, i.e. the date is set to the specified number of days from epoch. The result date must be in the range of 0/1/1 to 12/31/9999.\r\n// 构造一个新的 Date 对象，日期设置为相对于纪元的偏移，即日期设置为距离纪元的指定天数。结果日期必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ndays_since_epoch – Number of days since epoch."
            },
            {
                "content": "```cpp\r\nexplicit Date(int32_t days_since_epoch)\r\n```\r\nConstruct a new Date object with date set to an offset from epoch, i.e. the date is set to the specified number of days from epoch. The result date must be in the range of 0/1/1 to 12/31/9999.\r\n// 构造一个新的 Date 对象，日期设置为相对于纪元的偏移，即日期设置为距离纪元的指定天数。结果日期必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ndays_since_epoch – Number of days since epoch.\r\n// **参数** days_since_epoch – 从纪元开始的天数。\r\n\r\n```cpp\r\nexplicit Date(const std::string &str)\r\n```\r\nParse date from a YYYY-MM-DD string.\r\n// 从 YYYY-MM-DD 字符串解析日期。\r\n\r\n**抛出**  \r\nInputError – if the string is not in the correct format.\r\n// **抛出** InputError – 如果字符串不符合正确格式则抛出。\r\n\r\n**参数**  \r\nstr – The string.\r\n// **参数** str – 字符串。\r\n\r\n```cpp\r\nYearMonthDay GetYearMonthDay() const noexcept\r\n```\r\nReturns the current Date in the form of year, month and day.\r\n// 返回当前日期的年、月、日形式。\r\n\r\n**返回**  \r\nThe year month day.\r\n// **返回** 年月日。\r\n\r\n```cpp"
            },
            {
                "content": "```cpp\r\nexplicit Date(const std::string &str)\r\n```\r\nParse date from a YYYY-MM-DD string.\r\n// 从 YYYY-MM-DD 字符串解析日期。\r\n\r\n**抛出**  \r\nInputError – if the string is not in the correct format.\r\n// **抛出** InputError – 如果字符串不符合正确格式则抛出。\r\n\r\n**参数**  \r\nstr – The string.\r\n// **参数** str – 字符串。\r\n\r\n```cpp\r\nYearMonthDay GetYearMonthDay() const noexcept\r\n```\r\nReturns the current Date in the form of year, month and day.\r\n// 返回当前日期的年、月、日形式。\r\n\r\n**返回**  \r\nThe year month day.\r\n// **返回** 年月日。\r\n\r\n```cpp\r\nDate operator+(int days) const\r\n```\r\nAdd a number of days to the Date object.\r\n// 向 Date 对象添加一定数量的天数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to add.\r\n// **参数** days – 要添加的天数。\r\n\r\n**返回**  \r\nThe resulting Date object.\r\n// **返回** 结果 Date 对象。\r\n\r\n```cpp\r\nDate &operator+=(int days)\r\n```\r\nAdd a number of days to the current Date object. In case of overflow, current object is not modified.\r\n// 向当前 Date 对象添加一定数量的天数。在溢出的情况下，当前对象不进行修改。"
            },
            {
                "content": "```\r\nAdd a number of days to the Date object.\r\n// 向 Date 对象添加一定数量的天数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to add.\r\n// **参数** days – 要添加的天数。\r\n\r\n**返回**  \r\nThe resulting Date object.\r\n// **返回** 结果 Date 对象。\r\n\r\n```cpp\r\nDate &operator+=(int days)\r\n```\r\nAdd a number of days to the current Date object. In case of overflow, current object is not modified.\r\n// 向当前 Date 对象添加一定数量的天数。在溢出的情况下，当前对象不进行修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to add.\r\n// **参数** days – 要添加的天数。\r\n\r\n**返回**  \r\nReference to the current date.\r\n// **返回** 当前日期的引用。\r\n\r\n```cpp\r\nDate operator-(int days) const\r\n```\r\nSubtract a number of days from the Date object.\r\n// 从 Date 对象中减去一定数量的天数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to subtract."
            },
            {
                "content": "OutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to add.\r\n// **参数** days – 要添加的天数。\r\n\r\n**返回**  \r\nReference to the current date.\r\n// **返回** 当前日期的引用。\r\n\r\n```cpp\r\nDate operator-(int days) const\r\n```\r\nSubtract a number of days from the Date object.\r\n// 从 Date 对象中减去一定数量的天数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to subtract.\r\n// **参数** days – 要减去的天数。\r\n\r\n**返回**  \r\nThe resulting Date object.\r\n// **返回** 结果 Date 对象。\r\n\r\n```cpp\r\nDate &operator-=(int days)\r\n```\r\nSubtract a number of days from the current Date object. In case of overflow, current object is not modified.\r\n// 从当前 Date 对象中减去一定数量的天数。在溢出的情况下，当前对象不进行修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to subtract.\r\n// **参数** days – 要减去的天数。\r\n\r\n**返回**"
            },
            {
                "content": "// **参数** days – 要减去的天数。\r\n\r\n**返回**  \r\nThe resulting Date object.\r\n// **返回** 结果 Date 对象。\r\n\r\n```cpp\r\nDate &operator-=(int days)\r\n```\r\nSubtract a number of days from the current Date object. In case of overflow, current object is not modified.\r\n// 从当前 Date 对象中减去一定数量的天数。在溢出的情况下，当前对象不进行修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to subtract.\r\n// **参数** days – 要减去的天数。\r\n\r\n**返回**  \r\nReference to the current Date object.\r\n// **返回** 当前 Date 对象的引用。\r\n\r\n```cpp\r\nbool operator<(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator<=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator>(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator>=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator==(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator!=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nint32_t DaysSinceEpoch() const noexcept\r\n```"
            },
            {
                "content": "**返回**  \r\nReference to the current Date object.\r\n// **返回** 当前 Date 对象的引用。\r\n\r\n```cpp\r\nbool operator<(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator<=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator>(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator>=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator==(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator!=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nint32_t DaysSinceEpoch() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nint32_t GetStorage() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nexplicit operator int32_t() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nstd::chrono::system_clock::time_point TimePoint() const noexcept\r\n```\r\nReturns the timepoint corresponding to this date at 00:00 am.\r\n// 返回与该日期对应的时间点（00:00 AM）。\r\n\r\n```cpp"
            },
            {
                "content": "Returns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nint32_t GetStorage() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nexplicit operator int32_t() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nstd::chrono::system_clock::time_point TimePoint() const noexcept\r\n```\r\nReturns the timepoint corresponding to this date at 00:00 am.\r\n// 返回与该日期对应的时间点（00:00 AM）。\r\n\r\n```cpp\r\nstd::string ToString() const noexcept\r\n```\r\nGet the string representation of the date in the format of YYYY-MM-DD.\r\n// 获取日期的字符串表示，格式为 YYYY-MM-DD。\r\n\r\n```cpp\r\nexplicit operator DateTime() const noexcept\r\n```\r\nGet the DateTime object corresponding to 00:00 am on this date.\r\n// 获取与该日期的 00:00 AM 对应的 DateTime 对象。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic bool Parse(const std::string &str, Date &d) noexcept\r\n```\r\nParse date from YYYY-MM-DD, save value in d.  \r\n从YYYY-MM-DD格式解析日期，并将结果保存到d中。\r\n\r\n**参数**"
            },
            {
                "content": "std::string ToString() const noexcept\r\n```\r\nGet the string representation of the date in the format of YYYY-MM-DD.\r\n// 获取日期的字符串表示，格式为 YYYY-MM-DD。\r\n\r\n```cpp\r\nexplicit operator DateTime() const noexcept\r\n```\r\nGet the DateTime object corresponding to 00:00 am on this date.\r\n// 获取与该日期的 00:00 AM 对应的 DateTime 对象。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic bool Parse(const std::string &str, Date &d) noexcept\r\n```\r\nParse date from YYYY-MM-DD, save value in d.  \r\n从YYYY-MM-DD格式解析日期，并将结果保存到d中。\r\n\r\n**参数**  \r\nstr – The string.  \r\nstr – 输入的字符串。\r\n\r\nd – [out] The resulting Date.  \r\nd – [输出] 解析结果的日期对象。\r\n\r\n**返回**  \r\nTrue if success, otherwise false.  \r\n如果成功返回true，否则返回false。\r\n\r\n```cpp\r\nstatic size_t Parse(const char *beg, const char *end, Date &d) noexcept\r\n```\r\nParse date from YYYY-MM-DD, save value in d.  \r\n从YYYY-MM-DD格式解析日期，并将结果保存到d中。\r\n\r\n**参数**  \r\nbeg – The beg.  \r\nbeg – 字符串的起始指针。\r\n\r\nend – The end.  \r\nend – 字符串的结束指针。\r\n\r\nd – [out] The result.  \r\nd – [输出] 解析结果的日期对象。\r\n\r\n**返回**"
            },
            {
                "content": "**参数**  \r\nstr – The string.  \r\nstr – 输入的字符串。\r\n\r\nd – [out] The resulting Date.  \r\nd – [输出] 解析结果的日期对象。\r\n\r\n**返回**  \r\nTrue if success, otherwise false.  \r\n如果成功返回true，否则返回false。\r\n\r\n```cpp\r\nstatic size_t Parse(const char *beg, const char *end, Date &d) noexcept\r\n```\r\nParse date from YYYY-MM-DD, save value in d.  \r\n从YYYY-MM-DD格式解析日期，并将结果保存到d中。\r\n\r\n**参数**  \r\nbeg – The beg.  \r\nbeg – 字符串的起始指针。\r\n\r\nend – The end.  \r\nend – 字符串的结束指针。\r\n\r\nd – [out] The result.  \r\nd – [输出] 解析结果的日期对象。\r\n\r\n**返回**  \r\nNumber of bytes parsed (must be 10), 0 if failed.  \r\n解析的字节数（必须为10），如果失败则返回0。\r\n\r\n```cpp\r\nstatic Date Now() noexcept\r\n```\r\nReturns the current Date.  \r\n返回当前日期。\r\n\r\n**返回**  \r\nCurrent Date in UTC.  \r\n以UTC格式返回当前日期。\r\n\r\n```cpp\r\nstatic Date LocalNow() noexcept\r\n```\r\nReturns the current Date in local timezone.  \r\n返回本地时区的当前日期。\r\n\r\n**返回**  \r\nCurrent Date in local timezone.  \r\n以本地时区格式返回当前日期。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint32_t days_since_epoch_\r\n```\r\nThe days since epoch  \r\n自纪元以来的天数。\r\n\r\n### struct YearMonthDay\r\n```cpp\r\n#include \r\n```"
            },
            {
                "content": "解析的字节数（必须为10），如果失败则返回0。\r\n\r\n```cpp\r\nstatic Date Now() noexcept\r\n```\r\nReturns the current Date.  \r\n返回当前日期。\r\n\r\n**返回**  \r\nCurrent Date in UTC.  \r\n以UTC格式返回当前日期。\r\n\r\n```cpp\r\nstatic Date LocalNow() noexcept\r\n```\r\nReturns the current Date in local timezone.  \r\n返回本地时区的当前日期。\r\n\r\n**返回**  \r\nCurrent Date in local timezone.  \r\n以本地时区格式返回当前日期。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint32_t days_since_epoch_\r\n```\r\nThe days since epoch  \r\n自纪元以来的天数。\r\n\r\n### struct YearMonthDay\r\n```cpp\r\n#include \r\n```\r\nStructure representing a date in the format of year, month and day.  \r\n用于表示日期的结构，包括年、月、日格式。\r\n\r\n#### Public Members\r\n\r\n```cpp\r\nint year\r\n```\r\nThe year, 0-9999  \r\n年份，范围是0-9999。\r\n\r\n```cpp\r\nunsigned month\r\n```\r\nMonth, 1-12  \r\n月份，范围是1-12。\r\n\r\n```cpp\r\nunsigned day\r\n```\r\nDay, 1-31  \r\n日期，范围是1-31。\r\n\r\n### class DateTime\r\n```cpp\r\n#include \r\n```\r\nImplements a DateTime class that holds DateTime in the range of 0000-01-01 00:00:00.000000 to 9999-12-31 23:59:59.999999.  \r\n实现一个DateTime类，范围从0000-01-01 00:00:00.000000到9999-12-31 23:59:59.999999。"
            },
            {
                "content": "用于表示日期的结构，包括年、月、日格式。\r\n\r\n#### Public Members\r\n\r\n```cpp\r\nint year\r\n```\r\nThe year, 0-9999  \r\n年份，范围是0-9999。\r\n\r\n```cpp\r\nunsigned month\r\n```\r\nMonth, 1-12  \r\n月份，范围是1-12。\r\n\r\n```cpp\r\nunsigned day\r\n```\r\nDay, 1-31  \r\n日期，范围是1-31。\r\n\r\n### class DateTime\r\n```cpp\r\n#include \r\n```\r\nImplements a DateTime class that holds DateTime in the range of 0000-01-01 00:00:00.000000 to 9999-12-31 23:59:59.999999.  \r\n实现一个DateTime类，范围从0000-01-01 00:00:00.000000到9999-12-31 23:59:59.999999。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nDateTime()\r\n```\r\nConstruct a new DateTime object with date set to the epoch time, i.e., 1970-1-1 00:00:00.  \r\n构造一个新的DateTime对象，日期设置为纪元时间，即1970-1-1 00:00:00。\r\n\r\n```cpp\r\nexplicit DateTime(const std::chrono::system_clock::time_point &tp)\r\n```\r\nConstruct a new DateTime object with date set to the specified timepoint.  \r\n构造一个新的DateTime对象，日期设置为指定的时间点。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ntp – Timepoint to set the DateTime to.  \r\ntp – 设置DateTime的时间点。"
            },
            {
                "content": "```\r\nConstruct a new DateTime object with date set to the epoch time, i.e., 1970-1-1 00:00:00.  \r\n构造一个新的DateTime对象，日期设置为纪元时间，即1970-1-1 00:00:00。\r\n\r\n```cpp\r\nexplicit DateTime(const std::chrono::system_clock::time_point &tp)\r\n```\r\nConstruct a new DateTime object with date set to the specified timepoint.  \r\n构造一个新的DateTime对象，日期设置为指定的时间点。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ntp – Timepoint to set the DateTime to.  \r\ntp – 设置DateTime的时间点。\r\n\r\n```cpp\r\nexplicit DateTime(const YMDHMSF &ymdhmsf)\r\n```\r\nConstruct a new DateTime object with date set to the specified date and time given in YMDHMSF.  \r\n构造一个新的DateTime对象，日期设置为在YMDHMSF中给定的指定日期和时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nymdhmsf – Date and time to set the DateTime to.  \r\nymdhmsf – 设置DateTime的日期和时间。\r\n\r\n```cpp\r\nexplicit DateTime(int64_t microseconds_since_epoch)\r\n```"
            },
            {
                "content": "tp – 设置DateTime的时间点。\r\n\r\n```cpp\r\nexplicit DateTime(const YMDHMSF &ymdhmsf)\r\n```\r\nConstruct a new DateTime object with date set to the specified date and time given in YMDHMSF.  \r\n构造一个新的DateTime对象，日期设置为在YMDHMSF中给定的指定日期和时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nymdhmsf – Date and time to set the DateTime to.  \r\nymdhmsf – 设置DateTime的日期和时间。\r\n\r\n```cpp\r\nexplicit DateTime(int64_t microseconds_since_epoch)\r\n```\r\nConstruct a new DateTime object with date set to specified number of microseconds since epoch.  \r\n构造一个新的DateTime对象，日期设置为从纪元以来指定的微秒数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nmicroseconds_since_epoch – Number of microseconds since epoch.  \r\nmicroseconds_since_epoch – 从纪元以来的微秒数。\r\n\r\n```cpp\r\nexplicit DateTime(const std::string &str)\r\n```\r\nConstruct a new DateTime object with date set to the specified date and time given in the form of YYYY-MM-DD HH:MM:SS[.FFFFFF]."
            },
            {
                "content": "构造一个新的DateTime对象，日期设置为从纪元以来指定的微秒数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nmicroseconds_since_epoch – Number of microseconds since epoch.  \r\nmicroseconds_since_epoch – 从纪元以来的微秒数。\r\n\r\n```cpp\r\nexplicit DateTime(const std::string &str)\r\n```\r\nConstruct a new DateTime object with date set to the specified date and time given in the form of YYYY-MM-DD HH:MM:SS[.FFFFFF].  \r\n构造一个新的DateTime对象，日期设置为以YYYY-MM-DD HH:MM:SS[.FFFFFF]形式给定的指定日期和时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\nInputError – Thrown if str has invalid format.  \r\n输入错误 - 如果字符串格式无效则抛出。\r\n\r\n**参数**  \r\nstr – String representation of the date and time in the form of YYYY-MM-DD HH:MM:SS.  \r\nstr – 日期和时间的字符串表示，格式为YYYY-MM-DD HH:MM:SS。\r\n\r\n```cpp\r\nYMDHMSF GetYMDHMSF() const noexcept\r\n```\r\nGet current DateTime in the form of year, month, day, hour, minute, second, fraction.  \r\n以年、月、日、小时、分钟、秒和小数组成的形式获取当前DateTime。\r\n\r\n**返回**  \r\nThe ymdhmsf."
            },
            {
                "content": "OutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\nInputError – Thrown if str has invalid format.  \r\n输入错误 - 如果字符串格式无效则抛出。\r\n\r\n**参数**  \r\nstr – String representation of the date and time in the form of YYYY-MM-DD HH:MM:SS.  \r\nstr – 日期和时间的字符串表示，格式为YYYY-MM-DD HH:MM:SS。\r\n\r\n```cpp\r\nYMDHMSF GetYMDHMSF() const noexcept\r\n```\r\nGet current DateTime in the form of year, month, day, hour, minute, second, fraction.  \r\n以年、月、日、小时、分钟、秒和小数组成的形式获取当前DateTime。\r\n\r\n**返回**  \r\nThe ymdhmsf.  \r\n返回ymdhmsf格式的数据。\r\n\r\n```cpp\r\nDateTime operator+(int64_t n_microseconds) const\r\n```\r\nAdd a number of microseconds to the DateTime.  \r\n将一定数量的微秒添加到DateTime中。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of micorseconds to add.  \r\nn_microseconds – 要添加的微秒数。\r\n\r\n**返回**  \r\nThe resulting DateTime.  \r\n结果DateTime。\r\n\r\n```cpp\r\nDateTime &operator+=(int64_t n_microseconds)\r\n```"
            },
            {
                "content": "**返回**  \r\nThe ymdhmsf.  \r\n返回ymdhmsf格式的数据。\r\n\r\n```cpp\r\nDateTime operator+(int64_t n_microseconds) const\r\n```\r\nAdd a number of microseconds to the DateTime.  \r\n将一定数量的微秒添加到DateTime中。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of micorseconds to add.  \r\nn_microseconds – 要添加的微秒数。\r\n\r\n**返回**  \r\nThe resulting DateTime.  \r\n结果DateTime。\r\n\r\n```cpp\r\nDateTime &operator+=(int64_t n_microseconds)\r\n```\r\nAdds a number of microseconds to the current DateTime object. In case of overflow, current object is not modified.  \r\n将一定数量的微秒添加到当前DateTime对象。 如果发生溢出，当前对象不会被修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to add.  \r\nn_microseconds – 要添加的微秒数。\r\n\r\n**返回**  \r\nReference to the current DateTime.  \r\n返回对当前DateTime的引用。\r\n\r\n```cpp\r\nDateTime operator-(int64_t n_microseconds) const\r\n```"
            },
            {
                "content": "```\r\nAdds a number of microseconds to the current DateTime object. In case of overflow, current object is not modified.  \r\n将一定数量的微秒添加到当前DateTime对象。 如果发生溢出，当前对象不会被修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to add.  \r\nn_microseconds – 要添加的微秒数。\r\n\r\n**返回**  \r\nReference to the current DateTime.  \r\n返回对当前DateTime的引用。\r\n\r\n```cpp\r\nDateTime operator-(int64_t n_microseconds) const\r\n```\r\nSubtract a number of microseconds from the DateTime.  \r\n从DateTime中减去一定数量的微秒。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to subtract.  \r\nn_microseconds – 要减去的微秒数。\r\n\r\n**返回**  \r\nThe resulting DateTime.  \r\n结果DateTime。\r\n\r\n```cpp\r\nDateTime &operator-=(int64_t n_microseconds)\r\n```\r\nSubtract a number of microseconds from the current DateTime object. In case of overflow, current object is not modified."
            },
            {
                "content": "从DateTime中减去一定数量的微秒。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to subtract.  \r\nn_microseconds – 要减去的微秒数。\r\n\r\n**返回**  \r\nThe resulting DateTime.  \r\n结果DateTime。\r\n\r\n```cpp\r\nDateTime &operator-=(int64_t n_microseconds)\r\n```\r\nSubtract a number of microseconds from the current DateTime object. In case of overflow, current object is not modified.  \r\n从当前DateTime对象中减去一定数量的微秒。如果发生溢出，当前对象不会被修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to subtract.  \r\nn_microseconds – 要减去的微秒数。\r\n\r\n**返回**  \r\nReference to the current DateTime.  \r\n返回对当前DateTime的引用。\r\n\r\n```cpp\r\nbool operator<(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator<=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator>(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp"
            },
            {
                "content": "**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to subtract.  \r\nn_microseconds – 要减去的微秒数。\r\n\r\n**返回**  \r\nReference to the current DateTime.  \r\n返回对当前DateTime的引用。\r\n\r\n```cpp\r\nbool operator<(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator<=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator>(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator>=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator==(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator!=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nint64_t MicroSecondsSinceEpoch() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nint64_t GetStorage() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nexplicit operator int64_t() const noexcept\r\n```"
            },
            {
                "content": "```cpp\r\nbool operator>=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator==(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator!=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nint64_t MicroSecondsSinceEpoch() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nint64_t GetStorage() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nexplicit operator int64_t() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nstd::chrono::system_clock::time_point TimePoint() const noexcept\r\n```\r\nReturns the time point corresponding to this DateTime.  \r\n返回与该DateTime对应的时间点。\r\n\r\n```cpp\r\nstd::string ToString() const noexcept\r\n```\r\nGet the string representation of the DateTime in the format of YYYY-MM-DD HH:MM:SS[.FFFFFF].  \r\n获得DateTime的字符串表示，格式为YYYY-MM-DD HH:MM:SS[.FFFFFF]。\r\n\r\n```cpp\r\nstd::string ToDateString() const noexcept\r\n```"
            },
            {
                "content": "```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nstd::chrono::system_clock::time_point TimePoint() const noexcept\r\n```\r\nReturns the time point corresponding to this DateTime.  \r\n返回与该DateTime对应的时间点。\r\n\r\n```cpp\r\nstd::string ToString() const noexcept\r\n```\r\nGet the string representation of the DateTime in the format of YYYY-MM-DD HH:MM:SS[.FFFFFF].  \r\n获得DateTime的字符串表示，格式为YYYY-MM-DD HH:MM:SS[.FFFFFF]。\r\n\r\n```cpp\r\nstd::string ToDateString() const noexcept\r\n```\r\nGet the string representation of the date part of DateTime in the format of YYYY-MM-DD.  \r\n获得DateTime日期部分的字符串表示，格式为YYYY-MM-DD。\r\n\r\n```cpp\r\nstd::string ToTimeString() const noexcept\r\n```\r\nGet the string representation of the time part of DateTime in the format of HH:MM:SS[.FFFFFF].  \r\n获得DateTime时间部分的字符串表示，格式为HH:MM:SS[.FFFFFF]。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic bool Parse(const std::string &str, DateTime &dt) noexcept\r\n```\r\nParse DateTime from string representation, save value in dt.  \r\n从字符串表示中解析DateTime，并将值保存到dt中。"
            },
            {
                "content": "获得DateTime日期部分的字符串表示，格式为YYYY-MM-DD。\r\n\r\n```cpp\r\nstd::string ToTimeString() const noexcept\r\n```\r\nGet the string representation of the time part of DateTime in the format of HH:MM:SS[.FFFFFF].  \r\n获得DateTime时间部分的字符串表示，格式为HH:MM:SS[.FFFFFF]。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic bool Parse(const std::string &str, DateTime &dt) noexcept\r\n```\r\nParse DateTime from string representation, save value in dt.  \r\n从字符串表示中解析DateTime，并将值保存到dt中。\r\n\r\n**参数**  \r\nstr – The string.  \r\nstr – 字符串。\r\n\r\ndt – [out] The resulting DateTime.  \r\ndt – [输出] 结果的DateTime。\r\n\r\n**返回**  \r\nTrue if success, otherwise false.  \r\n成功返回true，否则返回false。\r\n\r\n```cpp\r\nstatic size_t Parse(const char *beg, const char *end, DateTime &dt) noexcept\r\n```\r\nParse DateTime from string representation, save value in dt.  \r\n从字符串表示中解析DateTime，并将值保存到dt中。\r\n\r\n**参数**  \r\nbeg – The beg.  \r\nbeg – 开始指针。\r\n\r\nend – The end.  \r\nend – 结束指针。\r\n\r\ndt – [out] The result.  \r\ndt – [输出] 结果。\r\n\r\n**返回**  \r\nNumber of bytes parsed (must be 26), 0 if failed.  \r\n解析的字节数（必须为26），如果失败则返回0。"
            },
            {
                "content": "dt – [输出] 结果的DateTime。\r\n\r\n**返回**  \r\nTrue if success, otherwise false.  \r\n成功返回true，否则返回false。\r\n\r\n```cpp\r\nstatic size_t Parse(const char *beg, const char *end, DateTime &dt) noexcept\r\n```\r\nParse DateTime from string representation, save value in dt.  \r\n从字符串表示中解析DateTime，并将值保存到dt中。\r\n\r\n**参数**  \r\nbeg – The beg.  \r\nbeg – 开始指针。\r\n\r\nend – The end.  \r\nend – 结束指针。\r\n\r\ndt – [out] The result.  \r\ndt – [输出] 结果。\r\n\r\n**返回**  \r\nNumber of bytes parsed (must be 26), 0 if failed.  \r\n解析的字节数（必须为26），如果失败则返回0。\r\n\r\n```cpp\r\nstatic DateTime Now() noexcept\r\n```\r\nReturns the current DateTime.  \r\n返回当前的DateTime。\r\n\r\n**返回**  \r\nCurrent DateTime in UTC.  \r\n以UTC格式返回当前DateTime。\r\n\r\n```cpp\r\nstatic DateTime LocalNow() noexcept\r\n```\r\nReturns the current DateTime in local timezone.  \r\n返回本地时区的当前DateTime。\r\n\r\n**返回**  \r\nCurrent DateTime in local timezone.  \r\n以本地时区格式返回当前DateTime。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint64_t microseconds_since_epoch_\r\n```\r\nThe microseconds since epoch.  \r\n自纪元以来的微秒数。\r\n\r\n### struct YMDHMSF\r\n```cpp\r\n#include \r\n```"
            },
            {
                "content": "static DateTime Now() noexcept\r\n```\r\nReturns the current DateTime.  \r\n返回当前的DateTime。\r\n\r\n**返回**  \r\nCurrent DateTime in UTC.  \r\n以UTC格式返回当前DateTime。\r\n\r\n```cpp\r\nstatic DateTime LocalNow() noexcept\r\n```\r\nReturns the current DateTime in local timezone.  \r\n返回本地时区的当前DateTime。\r\n\r\n**返回**  \r\nCurrent DateTime in local timezone.  \r\n以本地时区格式返回当前DateTime。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint64_t microseconds_since_epoch_\r\n```\r\nThe microseconds since epoch.  \r\n自纪元以来的微秒数。\r\n\r\n### struct YMDHMSF\r\n```cpp\r\n#include \r\n```\r\nStructure representing a DateTime in the format of year, month, day, hour, minute, second and fraction.  \r\n表示日期时间的结构，格式为年、月、日、小时、分钟、秒和分数。\r\n\r\n#### Public Members\r\n\r\n```cpp\r\nint year\r\n```\r\nThe year, 0-9999  \r\n年份，范围是0到9999。\r\n\r\n```cpp\r\nunsigned month\r\n```\r\nMonth, 1-12  \r\n月份，范围是1到12。\r\n\r\n```cpp\r\nunsigned day\r\n```\r\nDay, 1-31  \r\n天，范围是1到31。\r\n\r\n```cpp\r\nunsigned hour\r\n```\r\nHour, 0-23  \r\n小时，范围是0到23。\r\n\r\n```cpp\r\nunsigned minute\r\n```\r\nMinute, 0-59  \r\n分钟，范围是0到59。\r\n\r\n```cpp\r\nunsigned second\r\n```\r\nSecond, 0-59  \r\n秒，范围是0到59。"
            },
            {
                "content": "表示日期时间的结构，格式为年、月、日、小时、分钟、秒和分数。\r\n\r\n#### Public Members\r\n\r\n```cpp\r\nint year\r\n```\r\nThe year, 0-9999  \r\n年份，范围是0到9999。\r\n\r\n```cpp\r\nunsigned month\r\n```\r\nMonth, 1-12  \r\n月份，范围是1到12。\r\n\r\n```cpp\r\nunsigned day\r\n```\r\nDay, 1-31  \r\n天，范围是1到31。\r\n\r\n```cpp\r\nunsigned hour\r\n```\r\nHour, 0-23  \r\n小时，范围是0到23。\r\n\r\n```cpp\r\nunsigned minute\r\n```\r\nMinute, 0-59  \r\n分钟，范围是0到59。\r\n\r\n```cpp\r\nunsigned second\r\n```\r\nSecond, 0-59  \r\n秒，范围是0到59。\r\n\r\n```cpp\r\nunsigned fraction\r\n```\r\nFraction, 0-999999  \r\n小数部分，范围是0到999999。\r\n\r\n### class TimeZone\r\n```cpp\r\n#include \r\n```\r\nA class that represents a time zone.  \r\n表示时区的类。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit TimeZone(int time_diff_hours = 0)\r\n```\r\nCreate a timezone which has time difference with UTC in hours `time_diff_hours`.  \r\n创建与UTC有时差`time_diff_hours`小时的时区。\r\n\r\n**抛出**  \r\nInvalidParameter – Thrown if `time_diff_hours` is invalid.  \r\nInvalidParameter – 如果`time_diff_hours`无效则抛出。\r\n\r\n**参数**"
            },
            {
                "content": "```cpp\r\nunsigned fraction\r\n```\r\nFraction, 0-999999  \r\n小数部分，范围是0到999999。\r\n\r\n### class TimeZone\r\n```cpp\r\n#include \r\n```\r\nA class that represents a time zone.  \r\n表示时区的类。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit TimeZone(int time_diff_hours = 0)\r\n```\r\nCreate a timezone which has time difference with UTC in hours `time_diff_hours`.  \r\n创建与UTC有时差`time_diff_hours`小时的时区。\r\n\r\n**抛出**  \r\nInvalidParameter – Thrown if `time_diff_hours` is invalid.  \r\nInvalidParameter – 如果`time_diff_hours`无效则抛出。\r\n\r\n**参数**  \r\ntime_diff_hours – (Optional) Difference between local timezone and UTC. Must be >= -10 && <= 14. Otherwise, the function will throw.  \r\ntime_diff_hours – （可选）本地时区与UTC之间的差异。必须在-10到14之间。否则，该函数将抛出异常。\r\n\r\n```cpp\r\nDateTime FromUTC(const DateTime &dt) const\r\n```\r\nConvert a DateTime from UTC time to this time zone.  \r\n将UTC时间的DateTime转换为此时区。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting value is out of range.  \r\nOutOfRange – 如果结果值超出范围，则抛出。\r\n\r\n**参数**  \r\ndt – DateTime in UTC time.  \r\ndt – UTC时间下的DateTime。\r\n\r\n**返回**"
            },
            {
                "content": "time_diff_hours – （可选）本地时区与UTC之间的差异。必须在-10到14之间。否则，该函数将抛出异常。\r\n\r\n```cpp\r\nDateTime FromUTC(const DateTime &dt) const\r\n```\r\nConvert a DateTime from UTC time to this time zone.  \r\n将UTC时间的DateTime转换为此时区。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting value is out of range.  \r\nOutOfRange – 如果结果值超出范围，则抛出。\r\n\r\n**参数**  \r\ndt – DateTime in UTC time.  \r\ndt – UTC时间下的DateTime。\r\n\r\n**返回**  \r\nDateTime in local timezone.  \r\n本地时区下的DateTime。\r\n\r\n```cpp\r\nDateTime ToUTC(const DateTime &dt) const\r\n```\r\nConvert a DateTime from this timezone to UTC time.  \r\n将此时区的DateTime转换为UTC时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting value is out of range.  \r\nOutOfRange – 如果结果值超出范围，则抛出。\r\n\r\n**参数**  \r\ndt – DateTime in local timezone.  \r\ndt – 本地时区下的DateTime。\r\n\r\n**返回**  \r\nDateTime in UTC.  \r\nUTC时间下的DateTime。\r\n\r\n```cpp\r\nint64_t UTCDiffSeconds() const noexcept\r\n```\r\nReturns diff from UTC in seconds, this is used in Date and DateTime.  \r\n返回与UTC的秒数差，此差值用于日期和时间。\r\n\r\n**返回**  \r\nNumber of seconds local timezone is from UTC.  \r\n本地时区与UTC的秒数差。"
            },
            {
                "content": "将此时区的DateTime转换为UTC时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting value is out of range.  \r\nOutOfRange – 如果结果值超出范围，则抛出。\r\n\r\n**参数**  \r\ndt – DateTime in local timezone.  \r\ndt – 本地时区下的DateTime。\r\n\r\n**返回**  \r\nDateTime in UTC.  \r\nUTC时间下的DateTime。\r\n\r\n```cpp\r\nint64_t UTCDiffSeconds() const noexcept\r\n```\r\nReturns diff from UTC in seconds, this is used in Date and DateTime.  \r\n返回与UTC的秒数差，此差值用于日期和时间。\r\n\r\n**返回**  \r\nNumber of seconds local timezone is from UTC.  \r\n本地时区与UTC的秒数差。\r\n\r\n```cpp\r\nint64_t UTCDiffHours() const noexcept\r\n```\r\nReturns diff from UTC in hours, this is used in Date and DateTime.  \r\n返回与UTC的小时数差，此差值用于日期和时间。\r\n\r\n**返回**  \r\nNumber of hours local timezone is from UTC.  \r\n本地时区与UTC的小时数差。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic const TimeZone &LocalTimeZone() noexcept\r\n```\r\nGet local timezone.  \r\n获取本地时区。\r\n\r\n**返回**  \r\nA const reference to local timezone.  \r\n对本地时区的常量引用。\r\n\r\n```cpp\r\nstatic void UpdateLocalTimeZone() noexcept\r\n```"
            },
            {
                "content": "本地时区与UTC的秒数差。\r\n\r\n```cpp\r\nint64_t UTCDiffHours() const noexcept\r\n```\r\nReturns diff from UTC in hours, this is used in Date and DateTime.  \r\n返回与UTC的小时数差，此差值用于日期和时间。\r\n\r\n**返回**  \r\nNumber of hours local timezone is from UTC.  \r\n本地时区与UTC的小时数差。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic const TimeZone &LocalTimeZone() noexcept\r\n```\r\nGet local timezone.  \r\n获取本地时区。\r\n\r\n**返回**  \r\nA const reference to local timezone.  \r\n对本地时区的常量引用。\r\n\r\n```cpp\r\nstatic void UpdateLocalTimeZone() noexcept\r\n```\r\nUpdate local timezone, used only when daylight saving time changes. Daylight saving time may change after `LocalTZ` was initialized, in which case we need to update it. This function will update all references returned by `LocalTimeZone()`.  \r\n更新本地时区，仅在夏令时变化时使用。夏令时可能在`LocalTZ`初始化后发生变化，在这种情况下，我们需要更新它。此函数将更新所有由`LocalTimeZone()`返回的引用。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint64_t time_diff_microseconds_\r\n```\r\nThe difference in microseconds from UTC.  \r\n与UTC的微秒差异。\r\n\r\n#### Private Static Functions\r\n\r\n```cpp"
            },
            {
                "content": "```\r\nUpdate local timezone, used only when daylight saving time changes. Daylight saving time may change after `LocalTZ` was initialized, in which case we need to update it. This function will update all references returned by `LocalTimeZone()`.  \r\n更新本地时区，仅在夏令时变化时使用。夏令时可能在`LocalTZ`初始化后发生变化，在这种情况下，我们需要更新它。此函数将更新所有由`LocalTimeZone()`返回的引用。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint64_t time_diff_microseconds_\r\n```\r\nThe difference in microseconds from UTC.  \r\n与UTC的微秒差异。\r\n\r\n#### Private Static Functions\r\n\r\n```cpp\r\nstatic TimeZone GetLocalTZ()\r\n```\r\n获取本地时区的私有静态函数。\r\n\r\n```cpp\r\nstatic TimeZone &LocalTZ()\r\n```\r\n获取本地时区的私有静态函数引用。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_db\r\n\r\n### namespace lgraph\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n#### bool ShouldKillThisTask()\r\nDetermine if we should kill current task.\r\n确定是否应该终止当前任务。\r\n\r\n**返回**  \r\nTrue if a KillTask command was issued for this task, either due to user request or timeout.  \r\n如果对该任务发出了KillTask命令（由于用户请求或超时），则返回True。\r\n\r\n#### ThreadContextPtr GetThreadContext()"
            },
            {
                "content": "```cpp\r\nstatic TimeZone GetLocalTZ()\r\n```\r\n获取本地时区的私有静态函数。\r\n\r\n```cpp\r\nstatic TimeZone &LocalTZ()\r\n```\r\n获取本地时区的私有静态函数引用。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_db\r\n\r\n### namespace lgraph\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n#### bool ShouldKillThisTask()\r\nDetermine if we should kill current task.\r\n确定是否应该终止当前任务。\r\n\r\n**返回**  \r\nTrue if a KillTask command was issued for this task, either due to user request or timeout.  \r\n如果对该任务发出了KillTask命令（由于用户请求或超时），则返回True。\r\n\r\n#### ThreadContextPtr GetThreadContext()\r\nGets thread context pointer, which can then be used in ShouldKillThisTask(ctx). Calling ShouldKillThisTask() is equivalent to ShouldKillThisTask(GetThreadContext()). In order to save the cost of GetThreadContext(), you can store the context and use it in ShouldKillThisTask(ctx).\r\n获取线程上下文指针，然后可以在ShouldKillThisTask(ctx)中使用。调用ShouldKillThisTask()等效于调用ShouldKillThisTask(GetThreadContext())。为了节省GetThreadContext()的开销，可以存储上下文并在ShouldKillThisTask(ctx)中使用。\r\n\r\n**Example:** \r\n```c++"
            },
            {
                "content": "Gets thread context pointer, which can then be used in ShouldKillThisTask(ctx). Calling ShouldKillThisTask() is equivalent to ShouldKillThisTask(GetThreadContext()). In order to save the cost of GetThreadContext(), you can store the context and use it in ShouldKillThisTask(ctx).\r\n获取线程上下文指针，然后可以在ShouldKillThisTask(ctx)中使用。调用ShouldKillThisTask()等效于调用ShouldKillThisTask(GetThreadContext())。为了节省GetThreadContext()的开销，可以存储上下文并在ShouldKillThisTask(ctx)中使用。\r\n\r\n**Example:** \r\n```c++\r\nThreadContextPtr ctx = GetThreadContext(); \r\nwhile (HasMoreWorkToDo()) { \r\n    if (ShouldKillThisTask(ctx)) { \r\n        break; \r\n    } \r\n    DoWork(); \r\n}\r\n```\r\n\r\n**返回**  \r\nThe thread context.  \r\n线程上下文。\r\n\r\n#### bool ShouldKillThisTask(ThreadContextPtr ctx)\r\nDetermine if we should kill the task currently running in the thread identified by ctx.\r\n确定是否应该终止在ctx标识的线程中当前运行的任务。\r\n\r\n**参数**  \r\n- ctx – The context, as obtained with GetThreadContext.  \r\n参数ctx – 通过GetThreadContext获得的上下文。\r\n\r\n**返回**"
            },
            {
                "content": "```c++\r\nThreadContextPtr ctx = GetThreadContext(); \r\nwhile (HasMoreWorkToDo()) { \r\n    if (ShouldKillThisTask(ctx)) { \r\n        break; \r\n    } \r\n    DoWork(); \r\n}\r\n```\r\n\r\n**返回**  \r\nThe thread context.  \r\n线程上下文。\r\n\r\n#### bool ShouldKillThisTask(ThreadContextPtr ctx)\r\nDetermine if we should kill the task currently running in the thread identified by ctx.\r\n确定是否应该终止在ctx标识的线程中当前运行的任务。\r\n\r\n**参数**  \r\n- ctx – The context, as obtained with GetThreadContext.  \r\n参数ctx – 通过GetThreadContext获得的上下文。\r\n\r\n**返回**  \r\nTrue if a KillTask command was issued for this task.  \r\n如果对该任务发出了KillTask命令，则返回True。\r\n\r\n### Variables\r\n\r\n#### const typedef void * ThreadContextPtr\r\nDefines an alias representing the thread context pointer.  \r\n定义代表线程上下文指针的别名。\r\n\r\n### class GraphDB\r\n```cpp\r\n#include \r\n```\r\nGraphDB represents a graph instance. In TuGraph, each graph instance has its own schema and access control settings. Accessing a GraphDB without appropriate access rights yields WriteNotAllowed."
            },
            {
                "content": "**返回**  \r\nTrue if a KillTask command was issued for this task.  \r\n如果对该任务发出了KillTask命令，则返回True。\r\n\r\n### Variables\r\n\r\n#### const typedef void * ThreadContextPtr\r\nDefines an alias representing the thread context pointer.  \r\n定义代表线程上下文指针的别名。\r\n\r\n### class GraphDB\r\n```cpp\r\n#include \r\n```\r\nGraphDB represents a graph instance. In TuGraph, each graph instance has its own schema and access control settings. Accessing a GraphDB without appropriate access rights yields WriteNotAllowed.  \r\nGraphDB表示一个图实例。在TuGraph中，每个图实例都有自己的模式和访问控制设置。没有适当访问权限访问GraphDB会导致WriteNotAllowed。\r\n\r\nA GraphDB becomes invalid if Close() is called, in which case all transactions and iterators associated with that GraphDB become invalid. Further operation on that GraphDB yields InvalidGraphDB.  \r\n如果调用Close()，则GraphDB变为无效，此时与该GraphDB相关的所有事务和迭代器都会变得无效。对该GraphDB的进一步操作将导致InvalidGraphDB。\r\n\r\n### Public Functions\r\n\r\n#### explicit GraphDB(lgraph::AccessControlledDB *db_with_access_control, bool read_only, bool owns_db = false)"
            },
            {
                "content": "GraphDB表示一个图实例。在TuGraph中，每个图实例都有自己的模式和访问控制设置。没有适当访问权限访问GraphDB会导致WriteNotAllowed。\r\n\r\nA GraphDB becomes invalid if Close() is called, in which case all transactions and iterators associated with that GraphDB become invalid. Further operation on that GraphDB yields InvalidGraphDB.  \r\n如果调用Close()，则GraphDB变为无效，此时与该GraphDB相关的所有事务和迭代器都会变得无效。对该GraphDB的进一步操作将导致InvalidGraphDB。\r\n\r\n### Public Functions\r\n\r\n#### explicit GraphDB(lgraph::AccessControlledDB *db_with_access_control, bool read_only, bool owns_db = false)\r\nFor internal use only. Users should use Galaxy::OpenGraph() to get GraphDB.  \r\n仅供内部使用。用户应使用Galaxy::OpenGraph()获取GraphDB。\r\n\r\n#### GraphDB(GraphDB&&)\r\n#### GraphDB &operator=(GraphDB&&)\r\n#### ~GraphDB()\r\n#### void Close()\r\nClose the graph. This will close the graph and release all transactions, iterators associated with the graph. After calling Close(), the graph becomes invalid, and cannot be used anymore.  \r\n关闭图。此操作将关闭图并释放与图相关的所有事务和迭代器。调用Close()后，图将变为无效，无法再使用。\r\n\r\n#### Transaction CreateReadTxn()"
            },
            {
                "content": "For internal use only. Users should use Galaxy::OpenGraph() to get GraphDB.  \r\n仅供内部使用。用户应使用Galaxy::OpenGraph()获取GraphDB。\r\n\r\n#### GraphDB(GraphDB&&)\r\n#### GraphDB &operator=(GraphDB&&)\r\n#### ~GraphDB()\r\n#### void Close()\r\nClose the graph. This will close the graph and release all transactions, iterators associated with the graph. After calling Close(), the graph becomes invalid, and cannot be used anymore.  \r\n关闭图。此操作将关闭图并释放与图相关的所有事务和迭代器。调用Close()后，图将变为无效，无法再使用。\r\n\r\n#### Transaction CreateReadTxn()\r\nCreates a read transaction.  \r\n创建一个读事务。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe new read transaction.  \r\n新的读事务。\r\n\r\n#### Transaction CreateWriteTxn(bool optimistic = false)"
            },
            {
                "content": "关闭图。此操作将关闭图并释放与图相关的所有事务和迭代器。调用Close()后，图将变为无效，无法再使用。\r\n\r\n#### Transaction CreateReadTxn()\r\nCreates a read transaction.  \r\n创建一个读事务。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe new read transaction.  \r\n新的读事务。\r\n\r\n#### Transaction CreateWriteTxn(bool optimistic = false)\r\nCreates a write transaction. Write operations can only be performed in write transactions, otherwise exceptions will be thrown. A write transaction can be optimistic. Optimistic transactions can run in parallel and any conflict will be detected during commit. If a transaction conflicts with an earlier one, a TxnConflict will be thrown during commit.  \r\n创建一个写事务。写操作仅能在写事务中执行，否则会抛出异常。写事务可以是乐观的。乐观事务可以并行运行，任何冲突将在提交时被检测到。如果事务与先前事务冲突，提交时将抛出TxnConflict。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。"
            },
            {
                "content": "创建一个写事务。写操作仅能在写事务中执行，否则会抛出异常。写事务可以是乐观的。乐观事务可以并行运行，任何冲突将在提交时被检测到。如果事务与先前事务冲突，提交时将抛出TxnConflict。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n**参数**  \r\n- optimistic – (Optional) True to create an optimistic transaction.  \r\n- optimistic –（可选）True以创建乐观事务。\r\n\r\n**返回**  \r\nThe new write transaction.  \r\n新的写事务。\r\n\r\n#### Transaction ForkTxn(Transaction &txn)\r\nForks a read transaction. The resulting read transaction will share the same view as the forked one, meaning that when reads are performed on the same vertex/edge, the results will always be identical, whether they are performed in the original transaction or the forked one. Only read transactions can be forked. Calling ForkTxn() on a write txn causes an InvalidFork to be thrown."
            },
            {
                "content": "**返回**  \r\nThe new write transaction.  \r\n新的写事务。\r\n\r\n#### Transaction ForkTxn(Transaction &txn)\r\nForks a read transaction. The resulting read transaction will share the same view as the forked one, meaning that when reads are performed on the same vertex/edge, the results will always be identical, whether they are performed in the original transaction or the forked one. Only read transactions can be forked. Calling ForkTxn() on a write txn causes an InvalidFork to be thrown.  \r\n分叉一个读事务。结果读事务将与被分叉的事务共享相同的视图，这意味着当在同一个顶点/边上执行读取时，无论是在原始事务中还是分叉事务中执行，结果总是相同的。只有读事务可以被分叉。在写事务上调用ForkTxn()会导致抛出InvalidFork。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- InvalidFork – Thrown when txn is a write transaction.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InvalidFork – 当txn是一个写事务时抛出。\r\n\r\n**参数**  \r\n- txn – [in] The read transaction to be forked.  \r\n- txn – [in] 要分叉的读事务。\r\n\r\n**返回**  \r\nA new read Transaction that shares the same view with txn.  \r\n一个新的读事务，与txn共享相同的视图。\r\n\r\n#### void Flush()"
            },
            {
                "content": "**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- InvalidFork – Thrown when txn is a write transaction.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InvalidFork – 当txn是一个写事务时抛出。\r\n\r\n**参数**  \r\n- txn – [in] The read transaction to be forked.  \r\n- txn – [in] 要分叉的读事务。\r\n\r\n**返回**  \r\nA new read Transaction that shares the same view with txn.  \r\n一个新的读事务，与txn共享相同的视图。\r\n\r\n#### void Flush()\r\nFlushes buffered data to disk. If there have been some async transactions, there could be data that are written to this graph, but not persisted to disk yet. Calling Flush() will persist the data and prevent data loss in case of system crash.  \r\n将缓冲数据刷新到磁盘。如果存在一些异步事务，可能有数据已写入此图，但尚未持久化到磁盘。调用Flush()将持久化数据，并防止在系统崩溃时丢失数据。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n#### void DropAllData()\r\nDrop all the data in the graph, including labels, indexes and vertexes/edges.  \r\n删除图中的所有数据，包括标签、索引和顶点/边。\r\n\r\n**抛出**"
            },
            {
                "content": "将缓冲数据刷新到磁盘。如果存在一些异步事务，可能有数据已写入此图，但尚未持久化到磁盘。调用Flush()将持久化数据，并防止在系统崩溃时丢失数据。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n#### void DropAllData()\r\nDrop all the data in the graph, including labels, indexes and vertexes/edges.  \r\n删除图中的所有数据，包括标签、索引和顶点/边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n#### void DropAllVertex()\r\nDrop all vertex and edges but keep the labels and indexes.  \r\n删除所有顶点和边，但保留标签和索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n#### size_t EstimateNumVertices()"
            },
            {
                "content": "- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n#### void DropAllVertex()\r\nDrop all vertex and edges but keep the labels and indexes.  \r\n删除所有顶点和边，但保留标签和索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n#### size_t EstimateNumVertices()\r\nEstimate number of vertices. We don’t maintain the exact number of vertices, but only the next vid. This function actually returns the next vid to be used. So if you have deleted a lot of vertices, the result can be quite different from actual number of vertices.  \r\n估算顶点数量。我们并不维护确切的顶点数量，而只是维护下一个vid。此函数实际上返回即将使用的下一个vid。因此，如果您删除了很多顶点，则结果可能与实际顶点数量差异很大。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nEstimated number of vertices.  \r\n估计的顶点数量。"
            },
            {
                "content": "估算顶点数量。我们并不维护确切的顶点数量，而只是维护下一个vid。此函数实际上返回即将使用的下一个vid。因此，如果您删除了很多顶点，则结果可能与实际顶点数量差异很大。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nEstimated number of vertices.  \r\n估计的顶点数量。\r\n\r\n#### bool AddVertexLabel(const std::string &label, const std::vector &fds, const VertexOptions &options)\r\nAdds a vertex label.  \r\n添加一个顶点标签。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if the schema is illegal.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果模式不合法，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- fds – The field specifications.  \r\n- primary_field – The primary field.  \r\n- label – 标签名称。  \r\n- fds – 字段规范。  \r\n- primary_field – 主字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label already exists.  \r\n如果成功则返回True，如果标签已存在则返回false。"
            },
            {
                "content": "- InputError – Thrown if the schema is illegal.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果模式不合法，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- fds – The field specifications.  \r\n- primary_field – The primary field.  \r\n- label – 标签名称。  \r\n- fds – 字段规范。  \r\n- primary_field – 主字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label already exists.  \r\n如果成功则返回True，如果标签已存在则返回false。\r\n\r\n#### bool DeleteVertexLabel(const std::string &label, size_t *n_modified = nullptr)\r\nDeletes a vertex label and all the vertices with this label.  \r\n删除一个顶点标签及其所有顶点。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- n_modified – [out] (Optional) If non-null, return the number of deleted vertices.  \r\n- label – 标签名称。"
            },
            {
                "content": "Deletes a vertex label and all the vertices with this label.  \r\n删除一个顶点标签及其所有顶点。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- n_modified – [out] (Optional) If non-null, return the number of deleted vertices.  \r\n- label – 标签名称。  \r\n- n_modified – [out]（可选）如果不为null，返回删除的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelDelFields(const std::string &label, const std::vector &del_fields, size_t *n_modified = nullptr)\r\nDeletes fields in a vertex label. This function also updates the vertex data and indices accordingly to make sure the database remains in a consistent state.  \r\n删除顶点标签中的字段。此函数还会相应地更新顶点数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**"
            },
            {
                "content": "- label – 标签名称。  \r\n- n_modified – [out]（可选）如果不为null，返回删除的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelDelFields(const std::string &label, const std::vector &del_fields, size_t *n_modified = nullptr)\r\nDeletes fields in a vertex label. This function also updates the vertex data and indices accordingly to make sure the database remains in a consistent state.  \r\n删除顶点标签中的字段。此函数还会相应地更新顶点数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if field not found, or some fields cannot be deleted.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果未找到字段，或者某些字段无法删除，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- del_fields – Labels of the fields to be deleted."
            },
            {
                "content": "删除顶点标签中的字段。此函数还会相应地更新顶点数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if field not found, or some fields cannot be deleted.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果未找到字段，或者某些字段无法删除，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- del_fields – Labels of the fields to be deleted.  \r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.  \r\n- label – 标签名称。  \r\n- del_fields – 要删除字段的标签。  \r\n- n_modified – [out]（可选）如果不为null，返回修改后的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelAddFields(const std::string &label, const std::vector &add_fields, const std::vector &default_values, size_t *n_modified = nullptr)"
            },
            {
                "content": "- del_fields – Labels of the fields to be deleted.  \r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.  \r\n- label – 标签名称。  \r\n- del_fields – 要删除字段的标签。  \r\n- n_modified – [out]（可选）如果不为null，返回修改后的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelAddFields(const std::string &label, const std::vector &add_fields, const std::vector &default_values, size_t *n_modified = nullptr)\r\nAdd fields to a vertex label. The new fields in existing vertices will be filled with default values.  \r\n向顶点标签添加字段。现有顶点中的新字段将填充默认值。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if field already exists.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果字段已存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label name."
            },
            {
                "content": "Add fields to a vertex label. The new fields in existing vertices will be filled with default values.  \r\n向顶点标签添加字段。现有顶点中的新字段将填充默认值。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if field already exists.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果字段已存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- add_fields – The add fields.  \r\n- default_values – The default values of the newly added fields.  \r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.  \r\n- label – 标签名称。  \r\n- add_fields – 添加的字段。  \r\n- default_values – 新添加字段的默认值。  \r\n- n_modified – [out]（可选）如果不为null，返回修改后的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。"
            },
            {
                "content": "- InputError – 如果字段已存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- add_fields – The add fields.  \r\n- default_values – The default values of the newly added fields.  \r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.  \r\n- label – 标签名称。  \r\n- add_fields – 添加的字段。  \r\n- default_values – 新添加字段的默认值。  \r\n- n_modified – [out]（可选）如果不为null，返回修改后的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelModFields(const std::string &label, const std::vector &mod_fields, size_t *n_modified = nullptr)\r\nModify fields in a vertex label, either change the data type or optional, or both.\r\n// 修改顶点标签中的字段，可以改变数据类型、选项，或两者均可。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or is of incompatible data type."
            },
            {
                "content": "Modify fields in a vertex label, either change the data type or optional, or both.\r\n// 修改顶点标签中的字段，可以改变数据类型、选项，或两者均可。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or is of incompatible data type.\r\n// 如果找不到字段或者字段的数据类型不兼容，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- mod_fields – The new specification of the modified fields.\r\n// 修改字段的新规格。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.\r\n// [输出]（可选）如果非空，返回修改的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AddEdgeLabel(const std::string &label, const std::vector &fds, const EdgeOptions &options)"
            },
            {
                "content": "// 如果找不到字段或者字段的数据类型不兼容，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- mod_fields – The new specification of the modified fields.\r\n// 修改字段的新规格。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.\r\n// [输出]（可选）如果非空，返回修改的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AddEdgeLabel(const std::string &label, const std::vector &fds, const EdgeOptions &options)\r\nAdd an edge label, specifying its schema. It is allowed to specify edge constraints, too. An edge can be bound to several (source_label, destination_label) pairs, which makes sure this type of edges will only be added between these types of vertices. By default, the constraint is empty, meaning that the edge is not restricted.\r\n// 添加边标签，指定其模式。也允许指定边约束。一个边可以绑定到多个 (source_label, destination_label) 对，这确保这种类型的边只会在这些类型的顶点之间添加。默认情况下，约束为空，意味着边没有限制。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。"
            },
            {
                "content": "// 添加边标签，指定其模式。也允许指定边约束。一个边可以绑定到多个 (source_label, destination_label) 对，这确保这种类型的边只会在这些类型的顶点之间添加。默认情况下，约束为空，意味着边没有限制。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – if invalid schema (invalid specification, re-definition of the same field, etc.).\r\n// 如果模式无效（规格无效、重新定义相同字段等）则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- fds – The field specifications.\r\n// 字段规格。\r\n- options – The edge options.\r\n// 边选项。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label already exists.\r\n// 如果成功返回真，如果标签已经存在则返回假。\r\n\r\n#### bool DeleteEdgeLabel(const std::string &label, size_t *n_modified = nullptr)\r\nDeletes an edge label and all the edges with this label.\r\n// 删除边标签及其所有相关的边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。"
            },
            {
                "content": "**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- fds – The field specifications.\r\n// 字段规格。\r\n- options – The edge options.\r\n// 边选项。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label already exists.\r\n// 如果成功返回真，如果标签已经存在则返回假。\r\n\r\n#### bool DeleteEdgeLabel(const std::string &label, size_t *n_modified = nullptr)\r\nDeletes an edge label and all the edges with this label.\r\n// 删除边标签及其所有相关的边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- n_modified – [out] (Optional) If non-null, return the number of deleted edges.\r\n// [输出]（可选）如果非空，返回已删除边的数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelDelFields(const std::string &label, const std::vector &del_fields, size_t *n_modified = nullptr)"
            },
            {
                "content": "// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- n_modified – [out] (Optional) If non-null, return the number of deleted edges.\r\n// [输出]（可选）如果非空，返回已删除边的数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelDelFields(const std::string &label, const std::vector &del_fields, size_t *n_modified = nullptr)\r\nDeletes fields in an edge label. This function also updates the edge data and indices accordingly to make sure the database remains in a consistent state.\r\n// 删除边标签中的字段。此函数还会相应地更新边数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or some fields cannot be deleted."
            },
            {
                "content": "Deletes fields in an edge label. This function also updates the edge data and indices accordingly to make sure the database remains in a consistent state.\r\n// 删除边标签中的字段。此函数还会相应地更新边数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or some fields cannot be deleted.\r\n// 如果找不到字段，或者某些字段无法被删除，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- del_fields – Labels of the fields to be deleted.\r\n// 要删除的字段标签。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelAddFields(const std::string &label, const std::vector &add_fields, const std::vector &default_values, size_t *n_modified = nullptr)"
            },
            {
                "content": "// 如果找不到字段，或者某些字段无法被删除，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- del_fields – Labels of the fields to be deleted.\r\n// 要删除的字段标签。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelAddFields(const std::string &label, const std::vector &add_fields, const std::vector &default_values, size_t *n_modified = nullptr)\r\nAdd fields to an edge label. The new fields in existing edges will be filled with default values.\r\n// 向边标签添加字段。现有边中的新字段将填充默认值。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field already exists.\r\n// 如果字段已经存在则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- add_fields – The add fields.\r\n// 添加的字段。"
            },
            {
                "content": "Add fields to an edge label. The new fields in existing edges will be filled with default values.\r\n// 向边标签添加字段。现有边中的新字段将填充默认值。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field already exists.\r\n// 如果字段已经存在则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- add_fields – The add fields.\r\n// 添加的字段。\r\n- default_values – The default values of the newly added fields.\r\n// 新添加字段的默认值。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelModFields(const std::string &label, const std::vector &mod_fields, size_t *n_modified = nullptr)\r\nModify fields in an edge label, either change the data type or optional, or both.\r\n// 修改边标签中的字段，可以改变数据类型、选项，或两者均可。"
            },
            {
                "content": "// 新添加字段的默认值。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelModFields(const std::string &label, const std::vector &mod_fields, size_t *n_modified = nullptr)\r\nModify fields in an edge label, either change the data type or optional, or both.\r\n// 修改边标签中的字段，可以改变数据类型、选项，或两者均可。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or is of incompatible data type.\r\n// 如果找不到字段或者字段的数据类型不兼容，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- mod_fields – The new specification of the modified fields.\r\n// 修改字段的新规格。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**"
            },
            {
                "content": "// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or is of incompatible data type.\r\n// 如果找不到字段或者字段的数据类型不兼容，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- mod_fields – The new specification of the modified fields.\r\n// 修改字段的新规格。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n\r\n#### bool AddVertexIndex(const std::string &label, const std::string &field, IndexType type)\r\nAdds an index to ‘label:field’. This function blocks until the index is fully created.\r\n// 为 'label:field' 添加索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。"
            },
            {
                "content": "// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n\r\n#### bool AddVertexIndex(const std::string &label, const std::string &field, IndexType type)\r\nAdds an index to ‘label:field’. This function blocks until the index is fully created.\r\n// 为 'label:field' 添加索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- field – The field name.\r\n// 字段名称。\r\n- is_unique – True if it's a unique index, false if not.\r\n// 如果是唯一索引则为真，不是则为假。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool AddEdgeIndex(const std::string &label, const std::string &field, IndexType type)\r\nAdds an index to ‘label:field’. This function blocks until the index is fully created."
            },
            {
                "content": "// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- field – The field name.\r\n// 字段名称。\r\n- is_unique – True if it's a unique index, false if not.\r\n// 如果是唯一索引则为真，不是则为假。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool AddEdgeIndex(const std::string &label, const std::string &field, IndexType type)\r\nAdds an index to ‘label:field’. This function blocks until the index is fully created.\r\n// 为 'label:field' 添加索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n- is_unique – True if the field content is unique for each vertex.\r\n// 如果字段内容对每个顶点都是唯一的，则为真。\r\n\r\n**返回**"
            },
            {
                "content": "**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n- is_unique – True if the field content is unique for each vertex.\r\n// 如果字段内容对每个顶点都是唯一的，则为真。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool AddVertexCompositeIndex(const std::string &label, const std::vector &fields, CompositeIndexType type)\r\n\r\n#### bool AddVectorIndex(bool is_vertex, const std::string &label, const std::string &field, const std::string &index_type, int vec_dimension, const std::string &distance_type, std::vector &index_spec)\r\nAdds a vector index to ‘label:field’. This function blocks until the index is fully created."
            },
            {
                "content": "True if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool AddVertexCompositeIndex(const std::string &label, const std::vector &fields, CompositeIndexType type)\r\n\r\n#### bool AddVectorIndex(bool is_vertex, const std::string &label, const std::string &field, const std::string &index_type, int vec_dimension, const std::string &distance_type, std::vector &index_spec)\r\nAdds a vector index to ‘label:field’. This function blocks until the index is fully created.\r\n// 为 'label:field' 添加向量索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- is_vertex – Vertex or edge.\r\n// 顶点或边。\r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。"
            },
            {
                "content": "// 为 'label:field' 添加向量索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- is_vertex – Vertex or edge.\r\n// 顶点或边。\r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n- is_unique – True if the field content is unique for each vertex.\r\n// 如果字段内容对每个顶点都是唯一的，则为真。\r\n- index_type – Type of the index.\r\n// 索引类型。\r\n- vec_dimension – Dimension of the vector.\r\n// 向量的维度。\r\n- distance_type – Type of the distance.\r\n// 距离的类型。\r\n- index_spec – Specification of the index.\r\n// 索引的规格。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool IsVertexIndexed(const std::string &label, const std::string &field)\r\nCheck if this vertex_label:field is indexed."
            },
            {
                "content": "// 如果字段内容对每个顶点都是唯一的，则为真。\r\n- index_type – Type of the index.\r\n// 索引类型。\r\n- vec_dimension – Dimension of the vector.\r\n// 向量的维度。\r\n- distance_type – Type of the distance.\r\n// 距离的类型。\r\n- index_spec – Specification of the index.\r\n// 索引的规格。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool IsVertexIndexed(const std::string &label, const std::string &field)\r\nCheck if this vertex_label:field is indexed.\r\n// 检查这个 vertex_label:field 是否被索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- InputError – Thrown if label:field does not exist.\r\n// 如果 label:field 不存在则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if index exists, false if label:field exists but not indexed.\r\n// 如果索引存在则返回真，如果 label:field 存在但没有被索引则返回假。\r\n\r\n---\r\n\r\n#### bool IsEdgeIndexed(const std::string &label, const std::string &field)\r\nCheck if this edge_label:field is indexed."
            },
            {
                "content": "**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- InputError – Thrown if label:field does not exist.\r\n// 如果 label:field 不存在则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if index exists, false if label:field exists but not indexed.\r\n// 如果索引存在则返回真，如果 label:field 存在但没有被索引则返回假。\r\n\r\n---\r\n\r\n#### bool IsEdgeIndexed(const std::string &label, const std::string &field)\r\nCheck if this edge_label:field is indexed.\r\n// 检查这个 edge_label:field 是否被索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- InputError – Thrown if label:field does not exist.\r\n// 如果 label:field 不存在则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if index exists, false if label:field exists but not indexed.\r\n// 如果索引存在则返回真，如果 label:field 存在但没有被索引则返回假。\r\n\r\n---\r\n\r\n#### bool IsVertexCompositeIndexed(const std::string &label, const std::vector &field)"
            },
            {
                "content": "// 检查这个 edge_label:field 是否被索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- InputError – Thrown if label:field does not exist.\r\n// 如果 label:field 不存在则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if index exists, false if label:field exists but not indexed.\r\n// 如果索引存在则返回真，如果 label:field 存在但没有被索引则返回假。\r\n\r\n---\r\n\r\n#### bool IsVertexCompositeIndexed(const std::string &label, const std::vector &field)\r\n\r\n#### bool DeleteVertexIndex(const std::string &label, const std::string &field)\r\nDeletes the index to ‘vertex_label:field’.\r\n// 删除对 'vertex_label:field' 的索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。"
            },
            {
                "content": "Deletes the index to ‘vertex_label:field’.\r\n// 删除对 'vertex_label:field' 的索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### bool DeleteVertexCompositeIndex(const std::string &label, const std::vector &fields)\r\n\r\n#### bool DeleteEdgeIndex(const std::string &label, const std::string &field)\r\nDeletes the index to ‘edge_label:field’.\r\n// 删除对 'edge_label:field' 的索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。"
            },
            {
                "content": "// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### bool DeleteVertexCompositeIndex(const std::string &label, const std::vector &fields)\r\n\r\n#### bool DeleteEdgeIndex(const std::string &label, const std::string &field)\r\nDeletes the index to ‘edge_label:field’.\r\n// 删除对 'edge_label:field' 的索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### bool DeleteVectorIndex(bool is_vertex, const std::string &label, const std::string &field)\r\nDeletes the vector index to ‘vertex_label:field’.\r\n// 删除对 'vertex_label:field' 的向量索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。"
            },
            {
                "content": "// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### bool DeleteVectorIndex(bool is_vertex, const std::string &label, const std::string &field)\r\nDeletes the vector index to ‘vertex_label:field’.\r\n// 删除对 'vertex_label:field' 的向量索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- is_vertex – Vertex or edge.\r\n// 顶点或边。\r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### std::string GetDescription() const\r\nGet graph description.\r\n获取图形描述。\r\n\r\n**抛出**"
            },
            {
                "content": "- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- is_vertex – Vertex or edge.\r\n// 顶点或边。\r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### std::string GetDescription() const\r\nGet graph description.\r\n获取图形描述。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n抛出异常：InvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe description.\r\n返回图形描述。\r\n\r\n---\r\n\r\n#### size_t GetMaxSize() const\r\nGet maximum graph size.\r\n获取最大图形大小。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n抛出异常：InvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe maximum size.\r\n返回最大大小。\r\n\r\n---\r\n\r\n#### bool AddVertexFullTextIndex(const std::string &vertex_label, const std::string &field)\r\nAdd fulltext index to ‘vertex_label:field’."
            },
            {
                "content": "抛出异常：InvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe description.\r\n返回图形描述。\r\n\r\n---\r\n\r\n#### size_t GetMaxSize() const\r\nGet maximum graph size.\r\n获取最大图形大小。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n抛出异常：InvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe maximum size.\r\n返回最大大小。\r\n\r\n---\r\n\r\n#### bool AddVertexFullTextIndex(const std::string &vertex_label, const std::string &field)\r\nAdd fulltext index to ‘vertex_label:field’.\r\n将全文索引添加到‘vertex_label:field’。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if vertex label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果顶点标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- vertex_label – The vertex label.\r\n顶点标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index already exists."
            },
            {
                "content": "**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if vertex label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果顶点标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- vertex_label – The vertex label.\r\n顶点标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index already exists.\r\n如果成功返回true，如果全文索引已存在则返回false。\r\n\r\n---\r\n\r\n#### bool AddEdgeFullTextIndex(const std::string &edge_label, const std::string &field)\r\nAdd fulltext index to ‘edge_label:field’.\r\n将全文索引添加到‘edge_label:field’。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if edge label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。"
            },
            {
                "content": "如果成功返回true，如果全文索引已存在则返回false。\r\n\r\n---\r\n\r\n#### bool AddEdgeFullTextIndex(const std::string &edge_label, const std::string &field)\r\nAdd fulltext index to ‘edge_label:field’.\r\n将全文索引添加到‘edge_label:field’。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if edge label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果边标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- edge_label – The edge label.\r\n边标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index already exists.\r\n如果成功返回true，如果全文索引已存在则返回false。\r\n\r\n---\r\n\r\n#### bool DeleteVertexFullTextIndex(const std::string &vertex_label, const std::string &field)\r\nDelete the fulltext index of ‘vertex_label:field’.\r\n删除‘vertex_label:field’的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid."
            },
            {
                "content": "- InputError – 如果边标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- edge_label – The edge label.\r\n边标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index already exists.\r\n如果成功返回true，如果全文索引已存在则返回false。\r\n\r\n---\r\n\r\n#### bool DeleteVertexFullTextIndex(const std::string &vertex_label, const std::string &field)\r\nDelete the fulltext index of ‘vertex_label:field’.\r\n删除‘vertex_label:field’的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if vertex label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果顶点标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- vertex_label – The vertex label.\r\n顶点标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index does not exist.\r\n如果成功返回true，如果全文索引不存在则返回false。\r\n\r\n---"
            },
            {
                "content": "- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if vertex label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果顶点标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- vertex_label – The vertex label.\r\n顶点标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index does not exist.\r\n如果成功返回true，如果全文索引不存在则返回false。\r\n\r\n---\r\n\r\n#### bool DeleteEdgeFullTextIndex(const std::string &edge_label, const std::string &field)\r\nDelete the fulltext index of ‘edge_label:field’.\r\n删除‘edge_label:field’的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if edge label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果边标签或字段不存在，则抛出。  \r\n\r\n**参数**"
            },
            {
                "content": "Delete the fulltext index of ‘edge_label:field’.\r\n删除‘edge_label:field’的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if edge label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果边标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- edge_label – The edge label.\r\n边标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index does not exist.\r\n如果成功返回true，如果全文索引不存在则返回false。\r\n\r\n---\r\n\r\n#### void RebuildFullTextIndex(const std::set &vertex_labels, const std::set &edge_labels)\r\nRebuild the fulltext index of vertex_labels and edge_labels.\r\n重建顶点标签和边标签的全文索引。\r\n\r\n**参数**  \r\n- vertex_labels – The vertex labels whose fulltext index need to be rebuilt.\r\n需要重建全文索引的顶点标签。\r\n\r\n- edge_labels – The edge labels whose fulltext index need to be rebuilt.\r\n需要重建全文索引的边标签。\r\n\r\n---"
            },
            {
                "content": "字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index does not exist.\r\n如果成功返回true，如果全文索引不存在则返回false。\r\n\r\n---\r\n\r\n#### void RebuildFullTextIndex(const std::set &vertex_labels, const std::set &edge_labels)\r\nRebuild the fulltext index of vertex_labels and edge_labels.\r\n重建顶点标签和边标签的全文索引。\r\n\r\n**参数**  \r\n- vertex_labels – The vertex labels whose fulltext index need to be rebuilt.\r\n需要重建全文索引的顶点标签。\r\n\r\n- edge_labels – The edge labels whose fulltext index need to be rebuilt.\r\n需要重建全文索引的边标签。\r\n\r\n---\r\n\r\n#### std::vector> ListFullTextIndexes()\r\nList fulltext indexes of vertex and edge.\r\n列出顶点和边的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n\r\n**返回**  \r\nFormat of returned data: (is_vertex, label_name, property_name).\r\n返回数据格式：(is_vertex, label_name, property_name)。\r\n\r\n---"
            },
            {
                "content": "需要重建全文索引的边标签。\r\n\r\n---\r\n\r\n#### std::vector> ListFullTextIndexes()\r\nList fulltext indexes of vertex and edge.\r\n列出顶点和边的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n\r\n**返回**  \r\nFormat of returned data: (is_vertex, label_name, property_name).\r\n返回数据格式：(is_vertex, label_name, property_name)。\r\n\r\n---\r\n\r\n#### std::vector> QueryVertexByFullTextIndex(const std::string &label, const std::string &query, int top_n)\r\nQuery vertex by fulltext index.\r\n通过全文索引查询顶点。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- InputError – Thrown if label does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InputError – 如果标签不存在，则抛出。  \r\n\r\n**参数**  \r\n- label – The vertex label.\r\n标签 – 顶点标签。\r\n\r\n- query – Lucene query language.\r\n查询 – Lucene查询语言。\r\n\r\n- top_n – Return top n data.\r\ntop_n – 返回前n条数据。"
            },
            {
                "content": "Query vertex by fulltext index.\r\n通过全文索引查询顶点。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- InputError – Thrown if label does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InputError – 如果标签不存在，则抛出。  \r\n\r\n**参数**  \r\n- label – The vertex label.\r\n标签 – 顶点标签。\r\n\r\n- query – Lucene query language.\r\n查询 – Lucene查询语言。\r\n\r\n- top_n – Return top n data.\r\ntop_n – 返回前n条数据。\r\n\r\n**返回**  \r\nVertex vids and score. Throws exception on error.\r\n返回顶点的vid和分数。发生错误时抛出异常。\r\n\r\n---\r\n\r\n#### std::vector> QueryEdgeByFullTextIndex(const std::string &label, const std::string &query, int top_n)\r\nQuery edge by fulltext index.\r\n通过全文索引查询边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- InputError – Thrown if label does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InputError – 如果标签不存在，则抛出。  \r\n\r\n**参数**  \r\n- label – The edge label.\r\n标签 – 边标签。\r\n\r\n- query – Lucene query language.\r\n查询 – Lucene查询语言。\r\n\r\n- top_n – Return top n data.\r\ntop_n – 返回前n条数据。\r\n\r\n**返回**"
            },
            {
                "content": "Query edge by fulltext index.\r\n通过全文索引查询边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- InputError – Thrown if label does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InputError – 如果标签不存在，则抛出。  \r\n\r\n**参数**  \r\n- label – The edge label.\r\n标签 – 边标签。\r\n\r\n- query – Lucene query language.\r\n查询 – Lucene查询语言。\r\n\r\n- top_n – Return top n data.\r\ntop_n – 返回前n条数据。\r\n\r\n**返回**  \r\nEdge uids and score. Throws exception on error.\r\n返回边的uids和分数。发生错误时抛出异常。\r\n\r\n---\r\n\r\n#### void RefreshCount()\r\nRecount the total number of vertex and edge, stop writing during the count.\r\n重新计算顶点和边的总数，在计数期间停止写入。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n\r\n---\r\n\r\n### Private Functions\r\n\r\n#### GraphDB(const GraphDB&) = delete\r\nCopying is disabled.\r\n复制功能被禁止。"
            },
            {
                "content": "---\r\n\r\n#### void RefreshCount()\r\nRecount the total number of vertex and edge, stop writing during the count.\r\n重新计算顶点和边的总数，在计数期间停止写入。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n\r\n---\r\n\r\n### Private Functions\r\n\r\n#### GraphDB(const GraphDB&) = delete\r\nCopying is disabled.\r\n复制功能被禁止。\r\n\r\n#### GraphDB &operator=(const GraphDB&) = delete\r\n赋值操作被禁止。\r\n\r\n### Private Members\r\n\r\n#### lgraph::AccessControlledDB *db_\r\n数据库指针。\r\n\r\n#### bool should_delete_db_ = false\r\n是否应该删除数据库的标志，默认值为false。\r\n\r\n#### bool read_only_ = false\r\n是否只读的标志，默认值为false。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_edge_index_iterator\r\n\r\n```cpp\r\nnamespace lgraph {\r\nnamespace lgraph_api {\r\nclass EdgeIndexIterator {\r\n#include \r\n```"
            },
            {
                "content": "---\r\n\r\n### Private Functions\r\n\r\n#### GraphDB(const GraphDB&) = delete\r\nCopying is disabled.\r\n复制功能被禁止。\r\n\r\n#### GraphDB &operator=(const GraphDB&) = delete\r\n赋值操作被禁止。\r\n\r\n### Private Members\r\n\r\n#### lgraph::AccessControlledDB *db_\r\n数据库指针。\r\n\r\n#### bool should_delete_db_ = false\r\n是否应该删除数据库的标志，默认值为false。\r\n\r\n#### bool read_only_ = false\r\n是否只读的标志，默认值为false。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_edge_index_iterator\r\n\r\n```cpp\r\nnamespace lgraph {\r\nnamespace lgraph_api {\r\nclass EdgeIndexIterator {\r\n#include \r\n```\r\n\r\n`EdgeIndexIterator` can be used to access a set of edges that has the same indexed value. 如果索引是唯一的（即每条边具有唯一的索引值），那么每个 `EdgeIndexIterator` 只会有一个边的唯一 ID，并且在调用 `Next()` 后将变得无效。\r\n\r\nAn `EdgeIndexIterator` is valid iff it points to a valid `(index_value, euid)` pair; otherwise, it is invalid. `EdgeIndexIterator` 在指向有效的 `(index_value, euid)` 对时有效；否则，它是无效的。调用无效 `EdgeIndexIterator` 的成员函数会抛出异常，唯一不抛出异常的函数是 `IsValid()`。\r\n\r\n### Public Functions\r\n\r\n- **EdgeIndexIterator(EdgeIndexIterator &&rhs)**"
            },
            {
                "content": "#include \r\n```\r\n\r\n`EdgeIndexIterator` can be used to access a set of edges that has the same indexed value. 如果索引是唯一的（即每条边具有唯一的索引值），那么每个 `EdgeIndexIterator` 只会有一个边的唯一 ID，并且在调用 `Next()` 后将变得无效。\r\n\r\nAn `EdgeIndexIterator` is valid iff it points to a valid `(index_value, euid)` pair; otherwise, it is invalid. `EdgeIndexIterator` 在指向有效的 `(index_value, euid)` 对时有效；否则，它是无效的。调用无效 `EdgeIndexIterator` 的成员函数会抛出异常，唯一不抛出异常的函数是 `IsValid()`。\r\n\r\n### Public Functions\r\n\r\n- **EdgeIndexIterator(EdgeIndexIterator &&rhs)**\r\n\r\n- **EdgeIndexIterator &operator=(EdgeIndexIterator&&)**\r\n\r\n- **~EdgeIndexIterator()**\r\n\r\n- **void Close()**\r\n  - Closes this iterator.\r\n  - 关闭此迭代器。\r\n\r\n- **bool IsValid() const**\r\n  - Query if this iterator is valid, i.e., the Key and Vid can be queried.\r\n  - 查询此迭代器是否有效，即 Key 和 Vid 是否可以查询。\r\n  \r\n  **返回**\r\n  - True if valid, false if not.\r\n  - 如果有效返回 True，如果无效返回 false。\r\n\r\n- **bool Next()**"
            },
            {
                "content": "### Public Functions\r\n\r\n- **EdgeIndexIterator(EdgeIndexIterator &&rhs)**\r\n\r\n- **EdgeIndexIterator &operator=(EdgeIndexIterator&&)**\r\n\r\n- **~EdgeIndexIterator()**\r\n\r\n- **void Close()**\r\n  - Closes this iterator.\r\n  - 关闭此迭代器。\r\n\r\n- **bool IsValid() const**\r\n  - Query if this iterator is valid, i.e., the Key and Vid can be queried.\r\n  - 查询此迭代器是否有效，即 Key 和 Vid 是否可以查询。\r\n  \r\n  **返回**\r\n  - True if valid, false if not.\r\n  - 如果有效返回 True，如果无效返回 false。\r\n\r\n- **bool Next()**\r\n  - Move to the next edge unique id in the list, which consists of all the valid edge unique ids of the iterator and is sorted from small to large. If we hit the end of the list, the iterator will become invalid and false is returned.\r\n  - 移动到列表中的下一个边的唯一 ID，该列表由迭代器的所有有效边的唯一 ID 组成，并按从小到大的顺序排序。如果到达列表的末尾，则迭代器将变为无效并返回 false。\r\n  \r\n  **返回**\r\n  - True if it succeeds, otherwise false.\r\n  - 如果成功返回 True，否则返回 false。\r\n\r\n- **FieldData GetIndexValue() const**"
            },
            {
                "content": "- 如果有效返回 True，如果无效返回 false。\r\n\r\n- **bool Next()**\r\n  - Move to the next edge unique id in the list, which consists of all the valid edge unique ids of the iterator and is sorted from small to large. If we hit the end of the list, the iterator will become invalid and false is returned.\r\n  - 移动到列表中的下一个边的唯一 ID，该列表由迭代器的所有有效边的唯一 ID 组成，并按从小到大的顺序排序。如果到达列表的末尾，则迭代器将变为无效并返回 false。\r\n  \r\n  **返回**\r\n  - True if it succeeds, otherwise false.\r\n  - 如果成功返回 True，否则返回 false。\r\n\r\n- **FieldData GetIndexValue() const**\r\n  - Gets the current index value. The euids are sorted in `(EdgeIndexValue, euid)` order. When `Next()` is called, the iterator moves from one euid to the next, possibly moving from one `EdgeIndexValue` to another. This function tells the `EdgeIndexValue` currently pointed to.\r\n  - 获取当前的索引值。euids 按 `(EdgeIndexValue, euid)` 顺序排序。当调用 `Next()` 时，迭代器从一个 euid 移动到下一个，可能会从一个 `EdgeIndexValue` 移动到另一个。此函数返回当前指向的 `EdgeIndexValue`。\r\n  \r\n  **返回**\r\n  - The key.\r\n  - 返回键值。\r\n\r\n- **EdgeUid GetUid() const**"
            },
            {
                "content": "- Gets the current index value. The euids are sorted in `(EdgeIndexValue, euid)` order. When `Next()` is called, the iterator moves from one euid to the next, possibly moving from one `EdgeIndexValue` to another. This function tells the `EdgeIndexValue` currently pointed to.\r\n  - 获取当前的索引值。euids 按 `(EdgeIndexValue, euid)` 顺序排序。当调用 `Next()` 时，迭代器从一个 euid 移动到下一个，可能会从一个 `EdgeIndexValue` 移动到另一个。此函数返回当前指向的 `EdgeIndexValue`。\r\n  \r\n  **返回**\r\n  - The key.\r\n  - 返回键值。\r\n\r\n- **EdgeUid GetUid() const**\r\n  - Gets the Edge Unique Id.\r\n  - 获取边的唯一 ID。\r\n  \r\n  **返回**\r\n  - The UID.\r\n  - 返回 UID。\r\n\r\n- **int64_t GetSrc() const**\r\n  - Gets the source vertex id.\r\n  - 获取源顶点 ID。\r\n  \r\n  **返回**\r\n  - The source vertex id.\r\n  - 返回源顶点 ID。\r\n\r\n- **int64_t GetDst() const**\r\n  - Gets the destination of the edge.\r\n  - 获取边的目的地。\r\n  \r\n  **返回**\r\n  - The destination vertex id.\r\n  - 返回目的顶点 ID。\r\n\r\n- **size_t GetLabelId() const**\r\n  - Gets label id of this edge.\r\n  - 获取此边的标签 ID。\r\n  \r\n  **返回**\r\n  - The label identifier.\r\n  - 返回标签标识符。"
            },
            {
                "content": "- Gets the Edge Unique Id.\r\n  - 获取边的唯一 ID。\r\n  \r\n  **返回**\r\n  - The UID.\r\n  - 返回 UID。\r\n\r\n- **int64_t GetSrc() const**\r\n  - Gets the source vertex id.\r\n  - 获取源顶点 ID。\r\n  \r\n  **返回**\r\n  - The source vertex id.\r\n  - 返回源顶点 ID。\r\n\r\n- **int64_t GetDst() const**\r\n  - Gets the destination of the edge.\r\n  - 获取边的目的地。\r\n  \r\n  **返回**\r\n  - The destination vertex id.\r\n  - 返回目的顶点 ID。\r\n\r\n- **size_t GetLabelId() const**\r\n  - Gets label id of this edge.\r\n  - 获取此边的标签 ID。\r\n  \r\n  **返回**\r\n  - The label identifier.\r\n  - 返回标签标识符。\r\n\r\n- **int64_t GetEdgeId() const**\r\n  - Gets edge id.\r\n  - 获取边的 ID。\r\n  \r\n  **返回**\r\n  - The edge identifier.\r\n  - 返回边标识符。\r\n\r\n### Private Functions\r\n\r\n- **EdgeIndexIterator(lgraph::EdgeIndexIterator &⁢, const std::shared_ptr &txn)**\r\n\r\n- **EdgeIndexIterator(const EdgeIndexIterator&) = delete**\r\n\r\n- **EdgeIndexIterator &operator=(const EdgeIndexIterator&) = delete**\r\n\r\n### Private Members\r\n\r\n- **std::unique_ptr it_**\r\n\r\n- **std::shared_ptr txn_**\r\n\r\n### Friends\r\n\r\n- **friend class Transaction**"
            },
            {
                "content": "- Gets edge id.\r\n  - 获取边的 ID。\r\n  \r\n  **返回**\r\n  - The edge identifier.\r\n  - 返回边标识符。\r\n\r\n### Private Functions\r\n\r\n- **EdgeIndexIterator(lgraph::EdgeIndexIterator &⁢, const std::shared_ptr &txn)**\r\n\r\n- **EdgeIndexIterator(const EdgeIndexIterator&) = delete**\r\n\r\n- **EdgeIndexIterator &operator=(const EdgeIndexIterator&) = delete**\r\n\r\n### Private Members\r\n\r\n- **std::unique_ptr it_**\r\n\r\n- **std::shared_ptr txn_**\r\n\r\n### Friends\r\n\r\n- **friend class Transaction**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_edge_iterator\r\n\r\n### namespace lgraph\r\n### namespace graph\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n```cpp\r\nbool operator==(const OutEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const OutEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const InEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```"
            },
            {
                "content": "### namespace lgraph\r\n### namespace graph\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n```cpp\r\nbool operator==(const OutEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const OutEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const InEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const InEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const OutEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const OutEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```"
            },
            {
                "content": "```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const InEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const OutEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const OutEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const InEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const InEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n### class InEdgeIterator\r\n```cpp\r\n#include \r\n```"
            },
            {
                "content": "```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const InEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const InEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n### class InEdgeIterator\r\n```cpp\r\n#include \r\n```\r\nAn InEdgeIterator can be used to iterate through the in-coming edges of a vertex. Edges are sorted in (lid, tid, src, eid) order, and each (dst, lid, tid, src, eid) tuple is guaranteed to uniquely identify an edge.  // InEdgeIterator 可用于遍历一个顶点的入边。边按 (lid, tid, src, eid) 的顺序排序，每个 (dst, lid, tid, src, eid) 元组保证唯一标识一条边。"
            },
            {
                "content": "```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n### class InEdgeIterator\r\n```cpp\r\n#include \r\n```\r\nAn InEdgeIterator can be used to iterate through the in-coming edges of a vertex. Edges are sorted in (lid, tid, src, eid) order, and each (dst, lid, tid, src, eid) tuple is guaranteed to uniquely identify an edge.  // InEdgeIterator 可用于遍历一个顶点的入边。边按 (lid, tid, src, eid) 的顺序排序，每个 (dst, lid, tid, src, eid) 元组保证唯一标识一条边。\r\n\r\nAn InEdgeIterator is valid iff it points to a valid in-coming edge; otherwise, it is invalid. Calling member function on an invalid InEdgeIterator throws an exception, except for the IsValid() and Goto() functions.  // 当 InEdgeIterator 指向一个有效的入边时，它是有效的；否则，它是无效的。在无效的 InEdgeIterator 上调用成员函数会抛出异常，除了 IsValid() 和 Goto() 函数。\r\n\r\nThe following operations invalidate an InEdgeIterator:  // 以下操作会使 InEdgeIterator 无效：\r\n\r\n- Constructing an InEdgeIterator for non-existing edge.  // 为不存在的边构造 InEdgeIterator。"
            },
            {
                "content": "An InEdgeIterator is valid iff it points to a valid in-coming edge; otherwise, it is invalid. Calling member function on an invalid InEdgeIterator throws an exception, except for the IsValid() and Goto() functions.  // 当 InEdgeIterator 指向一个有效的入边时，它是有效的；否则，它是无效的。在无效的 InEdgeIterator 上调用成员函数会抛出异常，除了 IsValid() 和 Goto() 函数。\r\n\r\nThe following operations invalidate an InEdgeIterator:  // 以下操作会使 InEdgeIterator 无效：\r\n\r\n- Constructing an InEdgeIterator for non-existing edge.  // 为不存在的边构造 InEdgeIterator。\r\n- Calling Goto() with the id of a non-existing edge.  // 使用不存在的边的 ID 调用 Goto()。\r\n- Calling Next() on the last in-coming edge.  // 在最后一个入边上调用 Next()。\r\n- Calling Delete() on the last in-coming edge.  // 在最后一个入边上调用 Delete()。\r\n- Calling Close() on the iterator.  // 在迭代器上调用 Close()。"
            },
            {
                "content": "The following operations invalidate an InEdgeIterator:  // 以下操作会使 InEdgeIterator 无效：\r\n\r\n- Constructing an InEdgeIterator for non-existing edge.  // 为不存在的边构造 InEdgeIterator。\r\n- Calling Goto() with the id of a non-existing edge.  // 使用不存在的边的 ID 调用 Goto()。\r\n- Calling Next() on the last in-coming edge.  // 在最后一个入边上调用 Next()。\r\n- Calling Delete() on the last in-coming edge.  // 在最后一个入边上调用 Delete()。\r\n- Calling Close() on the iterator.  // 在迭代器上调用 Close()。\r\n\r\nIn TuGraph, every iterator belongs to a transaction, and can only be used when the transaction is valid. Calling member functions on an iterator inside an invalid transaction yields InvalidTxn, except for Invalid().  // 在 TuGraph 中，每个迭代器属于一个事务，只能在事务有效时使用。在无效事务中的迭代器上调用成员函数会返回 InvalidTxn，Invalid() 除外。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nInEdgeIterator(InEdgeIterator &&rhs)\r\n```\r\n\r\n```cpp\r\nInEdgeIterator &operator=(InEdgeIterator&&)\r\n```\r\n\r\n```cpp\r\n~InEdgeIterator()\r\n```\r\n\r\n```cpp\r\nvoid Close() noexcept\r\n```"
            },
            {
                "content": "In TuGraph, every iterator belongs to a transaction, and can only be used when the transaction is valid. Calling member functions on an iterator inside an invalid transaction yields InvalidTxn, except for Invalid().  // 在 TuGraph 中，每个迭代器属于一个事务，只能在事务有效时使用。在无效事务中的迭代器上调用成员函数会返回 InvalidTxn，Invalid() 除外。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nInEdgeIterator(InEdgeIterator &&rhs)\r\n```\r\n\r\n```cpp\r\nInEdgeIterator &operator=(InEdgeIterator&&)\r\n```\r\n\r\n```cpp\r\n~InEdgeIterator()\r\n```\r\n\r\n```cpp\r\nvoid Close() noexcept\r\n```\r\nCloses this iterator. The iterator turns invalid after being closed.  // 关闭此迭代器。关闭后，迭代器变为无效。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next incoming edge to current destination vertex. If there is no more edge, the iterator becomes invalid and false is returned.  // 移动到当前目标顶点的下一个入边。如果没有更多边，迭代器变为无效并返回 false。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**"
            },
            {
                "content": "```\r\nCloses this iterator. The iterator turns invalid after being closed.  // 关闭此迭代器。关闭后，迭代器变为无效。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next incoming edge to current destination vertex. If there is no more edge, the iterator becomes invalid and false is returned.  // 移动到当前目标顶点的下一个入边。如果没有更多边，迭代器变为无效并返回 false。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nTrue if it succeeds, false if it fails.  // 如果成功则返回 true，失败则返回 false。\r\n\r\n```cpp\r\nbool Goto(EdgeUid euid, bool nearest = false)\r\n```\r\nGo to the edge specified by euid. If the specified edge cannot be found and nearest==true, then try to get the next in-coming edge to the vertex euid.dst, sorted by (label, tid, src, eid). If there is no such edge, iterator is invalidated and false is returned.  // 转到由 euid 指定的边。如果无法找到指定的边且 nearest==true，则尝试获取到顶点 euid.dst 的下一个入边，按 (label, tid, src, eid) 排序。如果没有这样的边，迭代器变为无效并返回 false。"
            },
            {
                "content": "```cpp\r\nbool Goto(EdgeUid euid, bool nearest = false)\r\n```\r\nGo to the edge specified by euid. If the specified edge cannot be found and nearest==true, then try to get the next in-coming edge to the vertex euid.dst, sorted by (label, tid, src, eid). If there is no such edge, iterator is invalidated and false is returned.  // 转到由 euid 指定的边。如果无法找到指定的边且 nearest==true，则尝试获取到顶点 euid.dst 的下一个入边，按 (label, tid, src, eid) 排序。如果没有这样的边，迭代器变为无效并返回 false。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**参数**\r\n- euid – Edge Unique Id.  // 边的唯一 ID。\r\n- nearest – (Optional) True to get the nearest edge if the specified one cannot be found.  // （可选）如果未找到指定的边，则为真以获取最近的边。\r\n\r\n**返回**\r\nTrue if it succeeds, false if it fails.  // 如果成功则返回 true，失败则返回 false。\r\n\r\n```cpp\r\nEdgeUid GetUid() const\r\n```\r\nGets the Edge Unique Id.  // 获取边的唯一 ID。\r\n\r\n**抛出**"
            },
            {
                "content": "InvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**参数**\r\n- euid – Edge Unique Id.  // 边的唯一 ID。\r\n- nearest – (Optional) True to get the nearest edge if the specified one cannot be found.  // （可选）如果未找到指定的边，则为真以获取最近的边。\r\n\r\n**返回**\r\nTrue if it succeeds, false if it fails.  // 如果成功则返回 true，失败则返回 false。\r\n\r\n```cpp\r\nEdgeUid GetUid() const\r\n```\r\nGets the Edge Unique Id.  // 获取边的唯一 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe UID.  // 返回 UID。\r\n\r\n```cpp\r\nint64_t GetSrc() const\r\n```\r\nGets the source vertex id.  // 获取源顶点 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe source vertex id.  // 返回源顶点 ID。"
            },
            {
                "content": "InvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe UID.  // 返回 UID。\r\n\r\n```cpp\r\nint64_t GetSrc() const\r\n```\r\nGets the source vertex id.  // 获取源顶点 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe source vertex id.  // 返回源顶点 ID。\r\n\r\n```cpp\r\nint64_t GetDst() const\r\n```\r\nGets destination vertex id.  // 获取目标顶点 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe destination vertex id.  // 返回目标顶点 ID。\r\n\r\n```cpp\r\nint64_t GetEdgeId() const\r\n```\r\nGets edge id.  // 获取边 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。"
            },
            {
                "content": "The source vertex id.  // 返回源顶点 ID。\r\n\r\n```cpp\r\nint64_t GetDst() const\r\n```\r\nGets destination vertex id.  // 获取目标顶点 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe destination vertex id.  // 返回目标顶点 ID。\r\n\r\n```cpp\r\nint64_t GetEdgeId() const\r\n```\r\nGets edge id.  // 获取边 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe edge id.  // 返回边 ID。\r\n\r\n```cpp\r\nint64_t GetTemporalId() const\r\n```\r\nGets temporal id.  // 获取时间 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe temporal id.  // 返回时间 ID。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid.  // 查询此迭代器是否有效。"
            },
            {
                "content": "InvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe edge id.  // 返回边 ID。\r\n\r\n```cpp\r\nint64_t GetTemporalId() const\r\n```\r\nGets temporal id.  // 获取时间 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe temporal id.  // 返回时间 ID。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid.  // 查询此迭代器是否有效。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nTrue if valid, false if not.  // 如果有效则返回 true，如果无效则返回 false。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this edge.  // 获取该边的标签。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。"
            },
            {
                "content": "```\r\nQuery if this iterator is valid.  // 查询此迭代器是否有效。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nTrue if valid, false if not.  // 如果有效则返回 true，如果无效则返回 false。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this edge.  // 获取该边的标签。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe label.  // 返回标签。\r\n\r\n```cpp\r\nint16_t GetLabelId() const\r\n```\r\nGets label id of this edge.  // 获取该边的标签 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe label identifier.  // 返回标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```"
            },
            {
                "content": "InvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe label.  // 返回标签。\r\n\r\n```cpp\r\nint16_t GetLabelId() const\r\n```\r\nGets label id of this edge.  // 获取该边的标签 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe label identifier.  // 返回标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  // 获取指定的字段。"
            },
            {
                "content": "**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Field name.  // 字段名称。\r\n\r\n**返回**\r\nField value.  // 返回字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。"
            },
            {
                "content": "InvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Field name.  // 字段名称。\r\n\r\n**返回**\r\nField value.  // 返回字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of ids for the fields.  // 字段 ID 的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。"
            },
            {
                "content": "InputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of ids for the fields.  // 字段 ID 的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of ids for the fields.  // 字段 ID 的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**"
            },
            {
                "content": "**参数**\r\nfield_ids – List of ids for the fields.  // 字段 ID 的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_id – Field ID.  // 字段 ID。\r\n\r\n**返回**\r\nField value.  // 返回字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by field_name.  // 获取由字段名标识的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Filename of the file.  // 文件名。\r\n\r\n**返回**\r\nThe indexed value.  // 返回索引值。\r\n\r\n```cpp"
            },
            {
                "content": "```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by field_name.  // 获取由字段名标识的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Filename of the file.  // 文件名。\r\n\r\n**返回**\r\nThe indexed value.  // 返回索引值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id.  // 获取由字段 ID 标识的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfid – The field id.  // 字段 ID。\r\n\r\n**返回**\r\nThe indexed value.  // 返回索引值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```"
            },
            {
                "content": "```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id.  // 获取由字段 ID 标识的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfid – The field id.  // 字段 ID。\r\n\r\n**返回**\r\nThe indexed value.  // 返回索引值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of current vertex.  // 获取当前顶点的所有字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**返回**\r\nAll field names and values stored as a {(field_name, field_value),…} map.  // 返回以 {(字段名, 字段值), …} 存储的所有字段名和值的映射。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)"
            },
            {
                "content": "**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**返回**\r\nAll field names and values stored as a {(field_name, field_value),…} map.  // 返回以 {(字段名, 字段值), …} 存储的所有字段名和值的映射。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Field name.  // 字段名。\r\n\r\nfield_value – Field value.  // 字段值。\r\n\r\n```cpp"
            },
            {
                "content": "```\r\nSets the specified field.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Field name.  // 字段名。\r\n\r\nfield_value – Field value.  // 字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_id – Field id.  // 字段 ID。"
            },
            {
                "content": "void SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_id – Field id.  // 字段 ID。\r\n\r\nfield_value – Field value.  // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。"
            },
            {
                "content": "**参数**\r\nfield_id – Field id.  // 字段 ID。\r\n\r\nfield_value – Field value.  // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\nfield_value_strings – The field value strings.  // 字段值字符串。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。"
            },
            {
                "content": "InputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\nfield_value_strings – The field value strings.  // 字段值字符串。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\nfield_values – The field values.  // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```"
            },
            {
                "content": "WriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\nfield_values – The field values.  // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of identifiers for the fields.  // 字段的标识符列表。\r\n\r\nfield_values – The field values.  // 字段值。\r\n\r\n```cpp"
            },
            {
                "content": "InvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of identifiers for the fields.  // 字段的标识符列表。\r\n\r\nfield_values – The field values.  // 字段值。\r\n\r\n```cpp\r\nvoid Delete()\r\n```\r\nDeletes this edge. The iterator will point to the next incoming edge sorted by (lid, tid, src, eid) if there is any. If no in-coming edge is left for this vertex, the iterator becomes invalid.  // 删除这条边。如果有任何边，这个迭代器将指向下一个按 (lid, tid, src, eid) 排序的入边。如果此顶点没有剩余的入边，迭代器将变为无效。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。"
            },
            {
                "content": "```cpp\r\nvoid Delete()\r\n```\r\nDeletes this edge. The iterator will point to the next incoming edge sorted by (lid, tid, src, eid) if there is any. If no in-coming edge is left for this vertex, the iterator becomes invalid.  // 删除这条边。如果有任何边，这个迭代器将指向下一个按 (lid, tid, src, eid) 排序的入边。如果此顶点没有剩余的入边，迭代器将变为无效。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet string representation of the edge.  // 获取边的字符串表示。\r\n\r\n### Private Functions\r\n\r\n```cpp\r\nInEdgeIterator(lgraph::graph::InEdgeIterator&&, const std::shared_ptr&)\r\n```\r\nConstructors are private; use `Transaction::GetInEdgeIterator()` or `VertexIterator::GetInEdgeIterator()` instead.  \r\n构造函数是私有的；请使用 `Transaction::GetInEdgeIterator()` 或 `VertexIterator::GetInEdgeIterator()` 代替。\r\n\r\n```cpp"
            },
            {
                "content": "```cpp\r\nstd::string ToString() const\r\n```\r\nGet string representation of the edge.  // 获取边的字符串表示。\r\n\r\n### Private Functions\r\n\r\n```cpp\r\nInEdgeIterator(lgraph::graph::InEdgeIterator&&, const std::shared_ptr&)\r\n```\r\nConstructors are private; use `Transaction::GetInEdgeIterator()` or `VertexIterator::GetInEdgeIterator()` instead.  \r\n构造函数是私有的；请使用 `Transaction::GetInEdgeIterator()` 或 `VertexIterator::GetInEdgeIterator()` 代替。\r\n\r\n```cpp\r\nInEdgeIterator(const InEdgeIterator&) = delete\r\n```\r\nDeleted copy constructor.  \r\n删除拷贝构造函数。\r\n\r\n```cpp\r\nInEdgeIterator &operator=(const InEdgeIterator&) = delete\r\n```\r\nDeleted copy assignment operator.  \r\n删除拷贝赋值运算符。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\nUnique pointer to an InEdgeIterator.  \r\n指向 InEdgeIterator 的唯一指针。\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\nShared pointer to a Transaction.  \r\n指向 Transaction 的共享指针。\r\n\r\n#### Friends\r\n\r\n```cpp\r\nfriend class Transaction\r\n```\r\nFriend class declaration for Transaction.  \r\nTransaction 的友元类声明。\r\n\r\n```cpp"
            },
            {
                "content": "删除拷贝构造函数。\r\n\r\n```cpp\r\nInEdgeIterator &operator=(const InEdgeIterator&) = delete\r\n```\r\nDeleted copy assignment operator.  \r\n删除拷贝赋值运算符。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\nUnique pointer to an InEdgeIterator.  \r\n指向 InEdgeIterator 的唯一指针。\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\nShared pointer to a Transaction.  \r\n指向 Transaction 的共享指针。\r\n\r\n#### Friends\r\n\r\n```cpp\r\nfriend class Transaction\r\n```\r\nFriend class declaration for Transaction.  \r\nTransaction 的友元类声明。\r\n\r\n```cpp\r\nfriend class VertexIterator\r\n```\r\nFriend class declaration for VertexIterator.  \r\nVertexIterator 的友元类声明。\r\n\r\n### Class OutEdgeIterator\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\nAn `OutEdgeIterator` can be used to iterate through the outgoing edges of a vertex. Edges are sorted in the order of (lid, dst, eid), and each (src, lid, tid, dst, eid) tuple uniquely identifies an edge.  \r\n`OutEdgeIterator` 可以用于遍历一个顶点的出边。边按 (lid, dst, eid) 的顺序排序，每个 (src, lid, tid, dst, eid) 元组唯一标识一条边。"
            },
            {
                "content": "Transaction 的友元类声明。\r\n\r\n```cpp\r\nfriend class VertexIterator\r\n```\r\nFriend class declaration for VertexIterator.  \r\nVertexIterator 的友元类声明。\r\n\r\n### Class OutEdgeIterator\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\nAn `OutEdgeIterator` can be used to iterate through the outgoing edges of a vertex. Edges are sorted in the order of (lid, dst, eid), and each (src, lid, tid, dst, eid) tuple uniquely identifies an edge.  \r\n`OutEdgeIterator` 可以用于遍历一个顶点的出边。边按 (lid, dst, eid) 的顺序排序，每个 (src, lid, tid, dst, eid) 元组唯一标识一条边。\r\n\r\nAn `OutEdgeIterator` is valid if it points to a valid outgoing edge; otherwise, it is invalid. Calling member functions on an invalid `OutEdgeIterator` throws an `InvalidIterator`, except for the `IsValid()` and `Goto()` functions.  \r\n如果 `OutEdgeIterator` 指向有效的出边，则它是有效的；否则，它是无效的。在无效的 `OutEdgeIterator` 上调用成员函数会抛出 `InvalidIterator`， `IsValid()` 和 `Goto()` 函数除外。\r\n\r\nThe following operations invalidate an `OutEdgeIterator`:\r\n- Constructing an `OutEdgeIterator` for a non-existing edge.  \r\n- 为不存在的边构造 `OutEdgeIterator`。"
            },
            {
                "content": "如果 `OutEdgeIterator` 指向有效的出边，则它是有效的；否则，它是无效的。在无效的 `OutEdgeIterator` 上调用成员函数会抛出 `InvalidIterator`， `IsValid()` 和 `Goto()` 函数除外。\r\n\r\nThe following operations invalidate an `OutEdgeIterator`:\r\n- Constructing an `OutEdgeIterator` for a non-existing edge.  \r\n- 为不存在的边构造 `OutEdgeIterator`。\r\n- Calling `Goto()` with the id of a non-existing edge.  \r\n- 使用不存在边的 ID 调用 `Goto()`。\r\n- Calling `Next()` on the last outgoing edge.  \r\n- 在最后一条出边上调用 `Next()`。\r\n- Calling `Delete()` on the last outgoing edge.  \r\n- 在最后一条出边上调用 `Delete()`。\r\n- Calling `Close()` on the iterator.  \r\n- 在迭代器上调用 `Close()`。\r\n\r\nIn TuGraph, every iterator belongs to a transaction and can only be used when the transaction is valid. Calling member functions on an iterator inside an invalid transaction yields `InvalidTxn`, except for `Invalid()`.  \r\n在 TuGraph 中，每个迭代器属于一个事务，并且只能在事务有效时使用。在无效事务中的迭代器上调用成员函数会导致 `InvalidTxn`， `Invalid()` 除外。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nOutEdgeIterator(OutEdgeIterator &&rhs)\r\n```\r\nMove constructor.  \r\n移动构造函数。\r\n\r\n```cpp"
            },
            {
                "content": "- Calling `Close()` on the iterator.  \r\n- 在迭代器上调用 `Close()`。\r\n\r\nIn TuGraph, every iterator belongs to a transaction and can only be used when the transaction is valid. Calling member functions on an iterator inside an invalid transaction yields `InvalidTxn`, except for `Invalid()`.  \r\n在 TuGraph 中，每个迭代器属于一个事务，并且只能在事务有效时使用。在无效事务中的迭代器上调用成员函数会导致 `InvalidTxn`， `Invalid()` 除外。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nOutEdgeIterator(OutEdgeIterator &&rhs)\r\n```\r\nMove constructor.  \r\n移动构造函数。\r\n\r\n```cpp\r\nOutEdgeIterator &operator=(OutEdgeIterator &&rhs)\r\n```\r\nMove assignment operator.  \r\n移动赋值运算符。\r\n\r\n```cpp\r\n~OutEdgeIterator()\r\n```\r\nDestructor.  \r\n析构函数。\r\n\r\n```cpp\r\nvoid Close() noexcept\r\n```\r\nCloses this iterator. The iterator turns invalid after being closed.  \r\n关闭此迭代器。迭代器在关闭后变为无效。\r\n\r\n```cpp\r\nbool Goto(EdgeUid euid, bool nearest = false)\r\n```"
            },
            {
                "content": "#### Public Functions\r\n\r\n```cpp\r\nOutEdgeIterator(OutEdgeIterator &&rhs)\r\n```\r\nMove constructor.  \r\n移动构造函数。\r\n\r\n```cpp\r\nOutEdgeIterator &operator=(OutEdgeIterator &&rhs)\r\n```\r\nMove assignment operator.  \r\n移动赋值运算符。\r\n\r\n```cpp\r\n~OutEdgeIterator()\r\n```\r\nDestructor.  \r\n析构函数。\r\n\r\n```cpp\r\nvoid Close() noexcept\r\n```\r\nCloses this iterator. The iterator turns invalid after being closed.  \r\n关闭此迭代器。迭代器在关闭后变为无效。\r\n\r\n```cpp\r\nbool Goto(EdgeUid euid, bool nearest = false)\r\n```\r\nGo to the edge specified by `euid`. If `nearest == true` and the exact edge was not found, the iterator tries to get the next edge that sorts after the specified edge. The edges are sorted in (label, tid, dst, eid) order. The iterator becomes invalid if there is no outgoing edge from `euid.src` that sorts after `euid`.  \r\n转到由 `euid` 指定的边。如果 `nearest == true` 并且未找到确切的边，则迭代器尝试获取在指定边后排序的下一条边。边按 (label, tid, dst, eid) 顺序排序。如果从 `euid.src` 没有排在 `euid` 后面的出边，则迭代器变为无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction."
            },
            {
                "content": "转到由 `euid` 指定的边。如果 `nearest == true` 并且未找到确切的边，则迭代器尝试获取在指定边后排序的下一条边。边按 (label, tid, dst, eid) 顺序排序。如果从 `euid.src` 没有排在 `euid` 后面的出边，则迭代器变为无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。\r\n\r\n**参数**  \r\n- `euid` – Edge Unique ID.  \r\n  边的唯一 ID。\r\n- `nearest` – (Optional) True to get the nearest edge if the specified one cannot be found.  \r\n  （可选）如果找不到指定的边，则为 true 以获取最近的边。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if there is no such edge.  \r\n成功则返回 true，如果没有这样的边则返回 false。\r\n\r\n```cpp\r\nbool IsValid() const noexcept\r\n```\r\nQuery if this iterator is valid.  \r\n查询此迭代器是否有效。\r\n\r\n**返回**  \r\nTrue if valid, false if not.  \r\n有效则返回 true，无效则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next edge. Invalidates iterator if there are no more outgoing edges from the current source vertex.  \r\n移动到下一条边。如果当前源顶点没有更多的出边，则使迭代器无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid."
            },
            {
                "content": "```cpp\r\nbool IsValid() const noexcept\r\n```\r\nQuery if this iterator is valid.  \r\n查询此迭代器是否有效。\r\n\r\n**返回**  \r\nTrue if valid, false if not.  \r\n有效则返回 true，无效则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next edge. Invalidates iterator if there are no more outgoing edges from the current source vertex.  \r\n移动到下一条边。如果当前源顶点没有更多的出边，则使迭代器无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if it fails (no more out edges from current source).  \r\n成功则返回 true，如果失败（当前源没有更多出边）则返回 false。\r\n\r\n```cpp\r\nEdgeUid GetUid() const\r\n```\r\nGets the Edge Unique Id.  \r\n获取边的唯一 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe UID.  \r\n唯一 ID。\r\n\r\n```cpp\r\nint64_t GetDst() const\r\n```\r\nGets the destination of the edge.  \r\n获取边的目的地。"
            },
            {
                "content": "**返回**  \r\nTrue if it succeeds, false if it fails (no more out edges from current source).  \r\n成功则返回 true，如果失败（当前源没有更多出边）则返回 false。\r\n\r\n```cpp\r\nEdgeUid GetUid() const\r\n```\r\nGets the Edge Unique Id.  \r\n获取边的唯一 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe UID.  \r\n唯一 ID。\r\n\r\n```cpp\r\nint64_t GetDst() const\r\n```\r\nGets the destination of the edge.  \r\n获取边的目的地。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe destination vertex id.  \r\n目的地顶点 ID。\r\n\r\n```cpp\r\nint64_t GetEdgeId() const\r\n```\r\nGets the edge id.  \r\n获取边的 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe edge identifier."
            },
            {
                "content": "**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe destination vertex id.  \r\n目的地顶点 ID。\r\n\r\n```cpp\r\nint64_t GetEdgeId() const\r\n```\r\nGets the edge id.  \r\n获取边的 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe edge identifier.  \r\n边的标识符。\r\n\r\n```cpp\r\nint64_t GetTemporalId() const\r\n```\r\nGets the primary id.  \r\n获取主 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe primary id of the edge.  \r\n边的主 ID。\r\n\r\n```cpp\r\nint64_t GetSrc() const\r\n```\r\nGets the source vertex id.  \r\n获取源顶点 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。"
            },
            {
                "content": "边的标识符。\r\n\r\n```cpp\r\nint64_t GetTemporalId() const\r\n```\r\nGets the primary id.  \r\n获取主 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe primary id of the edge.  \r\n边的主 ID。\r\n\r\n```cpp\r\nint64_t GetSrc() const\r\n```\r\nGets the source vertex id.  \r\n获取源顶点 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe source vertex id.  \r\n源顶点 ID。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this edge.  \r\n获取该边的标签。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe label.  \r\n标签。\r\n\r\n```cpp\r\nint16_t GetLabelId() const\r\n```\r\nGets the label id of this edge.  \r\n获取该边的标签 ID。\r\n\r\n**抛出**"
            },
            {
                "content": "当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe source vertex id.  \r\n源顶点 ID。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this edge.  \r\n获取该边的标签。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe label.  \r\n标签。\r\n\r\n```cpp\r\nint16_t GetLabelId() const\r\n```\r\nGets the label id of this edge.  \r\n获取该边的标签 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe label identifier.  \r\n标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。"
            },
            {
                "content": "**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe label identifier.  \r\n标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields.  \r\n  字段名称列表。\r\n\r\n**返回**  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。"
            },
            {
                "content": "当当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields.  \r\n  字段名称列表。\r\n\r\n**返回**  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n**参数**  \r\n- `field_name` – Field name.  \r\n  字段名称。\r\n\r\n**返回**  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。"
            },
            {
                "content": "当当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n**参数**  \r\n- `field_name` – Field name.  \r\n  字段名称。\r\n\r\n**返回**  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_ids` – List of ids for the fields. // 字段的ID列表。\r\n\r\n**返回**  \r\nThe fields. // 字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified. // 获取指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_ids` – List of ids for the fields. // 字段的ID列表。\r\n\r\n**返回**  \r\nThe fields. // 字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified. // 获取指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_id` – Field ID. // 字段ID。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by field_name. // 获取由 field_name 标识的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_id` – Field ID. // 字段ID。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by field_name. // 获取由 field_name 标识的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_name` – The name of the field to get. // 要获取的字段名称。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id. FieldId can be obtained with `txn.GetEdgeFieldId()`. // 获取由字段ID标识的字段。FieldId 可以通过 `txn.GetEdgeFieldId()` 获取。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_name` – The name of the field to get. // 要获取的字段名称。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id. FieldId can be obtained with `txn.GetEdgeFieldId()`. // 获取由字段ID标识的字段。FieldId 可以通过 `txn.GetEdgeFieldId()` 获取。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `fid` – Field id. // 字段ID。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of the current vertex. // 获取当前顶点的所有字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `fid` – Field id. // 字段ID。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of the current vertex. // 获取当前顶点的所有字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nAll fields in a dictionary of {(field_name, field_value),…}. // 返回一个字典，其中包含所有字段 {(字段名称, 字段值),…}。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。"
            },
            {
                "content": "**返回**  \r\nAll fields in a dictionary of {(field_name, field_value),…}. // 返回一个字典，其中包含所有字段 {(字段名称, 字段值),…}。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_name` – Field name. // 字段名称。\r\n- `field_value` – Field value. // 字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_name` – Field name. // 字段名称。\r\n- `field_value` – Field value. // 字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_id` – Field id. // 字段ID。\r\n- `field_value` – Field value. // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。"
            },
            {
                "content": "WriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_id` – Field id. // 字段ID。\r\n- `field_value` – Field value. // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields. // 字段名称列表。\r\n- `field_value_strings` – The field values in string representation. // 字段值的字符串表示。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```"
            },
            {
                "content": "InvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields. // 字段名称列表。\r\n- `field_value_strings` – The field values in string representation. // 字段值的字符串表示。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields. // 字段名称列表。\r\n- `field_values` – The field values. // 字段值。\r\n\r\n```cpp"
            },
            {
                "content": "**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields. // 字段名称列表。\r\n- `field_values` – The field values. // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**"
            },
            {
                "content": "```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_ids` – List of identifiers for the fields. // 字段的标识符列表。\r\n- `field_values` – The field values. // 字段值。\r\n\r\n```cpp\r\nvoid Delete()\r\n```\r\nDeletes this edge. The iterator will point to the next outgoing edge sorted by (label, tid, dst, eid) if there is any. If there are no more outgoing edges for this source vertex, the iterator becomes invalid. // 删除该边。如果有，迭代器将指向下一个按 (label, tid, dst, eid) 排序的出边。如果该源顶点没有更多出边，迭代器将变得无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。"
            },
            {
                "content": "- `field_values` – The field values. // 字段值。\r\n\r\n```cpp\r\nvoid Delete()\r\n```\r\nDeletes this edge. The iterator will point to the next outgoing edge sorted by (label, tid, dst, eid) if there is any. If there are no more outgoing edges for this source vertex, the iterator becomes invalid. // 删除该边。如果有，迭代器将指向下一个按 (label, tid, dst, eid) 排序的出边。如果该源顶点没有更多出边，迭代器将变得无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet string representation of the edge. // 获取边的字符串表示。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nA `std::string` that represents this object. // 一个表示该对象的 `std::string`。\r\n\r\n### Private Functions\r\n\r\n```cpp"
            },
            {
                "content": "WriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet string representation of the edge. // 获取边的字符串表示。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nA `std::string` that represents this object. // 一个表示该对象的 `std::string`。\r\n\r\n### Private Functions\r\n\r\n```cpp\r\nOutEdgeIterator(lgraph::graph::OutEdgeIterator&&, const std::shared_ptr&)\r\n```\r\nConstructors are private; use `Transaction::GetOutEdgeIterator()` or `VertexIterator::GetOutEdgeIterator()` instead. // 构造函数是私有的；请使用 `Transaction::GetOutEdgeIterator()` 或 `VertexIterator::GetOutEdgeIterator()`。\r\n\r\n```cpp\r\nOutEdgeIterator(const OutEdgeIterator&) = delete\r\n```\r\nThis copy constructor is deleted to prevent copying. // 该复制构造函数被删除以防止复制。\r\n\r\n```cpp\r\nOutEdgeIterator &operator=(const OutEdgeIterator&) = delete\r\n```"
            },
            {
                "content": "OutEdgeIterator(lgraph::graph::OutEdgeIterator&&, const std::shared_ptr&)\r\n```\r\nConstructors are private; use `Transaction::GetOutEdgeIterator()` or `VertexIterator::GetOutEdgeIterator()` instead. // 构造函数是私有的；请使用 `Transaction::GetOutEdgeIterator()` 或 `VertexIterator::GetOutEdgeIterator()`。\r\n\r\n```cpp\r\nOutEdgeIterator(const OutEdgeIterator&) = delete\r\n```\r\nThis copy constructor is deleted to prevent copying. // 该复制构造函数被删除以防止复制。\r\n\r\n```cpp\r\nOutEdgeIterator &operator=(const OutEdgeIterator&) = delete\r\n```\r\nThis assignment operator is deleted to prevent assignment. // 该赋值运算符被删除以防止赋值。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\nUnique pointer to the out-edge iterator. // 指向出边迭代器的唯一指针。\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\nShared pointer to the transaction. // 指向事务的共享指针。\r\n\r\n#### Friends\r\n\r\n```cpp\r\nfriend class Transaction\r\n```\r\nTransaction class is a friend. // Transaction 类是友元类。\r\n\r\n```cpp\r\nfriend class VertexIterator\r\n```\r\nVertexIterator class is a friend. // VertexIterator 类是友元类。"
            },
            {
                "content": "#### Private Members\r\n\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\nUnique pointer to the out-edge iterator. // 指向出边迭代器的唯一指针。\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\nShared pointer to the transaction. // 指向事务的共享指针。\r\n\r\n#### Friends\r\n\r\n```cpp\r\nfriend class Transaction\r\n```\r\nTransaction class is a friend. // Transaction 类是友元类。\r\n\r\n```cpp\r\nfriend class VertexIterator\r\n```\r\nVertexIterator class is a friend. // VertexIterator 类是友元类。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_exceptions\r\n\r\n### Defines\r\n\r\n- **ERROR_CODES**  // 定义了错误代码\r\n- **X(code, msg)**  // 定义了一个宏，接受错误代码和消息\r\n- **THROW_CODE(code, ...)**  // 定义了一个宏，用于抛出指定的错误代码\r\n\r\n### namespace lgraph_api  // 命名空间 lgraph_api\r\n\r\n### Enums\r\n\r\n- **enum class ErrorCode**  // 错误代码的枚举类\r\n  - Values:  // 枚举值\r\n    - enumerator X  // 枚举值 X\r\n    - enumerator ERROR_CODES  // 枚举值 ERROR_CODES\r\n\r\n### Functions\r\n\r\n```cpp\r\nconst char *ErrorCodeToString(ErrorCode code)  // 将错误代码转换为字符串\r\n```\r\n\r\n```cpp\r\nconst char *ErrorCodeDesc(ErrorCode code)  // 获取错误代码的描述\r\n```"
            },
            {
                "content": "- **ERROR_CODES**  // 定义了错误代码\r\n- **X(code, msg)**  // 定义了一个宏，接受错误代码和消息\r\n- **THROW_CODE(code, ...)**  // 定义了一个宏，用于抛出指定的错误代码\r\n\r\n### namespace lgraph_api  // 命名空间 lgraph_api\r\n\r\n### Enums\r\n\r\n- **enum class ErrorCode**  // 错误代码的枚举类\r\n  - Values:  // 枚举值\r\n    - enumerator X  // 枚举值 X\r\n    - enumerator ERROR_CODES  // 枚举值 ERROR_CODES\r\n\r\n### Functions\r\n\r\n```cpp\r\nconst char *ErrorCodeToString(ErrorCode code)  // 将错误代码转换为字符串\r\n```\r\n\r\n```cpp\r\nconst char *ErrorCodeDesc(ErrorCode code)  // 获取错误代码的描述\r\n```\r\n\r\n### class LgraphException : public exception  // LgraphException 类，继承自标准异常类\r\n\r\n```cpp\r\n#include   // 引入 lgraph_exceptions 头文件\r\n```\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code)  // 构造函数，接受一个错误代码\r\n```\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code, const std::string &msg)  // 构造函数，接受错误代码和消息字符串\r\n```\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code, const char *msg)  // 构造函数，接受错误代码和消息 C 字符串\r\n```\r\n\r\n```cpp\r\ntemplate"
            },
            {
                "content": "```\r\n\r\n### class LgraphException : public exception  // LgraphException 类，继承自标准异常类\r\n\r\n```cpp\r\n#include   // 引入 lgraph_exceptions 头文件\r\n```\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code)  // 构造函数，接受一个错误代码\r\n```\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code, const std::string &msg)  // 构造函数，接受错误代码和消息字符串\r\n```\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code, const char *msg)  // 构造函数，接受错误代码和消息 C 字符串\r\n```\r\n\r\n```cpp\r\ntemplate\r\ninline explicit LgraphException(ErrorCode code, const char *format, const Ts&... ds)  // 模板构造函数，支持格式化消息\r\n```\r\n\r\n```cpp\r\ninline ErrorCode code() const  // 返回错误代码\r\n```\r\n\r\n```cpp\r\ninline const std::string &msg() const  // 返回错误消息字符串\r\n```\r\n\r\n```cpp\r\ninline const char *what() const noexcept override  // 重写 what() 函数，返回异常的描述\r\n```\r\n\r\n#### Private Members\r\n\r\n- **ErrorCode code_**  // 存储错误代码的私有成员\r\n- **std::string msg_**  // 存储错误消息的私有成员\r\n- **std::string what_**  // 存储异常描述的私有成员\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_galaxy\r\n\r\n### namespace lgraph"
            },
            {
                "content": "```\r\n\r\n```cpp\r\ninline ErrorCode code() const  // 返回错误代码\r\n```\r\n\r\n```cpp\r\ninline const std::string &msg() const  // 返回错误消息字符串\r\n```\r\n\r\n```cpp\r\ninline const char *what() const noexcept override  // 重写 what() 函数，返回异常的描述\r\n```\r\n\r\n#### Private Members\r\n\r\n- **ErrorCode code_**  // 存储错误代码的私有成员\r\n- **std::string msg_**  // 存储错误消息的私有成员\r\n- **std::string what_**  // 存储异常描述的私有成员\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_galaxy\r\n\r\n### namespace lgraph\r\n### namespace lgraph_api\r\n\r\n### class Galaxy\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\nA galaxy is the storage engine for one TuGraph instance. It manages a set of User/Role/GraphDBs.\r\n  \r\n一个 galaxy 是一个 TuGraph 实例的存储引擎。它管理一组用户/角色/图数据库。\r\n\r\nA galaxy can be opened in async mode, in which case ALL write transactions will be treated as async, whether they declare async or not. This can come in handy if we are performing a lot of writing, but can cause data loss for online processing.\r\n\r\n一个 galaxy 可以在异步模式下打开，在这种情况下，所有写事务都将被视为异步，无论它们是否声明为异步。这在进行大量写入时可能会很有用，但可能会导致在线处理中的数据丢失。"
            },
            {
                "content": "#include \r\n```\r\n\r\nA galaxy is the storage engine for one TuGraph instance. It manages a set of User/Role/GraphDBs.\r\n  \r\n一个 galaxy 是一个 TuGraph 实例的存储引擎。它管理一组用户/角色/图数据库。\r\n\r\nA galaxy can be opened in async mode, in which case ALL write transactions will be treated as async, whether they declare async or not. This can come in handy if we are performing a lot of writing, but can cause data loss for online processing.\r\n\r\n一个 galaxy 可以在异步模式下打开，在这种情况下，所有写事务都将被视为异步，无论它们是否声明为异步。这在进行大量写入时可能会很有用，但可能会导致在线处理中的数据丢失。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit Galaxy(const std::string &dir, bool durable = false, bool create_if_not_exist = true)\r\n```\r\nConstructor.\r\n\r\n构造函数。\r\n\r\n抛出  \r\nDBNotExist – Thrown if DB does not exist and create_if_not_exist is false.\r\n\r\n此异常在数据库不存在且 create_if_not_exist 为 false 时抛出。\r\n\r\nIOError – Thrown if DB does not exist, but we failed to create the DB due to IO error.\r\n\r\n此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。"
            },
            {
                "content": "一个 galaxy 可以在异步模式下打开，在这种情况下，所有写事务都将被视为异步，无论它们是否声明为异步。这在进行大量写入时可能会很有用，但可能会导致在线处理中的数据丢失。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit Galaxy(const std::string &dir, bool durable = false, bool create_if_not_exist = true)\r\n```\r\nConstructor.\r\n\r\n构造函数。\r\n\r\n抛出  \r\nDBNotExist – Thrown if DB does not exist and create_if_not_exist is false.\r\n\r\n此异常在数据库不存在且 create_if_not_exist 为 false 时抛出。\r\n\r\nIOError – Thrown if DB does not exist, but we failed to create the DB due to IO error.\r\n\r\n此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。\r\n\r\nInputError – Thrown if there are other input errors. e.g., dir is actually a plain file, or DB is corruptted.\r\n\r\n此异常在存在其他输入错误时抛出。例如，dir 实际上是一个普通文件，或数据库已损坏。\r\n\r\n参数  \r\ndir – The TuGraph dir.\r\n\r\ndir – TuGraph 的目录。\r\n\r\ndurable – (Optional) True to open in durable mode. If set to false, ALL write transactions are async, whether they declare async or not.\r\n\r\ndurable – （可选）设置为 true 以在持久模式下打开。如果设置为 false，所有写事务都是异步的，无论它们是否声明为异步。"
            },
            {
                "content": "此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。\r\n\r\nInputError – Thrown if there are other input errors. e.g., dir is actually a plain file, or DB is corruptted.\r\n\r\n此异常在存在其他输入错误时抛出。例如，dir 实际上是一个普通文件，或数据库已损坏。\r\n\r\n参数  \r\ndir – The TuGraph dir.\r\n\r\ndir – TuGraph 的目录。\r\n\r\ndurable – (Optional) True to open in durable mode. If set to false, ALL write transactions are async, whether they declare async or not.\r\n\r\ndurable – （可选）设置为 true 以在持久模式下打开。如果设置为 false，所有写事务都是异步的，无论它们是否声明为异步。\r\n\r\ncreate_if_not_exist – (Optional) If true, the TuGraph DB will be created if dir does not exist; otherwise, an exception is thrown.\r\n\r\ncreate_if_not_exist – （可选）如果为 true，且 dir 不存在，则将创建 TuGraph 数据库；否则将抛出异常。\r\n\r\n```cpp\r\nGalaxy(const std::string &dir, const std::string &user, const std::string &password, bool durable, bool create_if_not_exist)\r\n```\r\nConstructor. Open the Galaxy and try to login with specified user and password.\r\n\r\n构造函数。打开 Galaxy 并尝试使用指定的用户和密码登录。\r\n\r\n抛出  \r\nDBNotExist – Thrown if DB does not exist and create_if_not_exist is false."
            },
            {
                "content": "create_if_not_exist – （可选）如果为 true，且 dir 不存在，则将创建 TuGraph 数据库；否则将抛出异常。\r\n\r\n```cpp\r\nGalaxy(const std::string &dir, const std::string &user, const std::string &password, bool durable, bool create_if_not_exist)\r\n```\r\nConstructor. Open the Galaxy and try to login with specified user and password.\r\n\r\n构造函数。打开 Galaxy 并尝试使用指定的用户和密码登录。\r\n\r\n抛出  \r\nDBNotExist – Thrown if DB does not exist and create_if_not_exist is false.\r\n\r\n此异常在数据库不存在且 create_if_not_exist 为 false 时抛出。\r\n\r\nIOError – Thrown if DB does not exist, but we failed to create the DB due to IO error.\r\n\r\n此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。\r\n\r\nInputError – Thrown if there are other input errors. e.g., dir is actually a plain file, or DB is corruptted.\r\n\r\n此异常在存在其他输入错误时抛出。例如，dir 实际上是一个普通文件，或数据库已损坏。\r\n\r\nUnauthorized – Thrown if user/password is not correct.\r\n\r\n当用户/密码不正确时抛出此异常。\r\n\r\n参数  \r\ndir – The dir.\r\n\r\ndir – 目录。\r\n\r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\npassword – The password.\r\n\r\npassword – 密码。\r\n\r\ndurable – True to open the Galaxy in durable mode."
            },
            {
                "content": "此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。\r\n\r\nInputError – Thrown if there are other input errors. e.g., dir is actually a plain file, or DB is corruptted.\r\n\r\n此异常在存在其他输入错误时抛出。例如，dir 实际上是一个普通文件，或数据库已损坏。\r\n\r\nUnauthorized – Thrown if user/password is not correct.\r\n\r\n当用户/密码不正确时抛出此异常。\r\n\r\n参数  \r\ndir – The dir.\r\n\r\ndir – 目录。\r\n\r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\npassword – The password.\r\n\r\npassword – 密码。\r\n\r\ndurable – True to open the Galaxy in durable mode.\r\n\r\ndurable – 设置为 true 以在持久模式下打开 Galaxy。\r\n\r\ncreate_if_not_exist – True to create if DB does not exist.\r\n\r\ncreate_if_not_exist – 如果数据库不存在，则为 true，以创建数据库。\r\n\r\n```cpp\r\nGalaxy(Galaxy&&)\r\n```\r\n\r\n```cpp\r\nGalaxy &operator=(Galaxy&&)\r\n```\r\n\r\n```cpp\r\n~Galaxy()\r\n```\r\n\r\n```cpp\r\nvoid SetCurrentUser(const std::string &user, const std::string &password)\r\n```\r\nValidate and set current user\r\n\r\n验证并设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user/password is incorrect.\r\n\r\n当用户/密码不正确时抛出此异常。\r\n\r\n参数  \r\nuser – The user."
            },
            {
                "content": "create_if_not_exist – 如果数据库不存在，则为 true，以创建数据库。\r\n\r\n```cpp\r\nGalaxy(Galaxy&&)\r\n```\r\n\r\n```cpp\r\nGalaxy &operator=(Galaxy&&)\r\n```\r\n\r\n```cpp\r\n~Galaxy()\r\n```\r\n\r\n```cpp\r\nvoid SetCurrentUser(const std::string &user, const std::string &password)\r\n```\r\nValidate and set current user\r\n\r\n验证并设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user/password is incorrect.\r\n\r\n当用户/密码不正确时抛出此异常。\r\n\r\n参数  \r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\npassword – The password.\r\n\r\npassword – 密码。\r\n\r\n```cpp\r\nvoid SetUser(const std::string &user)\r\n```\r\nSet current user\r\n\r\n设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if token is incorrect.\r\n\r\n当令牌不正确时抛出此异常。\r\n\r\n参数  \r\nuser – The current user.\r\n\r\nuser – 当前用户。\r\n\r\n```cpp\r\nbool CreateGraph(const std::string &graph_name, const std::string &description = \"\", size_t max_size = (size_t)1 << 40)\r\n```\r\nValidate token and set current user\r\n\r\n验证令牌并设置当前用户。\r\n\r\n抛出"
            },
            {
                "content": "password – 密码。\r\n\r\n```cpp\r\nvoid SetUser(const std::string &user)\r\n```\r\nSet current user\r\n\r\n设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if token is incorrect.\r\n\r\n当令牌不正确时抛出此异常。\r\n\r\n参数  \r\nuser – The current user.\r\n\r\nuser – 当前用户。\r\n\r\n```cpp\r\nbool CreateGraph(const std::string &graph_name, const std::string &description = \"\", size_t max_size = (size_t)1 << 40)\r\n```\r\nValidate token and set current user\r\n\r\n验证令牌并设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to create graph.\r\n\r\n当用户没有创建图表的权限时抛出此异常。\r\n\r\nInputError – Other input errors such as invalid graph name, size, etc.\r\n\r\n输入错误 – 其他输入错误，例如无效的图表名称、大小等。\r\n\r\n参数  \r\ngraph_name – Name of the graph to create.  \r\ndescription (Optional) – Description of the graph.  \r\nmax_size (Optional) – Maximum size of the graph.\r\n\r\n返回  \r\nTrue if it succeeds, false if graph already exists."
            },
            {
                "content": "抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to create graph.\r\n\r\n当用户没有创建图表的权限时抛出此异常。\r\n\r\nInputError – Other input errors such as invalid graph name, size, etc.\r\n\r\n输入错误 – 其他输入错误，例如无效的图表名称、大小等。\r\n\r\n参数  \r\ngraph_name – Name of the graph to create.  \r\ndescription (Optional) – Description of the graph.  \r\nmax_size (Optional) – Maximum size of the graph.\r\n\r\n返回  \r\nTrue if it succeeds, false if graph already exists.\r\n\r\n如果成功返回 true，如果图形已经存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteGraph(const std::string &graph_name)\r\n```\r\nDelete a graph\r\n\r\n删除一张图。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to delete graph.\r\n\r\n当用户没有删除图表的权限时抛出此异常。\r\n\r\n参数  \r\ngraph_name – Name of the graph.\r\n\r\ngraph_name – 图形名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if the graph does not exist.\r\n\r\n如果成功返回 true，如果图形不存在则返回 false。\r\n\r\n```cpp"
            },
            {
                "content": "如果成功返回 true，如果图形已经存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteGraph(const std::string &graph_name)\r\n```\r\nDelete a graph\r\n\r\n删除一张图。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to delete graph.\r\n\r\n当用户没有删除图表的权限时抛出此异常。\r\n\r\n参数  \r\ngraph_name – Name of the graph.\r\n\r\ngraph_name – 图形名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if the graph does not exist.\r\n\r\n如果成功返回 true，如果图形不存在则返回 false。\r\n\r\n```cpp\r\nbool ModGraph(const std::string &graph_name, bool mod_desc, const std::string &desc, bool mod_size, size_t new_max_size)\r\n```\r\nModify graph info\r\n\r\n修改图信息。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to modify graph.\r\n\r\n当用户没有修改图表的权限时抛出此异常。\r\n\r\n参数  \r\ngraph_name – Name of the graph.  \r\nmod_desc – True to modify description.  \r\ndesc – The new description.  \r\nmod_size – True to modify size.  \r\nnew_max_size – New maximum size.\r\n\r\n返回"
            },
            {
                "content": "```\r\nModify graph info\r\n\r\n修改图信息。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to modify graph.\r\n\r\n当用户没有修改图表的权限时抛出此异常。\r\n\r\n参数  \r\ngraph_name – Name of the graph.  \r\nmod_desc – True to modify description.  \r\ndesc – The new description.  \r\nmod_size – True to modify size.  \r\nnew_max_size – New maximum size.\r\n\r\n返回  \r\nTrue if it succeeds, false if it fails.\r\n\r\n如果成功返回 true，如果失败返回 false。\r\n\r\n```cpp\r\nstd::map> ListGraphs() const\r\n```\r\nList graphs\r\n\r\n列出图表。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to list graphs.\r\n\r\n当用户没有列出图表的权限时抛出此异常。\r\n\r\n返回  \r\nA dictionary of {graph_name: (description, max_size)}\r\n\r\n返回一个字典，格式为 {graph_name: (description, max_size)}。\r\n\r\n```cpp\r\nbool CreateUser(const std::string &user, const std::string &password, const std::string &desc = \"\")\r\n```\r\nCreates a user\r\n\r\n创建用户。\r\n\r\n抛出"
            },
            {
                "content": "std::map> ListGraphs() const\r\n```\r\nList graphs\r\n\r\n列出图表。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to list graphs.\r\n\r\n当用户没有列出图表的权限时抛出此异常。\r\n\r\n返回  \r\nA dictionary of {graph_name: (description, max_size)}\r\n\r\n返回一个字典，格式为 {graph_name: (description, max_size)}。\r\n\r\n```cpp\r\nbool CreateUser(const std::string &user, const std::string &password, const std::string &desc = \"\")\r\n```\r\nCreates a user\r\n\r\n创建用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if other input errors, such as illegal user name, password, etc.\r\n\r\n输入错误 – 如果存在其他输入错误，例如非法的用户名、密码等，抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\npassword – The password.  \r\ndesc – (Optional) The description.\r\n\r\n返回  \r\nTrue if it succeeds, false if user already exists.\r\n\r\n如果成功返回 true，如果用户已经存在则返回 false。\r\n\r\n```cpp"
            },
            {
                "content": "创建用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if other input errors, such as illegal user name, password, etc.\r\n\r\n输入错误 – 如果存在其他输入错误，例如非法的用户名、密码等，抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\npassword – The password.  \r\ndesc – (Optional) The description.\r\n\r\n返回  \r\nTrue if it succeeds, false if user already exists.\r\n\r\n如果成功返回 true，如果用户已经存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteUser(const std::string &user)\r\n```\r\nDeletes the user.\r\n\r\n删除用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\n参数  \r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetPassword(const std::string &user, const std::string &old_password, const std::string &new_password)\r\n```"
            },
            {
                "content": "```cpp\r\nbool DeleteUser(const std::string &user)\r\n```\r\nDeletes the user.\r\n\r\n删除用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\n参数  \r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetPassword(const std::string &user, const std::string &old_password, const std::string &new_password)\r\n```\r\nSet the password of the specified user.\r\n\r\n设置指定用户的密码。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission, or curr_user==user, but old_password is incorrect.\r\n\r\n当用户没有权限时抛出此异常，或当前用户 == 用户，但是旧密码不正确。\r\n\r\nInputError – Thrown if new_password is illegal.\r\n\r\n输入错误 – 当 new_password 不合法时抛出此异常。\r\n\r\n参数  \r\nuser – The user to modify.  \r\nold_password – The old password, required if curr_user==user.  \r\nnew_password – The new password."
            },
            {
                "content": "设置指定用户的密码。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission, or curr_user==user, but old_password is incorrect.\r\n\r\n当用户没有权限时抛出此异常，或当前用户 == 用户，但是旧密码不正确。\r\n\r\nInputError – Thrown if new_password is illegal.\r\n\r\n输入错误 – 当 new_password 不合法时抛出此异常。\r\n\r\n参数  \r\nuser – The user to modify.  \r\nold_password – The old password, required if curr_user==user.  \r\nnew_password – The new password.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserDesc(const std::string &user, const std::string &desc)\r\n```\r\nSets user description.\r\n\r\n设置用户描述。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if desc is illegal.\r\n\r\n输入错误 – 当 desc 不合法时抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\ndesc – The new description.\r\n\r\n返回"
            },
            {
                "content": "返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserDesc(const std::string &user, const std::string &desc)\r\n```\r\nSets user description.\r\n\r\n设置用户描述。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if desc is illegal.\r\n\r\n输入错误 – 当 desc 不合法时抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\ndesc – The new description.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserRoles(const std::string &user, const std::vector &roles)\r\n```\r\nSet the roles of the specified user. If you need to add or delete a role, you will need to use GetUserInfo to get the roles first.\r\n\r\n设置指定用户的角色。如果需要添加或删除角色，则首先需要使用 GetUserInfo 获取角色。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission."
            },
            {
                "content": "返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserRoles(const std::string &user, const std::vector &roles)\r\n```\r\nSet the roles of the specified user. If you need to add or delete a role, you will need to use GetUserInfo to get the roles first.\r\n\r\n设置指定用户的角色。如果需要添加或删除角色，则首先需要使用 GetUserInfo 获取角色。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if any role does not exist.\r\n\r\n输入错误 – 如果任何角色不存在则抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\nroles – A list of roles.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserGraphAccess(const std::string &user, const std::string &graph, const AccessLevel &access)\r\n```\r\nSets user access rights on a graph.\r\n\r\n设置用户对图表的访问权限。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。"
            },
            {
                "content": "当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if any role does not exist.\r\n\r\n输入错误 – 如果任何角色不存在则抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\nroles – A list of roles.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserGraphAccess(const std::string &user, const std::string &graph, const AccessLevel &access)\r\n```\r\nSets user access rights on a graph.\r\n\r\n设置用户对图表的访问权限。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if graph does not exist.\r\n\r\n输入错误 – 如果图形不存在则抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\ngraph – The graph.  \r\naccess – The access level.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool DisableUser(const std::string &user)\r\n```\r\nDisable a user. A disabled user is not able to login or perform any operation. A user cannot disable itself."
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if graph does not exist.\r\n\r\n输入错误 – 如果图形不存在则抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\ngraph – The graph.  \r\naccess – The access level.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool DisableUser(const std::string &user)\r\n```\r\nDisable a user. A disabled user is not able to login or perform any operation. A user cannot disable itself.\r\n\r\n禁用用户。被禁用的用户无法登录或执行任何操作。用户无法禁用自己。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if user name is illegal.\r\n\r\n输入错误 – 当用户名非法时抛出此异常。\r\n\r\n参数  \r\nuser – The user to disable.\r\n\r\nuser – 要禁用的用户。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool EnableUser(const std::string &user)\r\n```\r\nEnables the user. // 启用用户。\r\n\r\n抛出"
            },
            {
                "content": "禁用用户。被禁用的用户无法登录或执行任何操作。用户无法禁用自己。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if user name is illegal.\r\n\r\n输入错误 – 当用户名非法时抛出此异常。\r\n\r\n参数  \r\nuser – The user to disable.\r\n\r\nuser – 要禁用的用户。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool EnableUser(const std::string &user)\r\n```\r\nEnables the user. // 启用用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if user name is illegal. // 如果用户名不合法，则抛出 InputError。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist. // 成功返回 True，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nstd::map ListUsers() const\r\n```\r\nList all users // 列出所有用户\r\n\r\n抛出"
            },
            {
                "content": "```\r\nEnables the user. // 启用用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if user name is illegal. // 如果用户名不合法，则抛出 InputError。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist. // 成功返回 True，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nstd::map ListUsers() const\r\n```\r\nList all users // 列出所有用户\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n返回  \r\nA dictionary of {user_name:user_info} // 返回一个字典，格式为 {用户名:用户信息}\r\n\r\n```cpp\r\nUserInfo GetUserInfo(const std::string &user) const\r\n```\r\nGets user information // 获取用户信息\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。"
            },
            {
                "content": "```\r\nList all users // 列出所有用户\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n返回  \r\nA dictionary of {user_name:user_info} // 返回一个字典，格式为 {用户名:用户信息}\r\n\r\n```cpp\r\nUserInfo GetUserInfo(const std::string &user) const\r\n```\r\nGets user information // 获取用户信息\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。\r\n\r\n返回  \r\nThe user information. // 返回用户信息。\r\n\r\n```cpp\r\nbool CreateRole(const std::string &role, const std::string &desc)\r\n```\r\nCreate a role. A role has different access levels to different graphs. Every user must be assigned some role to get access to graphs. // 创建一个角色。角色对不同图形具有不同的访问级别。每个用户必须被分配某个角色才能访问图形。\r\n\r\n抛出"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。\r\n\r\n返回  \r\nThe user information. // 返回用户信息。\r\n\r\n```cpp\r\nbool CreateRole(const std::string &role, const std::string &desc)\r\n```\r\nCreate a role. A role has different access levels to different graphs. Every user must be assigned some role to get access to graphs. // 创建一个角色。角色对不同图形具有不同的访问级别。每个用户必须被分配某个角色才能访问图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or desc is illegal. // 如果角色名称或描述不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ndesc – The description. // desc – 描述。\r\n\r\n返回  \r\nTrue if it succeeds, false if role already exists. // 成功返回 True，如果角色已存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteRole(const std::string &role)\r\n```\r\nDeletes the role described by role // 删除由角色描述的角色\r\n\r\n抛出"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or desc is illegal. // 如果角色名称或描述不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ndesc – The description. // desc – 描述。\r\n\r\n返回  \r\nTrue if it succeeds, false if role already exists. // 成功返回 True，如果角色已存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteRole(const std::string &role)\r\n```\r\nDeletes the role described by role // 删除由角色描述的角色\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool DisableRole(const std::string &role)\r\n```"
            },
            {
                "content": "```\r\nDeletes the role described by role // 删除由角色描述的角色\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool DisableRole(const std::string &role)\r\n```\r\nDisable a role. A disabled role still has the data, but is not effective. i.e., users will not have access rights to graphs that are obtained by having this role. // 禁用一个角色。禁用的角色仍然有数据，但无效。即，用户将无法访问通过拥有该角色获得的图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数"
            },
            {
                "content": "```\r\nDisable a role. A disabled role still has the data, but is not effective. i.e., users will not have access rights to graphs that are obtained by having this role. // 禁用一个角色。禁用的角色仍然有数据，但无效。即，用户将无法访问通过拥有该角色获得的图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if the role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool EnableRole(const std::string &role)\r\n```\r\nEnables the role. // 启用角色。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回"
            },
            {
                "content": "返回  \r\nTrue if it succeeds, false if the role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool EnableRole(const std::string &role)\r\n```\r\nEnables the role. // 启用角色。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleDesc(const std::string &role, const std::string &desc)\r\n```\r\nSet the description of the specified role // 设置指定角色的描述\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or desc is illegal. // 如果角色名称或描述不合法，则抛出 InputError。\r\n\r\n参数"
            },
            {
                "content": "True if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleDesc(const std::string &role, const std::string &desc)\r\n```\r\nSet the description of the specified role // 设置指定角色的描述\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or desc is illegal. // 如果角色名称或描述不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ndesc – The description. // desc – 描述。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleAccessRights(const std::string &role, const std::map &graph_access)\r\n```\r\nSet access of the role to graphs. If you need to add or remove access to part of the graphs, you need to get full graph_access map by using GetRoleInfo first. // 设置角色对图形的访问权限。如果需要添加或删除对部分图形的访问权限，必须先通过 GetRoleInfo 获取完整的 graph_access 映射。\r\n\r\n抛出"
            },
            {
                "content": "role – The role. // role – 角色名称。  \r\ndesc – The description. // desc – 描述。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleAccessRights(const std::string &role, const std::map &graph_access)\r\n```\r\nSet access of the role to graphs. If you need to add or remove access to part of the graphs, you need to get full graph_access map by using GetRoleInfo first. // 设置角色对图形的访问权限。如果需要添加或删除对部分图形的访问权限，必须先通过 GetRoleInfo 获取完整的 graph_access 映射。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp"
            },
            {
                "content": "抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleAccessRightsIncremental(const std::string &role, const std::map &graph_access)\r\n```"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleAccessRightsIncremental(const std::string &role, const std::map &graph_access)\r\n```\r\nIncrementally modify the access right of the specified role. For example, for a role that has access right {graph1:READ, graph2:WRITE}, calling this function with graph_access={graph2:READ, graph3:FULL} will set the access right of this role to {graph1:READ, graph2:READ, graph3:FULL} // 逐步修改指定角色的访问权限。例如，对于一个访问权限为 {graph1:READ, graph2:WRITE} 的角色，调用此函数并传入 graph_access={graph2:READ, graph3:FULL} 将把该角色的访问权限设置为 {graph1:READ, graph2:READ, graph3:FULL}。\r\n\r\n抛出"
            },
            {
                "content": "```\r\nIncrementally modify the access right of the specified role. For example, for a role that has access right {graph1:READ, graph2:WRITE}, calling this function with graph_access={graph2:READ, graph3:FULL} will set the access right of this role to {graph1:READ, graph2:READ, graph3:FULL} // 逐步修改指定角色的访问权限。例如，对于一个访问权限为 {graph1:READ, graph2:WRITE} 的角色，调用此函数并传入 graph_access={graph2:READ, graph3:FULL} 将把该角色的访问权限设置为 {graph1:READ, graph2:READ, graph3:FULL}。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nRoleInfo GetRoleInfo(const std::string &role) const\r\n```"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nRoleInfo GetRoleInfo(const std::string &role) const\r\n```\r\nGets role information // 获取角色信息\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nThe role information. // 返回角色信息。\r\n\r\n```cpp\r\nstd::map ListRoles() const\r\n```\r\nList all the roles // 列出所有角色\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nThe role information. // 返回角色信息。\r\n\r\n```cpp\r\nstd::map ListRoles() const\r\n```\r\nList all the roles // 列出所有角色\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n返回  \r\nA dictionary of {role_name:RoleInfo} // 返回一个字典，格式为 {角色名称:角色信息}\r\n\r\n```cpp\r\nAccessLevel GetAccessLevel(const std::string &user, const std::string &graph) const\r\n```\r\nGet the access level that the specified user have to the graph // 获取指定用户对图形的访问级别\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。"
            },
            {
                "content": "返回  \r\nA dictionary of {role_name:RoleInfo} // 返回一个字典，格式为 {角色名称:角色信息}\r\n\r\n```cpp\r\nAccessLevel GetAccessLevel(const std::string &user, const std::string &graph) const\r\n```\r\nGet the access level that the specified user have to the graph // 获取指定用户对图形的访问级别\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if user name or graph name is illegal. // 如果用户名或图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。  \r\ngraph – The graph. // graph – 图形名称。\r\n\r\n返回  \r\nThe access level. // 返回访问级别。\r\n\r\n```cpp\r\nGraphDB OpenGraph(const std::string &graph, bool read_only = false) const\r\n```\r\nOpens a graph. // 打开一个图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。"
            },
            {
                "content": "参数  \r\nuser – The user. // user – 用户名。  \r\ngraph – The graph. // graph – 图形名称。\r\n\r\n返回  \r\nThe access level. // 返回访问级别。\r\n\r\n```cpp\r\nGraphDB OpenGraph(const std::string &graph, bool read_only = false) const\r\n```\r\nOpens a graph. // 打开一个图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if graph name is illegal. // 如果图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\ngraph – The graph. // graph – 图形名称。  \r\nread_only – (Optional) True to open in read-only mode. A read-only GraphDB cannot be written to. // read_only – （可选）若为 True，则以只读模式打开。只读的 GraphDB 不能被写入。\r\n\r\n返回  \r\nA GraphDB. // 返回一个 GraphDB。\r\n\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this Galaxy, turning it into an invalid state. // 关闭这个 Galaxy，将其变为无效状态。\r\n\r\n#### Private Functions\r\n\r\n```cpp\r\nexplicit Galaxy(lgraph::Galaxy *db)\r\n```\r\n\r\n```cpp\r\ninline Galaxy(const Galaxy&)\r\n```\r\n\r\n```cpp\r\ninline Galaxy &operator=(const Galaxy&)"
            },
            {
                "content": "graph – The graph. // graph – 图形名称。  \r\nread_only – (Optional) True to open in read-only mode. A read-only GraphDB cannot be written to. // read_only – （可选）若为 True，则以只读模式打开。只读的 GraphDB 不能被写入。\r\n\r\n返回  \r\nA GraphDB. // 返回一个 GraphDB。\r\n\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this Galaxy, turning it into an invalid state. // 关闭这个 Galaxy，将其变为无效状态。\r\n\r\n#### Private Functions\r\n\r\n```cpp\r\nexplicit Galaxy(lgraph::Galaxy *db)\r\n```\r\n\r\n```cpp\r\ninline Galaxy(const Galaxy&)\r\n```\r\n\r\n```cpp\r\ninline Galaxy &operator=(const Galaxy&)\r\n```\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::string user_\r\n```\r\n\r\n```cpp\r\nlgraph::Galaxy *db_\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_result\r\n\r\nResult interface for plugins and built-in procedures. The result of a plugin should be provided in this format in order for the Cypher engine and the graph visualizer to understand.  \r\n结果接口用于插件和内置过程。插件的结果应以这种格式提供，以便 Cypher 引擎和图形可视化工具能够理解。\r\n\r\n### Namespace\r\n- `namespace lgraph`  \r\n- `namespace cypher`  \r\n- `namespace lgraph_api`  \r\n\r\n### Typedefs\r\n```cpp"
            },
            {
                "content": "```\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::string user_\r\n```\r\n\r\n```cpp\r\nlgraph::Galaxy *db_\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_result\r\n\r\nResult interface for plugins and built-in procedures. The result of a plugin should be provided in this format in order for the Cypher engine and the graph visualizer to understand.  \r\n结果接口用于插件和内置过程。插件的结果应以这种格式提供，以便 Cypher 引擎和图形可视化工具能够理解。\r\n\r\n### Namespace\r\n- `namespace lgraph`  \r\n- `namespace cypher`  \r\n- `namespace lgraph_api`  \r\n\r\n### Typedefs\r\n```cpp\r\ntypedef std::unordered_map> NODEMAP\r\n```\r\n```cpp\r\ntypedef std::unordered_map, EdgeUid::Hash> RELPMAP\r\n```\r\n\r\n### Class Record\r\n```cpp\r\n#include \r\n```\r\nYou only initialize the class by Result instance. Record provides some insert methods to insert data into the record, e.g., Insert, InsertVertexByID, InsertEdgeByID.  \r\n您只能通过 Result 实例初始化类。Record 提供了一些插入方法将数据插入记录，例如：Insert、InsertVertexByID、InsertEdgeByID。\r\n\r\n#### Public Functions\r\n```cpp\r\nRecord(const Record&)\r\n```\r\n```cpp\r\nRecord(Record&&)\r\n```\r\n```cpp"
            },
            {
                "content": "typedef std::unordered_map> NODEMAP\r\n```\r\n```cpp\r\ntypedef std::unordered_map, EdgeUid::Hash> RELPMAP\r\n```\r\n\r\n### Class Record\r\n```cpp\r\n#include \r\n```\r\nYou only initialize the class by Result instance. Record provides some insert methods to insert data into the record, e.g., Insert, InsertVertexByID, InsertEdgeByID.  \r\n您只能通过 Result 实例初始化类。Record 提供了一些插入方法将数据插入记录，例如：Insert、InsertVertexByID、InsertEdgeByID。\r\n\r\n#### Public Functions\r\n```cpp\r\nRecord(const Record&)\r\n```\r\n```cpp\r\nRecord(Record&&)\r\n```\r\n```cpp\r\nRecord &operator=(const Record&)\r\n```\r\n```cpp\r\nRecord &operator=(Record&&)\r\n```\r\n```cpp\r\nvoid Insert(const std::string &fname, const FieldData &fv)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Field name you defined earlier.  // fname - 您之前定义的字段名  \r\nfv – Field value.  // fv - 字段值\r\n\r\n```cpp"
            },
            {
                "content": "```\r\n```cpp\r\nRecord(Record&&)\r\n```\r\n```cpp\r\nRecord &operator=(const Record&)\r\n```\r\n```cpp\r\nRecord &operator=(Record&&)\r\n```\r\n```cpp\r\nvoid Insert(const std::string &fname, const FieldData &fv)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Field name you defined earlier.  // fname - 您之前定义的字段名  \r\nfv – Field value.  // fv - 字段值\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const int64_t vid, lgraph_api::Transaction *txn)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier. You can get properties and labels from the interface; this is different from InsertVertexByID.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。您可以通过接口获取属性和标签，这与 InsertVertexByID 不同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\nvid – VertexId  // vid - 顶点 ID"
            },
            {
                "content": "```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier. You can get properties and labels from the interface; this is different from InsertVertexByID.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。您可以通过接口获取属性和标签，这与 InsertVertexByID 不同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\nvid – VertexId  // vid - 顶点 ID  \r\ntxn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, EdgeUid &euid, lgraph_api::Transaction *txn)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier. You can get properties and labels from the interface; this is different from InsertEdgeByID.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。您可以通过接口获取属性和标签，这与 InsertEdgeByID 不同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\neuid – EdgeUid  // euid - 边 UID"
            },
            {
                "content": "```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier. You can get properties and labels from the interface; this is different from InsertEdgeByID.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。您可以通过接口获取属性和标签，这与 InsertEdgeByID 不同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\neuid – EdgeUid  // euid - 边 UID  \r\ntxn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\nvoid InsertVertexByID(const std::string &fname, int64_t vid)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Field name you defined earlier.  // fname - 您之前定义的字段名  \r\nvid – VertexId.  // vid - 顶点 ID\r\n\r\n```cpp\r\nvoid InsertEdgeByID(const std::string &fname, const EdgeUid &uid)\r\n```"
            },
            {
                "content": "txn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\nvoid InsertVertexByID(const std::string &fname, int64_t vid)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Field name you defined earlier.  // fname - 您之前定义的字段名  \r\nvid – VertexId.  // vid - 顶点 ID\r\n\r\n```cpp\r\nvoid InsertEdgeByID(const std::string &fname, const EdgeUid &uid)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\nuid – EdgeUid.  // uid - 边 UID\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::VertexIterator &vit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier."
            },
            {
                "content": "将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\nuid – EdgeUid.  // uid - 边 UID\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::VertexIterator &vit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nvit – VertexIterator.  // vit - 顶点迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::InEdgeIterator &ieit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nieit – InEdgeIterator.  // ieit - 入边迭代器\r\n\r\n```cpp"
            },
            {
                "content": "vit – VertexIterator.  // vit - 顶点迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::InEdgeIterator &ieit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nieit – InEdgeIterator.  // ieit - 入边迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::OutEdgeIterator &oeit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\noeit – OutEdgeIterator.  // oeit - 出边迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const std::vector &list)\r\n```"
            },
            {
                "content": "```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::OutEdgeIterator &oeit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\noeit – OutEdgeIterator.  // oeit - 出边迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const std::vector &list)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nlist – List of FieldData.  // list - FieldData 的列表\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const std::map ↦)\r\n```"
            },
            {
                "content": "```cpp\r\nvoid Insert(const std::string &fname, const std::vector &list)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nlist – List of FieldData.  // list - FieldData 的列表\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const std::map ↦)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nmap – Map of   // map -  的映射\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const traversal::Path &path, lgraph_api::Transaction *txn, NODEMAP &node_map, RELPMAP &relp_map)\r\n```"
            },
            {
                "content": "```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nmap – Map of   // map -  的映射\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const traversal::Path &path, lgraph_api::Transaction *txn, NODEMAP &node_map, RELPMAP &relp_map)\r\n```\r\nInsert value into the result table. You can insert a value by the function, and the value must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过该函数插入值，且该值必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\npath – Path of traverse API.  // path - 遍历 API 的路径  \r\ntxn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\ninline int64_t Size() const\r\n```\r\nGet the size of the record. If the record is empty, return 0; max size is not beyond the length of your defined param list.  \r\n获取记录的大小。如果记录为空，则返回 0；最大大小不超过您定义的参数列表的长度。"
            },
            {
                "content": "将值插入结果表。您可以通过该函数插入值，且该值必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\npath – Path of traverse API.  // path - 遍历 API 的路径  \r\ntxn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\ninline int64_t Size() const\r\n```\r\nGet the size of the record. If the record is empty, return 0; max size is not beyond the length of your defined param list.  \r\n获取记录的大小。如果记录为空，则返回 0；最大大小不超过您定义的参数列表的长度。\r\n\r\n返回  \r\nSize of record.  // 返回：记录的大小\r\n\r\n```cpp\r\ninline bool HasKey(const std::string &key) const\r\n```\r\nCheck if a key exists or not. The key is one of the titles you defined earlier.  \r\n检查某个键是否存在。该键是您之前定义的标题之一。\r\n\r\n参数  \r\nkey – The key.  // key - 键\r\n\r\n返回  \r\nTrue if exists, otherwise false.  // 如果存在则返回真，否则返回假。\r\n\r\n#### Private Functions\r\n```cpp\r\nexplicit Record(const std::vector>&)\r\n```\r\n\r\n#### Private Members\r\n```cpp\r\nstd::unordered_map> record\r\n```\r\n```cpp\r\nstd::unordered_map header\r\n```\r\n```cpp\r\nint64_t length_\r\n```\r\n\r\n#### Friends\r\nfriend class Result\r\n\r\n### Class Result\r\n```cpp\r\n#include"
            },
            {
                "content": "```\r\nCheck if a key exists or not. The key is one of the titles you defined earlier.  \r\n检查某个键是否存在。该键是您之前定义的标题之一。\r\n\r\n参数  \r\nkey – The key.  // key - 键\r\n\r\n返回  \r\nTrue if exists, otherwise false.  // 如果存在则返回真，否则返回假。\r\n\r\n#### Private Functions\r\n```cpp\r\nexplicit Record(const std::vector>&)\r\n```\r\n\r\n#### Private Members\r\n```cpp\r\nstd::unordered_map> record\r\n```\r\n```cpp\r\nstd::unordered_map header\r\n```\r\n```cpp\r\nint64_t length_\r\n```\r\n\r\n#### Friends\r\nfriend class Result\r\n\r\n### Class Result\r\n```cpp\r\n#include \r\n```\r\nResult table, result instance provides [MutableRecord], [ResetHeader], [Dump], and [Load] methods. The table also provides some methods to view the content of the table. For example, [Header] and [Recordview].  \r\n结果表，结果实例提供 [MutableRecord]、[ResetHeader]、[Dump] 和 [Load] 方法。该表还提供一些方法以查看表的内容。例如， [Header] 和 [Recordview]。"
            },
            {
                "content": "std::unordered_map> record\r\n```\r\n```cpp\r\nstd::unordered_map header\r\n```\r\n```cpp\r\nint64_t length_\r\n```\r\n\r\n#### Friends\r\nfriend class Result\r\n\r\n### Class Result\r\n```cpp\r\n#include \r\n```\r\nResult table, result instance provides [MutableRecord], [ResetHeader], [Dump], and [Load] methods. The table also provides some methods to view the content of the table. For example, [Header] and [Recordview].  \r\n结果表，结果实例提供 [MutableRecord]、[ResetHeader]、[Dump] 和 [Load] 方法。该表还提供一些方法以查看表的内容。例如， [Header] 和 [Recordview]。\r\n\r\nIt’s worth noting that you are best to define your header before using the result table. e.g., `auto result = Result({title, LGraphType}…)` If you do not define the header and initialize by Result(), you will get an empty table without a header; you just use the table after using [ResetHeader] method to set your header.  \r\n值得注意的是，您最好在使用结果表之前定义您的头部。例如， `auto result = Result({title, LGraphType}…)` 如果您没有定义头部并通过 Result() 初始化，您将得到一个没有头部的空表；您只能在使用 [ResetHeader] 方法设置头部后使用该表。\r\n\r\n#### Public Functions\r\n```cpp\r\nResult()"
            },
            {
                "content": "值得注意的是，您最好在使用结果表之前定义您的头部。例如， `auto result = Result({title, LGraphType}…)` 如果您没有定义头部并通过 Result() 初始化，您将得到一个没有头部的空表；您只能在使用 [ResetHeader] 方法设置头部后使用该表。\r\n\r\n#### Public Functions\r\n```cpp\r\nResult()\r\n```\r\n构造函数，初始化一个结果对象。\r\n\r\n```cpp\r\nResult(const std::initializer_list>&)\r\n```\r\n使用初始化列表构造结果对象。\r\n\r\n```cpp\r\nexplicit Result(const std::vector>&)\r\n```\r\n使用向量构造结果对象，参数为一对字符串和LGraphType的向量。\r\n\r\n```cpp\r\nLGraphType GetType(std::string title)\r\n```\r\nGet the type of the title.  \r\n获取标题的类型。\r\n\r\n参数  \r\ntitle – One of the titles in the table.  \r\n标题 - 表格中的一个标题。\r\n\r\n返回  \r\nLGraphType.  \r\n返回LGraphType。\r\n\r\n```cpp\r\nvoid ResetHeader(const std::vector> &header)\r\n```\r\nReset your header; the operation will clear the original data and header. Please use the function carefully.  \r\n重置你的表头；该操作将清除原始数据和表头。请小心使用该函数。\r\n\r\n参数  \r\nheader – List of   \r\n表头 – <标题, LGraphType> 的列表。\r\n\r\n```cpp\r\nvoid ResetHeader(const std::initializer_list> &header)\r\n```\r\nReset your header; the operation will clear the original data and header. Please use the function carefully."
            },
            {
                "content": "标题 - 表格中的一个标题。\r\n\r\n返回  \r\nLGraphType.  \r\n返回LGraphType。\r\n\r\n```cpp\r\nvoid ResetHeader(const std::vector> &header)\r\n```\r\nReset your header; the operation will clear the original data and header. Please use the function carefully.  \r\n重置你的表头；该操作将清除原始数据和表头。请小心使用该函数。\r\n\r\n参数  \r\nheader – List of   \r\n表头 – <标题, LGraphType> 的列表。\r\n\r\n```cpp\r\nvoid ResetHeader(const std::initializer_list> &header)\r\n```\r\nReset your header; the operation will clear the original data and header. Please use the function carefully.  \r\n重置你的表头；该操作将清除原始数据和表头。请小心使用该函数。\r\n\r\n参数  \r\nheader – List of   \r\n表头 – <标题, LGraphType> 的列表。\r\n\r\n```cpp\r\nRecord *MutableRecord()\r\n```\r\nCreate a new record in the table and return the record. The record is a reference of the record in the table; if you want to modify the record, you must assign the return value to a reference variable.  \r\n在表中创建新记录并返回该记录。该记录是表中记录的引用；如果要修改该记录，必须将返回值分配给引用变量。\r\n\r\n返回  \r\nThe reference of the record.  \r\n记录的引用。\r\n\r\n```cpp\r\nvoid Reserve(size_t n)\r\n```"
            },
            {
                "content": "重置你的表头；该操作将清除原始数据和表头。请小心使用该函数。\r\n\r\n参数  \r\nheader – List of   \r\n表头 – <标题, LGraphType> 的列表。\r\n\r\n```cpp\r\nRecord *MutableRecord()\r\n```\r\nCreate a new record in the table and return the record. The record is a reference of the record in the table; if you want to modify the record, you must assign the return value to a reference variable.  \r\n在表中创建新记录并返回该记录。该记录是表中记录的引用；如果要修改该记录，必须将返回值分配给引用变量。\r\n\r\n返回  \r\nThe reference of the record.  \r\n记录的引用。\r\n\r\n```cpp\r\nvoid Reserve(size_t n)\r\n```\r\nThis function attempts to reserve enough memory for the result vector to hold the specified number of elements.  \r\n该函数尝试为结果向量预留足够的内存以容纳指定数量的元素。\r\n\r\n```cpp\r\nvoid Resize(size_t n)\r\n```\r\nThis function will resize the vector to the specified number of elements.  \r\n该函数将向量调整为指定数量的元素。\r\n\r\n```cpp\r\nRecord *At(size_t n)\r\n```\r\nProvides access to the data contained in the vector.  \r\n提供对向量中包含的数据的访问。\r\n\r\n```cpp\r\nconst std::vector> &Header() const\r\n```\r\nReturn the header of the table.  \r\n返回表头。\r\n\r\n返回  \r\nHeader.  \r\n表头。\r\n\r\n```cpp\r\nint64_t Size() const\r\n```"
            },
            {
                "content": "该函数尝试为结果向量预留足够的内存以容纳指定数量的元素。\r\n\r\n```cpp\r\nvoid Resize(size_t n)\r\n```\r\nThis function will resize the vector to the specified number of elements.  \r\n该函数将向量调整为指定数量的元素。\r\n\r\n```cpp\r\nRecord *At(size_t n)\r\n```\r\nProvides access to the data contained in the vector.  \r\n提供对向量中包含的数据的访问。\r\n\r\n```cpp\r\nconst std::vector> &Header() const\r\n```\r\nReturn the header of the table.  \r\n返回表头。\r\n\r\n返回  \r\nHeader.  \r\n表头。\r\n\r\n```cpp\r\nint64_t Size() const\r\n```\r\nReturn size of the table.  \r\n返回表的大小。\r\n\r\n返回  \r\nTable size.  \r\n表的大小。\r\n\r\n```cpp\r\nstd::string Dump(bool is_standard = true)\r\n```\r\nSerialize the table.  \r\n序列化表。\r\n\r\n参数  \r\nis_standard – (Optional) If true, the result will serialize to a standard result; the standard result can be visualized in the web. If false, the result will serialize a JSON object — SDK result.  \r\nis_standard – （可选）如果为true，结果将序列化为标准结果；标准结果可以在网页上可视化。如果为false，结果将序列化为JSON对象 - SDK结果。\r\n\r\n返回  \r\nSerialize result.  \r\n序列化结果。\r\n\r\n```cpp\r\nvoid Load(const std::string &json)\r\n```"
            },
            {
                "content": "返回表的大小。\r\n\r\n返回  \r\nTable size.  \r\n表的大小。\r\n\r\n```cpp\r\nstd::string Dump(bool is_standard = true)\r\n```\r\nSerialize the table.  \r\n序列化表。\r\n\r\n参数  \r\nis_standard – (Optional) If true, the result will serialize to a standard result; the standard result can be visualized in the web. If false, the result will serialize a JSON object — SDK result.  \r\nis_standard – （可选）如果为true，结果将序列化为标准结果；标准结果可以在网页上可视化。如果为false，结果将序列化为JSON对象 - SDK结果。\r\n\r\n返回  \r\nSerialize result.  \r\n序列化结果。\r\n\r\n```cpp\r\nvoid Load(const std::string &json)\r\n```\r\nDeserialize data to the result table. This will clear the original data and header; please use this function carefully.  \r\n将数据反序列化到结果表。 这将清除原始数据和表头；请小心使用此函数。\r\n\r\n参数  \r\njson – JSON string to be deserialized.  \r\njson – 要反序列化的JSON字符串。\r\n\r\n```cpp\r\nvoid ClearRecords()\r\n```\r\nClear all the records; Size() will be 0.  \r\n清除所有记录；Size()将为0。\r\n\r\n```cpp\r\nstd::vector BoltHeader()\r\n```\r\n```cpp\r\nstd::vector> BoltRecords()\r\n```\r\n```cpp\r\ninline void MarkPythonDriver(bool is_python_driver)\r\n```"
            },
            {
                "content": "```\r\nDeserialize data to the result table. This will clear the original data and header; please use this function carefully.  \r\n将数据反序列化到结果表。 这将清除原始数据和表头；请小心使用此函数。\r\n\r\n参数  \r\njson – JSON string to be deserialized.  \r\njson – 要反序列化的JSON字符串。\r\n\r\n```cpp\r\nvoid ClearRecords()\r\n```\r\nClear all the records; Size() will be 0.  \r\n清除所有记录；Size()将为0。\r\n\r\n```cpp\r\nstd::vector BoltHeader()\r\n```\r\n```cpp\r\nstd::vector> BoltRecords()\r\n```\r\n```cpp\r\ninline void MarkPythonDriver(bool is_python_driver)\r\n```\r\nMark that the result is returned to the Python driver. The Python driver is special, use the virtual edge id instead of the real edge id.  \r\n标记结果已返回给Python驱动程序。Python驱动程序是特殊的，使用虚拟边缘ID而不是实际边缘ID。\r\n\r\n#### Private Functions\r\n```cpp\r\nconst std::unordered_map> &RecordView(int64_t row_num)\r\n```\r\nGet record of the table; if row number is more significant than the max length of the table, throw an exception.  \r\n获取表的记录；如果行号大于表的最大长度，抛出异常。\r\n\r\n参数  \r\nrow_num – Row number of the table.  \r\nrow_num – 表的行号。\r\n\r\n返回  \r\nOne Record.  \r\n一个记录。"
            },
            {
                "content": "标记结果已返回给Python驱动程序。Python驱动程序是特殊的，使用虚拟边缘ID而不是实际边缘ID。\r\n\r\n#### Private Functions\r\n```cpp\r\nconst std::unordered_map> &RecordView(int64_t row_num)\r\n```\r\nGet record of the table; if row number is more significant than the max length of the table, throw an exception.  \r\n获取表的记录；如果行号大于表的最大长度，抛出异常。\r\n\r\n参数  \r\nrow_num – Row number of the table.  \r\nrow_num – 表的行号。\r\n\r\n返回  \r\nOne Record.  \r\n一个记录。\r\n\r\n#### Private Members\r\n```cpp\r\nstd::vector result\r\n```\r\n记录结果的向量。\r\n\r\n```cpp\r\nstd::vector> header\r\n```\r\n表头，存储标题与LGraphType的配对。\r\n\r\n```cpp\r\nint64_t row_count_\r\n```\r\n记录行数。\r\n\r\n```cpp\r\nbool is_python_driver_ = false\r\n```\r\n指示是否为Python驱动程序的标志，默认为false。\r\n\r\n```cpp\r\nint64_t v_eid_ = 0\r\n```\r\n虚拟边缘ID，默认为0。\r\n\r\n#### Friends\r\nfriend class lgraph::StateMachine  \r\nfriend class cypher::PluginAdapter  \r\nnamespace lgraph_result  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_rpc_client\r\n\r\n```cpp\r\nnamespace fma_common\r\nnamespace lgraph_rpc\r\nnamespace lgraph\r\n```\r\n\r\n### Enums\r\n\r\n- **enum class GraphQueryType**\r\n  \r\n  **Values:**"
            },
            {
                "content": "```\r\n表头，存储标题与LGraphType的配对。\r\n\r\n```cpp\r\nint64_t row_count_\r\n```\r\n记录行数。\r\n\r\n```cpp\r\nbool is_python_driver_ = false\r\n```\r\n指示是否为Python驱动程序的标志，默认为false。\r\n\r\n```cpp\r\nint64_t v_eid_ = 0\r\n```\r\n虚拟边缘ID，默认为0。\r\n\r\n#### Friends\r\nfriend class lgraph::StateMachine  \r\nfriend class cypher::PluginAdapter  \r\nnamespace lgraph_result  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_rpc_client\r\n\r\n```cpp\r\nnamespace fma_common\r\nnamespace lgraph_rpc\r\nnamespace lgraph\r\n```\r\n\r\n### Enums\r\n\r\n- **enum class GraphQueryType**\r\n  \r\n  **Values:**\r\n  - enumerator CYPHER  // 数据查询语言的枚举值，表示 Cypher 查询语言。\r\n  - enumerator GQL     // 数据查询语言的枚举值，表示 GQL 查询语言。\r\n\r\n- **enum ClientType**\r\n\r\n  **Values:**\r\n  - enumerator DIRECT_HA_CONNECTION      // 客户端类型，表示直接高可用性连接。\r\n  - enumerator INDIRECT_HA_CONNECTION     // 客户端类型，表示间接高可用性连接。\r\n  - enumerator SINGLE_CONNECTION           // 客户端类型，表示单一连接。\r\n\r\n### class RpcClient\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\n### Public Functions\r\n\r\n- **explicit RpcClient(const std::string &url, const std::string &user, const std::string &password)**"
            },
            {
                "content": "- enumerator GQL     // 数据查询语言的枚举值，表示 GQL 查询语言。\r\n\r\n- **enum ClientType**\r\n\r\n  **Values:**\r\n  - enumerator DIRECT_HA_CONNECTION      // 客户端类型，表示直接高可用性连接。\r\n  - enumerator INDIRECT_HA_CONNECTION     // 客户端类型，表示间接高可用性连接。\r\n  - enumerator SINGLE_CONNECTION           // 客户端类型，表示单一连接。\r\n\r\n### class RpcClient\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\n### Public Functions\r\n\r\n- **explicit RpcClient(const std::string &url, const std::string &user, const std::string &password)**  \r\n  RpcClient Login.  // 构造函数，用于登录。\r\n\r\n  **参数**\r\n  - url – Login address.  // 登录地址。\r\n  - user – The username.  // 用户名。\r\n  - password – The password.  // 密码。\r\n\r\n- **explicit RpcClient(std::vector &urls, std::string user, std::string password)**  \r\n  RpcClient Login.  // 构造函数，用于登录。\r\n\r\n  **参数**\r\n  - urls – Login address.  // 登录地址。\r\n  - user – The username.  // 用户名。\r\n  - password – The password.  // 密码。\r\n\r\n- **~RpcClient()**  // 析构函数。"
            },
            {
                "content": "RpcClient Login.  // 构造函数，用于登录。\r\n\r\n  **参数**\r\n  - url – Login address.  // 登录地址。\r\n  - user – The username.  // 用户名。\r\n  - password – The password.  // 密码。\r\n\r\n- **explicit RpcClient(std::vector &urls, std::string user, std::string password)**  \r\n  RpcClient Login.  // 构造函数，用于登录。\r\n\r\n  **参数**\r\n  - urls – Login address.  // 登录地址。\r\n  - user – The username.  // 用户名。\r\n  - password – The password.  // 密码。\r\n\r\n- **~RpcClient()**  // 析构函数。\r\n\r\n- **bool CallCypher(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0, const std::string &url = \"\")**  \r\n  Execute a cypher query.  // 执行 Cypher 查询。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - cypher – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。"
            },
            {
                "content": "Execute a cypher query.  // 执行 Cypher 查询。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - cypher – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - url – [in] (Optional) Node address of calling cypher.  // 可选，调用 Cypher 的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallCypherToLeader(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a cypher query to leader.  // 执行 Cypher 查询到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - cypher – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。"
            },
            {
                "content": "**返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallCypherToLeader(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a cypher query to leader.  // 执行 Cypher 查询到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - cypher – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallGql(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0, const std::string &url = \"\")**  \r\n  Execute a gql query.  // 执行 GQL 查询。\r\n\r\n  **参数**"
            },
            {
                "content": "- timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallGql(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0, const std::string &url = \"\")**  \r\n  Execute a gql query.  // 执行 GQL 查询。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - gql – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - url – [in] (Optional) Node address of calling cypher.  // 可选，调用 GQL 的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。"
            },
            {
                "content": "- gql – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - url – [in] (Optional) Node address of calling cypher.  // 可选，调用 GQL 的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallGqlToLeader(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a gql query to leader.  // 执行 GQL 查询到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - gql – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。"
            },
            {
                "content": "- **bool CallGqlToLeader(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a gql query to leader.  // 执行 GQL 查询到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - gql – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &param, double procedure_time_out = 0.0, bool in_process = false, const std::string &graph = \"default\", bool json_format = true, const std::string &url = \"\")**"
            },
            {
                "content": "- timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &param, double procedure_time_out = 0.0, bool in_process = false, const std::string &graph = \"default\", bool json_format = true, const std::string &url = \"\")**  \r\n  Execute a user-defined procedure.  // 执行用户自定义的过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - param – [in] the execution parameters.  // 输入执行参数。\r\n  - procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - in_process – [in] (Optional) support in future.  // 可选，未来支持。"
            },
            {
                "content": "Execute a user-defined procedure.  // 执行用户自定义的过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - param – [in] the execution parameters.  // 输入执行参数。\r\n  - procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - in_process – [in] (Optional) support in future.  // 可选，未来支持。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - url – [in] (Optional) Node address of calling procedure.  // 可选，调用过程的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。"
            },
            {
                "content": "- in_process – [in] (Optional) support in future.  // 可选，未来支持。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - url – [in] (Optional) Node address of calling procedure.  // 可选，调用过程的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallProcedureToLeader(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &param, double procedure_time_out = 0.0, bool in_process = false, const std::string &graph = \"default\", bool json_format = true)**  \r\n  Execute a user-defined procedure to leader.  // 执行用户自定义的过程到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。"
            },
            {
                "content": "Execute a user-defined procedure to leader.  // 执行用户自定义的过程到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - param – [in] the execution parameters.  // 输入执行参数。\r\n  - procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - in_process – [in] (Optional) support in future.  // 可选，未来支持。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。"
            },
            {
                "content": "- param – [in] the execution parameters.  // 输入执行参数。\r\n  - procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - in_process – [in] (Optional) support in future.  // 可选，未来支持。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool LoadProcedure(std::string &result, const std::string &source_file, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a built-in procedure.  // 加载内置过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - source_file – [in] the source_file contain procedure code.  // 输入包含过程代码的源文件。"
            },
            {
                "content": "- **bool LoadProcedure(std::string &result, const std::string &source_file, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a built-in procedure.  // 加载内置过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - source_file – [in] the source_file contain procedure code.  // 输入包含过程代码的源文件。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  // 输入代码类型，目前支持 PY、SO、CPP、ZIP。\r\n  - procedure_description – [in] procedure description.  // 输入过程描述。\r\n  - read_only – [in] procedure is read only or not.  // 输入过程是否为只读。\r\n  - version – [in] (Optional) the version of procedure.  // 可选，过程版本。"
            },
            {
                "content": "- procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  // 输入代码类型，目前支持 PY、SO、CPP、ZIP。\r\n  - procedure_description – [in] procedure description.  // 输入过程描述。\r\n  - read_only – [in] procedure is read only or not.  // 输入过程是否为只读。\r\n  - version – [in] (Optional) the version of procedure.  // 可选，过程版本。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool LoadProcedure(std::string &result, const std::vector &source_files, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a built-in procedure.  \r\n  加载一个内置过程。\r\n\r\n  **参数**"
            },
            {
                "content": "**返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool LoadProcedure(std::string &result, const std::vector &source_files, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a built-in procedure.  \r\n  加载一个内置过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - source_files – [in] the source_file list contain procedure code(only for code_type cpp).  // 输入参数，包含过程代码的源文件列表（仅适用于代码类型为cpp）。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入参数，过程类型，目前支持CPP和PY。\r\n  - procedure_name – [in] procedure name.  // 输入参数，过程名称。\r\n  - code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  // 输入参数，代码类型，目前支持PY、SO、CPP、ZIP。\r\n  - procedure_description – [in] procedure description.  // 输入参数，过程描述。"
            },
            {
                "content": "- source_files – [in] the source_file list contain procedure code(only for code_type cpp).  // 输入参数，包含过程代码的源文件列表（仅适用于代码类型为cpp）。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入参数，过程类型，目前支持CPP和PY。\r\n  - procedure_name – [in] procedure name.  // 输入参数，过程名称。\r\n  - code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  // 输入参数，代码类型，目前支持PY、SO、CPP、ZIP。\r\n  - procedure_description – [in] procedure description.  // 输入参数，过程描述。\r\n  - read_only – [in] procedure is read only or not.  // 输入参数，过程是否为只读。\r\n  - version – [in] (Optional) the version of procedure.  // 输入参数（可选），过程的版本。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ListProcedures(std::string &result, const std::string &procedure_type, const std::string &version = \"any\", const std::string &graph = \"default\", const std::string &url = \"\")**  \r\n  List user-defined procedures.  \r\n  列出用户定义的过程。\r\n\r\n  **参数**"
            },
            {
                "content": "- version – [in] (Optional) the version of procedure.  // 输入参数（可选），过程的版本。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ListProcedures(std::string &result, const std::string &procedure_type, const std::string &version = \"any\", const std::string &graph = \"default\", const std::string &url = \"\")**  \r\n  List user-defined procedures.  \r\n  列出用户定义的过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - procedure_type – [in] (Optional) the procedure type, “” for all procedures, CPP and PY for special type.  // 输入参数（可选），过程类型，\"\"表示所有过程，CPP和PY表示特定类型。\r\n  - version – [in] (Optional) the version of procedure.  // 输入参数（可选），过程的版本。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - url – [in] Node address of calling procedure.  // 输入参数，调用过程的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。"
            },
            {
                "content": "**参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - procedure_type – [in] (Optional) the procedure type, “” for all procedures, CPP and PY for special type.  // 输入参数（可选），过程类型，\"\"表示所有过程，CPP和PY表示特定类型。\r\n  - version – [in] (Optional) the version of procedure.  // 输入参数（可选），过程的版本。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - url – [in] Node address of calling procedure.  // 输入参数，调用过程的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool DeleteProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &graph = \"default\")**  \r\n  Execute a user-defined procedure.  \r\n  执行用户定义的过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入参数，过程类型，目前支持CPP和PY。\r\n  - procedure_name – [in] procedure name.  // 输入参数，过程名称。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。"
            },
            {
                "content": "- **bool DeleteProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &graph = \"default\")**  \r\n  Execute a user-defined procedure.  \r\n  执行用户定义的过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入参数，过程类型，目前支持CPP和PY。\r\n  - procedure_name – [in] procedure name.  // 输入参数，过程名称。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportSchemaFromContent(std::string &result, const std::string &schema, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from content string.  \r\n  从内容字符串中导入顶点或边的模式。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - schema – [in] the schema to be imported.  // 输入参数，要导入的模式。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。"
            },
            {
                "content": "True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportSchemaFromContent(std::string &result, const std::string &schema, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from content string.  \r\n  从内容字符串中导入顶点或边的模式。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - schema – [in] the schema to be imported.  // 输入参数，要导入的模式。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。"
            },
            {
                "content": "- result – [out] The result.  // 输出参数，返回结果。\r\n  - schema – [in] the schema to be imported.  // 输入参数，要导入的模式。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportDataFromContent(std::string &result, const std::string &desc, const std::string &data, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from content string.  \r\n  从内容字符串中导入顶点或边的数据。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - desc – [in] data format description.  // 输入参数，数据格式描述。"
            },
            {
                "content": "- **bool ImportDataFromContent(std::string &result, const std::string &desc, const std::string &data, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from content string.  \r\n  从内容字符串中导入顶点或边的数据。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - desc – [in] data format description.  // 输入参数，数据格式描述。\r\n  - data – [in] the data to be imported.  // 输入参数，要导入的数据。\r\n  - delimiter – [in] data separator.  // 输入参数，数据分隔符。\r\n  - continue_on_error – [in] (Optional) whether to continue when importing data fails.  // 输入参数（可选），导入数据失败时是否继续。\r\n  - thread_nums – [in] (Optional) maximum number of threads.  // 输入参数（可选），最大线程数。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。"
            },
            {
                "content": "- data – [in] the data to be imported.  // 输入参数，要导入的数据。\r\n  - delimiter – [in] data separator.  // 输入参数，数据分隔符。\r\n  - continue_on_error – [in] (Optional) whether to continue when importing data fails.  // 输入参数（可选），导入数据失败时是否继续。\r\n  - thread_nums – [in] (Optional) maximum number of threads.  // 输入参数（可选），最大线程数。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportSchemaFromFile(std::string &result, const std::string &schema_file, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from file.  \r\n  从文件导入顶点或边的模式。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。"
            },
            {
                "content": "- timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportSchemaFromFile(std::string &result, const std::string &schema_file, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from file.  \r\n  从文件导入顶点或边的模式。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - schema_file – [in] the schema_file contain schema.  // 输入参数，包含模式的schema文件。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。"
            },
            {
                "content": "- schema_file – [in] the schema_file contain schema.  // 输入参数，包含模式的schema文件。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportDataFromFile(std::string &result, const std::string &conf_file, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, int skip_packages = 0, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from file.  \r\n  从文件导入顶点或边的数据。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - conf_file – [in] data file contain format description and data.  // 输入参数，包含格式描述和数据的数据文件。\r\n  - delimiter – [in] data separator.  // 输入参数，数据分隔符。"
            },
            {
                "content": "Import vertex or edge data from file.  \r\n  从文件导入顶点或边的数据。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - conf_file – [in] data file contain format description and data.  // 输入参数，包含格式描述和数据的数据文件。\r\n  - delimiter – [in] data separator.  // 输入参数，数据分隔符。\r\n  - continue_on_error – [in] (Optional) whether to continue when importing data fails.  // 输入参数（可选），导入数据失败时是否继续。\r\n  - thread_nums – [in] (Optional) maximum number of threads.  // 输入参数（可选），最大线程数。\r\n  - skip_packages – [in] (Optional) skip packages number.  // 输入参数（可选），跳过的包数量。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **int64_t Restore(const std::vector &requests)**\r\n\r\n- **void Logout()**"
            },
            {
                "content": "- graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **int64_t Restore(const std::vector &requests)**\r\n\r\n- **void Logout()**  \r\n  Client log out.  \r\n  客户端登出。\r\n\r\n### Private Functions\r\n\r\n- **bool IsReadQuery(lgraph::GraphQueryType type, const std::string &query, const std::string &graph)**  \r\n  Determine whether it is a read-only query.  \r\n  确定是否为只读查询。\r\n\r\n  **参数**  \r\n  type – [in] inquire query type.  // 输入参数，查询类型。  \r\n  query – [in] inquire statement.  // 输入参数，查询语句。  \r\n  graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。"
            },
            {
                "content": "Client log out.  \r\n  客户端登出。\r\n\r\n### Private Functions\r\n\r\n- **bool IsReadQuery(lgraph::GraphQueryType type, const std::string &query, const std::string &graph)**  \r\n  Determine whether it is a read-only query.  \r\n  确定是否为只读查询。\r\n\r\n  **参数**  \r\n  type – [in] inquire query type.  // 输入参数，查询类型。  \r\n  query – [in] inquire statement.  // 输入参数，查询语句。  \r\n  graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **std::shared_ptr GetClient(lgraph::GraphQueryType type, const std::string &cypher, const std::string &graph)**  \r\n  Return rpc client based on whether it is a read-only query.  \r\n  根据是否为只读查询返回rpc客户端。\r\n\r\n  **参数**  \r\n  type – [in] inquire query type.  // 输入参数，查询类型。  \r\n  query – [in] inquire statement.  // 输入参数，查询语句。  \r\n  graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。  \r\n\r\n  **返回**"
            },
            {
                "content": "**返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **std::shared_ptr GetClient(lgraph::GraphQueryType type, const std::string &cypher, const std::string &graph)**  \r\n  Return rpc client based on whether it is a read-only query.  \r\n  根据是否为只读查询返回rpc客户端。\r\n\r\n  **参数**  \r\n  type – [in] inquire query type.  // 输入参数，查询类型。  \r\n  query – [in] inquire statement.  // 输入参数，查询语句。  \r\n  graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。  \r\n\r\n  **返回**  \r\n  Master rpc client if cypher is not read-only, slaver rpc client if cypher is read-only.  // 如果cypher不是只读，返回主rpc客户端；如果cypher是只读，返回从rpc客户端。\r\n\r\n- **std::shared_ptr GetClient(bool isReadQuery)**  \r\n  Return rpc client based on whether it is a read-only query.  \r\n  根据是否为只读查询返回rpc客户端。\r\n\r\n  **参数**  \r\n  isReadQuery – [in] read query or not.  // 输入参数，是否为只读查询。  \r\n\r\n  **返回**  \r\n  Master rpc client if cypher is not read-only, slaver rpc client if cypher is read-only.  // 如果cypher不是只读，返回主rpc客户端；如果cypher是只读，返回从rpc客户端。"
            },
            {
                "content": "- **std::shared_ptr GetClient(bool isReadQuery)**  \r\n  Return rpc client based on whether it is a read-only query.  \r\n  根据是否为只读查询返回rpc客户端。\r\n\r\n  **参数**  \r\n  isReadQuery – [in] read query or not.  // 输入参数，是否为只读查询。  \r\n\r\n  **返回**  \r\n  Master rpc client if cypher is not read-only, slaver rpc client if cypher is read-only.  // 如果cypher不是只读，返回主rpc客户端；如果cypher是只读，返回从rpc客户端。\r\n\r\n- **std::shared_ptr GetClientByNode(const std::string &url)**  \r\n  Get the client according to the node url.  \r\n  根据节点url获取客户端。\r\n\r\n  **参数**  \r\n  url – [in] Node address of client connection.  // 输入参数，客户端连接的节点地址。  \r\n\r\n  **返回**  \r\n  Rpc client connecting to url.  // 连接到url的Rpc客户端。\r\n\r\n- **void RefreshUserDefinedProcedure()**  \r\n  Refresh User-defined Procedure.  \r\n  刷新用户定义的过程。\r\n\r\n- **void RefreshBuiltInProcedure()**  \r\n  Refresh Built-in Procedure.  \r\n  刷新内置过程。\r\n\r\n- **void RefreshClientPool()**  \r\n  Refresh the client connection pool according to the cluster status.  \r\n  根据集群状态刷新客户端连接池。\r\n\r\n- **void LoadBalanceClientPool()**"
            },
            {
                "content": "**参数**  \r\n  url – [in] Node address of client connection.  // 输入参数，客户端连接的节点地址。  \r\n\r\n  **返回**  \r\n  Rpc client connecting to url.  // 连接到url的Rpc客户端。\r\n\r\n- **void RefreshUserDefinedProcedure()**  \r\n  Refresh User-defined Procedure.  \r\n  刷新用户定义的过程。\r\n\r\n- **void RefreshBuiltInProcedure()**  \r\n  Refresh Built-in Procedure.  \r\n  刷新内置过程。\r\n\r\n- **void RefreshClientPool()**  \r\n  Refresh the client connection pool according to the cluster status.  \r\n  根据集群状态刷新客户端连接池。\r\n\r\n- **void LoadBalanceClientPool()**  \r\n  Load balance the client pool.  \r\n  负载均衡客户端池。\r\n\r\n- **void RefreshConnection()**  \r\n  Refresh client pool, procedure info.  \r\n  刷新客户端池和过程信息。\r\n\r\n- **template bool DoubleCheckQuery(F const &f)**  \r\n  If an exception is thrown in the query, refresh the connection and re-execute.  \r\n  如果查询中抛出异常，刷新连接并重新执行。\r\n\r\n### Private Members\r\n\r\n- **ClientType client_type**  \r\n- **std::string user**  \r\n- **std::string password**  \r\n- **std::shared_ptr base_client**  \r\n- **std::vector urls**  \r\n- **std::shared_ptr leader_client**"
            },
            {
                "content": "负载均衡客户端池。\r\n\r\n- **void RefreshConnection()**  \r\n  Refresh client pool, procedure info.  \r\n  刷新客户端池和过程信息。\r\n\r\n- **template bool DoubleCheckQuery(F const &f)**  \r\n  If an exception is thrown in the query, refresh the connection and re-execute.  \r\n  如果查询中抛出异常，刷新连接并重新执行。\r\n\r\n### Private Members\r\n\r\n- **ClientType client_type**  \r\n- **std::string user**  \r\n- **std::string password**  \r\n- **std::shared_ptr base_client**  \r\n- **std::vector urls**  \r\n- **std::shared_ptr leader_client**  \r\n- **std::deque> client_pool**  \r\n- **nlohmann::json built_in_procedures = {}**  \r\n- **nlohmann::json user_defined_procedures = {}**  \r\n- **std::vector cypher_write_constant**  \r\n- **std::vector gql_write_constant**  \r\n\r\n### class RpcSingleClient\r\n\r\n#### Public Functions\r\n\r\n- **RpcSingleClient(const std::string &url, const std::string &user, const std::string &password)**  \r\n  RpcSingleClient Login.  \r\n  RpcSingleClient 登录。\r\n\r\n  **参数**  \r\n  url – Login address.  \r\n  url – 登录地址。  \r\n  user – The username.  \r\n  user – 用户名。"
            },
            {
                "content": "- **nlohmann::json built_in_procedures = {}**  \r\n- **nlohmann::json user_defined_procedures = {}**  \r\n- **std::vector cypher_write_constant**  \r\n- **std::vector gql_write_constant**  \r\n\r\n### class RpcSingleClient\r\n\r\n#### Public Functions\r\n\r\n- **RpcSingleClient(const std::string &url, const std::string &user, const std::string &password)**  \r\n  RpcSingleClient Login.  \r\n  RpcSingleClient 登录。\r\n\r\n  **参数**  \r\n  url – Login address.  \r\n  url – 登录地址。  \r\n  user – The username.  \r\n  user – 用户名。  \r\n  password – The password.  \r\n  password – 密码。  \r\n\r\n- **~RpcSingleClient()**\r\n\r\n- **int64_t Restore(const std::vector &requests)**\r\n\r\n- **bool LoadProcedure(std::string &result, const std::vector &source_files, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a user-defined procedure.  \r\n  加载用户定义的过程。\r\n\r\n  **参数**"
            },
            {
                "content": "password – The password.  \r\n  password – 密码。  \r\n\r\n- **~RpcSingleClient()**\r\n\r\n- **int64_t Restore(const std::vector &requests)**\r\n\r\n- **bool LoadProcedure(std::string &result, const std::vector &source_files, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a user-defined procedure.  \r\n  加载用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  source_files – [in] the source_file list contain procedure code(only for code_type cpp).  \r\n  source_files – [输入] 包含过程代码的源文件列表（仅适用于代码类型 cpp）。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。  \r\n  code_type – [in] code type, currently supported PY, SO, CPP, ZIP."
            },
            {
                "content": "加载用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  source_files – [in] the source_file list contain procedure code(only for code_type cpp).  \r\n  source_files – [输入] 包含过程代码的源文件列表（仅适用于代码类型 cpp）。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。  \r\n  code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  \r\n  code_type – [输入] 代码类型，目前支持 PY、SO、CPP、ZIP。  \r\n  procedure_description – [in] procedure description.  \r\n  procedure_description – [输入] 过程描述。  \r\n  read_only – [in] procedure is read only or not.  \r\n  read_only – [输入] 过程是否为只读。  \r\n  version – [in] (Optional) the version of procedure.  \r\n  version – [输入] （可选）过程的版本。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。"
            },
            {
                "content": "code_type – [输入] 代码类型，目前支持 PY、SO、CPP、ZIP。  \r\n  procedure_description – [in] procedure description.  \r\n  procedure_description – [输入] 过程描述。  \r\n  read_only – [in] procedure is read only or not.  \r\n  read_only – [输入] 过程是否为只读。  \r\n  version – [in] (Optional) the version of procedure.  \r\n  version – [输入] （可选）过程的版本。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &param, double procedure_time_out = 0.0, bool in_process = false, const std::string &graph = \"default\", bool json_format = true)**  \r\n  Execute a user-defined procedure.  \r\n  执行用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。"
            },
            {
                "content": "Execute a user-defined procedure.  \r\n  执行用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。  \r\n  param – [in] the execution parameters.  \r\n  param – [输入] 执行参数。  \r\n  procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  procedure_time_out – [输入] （可选）最大执行时间，超时将被中断。  \r\n  in_process – [in] (Optional) support in future.  \r\n  in_process – [输入] （可选）未来支持。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。"
            },
            {
                "content": "procedure_time_out – [输入] （可选）最大执行时间，超时将被中断。  \r\n  in_process – [in] (Optional) support in future.  \r\n  in_process – [输入] （可选）未来支持。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ListProcedures(std::string &result, const std::string &procedure_type, const std::string &version = \"any\", const std::string &graph = \"default\")**  \r\n  List user-defined procedures.  \r\n  列出用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] (Optional) the procedure type, “” for all procedures, CPP and PY for special type.  \r\n  procedure_type – [输入] （可选）过程类型，“”表示所有过程，CPP 和 PY 表示特定类型。  \r\n  version – [in] (Optional) the version of procedure.  \r\n  version – [输入] （可选）过程的版本。"
            },
            {
                "content": "List user-defined procedures.  \r\n  列出用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] (Optional) the procedure type, “” for all procedures, CPP and PY for special type.  \r\n  procedure_type – [输入] （可选）过程类型，“”表示所有过程，CPP 和 PY 表示特定类型。  \r\n  version – [in] (Optional) the version of procedure.  \r\n  version – [输入] （可选）过程的版本。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool DeleteProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &graph = \"default\")**  \r\n  Execute a user-defined procedure.  \r\n  删除用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。"
            },
            {
                "content": "如果成功则返回真，失败则返回假。\r\n\r\n- **bool DeleteProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &graph = \"default\")**  \r\n  Execute a user-defined procedure.  \r\n  删除用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportSchemaFromFile(std::string &result, const std::string &schema_file, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from file.  \r\n  从文件导入顶点或边的模式。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  schema_file – [in] the schema_file contain schema."
            },
            {
                "content": "graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportSchemaFromFile(std::string &result, const std::string &schema_file, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from file.  \r\n  从文件导入顶点或边的模式。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  schema_file – [in] the schema_file contain schema.  \r\n  schema_file – [输入] 包含模式的模式文件。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。"
            },
            {
                "content": "schema_file – [输入] 包含模式的模式文件。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportDataFromFile(std::string &result, const std::string &conf_file, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, int skip_packages = 0, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from file.  \r\n  从文件导入顶点或边的数据。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  conf_file – [in] data file contain format description and data.  \r\n  conf_file – [输入] 数据文件包含格式描述和数据。  \r\n  delimiter – [in] data separator."
            },
            {
                "content": "Import vertex or edge data from file.  \r\n  从文件导入顶点或边的数据。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  conf_file – [in] data file contain format description and data.  \r\n  conf_file – [输入] 数据文件包含格式描述和数据。  \r\n  delimiter – [in] data separator.  \r\n  delimiter – [输入] 数据分隔符。  \r\n  continue_on_error – [in] (Optional) whether to continue when importing data fails.  \r\n  continue_on_error – [输入] （可选）导入数据失败时是否继续。  \r\n  thread_nums – [in] (Optional) maximum number of threads.  \r\n  thread_nums – [输入] （可选）最大线程数。  \r\n  skip_packages – [in] (Optional) skip packages number.  \r\n  skip_packages – [输入] （可选）跳过的包数。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**"
            },
            {
                "content": "thread_nums – [输入] （可选）最大线程数。  \r\n  skip_packages – [in] (Optional) skip packages number.  \r\n  skip_packages – [输入] （可选）跳过的包数。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportSchemaFromContent(std::string &result, const std::string &schema, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from content string.  \r\n  从内容字符串导入顶点或边的模式。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  schema – [in] the schema to be imported.  \r\n  schema – [输入] 要导入的模式。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。"
            },
            {
                "content": "如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportSchemaFromContent(std::string &result, const std::string &schema, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from content string.  \r\n  从内容字符串导入顶点或边的模式。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  schema – [in] the schema to be imported.  \r\n  schema – [输入] 要导入的模式。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。"
            },
            {
                "content": "schema – [in] the schema to be imported.  \r\n  schema – [输入] 要导入的模式。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportDataFromContent(std::string &result, const std::string &desc, const std::string &data, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from content string.  \r\n  从内容字符串导入顶点或边的数据。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  desc – [in] data format description.  \r\n  desc – [输入] 数据格式描述。"
            },
            {
                "content": "如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportDataFromContent(std::string &result, const std::string &desc, const std::string &data, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from content string.  \r\n  从内容字符串导入顶点或边的数据。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  desc – [in] data format description.  \r\n  desc – [输入] 数据格式描述。  \r\n  data – [in] the data to be imported.  \r\n  data – [输入] 要导入的数据。  \r\n  delimiter – [in] data separator.  \r\n  delimiter – [输入] 数据分隔符。  \r\n  continue_on_error – [in] (Optional) whether to continue when importing data fails.  \r\n  continue_on_error – [输入] （可选）导入数据失败时是否继续。  \r\n  thread_nums – [in] (Optional) maximum number of threads.  \r\n  thread_nums – [输入] （可选）最大线程数。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。"
            },
            {
                "content": "desc – [in] data format description.  \r\n  desc – [输入] 数据格式描述。  \r\n  data – [in] the data to be imported.  \r\n  data – [输入] 要导入的数据。  \r\n  delimiter – [in] data separator.  \r\n  delimiter – [输入] 数据分隔符。  \r\n  continue_on_error – [in] (Optional) whether to continue when importing data fails.  \r\n  continue_on_error – [输入] （可选）导入数据失败时是否继续。  \r\n  thread_nums – [in] (Optional) maximum number of threads.  \r\n  thread_nums – [输入] （可选）最大线程数。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallCypher(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**"
            },
            {
                "content": "json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallCypher(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a cypher query.  \r\n  执行一个 cypher 查询。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  cypher – [in] inquire statement.  \r\n  cypher – [输入] 查询语句。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted."
            },
            {
                "content": "Execute a cypher query.  \r\n  执行一个 cypher 查询。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  cypher – [in] inquire statement.  \r\n  cypher – [输入] 查询语句。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallGql(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a gql query.  \r\n  执行一个 gql 查询。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  gql – [in] inquire statement.  \r\n  gql – [输入] 查询语句。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。"
            },
            {
                "content": "**返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallGql(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a gql query.  \r\n  执行一个 gql 查询。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  gql – [in] inquire statement.  \r\n  gql – [输入] 查询语句。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **std::string GetUrl()**  \r\n  Get the url of single client.  \r\n  获取单个客户端的 URL。\r\n\r\n  **返回**  \r\n  the url of single client.  \r\n  单个客户端的 URL。\r\n\r\n- **void Logout()**  \r\n  Client log out."
            },
            {
                "content": "json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **std::string GetUrl()**  \r\n  Get the url of single client.  \r\n  获取单个客户端的 URL。\r\n\r\n  **返回**  \r\n  the url of single client.  \r\n  单个客户端的 URL。\r\n\r\n- **void Logout()**  \r\n  Client log out.  \r\n  客户端登出。\r\n\r\n### Private Functions\r\n\r\n- **LGraphResponse HandleRequest(LGraphRequest *req)**  \r\n- **bool HandleGraphQueryRequest(lgraph::GraphQueryType type, LGraphResponse *res, const std::string &query, const std::string &graph, bool json_format, double timeout)**  \r\n- **std::string GraphQueryResponseExtractor(const GraphQueryResponse &cypher)**  \r\n\r\n### Private Members\r\n\r\n- **std::string url**  \r\n- **std::string user**  \r\n- **std::string password**  \r\n- **std::string token**  \r\n- **int64_t server_version**  \r\n- **std::shared_ptr channel**  \r\n- **std::shared_ptr cntl**"
            },
            {
                "content": "- **bool HandleGraphQueryRequest(lgraph::GraphQueryType type, LGraphResponse *res, const std::string &query, const std::string &graph, bool json_format, double timeout)**  \r\n- **std::string GraphQueryResponseExtractor(const GraphQueryResponse &cypher)**  \r\n\r\n### Private Members\r\n\r\n- **std::string url**  \r\n- **std::string user**  \r\n- **std::string password**  \r\n- **std::string token**  \r\n- **int64_t server_version**  \r\n- **std::shared_ptr channel**  \r\n- **std::shared_ptr cntl**  \r\n- **std::shared_ptr options**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_traversal\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace traversal\r\n```\r\n\r\n### Functions\r\n\r\n- **ParallelVector FindVertices(GraphDB &db, Transaction &txn, std::function filter, bool parallel = false)**  \r\n  Retrieve all vertices passing the specified filter. Note that if the transaction is not read-only, parallel will be ignored (i.e. parallelism will not be available).  \r\n  // 检索所有满足指定过滤条件的顶点。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **参数**"
            },
            {
                "content": "- **std::shared_ptr options**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_traversal\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace traversal\r\n```\r\n\r\n### Functions\r\n\r\n- **ParallelVector FindVertices(GraphDB &db, Transaction &txn, std::function filter, bool parallel = false)**  \r\n  Retrieve all vertices passing the specified filter. Note that if the transaction is not read-only, parallel will be ignored (i.e. parallelism will not be available).  \r\n  // 检索所有满足指定过滤条件的顶点。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  // db – [输入输出] GraphDB 实例。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  filter – [inout] The user-defined filter function.  \r\n  // filter – [输入输出] 用户定义的过滤函数。  \r\n  parallel – (Optional) Enable parallelism or not.  \r\n  // parallel – （可选）是否启用并行。\r\n\r\n  **返回**  \r\n  The corresponding list of vertices.  \r\n  // 返回相应的顶点列表。"
            },
            {
                "content": "// 检索所有满足指定过滤条件的顶点。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  // db – [输入输出] GraphDB 实例。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  filter – [inout] The user-defined filter function.  \r\n  // filter – [输入输出] 用户定义的过滤函数。  \r\n  parallel – (Optional) Enable parallelism or not.  \r\n  // parallel – （可选）是否启用并行。\r\n\r\n  **返回**  \r\n  The corresponding list of vertices.  \r\n  // 返回相应的顶点列表。\r\n\r\n- **template static ParallelVector ExtractVertexData(GraphDB &db, Transaction &txn, ParallelVector &frontier, std::function extract, bool parallel = false)**  \r\n  Extract data from specified vertices. Note that if the transaction is not read-only, parallel will be ignored (i.e. parallelism will not be available).  \r\n  // 从指定的顶点中提取数据。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  \r\n  // std::runtime_error – 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  VertexData – Type of the vertex data."
            },
            {
                "content": "Extract data from specified vertices. Note that if the transaction is not read-only, parallel will be ignored (i.e. parallelism will not be available).  \r\n  // 从指定的顶点中提取数据。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  \r\n  // std::runtime_error – 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  VertexData – Type of the vertex data.  \r\n  // VertexData – 顶点数据的类型。\r\n\r\n  **参数**  \r\n  db – [inout] The database.  \r\n  // db – [输入输出] 数据库。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  frontier – [inout] The vertices to extract data from.  \r\n  // frontier – [输入输出] 要提取数据的顶点。  \r\n  extract – [inout] The user-defined extract function.  \r\n  // extract – [输入输出] 用户定义的提取函数。  \r\n  parallel – (Optional) Enable parallelism or not.  \r\n  // parallel – （可选）是否启用并行。\r\n\r\n  **返回**  \r\n  The corresponding extracted data.  \r\n  // 返回相应的提取数据。\r\n\r\n- **template bool DefaultFilter(IT ⁢)**  \r\n  The default filter you may use.  \r\n  // 您可以使用的默认过滤器。\r\n\r\n  **模板参数**"
            },
            {
                "content": "// txn – [输入输出] 事务。  \r\n  frontier – [inout] The vertices to extract data from.  \r\n  // frontier – [输入输出] 要提取数据的顶点。  \r\n  extract – [inout] The user-defined extract function.  \r\n  // extract – [输入输出] 用户定义的提取函数。  \r\n  parallel – (Optional) Enable parallelism or not.  \r\n  // parallel – （可选）是否启用并行。\r\n\r\n  **返回**  \r\n  The corresponding extracted data.  \r\n  // 返回相应的提取数据。\r\n\r\n- **template bool DefaultFilter(IT ⁢)**  \r\n  The default filter you may use.  \r\n  // 您可以使用的默认过滤器。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  it – [inout] An iterator class.  \r\n  // it – [输入输出] 一个迭代器类。\r\n\r\n  **返回**  \r\n  Always true.  \r\n  // 总是返回 true。\r\n\r\n- **template std::function LabelEquals(const std::string &label)**  \r\n  Function closure filtering by label.  \r\n  // 根据标签进行过滤的函数闭包。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  label – An iterator class.  \r\n  // label – 一个迭代器类。\r\n\r\n  **返回**  \r\n  The filter function.  \r\n  // 返回过滤函数。"
            },
            {
                "content": "IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  it – [inout] An iterator class.  \r\n  // it – [输入输出] 一个迭代器类。\r\n\r\n  **返回**  \r\n  Always true.  \r\n  // 总是返回 true。\r\n\r\n- **template std::function LabelEquals(const std::string &label)**  \r\n  Function closure filtering by label.  \r\n  // 根据标签进行过滤的函数闭包。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  label – An iterator class.  \r\n  // label – 一个迭代器类。\r\n\r\n  **返回**  \r\n  The filter function.  \r\n  // 返回过滤函数。\r\n\r\n- **template std::function LabelEquals(size_t label_id)**  \r\n  Function closure filtering by label id.  \r\n  // 根据标签 ID 进行过滤的函数闭包。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  label_id – An iterator class.  \r\n  // label_id – 一个迭代器类。\r\n\r\n  **返回**  \r\n  The filter function.  \r\n  // 返回过滤函数。\r\n\r\n- **bool operator==(const Vertex &lhs, const Vertex &rhs)**  \r\n  // 重载运算符 ==，比较两个 Vertex 对象是否相等。\r\n\r\n- **bool operator!=(const Vertex &lhs, const Vertex &rhs)**"
            },
            {
                "content": "// 返回过滤函数。\r\n\r\n- **template std::function LabelEquals(size_t label_id)**  \r\n  Function closure filtering by label id.  \r\n  // 根据标签 ID 进行过滤的函数闭包。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  label_id – An iterator class.  \r\n  // label_id – 一个迭代器类。\r\n\r\n  **返回**  \r\n  The filter function.  \r\n  // 返回过滤函数。\r\n\r\n- **bool operator==(const Vertex &lhs, const Vertex &rhs)**  \r\n  // 重载运算符 ==，比较两个 Vertex 对象是否相等。\r\n\r\n- **bool operator!=(const Vertex &lhs, const Vertex &rhs)**  \r\n  // 重载运算符 !=，比较两个 Vertex 对象是否不相等。\r\n\r\n- **bool operator==(const Edge &lhs, const Edge &rhs)**  \r\n  // 重载运算符 ==，比较两个 Edge 对象是否相等。\r\n\r\n- **bool operator!=(const Edge &lhs, const Edge &rhs)**  \r\n  // 重载运算符 !=，比较两个 Edge 对象是否不相等。\r\n\r\n### Variables\r\n\r\n- `static constexpr size_t MAX_RESULT_SIZE = 1ul << 36`  \r\n  // 最大结果大小的静态常量。\r\n\r\n- `static constexpr size_t TRAVERSAL_PARALLEL = 1ul << 0`  \r\n  // 并行遍历的静态常量。\r\n\r\n- `static constexpr size_t TRAVERSAL_ALLOW_REVISITS = 1ul << 1`  \r\n  // 允许重新访问的静态常量。\r\n\r\n### class Edge"
            },
            {
                "content": "// 重载运算符 !=，比较两个 Vertex 对象是否不相等。\r\n\r\n- **bool operator==(const Edge &lhs, const Edge &rhs)**  \r\n  // 重载运算符 ==，比较两个 Edge 对象是否相等。\r\n\r\n- **bool operator!=(const Edge &lhs, const Edge &rhs)**  \r\n  // 重载运算符 !=，比较两个 Edge 对象是否不相等。\r\n\r\n### Variables\r\n\r\n- `static constexpr size_t MAX_RESULT_SIZE = 1ul << 36`  \r\n  // 最大结果大小的静态常量。\r\n\r\n- `static constexpr size_t TRAVERSAL_PARALLEL = 1ul << 0`  \r\n  // 并行遍历的静态常量。\r\n\r\n- `static constexpr size_t TRAVERSAL_ALLOW_REVISITS = 1ul << 1`  \r\n  // 允许重新访问的静态常量。\r\n\r\n### class Edge\r\n\r\n```cpp\r\n#include \r\n```\r\nRepresent an edge.  \r\n// 表示一条边。\r\n\r\n**Public Functions**\r\n\r\n- **Edge(size_t start, uint16_t lid, uint64_t tid, size_t end, size_t eid, bool forward)**  \r\n  Constructor  \r\n  // 构造函数\r\n\r\n  **参数**  \r\n  start – The start.  \r\n  // start – 起始位置。  \r\n  lid – The lid.  \r\n  // lid – 标签 ID。  \r\n  tid – The tid.  \r\n  // tid – 时间 ID。  \r\n  end – The end.  \r\n  // end – 结束位置。  \r\n  eid – The eid.  \r\n  // eid – 边 ID。  \r\n  forward – True to forward.  \r\n  // forward – 如果为 true，则表示为正向。"
            },
            {
                "content": "### class Edge\r\n\r\n```cpp\r\n#include \r\n```\r\nRepresent an edge.  \r\n// 表示一条边。\r\n\r\n**Public Functions**\r\n\r\n- **Edge(size_t start, uint16_t lid, uint64_t tid, size_t end, size_t eid, bool forward)**  \r\n  Constructor  \r\n  // 构造函数\r\n\r\n  **参数**  \r\n  start – The start.  \r\n  // start – 起始位置。  \r\n  lid – The lid.  \r\n  // lid – 标签 ID。  \r\n  tid – The tid.  \r\n  // tid – 时间 ID。  \r\n  end – The end.  \r\n  // end – 结束位置。  \r\n  eid – The eid.  \r\n  // eid – 边 ID。  \r\n  forward – True to forward.  \r\n  // forward – 如果为 true，则表示为正向。\r\n\r\n- **Edge(const Edge &rhs) = default**  \r\n  Copy constructor  \r\n  // 拷贝构造函数\r\n\r\n  **参数**  \r\n  rhs – The right hand side.  \r\n  // rhs – 右侧对象。\r\n\r\n- **Vertex GetStartVertex() const**  \r\n  Get the start vertex of this edge.  \r\n  // 获取此边的起始顶点。\r\n\r\n  **返回**  \r\n  The start vertex.  \r\n  // 返回起始顶点。\r\n\r\n- **Vertex GetEndVertex() const**  \r\n  Get the end vertex of this edge.  \r\n  // 获取此边的结束顶点。\r\n\r\n  **返回**  \r\n  The end vertex.  \r\n  // 返回结束顶点。\r\n\r\n- **uint16_t GetLabelId() const**  \r\n  Get the label ID.  \r\n  // 获取标签 ID。"
            },
            {
                "content": "- **Edge(const Edge &rhs) = default**  \r\n  Copy constructor  \r\n  // 拷贝构造函数\r\n\r\n  **参数**  \r\n  rhs – The right hand side.  \r\n  // rhs – 右侧对象。\r\n\r\n- **Vertex GetStartVertex() const**  \r\n  Get the start vertex of this edge.  \r\n  // 获取此边的起始顶点。\r\n\r\n  **返回**  \r\n  The start vertex.  \r\n  // 返回起始顶点。\r\n\r\n- **Vertex GetEndVertex() const**  \r\n  Get the end vertex of this edge.  \r\n  // 获取此边的结束顶点。\r\n\r\n  **返回**  \r\n  The end vertex.  \r\n  // 返回结束顶点。\r\n\r\n- **uint16_t GetLabelId() const**  \r\n  Get the label ID.  \r\n  // 获取标签 ID。\r\n\r\n  **返回**  \r\n  The label ID.  \r\n  // 返回标签 ID。\r\n\r\n- **uint64_t GetTemporalId() const**  \r\n  Get the Temporal ID.  \r\n  // 获取时间 ID。\r\n\r\n  **返回**  \r\n  The temporal ID.  \r\n  // 返回时间 ID。\r\n\r\n- **size_t GetEdgeId() const**  \r\n  Get the edge ID.  \r\n  // 获取边 ID。\r\n\r\n  **返回**  \r\n  The edge ID.  \r\n  // 返回边 ID。\r\n\r\n- **bool IsForward() const**  \r\n  Get the direction of this edge.  \r\n  // 获取此边的方向。\r\n\r\n  **返回**  \r\n  true : forward; false: backward.  \r\n  // 返回 true 表示正向，false 表示反向。\r\n\r\n- **Vertex GetSrcVertex() const**"
            },
            {
                "content": "**返回**  \r\n  The label ID.  \r\n  // 返回标签 ID。\r\n\r\n- **uint64_t GetTemporalId() const**  \r\n  Get the Temporal ID.  \r\n  // 获取时间 ID。\r\n\r\n  **返回**  \r\n  The temporal ID.  \r\n  // 返回时间 ID。\r\n\r\n- **size_t GetEdgeId() const**  \r\n  Get the edge ID.  \r\n  // 获取边 ID。\r\n\r\n  **返回**  \r\n  The edge ID.  \r\n  // 返回边 ID。\r\n\r\n- **bool IsForward() const**  \r\n  Get the direction of this edge.  \r\n  // 获取此边的方向。\r\n\r\n  **返回**  \r\n  true : forward; false: backward.  \r\n  // 返回 true 表示正向，false 表示反向。\r\n\r\n- **Vertex GetSrcVertex() const**  \r\n  Get the source vertex of this edge.  \r\n  // 获取此边的源顶点。\r\n\r\n  **返回**  \r\n  The source vertex.  \r\n  // 返回源顶点。\r\n\r\n- **Vertex GetDstVertex() const**  \r\n  Get the destination vertex of this edge.  \r\n  // 获取此边的目标顶点。\r\n\r\n  **返回**  \r\n  The destination vertex.  \r\n  // 返回目标顶点。\r\n\r\n**Private Members**\r\n\r\n- size_t start_  \r\n  // 起始位置。\r\n\r\n- size_t end_  \r\n  // 结束位置。\r\n\r\n- size_t eid_  \r\n  // 边 ID。\r\n\r\n- uint16_t lid_  \r\n  // 标签 ID。\r\n\r\n- int64_t tid_  \r\n  // 时间 ID。\r\n\r\n- bool forward_  \r\n  // 方向标志。\r\n\r\n**Friends**"
            },
            {
                "content": "Get the source vertex of this edge.  \r\n  // 获取此边的源顶点。\r\n\r\n  **返回**  \r\n  The source vertex.  \r\n  // 返回源顶点。\r\n\r\n- **Vertex GetDstVertex() const**  \r\n  Get the destination vertex of this edge.  \r\n  // 获取此边的目标顶点。\r\n\r\n  **返回**  \r\n  The destination vertex.  \r\n  // 返回目标顶点。\r\n\r\n**Private Members**\r\n\r\n- size_t start_  \r\n  // 起始位置。\r\n\r\n- size_t end_  \r\n  // 结束位置。\r\n\r\n- size_t eid_  \r\n  // 边 ID。\r\n\r\n- uint16_t lid_  \r\n  // 标签 ID。\r\n\r\n- int64_t tid_  \r\n  // 时间 ID。\r\n\r\n- bool forward_  \r\n  // 方向标志。\r\n\r\n**Friends**\r\n\r\n- friend class Path  \r\n  // 友元类 Path  \r\n- friend class IteratorHelper  \r\n  // 友元类 IteratorHelper  \r\n- friend class PathTraversal  \r\n  // 友元类 PathTraversal  \r\n\r\n### class FrontierTraversal\r\n\r\n```cpp\r\n#include \r\n```"
            },
            {
                "content": "**返回**  \r\n  The destination vertex.  \r\n  // 返回目标顶点。\r\n\r\n**Private Members**\r\n\r\n- size_t start_  \r\n  // 起始位置。\r\n\r\n- size_t end_  \r\n  // 结束位置。\r\n\r\n- size_t eid_  \r\n  // 边 ID。\r\n\r\n- uint16_t lid_  \r\n  // 标签 ID。\r\n\r\n- int64_t tid_  \r\n  // 时间 ID。\r\n\r\n- bool forward_  \r\n  // 方向标志。\r\n\r\n**Friends**\r\n\r\n- friend class Path  \r\n  // 友元类 Path  \r\n- friend class IteratorHelper  \r\n  // 友元类 IteratorHelper  \r\n- friend class PathTraversal  \r\n  // 友元类 PathTraversal  \r\n\r\n### class FrontierTraversal\r\n\r\n```cpp\r\n#include \r\n```\r\nFrontierTraversal provides the most common way to traverse graphs. You can start from a single vertex or a set of vertices (known as the initial frontier), and expand them frontier by frontier, each time visiting neighboring vertices of the current frontier and make those matching specified conditions the new frontier. One powerful feature of FrontierTraversal is that the traversal can be performed in parallel, accelerating those deep queries significantly."
            },
            {
                "content": "```cpp\r\n#include \r\n```\r\nFrontierTraversal provides the most common way to traverse graphs. You can start from a single vertex or a set of vertices (known as the initial frontier), and expand them frontier by frontier, each time visiting neighboring vertices of the current frontier and make those matching specified conditions the new frontier. One powerful feature of FrontierTraversal is that the traversal can be performed in parallel, accelerating those deep queries significantly.  \r\n// FrontierTraversal 提供了遍历图的最常用方式。您可以从单个顶点或一个顶点集合（称为初始前沿）开始，然后逐渐扩展每个前沿，每次访问当前前沿的邻居顶点，并使符合指定条件的顶点成为新的前沿。FrontierTraversal 的一个强大特性是遍历可以并行执行，从而显著加速深度查询。\r\n\r\n**Public Functions**\r\n\r\n- **FrontierTraversal(GraphDB &db, Transaction &txn, size_t flags = 0, size_t capacity = MAX_RESULT_SIZE)**"
            },
            {
                "content": "// FrontierTraversal 提供了遍历图的最常用方式。您可以从单个顶点或一个顶点集合（称为初始前沿）开始，然后逐渐扩展每个前沿，每次访问当前前沿的邻居顶点，并使符合指定条件的顶点成为新的前沿。FrontierTraversal 的一个强大特性是遍历可以并行执行，从而显著加速深度查询。\r\n\r\n**Public Functions**\r\n\r\n- **FrontierTraversal(GraphDB &db, Transaction &txn, size_t flags = 0, size_t capacity = MAX_RESULT_SIZE)**  \r\n  Construct the FrontierTraversal object. Note that the transaction must be read-only if you want to perform the traversals in parallel (i.e. TRAVERSAL_PARALLEL is specified in flags). Be careful when TRAVERSAL_ALLOW_REVISITS is used, as each vertex may be visited more than once, making the result set huge.  \r\n  // 构造 FrontierTraversal 对象。请注意，如果您希望并行执行遍历，则事务必须是只读的（即在标志中指定了 TRAVERSAL_PARALLEL）。使用 TRAVERSAL_ALLOW_REVISITS 时要小心，因为每个顶点可能会被访问多次，从而使结果集变得庞大。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  // db – [输入输出] GraphDB 实例。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  flags – (Optional) The options used during traversals.  \r\n  // flags – （可选）遍历时使用的选项。\r\n\r\n- **ParallelVector &GetFrontier()**"
            },
            {
                "content": "// 构造 FrontierTraversal 对象。请注意，如果您希望并行执行遍历，则事务必须是只读的（即在标志中指定了 TRAVERSAL_PARALLEL）。使用 TRAVERSAL_ALLOW_REVISITS 时要小心，因为每个顶点可能会被访问多次，从而使结果集变得庞大。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  // db – [输入输出] GraphDB 实例。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  flags – (Optional) The options used during traversals.  \r\n  // flags – （可选）遍历时使用的选项。\r\n\r\n- **ParallelVector &GetFrontier()**  \r\n  Retrieve the current (i.e. latest) frontier.  \r\n  // 获取当前（即最新）的前沿。\r\n\r\n  **返回**  \r\n  The frontier.  \r\n  // 返回前沿。\r\n\r\n- **void SetFrontier(size_t root_vid)**  \r\n  Set the (initial) frontier to contain a single vertex.  \r\n  // 设置（初始）前沿为单个顶点。\r\n\r\n  **参数**  \r\n  root_vid – The identifer for the starting vertex.  \r\n  // root_vid – 起始顶点的标识符。\r\n\r\n- **void SetFrontier(ParallelVector &root_vids)**  \r\n  Set the (initial) frontier to contain a set of vertices.  \r\n  // 设置（初始）前沿为一组顶点。\r\n\r\n  **参数**  \r\n  root_vids – [inout] The starting vertex identifiers.  \r\n  // root_vids – [输入输出] 起始顶点的标识符。"
            },
            {
                "content": "**返回**  \r\n  The frontier.  \r\n  // 返回前沿。\r\n\r\n- **void SetFrontier(size_t root_vid)**  \r\n  Set the (initial) frontier to contain a single vertex.  \r\n  // 设置（初始）前沿为单个顶点。\r\n\r\n  **参数**  \r\n  root_vid – The identifer for the starting vertex.  \r\n  // root_vid – 起始顶点的标识符。\r\n\r\n- **void SetFrontier(ParallelVector &root_vids)**  \r\n  Set the (initial) frontier to contain a set of vertices.  \r\n  // 设置（初始）前沿为一组顶点。\r\n\r\n  **参数**  \r\n  root_vids – [inout] The starting vertex identifiers.  \r\n  // root_vids – [输入输出] 起始顶点的标识符。\r\n\r\n- **void SetFrontier(std::function root_vertex_filter)**  \r\n  Set the (initial) frontier by using a filter function. Each vertex will be checked against the specified filter.  \r\n  // 使用过滤函数设置（初始）前沿。每个顶点将根据指定的过滤器进行检查。\r\n\r\n  **参数**  \r\n  root_vertex_filter – [inout] The filter function.  \r\n  // root_vertex_filter – [输入输出] 过滤函数。\r\n\r\n- **void ExpandOutEdges(std::function out_edge_filter = nullptr, std::function out_neighbour_filter = nullptr)**"
            },
            {
                "content": "// root_vids – [输入输出] 起始顶点的标识符。\r\n\r\n- **void SetFrontier(std::function root_vertex_filter)**  \r\n  Set the (initial) frontier by using a filter function. Each vertex will be checked against the specified filter.  \r\n  // 使用过滤函数设置（初始）前沿。每个顶点将根据指定的过滤器进行检查。\r\n\r\n  **参数**  \r\n  root_vertex_filter – [inout] The filter function.  \r\n  // root_vertex_filter – [输入输出] 过滤函数。\r\n\r\n- **void ExpandOutEdges(std::function out_edge_filter = nullptr, std::function out_neighbour_filter = nullptr)**  \r\n  Expand the current frontier through outgoing edges using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器通过出边扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  out_edge_filter – [inout] (Optional) The filter for an outgoing edge.  \r\n  // out_edge_filter – [输入输出] （可选）出边的过滤器。  \r\n  out_neighbour_filter – [inout] (Optional) The filter for an destination vertex."
            },
            {
                "content": "Expand the current frontier through outgoing edges using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器通过出边扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  out_edge_filter – [inout] (Optional) The filter for an outgoing edge.  \r\n  // out_edge_filter – [输入输出] （可选）出边的过滤器。  \r\n  out_neighbour_filter – [inout] (Optional) The filter for an destination vertex.  \r\n  // out_neighbour_filter – [输入输出] （可选）目标顶点的过滤器。\r\n\r\n- **void ExpandInEdges(std::function in_edge_filter = nullptr, std::function in_neighbour_filter = nullptr)**  \r\n  Expand the current frontier through incoming edges using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器通过入边扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**"
            },
            {
                "content": "// out_neighbour_filter – [输入输出] （可选）目标顶点的过滤器。\r\n\r\n- **void ExpandInEdges(std::function in_edge_filter = nullptr, std::function in_neighbour_filter = nullptr)**  \r\n  Expand the current frontier through incoming edges using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器通过入边扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  in_edge_filter – [inout] (Optional) The filter for an incoming edge.  \r\n  // in_edge_filter – [输入输出] （可选）入边的过滤器。  \r\n  in_neighbour_filter – [inout] (Optional) The filter for an source vertex.  \r\n  // in_neighbour_filter – [输入输出] （可选）源顶点的过滤器。\r\n\r\n- **void ExpandEdges(std::function out_edge_filter = nullptr, std::function in_edge_filter = nullptr, std::function out_neighbour_filter = nullptr, std::function in_neighbour_filter = nullptr)**"
            },
            {
                "content": "**参数**  \r\n  in_edge_filter – [inout] (Optional) The filter for an incoming edge.  \r\n  // in_edge_filter – [输入输出] （可选）入边的过滤器。  \r\n  in_neighbour_filter – [inout] (Optional) The filter for an source vertex.  \r\n  // in_neighbour_filter – [输入输出] （可选）源顶点的过滤器。\r\n\r\n- **void ExpandEdges(std::function out_edge_filter = nullptr, std::function in_edge_filter = nullptr, std::function out_neighbour_filter = nullptr, std::function in_neighbour_filter = nullptr)**  \r\n  Expand the current frontier through both directions using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器在两个方向上扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  out_edge_filter – [inout] (Optional) The filter for an outgoing edge.  \r\n  // out_edge_filter – [输入输出] （可选）出边的过滤器。  \r\n  in_edge_filter – [inout] (Optional) The filter for an incoming edge.  \r\n  // in_edge_filter – [输入输出] （可选）入边的过滤器。"
            },
            {
                "content": "// 通过使用过滤器在两个方向上扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  out_edge_filter – [inout] (Optional) The filter for an outgoing edge.  \r\n  // out_edge_filter – [输入输出] （可选）出边的过滤器。  \r\n  in_edge_filter – [inout] (Optional) The filter for an incoming edge.  \r\n  // in_edge_filter – [输入输出] （可选）入边的过滤器。  \r\n  out_neighbour_filter – [inout] (Optional) The filter for an destination vertex.  \r\n  // out_neighbour_filter – [输入输出] （可选）目标顶点的过滤器。  \r\n  in_neighbour_filter – [inout] (Optional) The filter for an source vertex.  \r\n  // in_neighbour_filter – [输入输出] （可选）源顶点的过滤器。\r\n\r\n- **void Reset()**  \r\n  Reset the traversal.  \r\n  // 重置遍历。\r\n\r\n- **void ResetVisited()**  \r\n  Reset only the visited flags.  \r\n  // 仅重置已访问的标志。\r\n\r\n**Private Members**\r\n\r\n- GraphDB &db_  \r\n  // GraphDB 引用。\r\n\r\n- Transaction &txn_  \r\n  // 事务引用。\r\n\r\n- size_t flags_  \r\n  // 标志。\r\n\r\n- size_t num_vertices_  \r\n  // 顶点数量。\r\n\r\n- ParallelVector curr_frontier_  \r\n  // 当前前沿。\r\n\r\n- ParallelVector next_frontier_  \r\n  // 下一个前沿。\r\n\r\n### class Vertex"
            },
            {
                "content": "// in_neighbour_filter – [输入输出] （可选）源顶点的过滤器。\r\n\r\n- **void Reset()**  \r\n  Reset the traversal.  \r\n  // 重置遍历。\r\n\r\n- **void ResetVisited()**  \r\n  Reset only the visited flags.  \r\n  // 仅重置已访问的标志。\r\n\r\n**Private Members**\r\n\r\n- GraphDB &db_  \r\n  // GraphDB 引用。\r\n\r\n- Transaction &txn_  \r\n  // 事务引用。\r\n\r\n- size_t flags_  \r\n  // 标志。\r\n\r\n- size_t num_vertices_  \r\n  // 顶点数量。\r\n\r\n- ParallelVector curr_frontier_  \r\n  // 当前前沿。\r\n\r\n- ParallelVector next_frontier_  \r\n  // 下一个前沿。\r\n\r\n### class Vertex\r\n\r\n```cpp\r\n#include \r\n```\r\nRepresent a vertex.  \r\n// 表示一个顶点。\r\n\r\n#### Public Functions\r\n\r\n- **explicit Vertex(size_t vid)**  \r\n  Constructor  \r\n  // 构造函数\r\n\r\n  **参数**  \r\n  vid – The vid.  \r\n  // vid – 顶点 ID。\r\n\r\n- **Vertex(const Vertex &rhs) = default**  \r\n  Copy constructor  \r\n  // 拷贝构造函数\r\n\r\n  **参数**  \r\n  rhs – The right hand side.  \r\n  // rhs – 右侧对象。\r\n\r\n- **size_t GetId() const**  \r\n  Get the Id of this vertex.  \r\n  // 获取此顶点的 ID。\r\n\r\n  **返回**  \r\n  The Id.  \r\n  // 返回 ID。\r\n\r\n#### Private Members\r\n\r\n- size_t vid_  \r\n  // 顶点 ID。"
            },
            {
                "content": "```\r\nRepresent a vertex.  \r\n// 表示一个顶点。\r\n\r\n#### Public Functions\r\n\r\n- **explicit Vertex(size_t vid)**  \r\n  Constructor  \r\n  // 构造函数\r\n\r\n  **参数**  \r\n  vid – The vid.  \r\n  // vid – 顶点 ID。\r\n\r\n- **Vertex(const Vertex &rhs) = default**  \r\n  Copy constructor  \r\n  // 拷贝构造函数\r\n\r\n  **参数**  \r\n  rhs – The right hand side.  \r\n  // rhs – 右侧对象。\r\n\r\n- **size_t GetId() const**  \r\n  Get the Id of this vertex.  \r\n  // 获取此顶点的 ID。\r\n\r\n  **返回**  \r\n  The Id.  \r\n  // 返回 ID。\r\n\r\n#### Private Members\r\n\r\n- size_t vid_  \r\n  // 顶点 ID。  \r\n\r\n#### Friends\r\n\r\n- friend class Path  \r\n  // 友元类 Path  \r\n- friend class IteratorHelper  \r\n  // 友元类 IteratorHelper  \r\n- friend class PathTraversal  \r\n  // 友元类 PathTraversal\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n\r\n\r\n## lgraph_txn\r\n\r\n```cpp\r\nnamespace lgraph\r\nnamespace lgraph_api\r\nclass Transaction\r\n#include \r\n```\r\n\r\nTuGraph operations happen in transactions. A transaction is a sequence of operations that is carried out atomically on the GraphDB. TuGraph transactions provide full ACID guarantees."
            },
            {
                "content": "// 顶点 ID。  \r\n\r\n#### Friends\r\n\r\n- friend class Path  \r\n  // 友元类 Path  \r\n- friend class IteratorHelper  \r\n  // 友元类 IteratorHelper  \r\n- friend class PathTraversal  \r\n  // 友元类 PathTraversal\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n\r\n\r\n## lgraph_txn\r\n\r\n```cpp\r\nnamespace lgraph\r\nnamespace lgraph_api\r\nclass Transaction\r\n#include \r\n```\r\n\r\nTuGraph operations happen in transactions. A transaction is a sequence of operations that is carried out atomically on the GraphDB. TuGraph transactions provide full ACID guarantees.\r\n// TuGraph 操作在交易中进行。一个交易是一系列在 GraphDB 上原子执行的操作。TuGraph 交易提供完全的 ACID 保证。\r\n\r\nTransactions are created using `GraphDB::CreateReadTxn()` and `GraphDB::CreateWriteTxn()`. A read transaction can only perform read operations, otherwise an exception is thrown. A write transaction can perform reads as well as writes. There are performance differences between read and write operations. So if you only need read in a transaction, you should create a read transaction."
            },
            {
                "content": "// TuGraph 操作在交易中进行。一个交易是一系列在 GraphDB 上原子执行的操作。TuGraph 交易提供完全的 ACID 保证。\r\n\r\nTransactions are created using `GraphDB::CreateReadTxn()` and `GraphDB::CreateWriteTxn()`. A read transaction can only perform read operations, otherwise an exception is thrown. A write transaction can perform reads as well as writes. There are performance differences between read and write operations. So if you only need read in a transaction, you should create a read transaction.\r\n// 交易是通过 `GraphDB::CreateReadTxn()` 和 `GraphDB::CreateWriteTxn()` 创建的。读交易只能执行读取操作，否则会抛出异常。写交易可以执行读取和写入操作。读取和写入操作之间存在性能差异。因此，如果您只需要在交易中读取，您应该创建一个读取交易。\r\n\r\nEach transaction must be used in one thread only, and they should not be passed from one thread to another unless it is a forked transaction.\r\n// 每个交易必须只在一个线程中使用，并且它们不应从一个线程传递到另一个线程，除非是一个派生交易。"
            },
            {
                "content": "// 交易是通过 `GraphDB::CreateReadTxn()` 和 `GraphDB::CreateWriteTxn()` 创建的。读交易只能执行读取操作，否则会抛出异常。写交易可以执行读取和写入操作。读取和写入操作之间存在性能差异。因此，如果您只需要在交易中读取，您应该创建一个读取交易。\r\n\r\nEach transaction must be used in one thread only, and they should not be passed from one thread to another unless it is a forked transaction.\r\n// 每个交易必须只在一个线程中使用，并且它们不应从一个线程传递到另一个线程，除非是一个派生交易。\r\n\r\nRead transactions can be forked. The new copy of the transaction will have the same view as the forked one, and it can be used in a separate thread. By forking from one read transaction and using the forked copies in different threads, we can parallelize the execution of specific operations. For example, you can implement a parallel BFS with this capability. Also, you can dump a snapshot of the whole graph using.\r\n// 读交易可以被派生。新副本的交易将与被派生的交易具有相同的视图，并且可以在不同的线程中使用。通过从一个读取交易派生并在不同线程中使用派生的副本，我们可以并行化特定操作的执行。例如，您可以利用此能力实现并行 BFS。同时，您可以使用它导出整个图的快照。\r\n\r\n### Public Functions\r\n\r\n```cpp\r\nTransaction(Transaction &&rhs) = default"
            },
            {
                "content": "// 读交易可以被派生。新副本的交易将与被派生的交易具有相同的视图，并且可以在不同的线程中使用。通过从一个读取交易派生并在不同线程中使用派生的副本，我们可以并行化特定操作的执行。例如，您可以利用此能力实现并行 BFS。同时，您可以使用它导出整个图的快照。\r\n\r\n### Public Functions\r\n\r\n```cpp\r\nTransaction(Transaction &&rhs) = default\r\nTransaction &operator=(Transaction &&rhs) = default\r\nTransaction(const Transaction&) = delete\r\nTransaction &operator=(const Transaction&) = delete\r\n```\r\n\r\n```cpp\r\nvoid Commit()\r\n```\r\nCommits this transaction. Note that optimistic write transactions may fail to commit (an TxnConflict would be thrown).\r\n// 提交此交易。请注意，乐观写交易可能会无法提交（将抛出 TxnConflict）。\r\n\r\n```cpp\r\nvoid Abort()\r\n```\r\nAborts this transaction.\r\n// 中止此交易。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this transaction is valid. Transaction becomes invalid after calling Abort() or Commit(). Operations on invalid transaction yield exceptions.\r\n// 查询此交易是否有效。交易在调用 Abort() 或 Commit() 后变为无效。在无效交易上执行操作将导致异常。\r\n\r\n返回  \r\nTrue if valid, false if not.\r\n// 如果有效返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool IsReadOnly() const\r\n```\r\nQuery if this txn is read only."
            },
            {
                "content": "// 提交此交易。请注意，乐观写交易可能会无法提交（将抛出 TxnConflict）。\r\n\r\n```cpp\r\nvoid Abort()\r\n```\r\nAborts this transaction.\r\n// 中止此交易。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this transaction is valid. Transaction becomes invalid after calling Abort() or Commit(). Operations on invalid transaction yield exceptions.\r\n// 查询此交易是否有效。交易在调用 Abort() 或 Commit() 后变为无效。在无效交易上执行操作将导致异常。\r\n\r\n返回  \r\nTrue if valid, false if not.\r\n// 如果有效返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool IsReadOnly() const\r\n```\r\nQuery if this txn is read only.\r\n// 查询此交易是否为只读。\r\n\r\n返回  \r\nTrue if read only, false if not.\r\n// 如果是只读返回 true，否则返回 false。\r\n\r\n```cpp\r\nconst std::shared_ptr GetTxn()\r\n```\r\nGet Transaction.\r\n// 获取交易。\r\n\r\n返回  \r\nTransaction.\r\n// 交易。\r\n\r\n```cpp\r\nVertexIterator GetVertexIterator()\r\n```\r\nGet a vertex iterator pointing to the first vertex. If there is no vertex, the iterator is invalid.\r\n// 获取指向第一个顶点的顶点迭代器。如果没有顶点，则迭代器无效。\r\n\r\n返回  \r\nThe vertex iterator.\r\n// 顶点迭代器。\r\n\r\n```cpp\r\nVertexIterator GetVertexIterator(int64_t vid, bool nearest = false)\r\n```"
            },
            {
                "content": "// 查询此交易是否为只读。\r\n\r\n返回  \r\nTrue if read only, false if not.\r\n// 如果是只读返回 true，否则返回 false。\r\n\r\n```cpp\r\nconst std::shared_ptr GetTxn()\r\n```\r\nGet Transaction.\r\n// 获取交易。\r\n\r\n返回  \r\nTransaction.\r\n// 交易。\r\n\r\n```cpp\r\nVertexIterator GetVertexIterator()\r\n```\r\nGet a vertex iterator pointing to the first vertex. If there is no vertex, the iterator is invalid.\r\n// 获取指向第一个顶点的顶点迭代器。如果没有顶点，则迭代器无效。\r\n\r\n返回  \r\nThe vertex iterator.\r\n// 顶点迭代器。\r\n\r\n```cpp\r\nVertexIterator GetVertexIterator(int64_t vid, bool nearest = false)\r\n```\r\nGets a vertex iterator pointing to the Vertex with vid. If the vertex does not exist, the iterator is invalid. If nearest==true, the iterator points to the first vertex sorted by vid, with id>=vid.\r\n// 获取指向具有 vid 的顶点的顶点迭代器。如果该顶点不存在，则迭代器无效。如果 nearest==true，迭代器指向按 vid 排序的第一个顶点，具有 id>=vid。\r\n\r\n参数  \r\nvid – The vid.  \r\n// vid – 顶点 ID。  \r\nnearest – (Optional) True to point to the nearest vertex sorted by vid.\r\n// nearest – （可选）如果为 true，则指向按 vid 排序的最近顶点。\r\n\r\n返回  \r\nThe vertex iterator.\r\n// 顶点迭代器。\r\n\r\n```cpp"
            },
            {
                "content": "```\r\nGets a vertex iterator pointing to the Vertex with vid. If the vertex does not exist, the iterator is invalid. If nearest==true, the iterator points to the first vertex sorted by vid, with id>=vid.\r\n// 获取指向具有 vid 的顶点的顶点迭代器。如果该顶点不存在，则迭代器无效。如果 nearest==true，迭代器指向按 vid 排序的第一个顶点，具有 id>=vid。\r\n\r\n参数  \r\nvid – The vid.  \r\n// vid – 顶点 ID。  \r\nnearest – (Optional) True to point to the nearest vertex sorted by vid.\r\n// nearest – （可选）如果为 true，则指向按 vid 排序的最近顶点。\r\n\r\n返回  \r\nThe vertex iterator.\r\n// 顶点迭代器。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const EdgeUid &euid, bool nearest = false)\r\n```\r\nGets an out edge iterator pointing to the edge specified by euid. If nearest==true, and the specified edge does not exist, return the first edge that sorts after the specified one.\r\n// 获取指向由 euid 指定的边的出边迭代器。如果 nearest==true，并且指定的边不存在，则返回在指定边之后排序的第一条边。\r\n\r\n参数  \r\neuid – Edge Unique Id.  \r\n// euid – 边的唯一 ID。  \r\nnearest – (Optional) If true, get the first edge that sorts after the specified one if the specified one does not exist."
            },
            {
                "content": "```\r\nGets an out edge iterator pointing to the edge specified by euid. If nearest==true, and the specified edge does not exist, return the first edge that sorts after the specified one.\r\n// 获取指向由 euid 指定的边的出边迭代器。如果 nearest==true，并且指定的边不存在，则返回在指定边之后排序的第一条边。\r\n\r\n参数  \r\neuid – Edge Unique Id.  \r\n// euid – 边的唯一 ID。  \r\nnearest – (Optional) If true, get the first edge that sorts after the specified one if the specified one does not exist.\r\n// nearest – （可选）如果为 true，则在指定边不存在时，获取在指定边之后排序的第一条边。\r\n\r\n返回  \r\nThe out edge iterator.\r\n// 出边迭代器。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const int64_t src, const int64_t dst, const int16_t lid)\r\n```\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const EdgeUid &euid, bool nearest = false)\r\n```\r\nGets an in edge iterator pointing to the edge specified by euid. If nearest==true, and the specified edge does not exist, return the first edge that sorts after the specified one.\r\n// 获取指向由 euid 指定的边的入边迭代器。如果 nearest==true，并且指定的边不存在，则返回在指定边之后排序的第一条边。\r\n\r\n参数  \r\neuid – Edge Unique Id."
            },
            {
                "content": "// 出边迭代器。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const int64_t src, const int64_t dst, const int16_t lid)\r\n```\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const EdgeUid &euid, bool nearest = false)\r\n```\r\nGets an in edge iterator pointing to the edge specified by euid. If nearest==true, and the specified edge does not exist, return the first edge that sorts after the specified one.\r\n// 获取指向由 euid 指定的边的入边迭代器。如果 nearest==true，并且指定的边不存在，则返回在指定边之后排序的第一条边。\r\n\r\n参数  \r\neuid – Edge Unique Id.  \r\n// euid – 边的唯一 ID。  \r\nnearest – (Optional) If true, get the first edge that sorts after the specified one if the specified one does not exist.\r\n// nearest – （可选）如果为 true，则在指定边不存在时，获取在指定边之后排序的第一条边。\r\n\r\n返回  \r\nThe out edge iterator.\r\n//出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const int64_t src, const int64_t dst, const int16_t lid)\r\n```\r\n\r\n```cpp\r\nsize_t GetNumVertexLabels()\r\n```\r\nGets number of vertex labels.\r\n// 获取顶点标签的数量。\r\n\r\n返回  \r\nThe number of vertex labels.\r\n// 顶点标签的数量。\r\n\r\n```cpp\r\nsize_t GetNumEdgeLabels()"
            },
            {
                "content": "nearest – (Optional) If true, get the first edge that sorts after the specified one if the specified one does not exist.\r\n// nearest – （可选）如果为 true，则在指定边不存在时，获取在指定边之后排序的第一条边。\r\n\r\n返回  \r\nThe out edge iterator.\r\n//出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const int64_t src, const int64_t dst, const int16_t lid)\r\n```\r\n\r\n```cpp\r\nsize_t GetNumVertexLabels()\r\n```\r\nGets number of vertex labels.\r\n// 获取顶点标签的数量。\r\n\r\n返回  \r\nThe number of vertex labels.\r\n// 顶点标签的数量。\r\n\r\n```cpp\r\nsize_t GetNumEdgeLabels()\r\n```\r\nGets number of edge labels.\r\n// 获取边标签的数量。\r\n\r\n返回  \r\nThe number of edge labels.\r\n// 边标签的数量。\r\n\r\n```cpp\r\nstd::vector ListVertexLabels()\r\n```\r\nLists all vertex labels.\r\n// 列出所有顶点标签。\r\n\r\n返回  \r\nLabel names.\r\n// 标签名称。\r\n\r\n```cpp\r\nstd::vector ListEdgeLabels()\r\n```\r\nList all edge labels.\r\n// 列出所有边标签。\r\n\r\n返回  \r\nLabel names.\r\n// 标签名称。\r\n\r\n```cpp\r\nsize_t GetVertexLabelId(const std::string &label)\r\n```\r\nGets vertex label id corresponding to the label name.\r\n// 获取与标签名称对应的顶点标签 ID。\r\n\r\n参数  \r\nlabel – The label name."
            },
            {
                "content": "```\r\nGets number of edge labels.\r\n// 获取边标签的数量。\r\n\r\n返回  \r\nThe number of edge labels.\r\n// 边标签的数量。\r\n\r\n```cpp\r\nstd::vector ListVertexLabels()\r\n```\r\nLists all vertex labels.\r\n// 列出所有顶点标签。\r\n\r\n返回  \r\nLabel names.\r\n// 标签名称。\r\n\r\n```cpp\r\nstd::vector ListEdgeLabels()\r\n```\r\nList all edge labels.\r\n// 列出所有边标签。\r\n\r\n返回  \r\nLabel names.\r\n// 标签名称。\r\n\r\n```cpp\r\nsize_t GetVertexLabelId(const std::string &label)\r\n```\r\nGets vertex label id corresponding to the label name.\r\n// 获取与标签名称对应的顶点标签 ID。\r\n\r\n参数  \r\nlabel – The label name.\r\n// label – 标签名称。\r\n\r\n返回  \r\nThe label id.\r\n// 标签 ID。\r\n\r\n```cpp\r\nsize_t GetEdgeLabelId(const std::string &label)\r\n```\r\nGets edge label id corresponding to the label name.\r\n// 获取与标签名称对应的边标签 ID。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe edge label id.\r\n// 边标签 ID。\r\n\r\n```cpp\r\nstd::vector GetVertexSchema(const std::string &label)\r\n```\r\nGets edge schema definition corresponding to the vertex label.\r\n// 获取与顶点标签对应的边架构定义。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe schema.\r\n// 架构。\r\n\r\n```cpp"
            },
            {
                "content": "返回  \r\nThe label id.\r\n// 标签 ID。\r\n\r\n```cpp\r\nsize_t GetEdgeLabelId(const std::string &label)\r\n```\r\nGets edge label id corresponding to the label name.\r\n// 获取与标签名称对应的边标签 ID。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe edge label id.\r\n// 边标签 ID。\r\n\r\n```cpp\r\nstd::vector GetVertexSchema(const std::string &label)\r\n```\r\nGets edge schema definition corresponding to the vertex label.\r\n// 获取与顶点标签对应的边架构定义。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe schema.\r\n// 架构。\r\n\r\n```cpp\r\nstd::vector GetEdgeSchema(const std::string &label)\r\n```\r\nGets edge schema definition corresponding to the edge label.\r\n// 获取与边标签对应的边架构定义。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe edge schema.\r\n// 边架构。\r\n\r\n```cpp\r\nsize_t GetVertexFieldId(size_t label_id, const std::string &field_name)\r\n```\r\nGets vertex field id.\r\n// 获取顶点字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_name – Field name.\r\n// field_name – 字段名称。\r\n\r\n返回  \r\nThe vertex field identifiers.\r\n// 顶点字段标识符。\r\n\r\n```cpp"
            },
            {
                "content": "```\r\nGets edge schema definition corresponding to the edge label.\r\n// 获取与边标签对应的边架构定义。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe edge schema.\r\n// 边架构。\r\n\r\n```cpp\r\nsize_t GetVertexFieldId(size_t label_id, const std::string &field_name)\r\n```\r\nGets vertex field id.\r\n// 获取顶点字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_name – Field name.\r\n// field_name – 字段名称。\r\n\r\n返回  \r\nThe vertex field identifiers.\r\n// 顶点字段标识符。\r\n\r\n```cpp\r\nstd::vector GetVertexFieldIds(size_t label_id, const std::vector &field_names)\r\n```\r\nGets vertex field ids.\r\n// 获取顶点字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_names – Field names.\r\n// field_names – 字段名称。\r\n\r\n返回  \r\nThe vertex field identifiers.\r\n// 顶点字段标识符。\r\n\r\n```cpp\r\nsize_t GetEdgeFieldId(size_t label_id, const std::string &field_name)\r\n```\r\nGets edge field id.\r\n// 获取边字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_name – Field name.\r\n// field_name – 字段名称。"
            },
            {
                "content": "```\r\nGets vertex field ids.\r\n// 获取顶点字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_names – Field names.\r\n// field_names – 字段名称。\r\n\r\n返回  \r\nThe vertex field identifiers.\r\n// 顶点字段标识符。\r\n\r\n```cpp\r\nsize_t GetEdgeFieldId(size_t label_id, const std::string &field_name)\r\n```\r\nGets edge field id.\r\n// 获取边字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_name – Field name.\r\n// field_name – 字段名称。\r\n\r\n返回  \r\nThe edge field identifier.\r\n// 边字段标识符。\r\n\r\n```cpp\r\nstd::vector GetEdgeFieldIds(size_t label_id, const std::vector &field_names)\r\n```\r\nGets edge field ids.\r\n// 获取边字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_names – Field names.\r\n// field_names – 字段名称。\r\n\r\n返回  \r\nThe edge field identifier.\r\n// 边字段标识符。\r\n\r\n```cpp\r\nint64_t AddVertex(const std::string &label_name, const std::vector &field_names, const std::vector &field_value_strings)\r\n```"
            },
            {
                "content": "// field_name – 字段名称。\r\n\r\n返回  \r\nThe edge field identifier.\r\n// 边字段标识符。\r\n\r\n```cpp\r\nstd::vector GetEdgeFieldIds(size_t label_id, const std::vector &field_names)\r\n```\r\nGets edge field ids.\r\n// 获取边字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_names – Field names.\r\n// field_names – 字段名称。\r\n\r\n返回  \r\nThe edge field identifier.\r\n// 边字段标识符。\r\n\r\n```cpp\r\nint64_t AddVertex(const std::string &label_name, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.\r\n// 添加一个顶点。必须指定所有非空字段。VertexIndex 也会更新。如果为顶点索引了 unique_id，并且相同的 unique_id 已存在，则会抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  \r\n// label_name – 标签的名称。  \r\nfield_names – List of names of the fields.  \r\n// field_names – 字段名称的列表。  \r\nfield_value_strings – The field values in string representation."
            },
            {
                "content": "```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.\r\n// 添加一个顶点。必须指定所有非空字段。VertexIndex 也会更新。如果为顶点索引了 unique_id，并且相同的 unique_id 已存在，则会抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  \r\n// label_name – 标签的名称。  \r\nfield_names – List of names of the fields.  \r\n// field_names – 字段名称的列表。  \r\nfield_value_strings – The field values in string representation.\r\n// field_value_strings – 字段值的字符串表示形式。\r\n\r\n返回  \r\nVertex id of the new vertex.\r\n// 新顶点的 ID。\r\n\r\n```cpp\r\nint64_t AddVertex(const std::string &label_name, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.\r\n// 添加一个顶点。必须指定所有非空字段。VertexIndex 也会更新。如果为顶点索引了 unique_id，并且相同的 unique_id 已存在，则会抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label."
            },
            {
                "content": "返回  \r\nVertex id of the new vertex.\r\n// 新顶点的 ID。\r\n\r\n```cpp\r\nint64_t AddVertex(const std::string &label_name, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.\r\n// 添加一个顶点。必须指定所有非空字段。VertexIndex 也会更新。如果为顶点索引了 unique_id，并且相同的 unique_id 已存在，则会抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  \r\n// label_name – 标签的名称。  \r\nfield_names – List of names of the fields.  \r\n// field_names – 字段名称的列表。  \r\nfield_values – The field values.\r\n// field_values – 字段值。\r\n\r\n返回  \r\nVertex id of the new vertex.\r\n// 新顶点的 ID。\r\n\r\n```cpp\r\nint64_t AddVertex(size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown."
            },
            {
                "content": "// label_name – 标签的名称。  \r\nfield_names – List of names of the fields.  \r\n// field_names – 字段名称的列表。  \r\nfield_values – The field values.\r\n// field_values – 字段值。\r\n\r\n返回  \r\nVertex id of the new vertex.\r\n// 新顶点的 ID。\r\n\r\n```cpp\r\nint64_t AddVertex(size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.  \r\n添加一个顶点。必须指定所有不能为空的字段。顶点索引也会被更新。如果顶点的 unique_id 被索引，并且存在相同的 unique_id，将抛出异常。\r\n\r\n参数  \r\nlabel_id – Label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – The field values.  \r\n标签 id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值。\r\n\r\n返回  \r\nVertex id of the new vertex.  \r\n新顶点的顶点 ID。\r\n\r\n```cpp\r\nint UpsertVertex(size_t label_id, size_t primary_pos, const std::vector &unique_pos, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nUpsert a vertex.  \r\n插入或更新一个顶点。\r\n\r\n参数"
            },
            {
                "content": "添加一个顶点。必须指定所有不能为空的字段。顶点索引也会被更新。如果顶点的 unique_id 被索引，并且存在相同的 unique_id，将抛出异常。\r\n\r\n参数  \r\nlabel_id – Label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – The field values.  \r\n标签 id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值。\r\n\r\n返回  \r\nVertex id of the new vertex.  \r\n新顶点的顶点 ID。\r\n\r\n```cpp\r\nint UpsertVertex(size_t label_id, size_t primary_pos, const std::vector &unique_pos, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nUpsert a vertex.  \r\n插入或更新一个顶点。\r\n\r\n参数  \r\nlabel_id – Label id.  \r\nprimary_pos – The location of the primary field in field_ids.  \r\nunique_pos – The locations of the unique index field in field_ids, can be empty.  \r\nfield_ids – List of field ids.  \r\nfield_values – The field values.  \r\n标签 id – 标签 ID。  \r\nprimary_pos – 字段 ID 中主字段的位置。  \r\nunique_pos – 字段 ID 中唯一索引字段的位置， 可以为空。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值。\r\n\r\n返回  \r\n0: nothing happened because of index conflict 1: the vertex is inserted 2: the vertex is updated.  \r\n0：由于索引冲突而没有发生任何事情 1：顶点已插入 2：顶点已更新。"
            },
            {
                "content": "primary_pos – The location of the primary field in field_ids.  \r\nunique_pos – The locations of the unique index field in field_ids, can be empty.  \r\nfield_ids – List of field ids.  \r\nfield_values – The field values.  \r\n标签 id – 标签 ID。  \r\nprimary_pos – 字段 ID 中主字段的位置。  \r\nunique_pos – 字段 ID 中唯一索引字段的位置， 可以为空。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值。\r\n\r\n返回  \r\n0: nothing happened because of index conflict 1: the vertex is inserted 2: the vertex is updated.  \r\n0：由于索引冲突而没有发生任何事情 1：顶点已插入 2：顶点已更新。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_value_strings – List of field values in string representation."
            },
            {
                "content": "EdgeUid AddEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_value_strings – List of field values in string representation.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_value_strings – 字段值字符串表示的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id."
            },
            {
                "content": "src – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_value_strings – 字段值字符串表示的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```"
            },
            {
                "content": "添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp"
            },
            {
                "content": "```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name."
            },
            {
                "content": "```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_value_strings – List of field values in string representation.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_value_strings – 字段值字符串表示的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边被插入返回 true，如果边被更新返回 false。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_values)\r\n```"
            },
            {
                "content": "label – The label name.  \r\nfield_names – List of field names.  \r\nfield_value_strings – List of field values in string representation.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_value_strings – 字段值字符串表示的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边被插入返回 true，如果边被更新返回 false。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。"
            },
            {
                "content": "```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边被插入返回 true，如果边被更新返回 false。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown."
            },
            {
                "content": "label – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边被插入返回 true，如果边被更新返回 false。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边被插入返回 true，如果边被更新返回 false。\r\n\r\n```cpp"
            },
            {
                "content": "插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边被插入返回 true，如果边被更新返回 false。\r\n\r\n```cpp\r\nint UpsertEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &unique_pos, const std::vector &field_ids, const std::vector &field_values, std::optional pair_unique_pos)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nunique_pos – The locations of the unique index field in field_ids, can be empty.  \r\nfield_ids – List of field ids."
            },
            {
                "content": "```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nunique_pos – The locations of the unique index field in field_ids, can be empty.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nunique_pos – 字段 ID 中唯一索引字段的位置，可以为空。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\n0: nothing happened because of index conflict 1: the vertex is inserted 2: the vertex is updated  \r\n0：由于索引冲突而没有发生任何事情 1：顶点已插入 2：顶点已更新\r\n\r\n```cpp\r\nstd::vector ListVertexIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of vertex index specs.  \r\n一个顶点索引规格的向量。\r\n\r\n```cpp\r\nstd::vector ListVertexCompositeIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of vertex composite index specs.  \r\n一个顶点组合索引规格的向量。\r\n\r\n```cpp\r\nstd::vector ListEdgeIndexes()\r\n```"
            },
            {
                "content": "field_values – 字段值的列表。\r\n\r\n返回  \r\n0: nothing happened because of index conflict 1: the vertex is inserted 2: the vertex is updated  \r\n0：由于索引冲突而没有发生任何事情 1：顶点已插入 2：顶点已更新\r\n\r\n```cpp\r\nstd::vector ListVertexIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of vertex index specs.  \r\n一个顶点索引规格的向量。\r\n\r\n```cpp\r\nstd::vector ListVertexCompositeIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of vertex composite index specs.  \r\n一个顶点组合索引规格的向量。\r\n\r\n```cpp\r\nstd::vector ListEdgeIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of edge index specs.  \r\n一个边索引规格的向量。\r\n\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(size_t label_id, size_t field_id, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets vertex index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取顶点索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel_id – The label id."
            },
            {
                "content": "列出索引\r\n\r\n返回  \r\nA vector of edge index specs.  \r\n一个边索引规格的向量。\r\n\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(size_t label_id, size_t field_id, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets vertex index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取顶点索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel_id – The label id.  \r\nfield_id – The field id.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(size_t label_id, const std::vector &field_id, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n```cpp"
            },
            {
                "content": "参数  \r\nlabel_id – The label id.  \r\nfield_id – The field id.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(size_t label_id, const std::vector &field_id, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(size_t label_id, size_t field_id, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets edge index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.  \r\n获取边索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的边的迭代器。\r\n\r\n参数  \r\nlabel_id – The label id.  \r\nfield_id – The field id.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。"
            },
            {
                "content": "```\r\nGets edge index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.  \r\n获取边索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的边的迭代器。\r\n\r\n参数  \r\nlabel_id – The label id.  \r\nfield_id – The field id.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nEdgeIndexIterator GetEdgePairUniqueIndexIterator(size_t label_id, size_t field_id, int64_t src_vid, int64_t dst_vid, const FieldData &key_start, const FieldData &key_end)\r\n```\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(const std::string &label, const std::string &field, const FieldData &key_start, const FieldData &key_end)\r\n```"
            },
            {
                "content": "key_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nEdgeIndexIterator GetEdgePairUniqueIndexIterator(size_t label_id, size_t field_id, int64_t src_vid, int64_t dst_vid, const FieldData &key_start, const FieldData &key_end)\r\n```\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(const std::string &label, const std::string &field, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets vertex index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取顶点索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel – The label.  \r\nfield – The field.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel – 标签。  \r\nfield – 字段。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp"
            },
            {
                "content": "```\r\nGets vertex index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取顶点索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel – The label.  \r\nfield – The field.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel – 标签。  \r\nfield – 字段。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(const std::string &label, const std::vector &field, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(const std::string &label, const std::string &field, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v."
            },
            {
                "content": "```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(const std::string &label, const std::vector &field, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(const std::string &label, const std::string &field, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.  \r\n获取索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的边的迭代器。\r\n\r\n参数  \r\nlabel – The label.  \r\nfield – The field.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel – 标签。  \r\nfield – 字段。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(const std::string &label, const std::string &field, const std::string &key_start, const std::string &key_end)\r\n```"
            },
            {
                "content": "获取索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的边的迭代器。\r\n\r\n参数  \r\nlabel – The label.  \r\nfield – The field.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel – 标签。  \r\nfield – 字段。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(const std::string &label, const std::string &field, const std::string &key_start, const std::string &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取索引迭代器。迭代器具有字段值 [key_start, key_end]。因此，当 key_start=key_end=v 时，它将返回一个指向所有字段值为 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\nkey_start – The key start.  键的起始值  \r\nkey_end – The key end.  键的结束值  \r\n\r\n返回  \r\nThe index iterator.  索引迭代器  \r\n\r\n```cpp"
            },
            {
                "content": "```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取索引迭代器。迭代器具有字段值 [key_start, key_end]。因此，当 key_start=key_end=v 时，它将返回一个指向所有字段值为 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\nkey_start – The key start.  键的起始值  \r\nkey_end – The key end.  键的结束值  \r\n\r\n返回  \r\nThe index iterator.  索引迭代器  \r\n\r\n```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(const std::string &label, const std::vector &field, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(const std::string &label, const std::string &field, const std::string &key_start, const std::string &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v."
            },
            {
                "content": "VertexCompositeIndexIterator GetVertexCompositeIndexIterator(const std::string &label, const std::vector &field, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(const std::string &label, const std::string &field, const std::string &key_start, const std::string &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.  \r\n获取索引迭代器。迭代器具有字段值 [key_start, key_end]。因此，当 key_start=key_end=v 时，它将返回一个指向所有字段值为 v 的边的迭代器。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\nkey_start – The key start.  键的起始值  \r\nkey_end – The key end.  键的结束值  \r\n\r\n返回  \r\nThe index iterator.  索引迭代器  \r\n\r\n```cpp\r\nbool IsVertexIndexed(const std::string &label, const std::string &field)\r\n```\r\nQuery if index is ready for use. This should be used only to decide whether to use an index. To wait for an index to be ready, use lgraphDB::WaitIndexReady()."
            },
            {
                "content": "参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\nkey_start – The key start.  键的起始值  \r\nkey_end – The key end.  键的结束值  \r\n\r\n返回  \r\nThe index iterator.  索引迭代器  \r\n\r\n```cpp\r\nbool IsVertexIndexed(const std::string &label, const std::string &field)\r\n```\r\nQuery if index is ready for use. This should be used only to decide whether to use an index. To wait for an index to be ready, use lgraphDB::WaitIndexReady().  \r\n查询索引是否准备好使用。这只能用于决定是否使用索引。要等待索引准备就绪，请使用 lgraphDB::WaitIndexReady()。\r\n\r\nVertexIndex building is async, especially when added for a (label, field) that already has a lot of vertices. This function tells us if the index building is finished.  \r\nVertexIndex 的构建是异步的，尤其是在已经有很多顶点的 (label, field) 上添加时。此函数告诉我们索引构建是否完成。\r\n\r\nDO NOT wait for index building in a transaction. Write transactions block other write transactions, so blocking in a write transaction is always a bad idea. And long-living read transactions interfere with GC, making the DB grow unexpectedly."
            },
            {
                "content": "VertexIndex building is async, especially when added for a (label, field) that already has a lot of vertices. This function tells us if the index building is finished.  \r\nVertexIndex 的构建是异步的，尤其是在已经有很多顶点的 (label, field) 上添加时。此函数告诉我们索引构建是否完成。\r\n\r\nDO NOT wait for index building in a transaction. Write transactions block other write transactions, so blocking in a write transaction is always a bad idea. And long-living read transactions interfere with GC, making the DB grow unexpectedly.  \r\n请勿在事务中等待索引构建。写事务会阻止其他写事务，因此在写事务中阻塞始终是个坏主意。长期存在的读事务会干扰 GC，导致数据库意外增长。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\n\r\n返回  \r\nTrue if index ready, false if not.  如果索引准备好，则返回 true，否则返回 false。  \r\n\r\n```cpp\r\nbool IsEdgeIndexed(const std::string &label, const std::string &field)\r\n```\r\nQuery if index is ready for use. This should be used only to decide whether to use an index. To wait for an index to be ready, use lgraphDB::WaitIndexReady().  \r\n查询索引是否准备好使用。这只能用于决定是否使用索引。要等待索引准备就绪，请使用 lgraphDB::WaitIndexReady()。"
            },
            {
                "content": "参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\n\r\n返回  \r\nTrue if index ready, false if not.  如果索引准备好，则返回 true，否则返回 false。  \r\n\r\n```cpp\r\nbool IsEdgeIndexed(const std::string &label, const std::string &field)\r\n```\r\nQuery if index is ready for use. This should be used only to decide whether to use an index. To wait for an index to be ready, use lgraphDB::WaitIndexReady().  \r\n查询索引是否准备好使用。这只能用于决定是否使用索引。要等待索引准备就绪，请使用 lgraphDB::WaitIndexReady()。\r\n\r\nVertexIndex building is async, especially when added for a (label, field) that already has a lot of edges. This function tells us if the index building is finished.  \r\nVertexIndex 的构建是异步的，尤其是在已经有很多边的 (label, field) 上添加时。此函数告诉我们索引构建是否完成。\r\n\r\nDO NOT wait for index building in a transaction. Write transactions block other write transactions, so blocking in a write transaction is always a bad idea. And long-living read transactions interfere with GC, making the DB grow unexpectedly.  \r\n请勿在事务中等待索引构建。写事务会阻止其他写事务，因此在写事务中阻塞始终是个坏主意。长期存在的读事务会干扰 GC，导致数据库意外增长。\r\n\r\n参数"
            },
            {
                "content": "VertexIndex 的构建是异步的，尤其是在已经有很多边的 (label, field) 上添加时。此函数告诉我们索引构建是否完成。\r\n\r\nDO NOT wait for index building in a transaction. Write transactions block other write transactions, so blocking in a write transaction is always a bad idea. And long-living read transactions interfere with GC, making the DB grow unexpectedly.  \r\n请勿在事务中等待索引构建。写事务会阻止其他写事务，因此在写事务中阻塞始终是个坏主意。长期存在的读事务会干扰 GC，导致数据库意外增长。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\n\r\n返回  \r\nTrue if index ready, false if not.  如果索引准备好，则返回 true，否则返回 false。  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(const std::string &label_name, const std::string &field_name, const std::string &field_value_string)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value_string – The field value string.  字段值字符串  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp"
            },
            {
                "content": "```cpp\r\nVertexIterator GetVertexByUniqueIndex(const std::string &label_name, const std::string &field_name, const std::string &field_value_string)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value_string – The field value string.  字段值字符串  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(const std::string &label_name, const std::vector &field_name, const std::vector &field_value_string)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(const std::string &label_name, const std::string &field_name, const std::string &field_value_string)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称"
            },
            {
                "content": "```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(const std::string &label_name, const std::vector &field_name, const std::vector &field_value_string)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(const std::string &label_name, const std::string &field_name, const std::string &field_value_string)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value_string – The field value string.  字段值字符串  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(const std::string &label_name, const std::string &field_name, const FieldData &field_value)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value – The field value.  字段值  \r\n\r\n返回"
            },
            {
                "content": "field_value_string – The field value string.  字段值字符串  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(const std::string &label_name, const std::string &field_name, const FieldData &field_value)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(const std::string &label_name, const std::vector &field_name, const std::vector &field_value)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(const std::string &label_name, const std::string &field_name, const FieldData &field_value)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称"
            },
            {
                "content": "返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(const std::string &label_name, const std::vector &field_name, const std::vector &field_value)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(const std::string &label_name, const std::string &field_name, const FieldData &field_value)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(size_t label_id, size_t field_id, const FieldData &field_value)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  标签的标识符  \r\nfield_id – Identifier for the field.  字段的标识符  \r\nfield_value – The field value.  字段值  \r\n\r\n返回"
            },
            {
                "content": "field_name – Name of the field.  字段的名称  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(size_t label_id, size_t field_id, const FieldData &field_value)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  标签的标识符  \r\nfield_id – Identifier for the field.  字段的标识符  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(size_t label_id, const std::vector &field_id, const std::vector &field_value)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(size_t label_id, size_t field_id, const FieldData &field_value)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  标签的标识符  \r\nfield_id – Identifier for the field.  字段的标识符"
            },
            {
                "content": "The vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(size_t label_id, const std::vector &field_id, const std::vector &field_value)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(size_t label_id, size_t field_id, const FieldData &field_value)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  标签的标识符  \r\nfield_id – Identifier for the field.  字段的标识符  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nsize_t GetNumVertices()\r\n```\r\nGets the number of vertices.  \r\n获取顶点的数量。\r\n\r\n返回  \r\nThe number of vertices.  顶点的数量  \r\n\r\n```cpp\r\nconst std::string &GetVertexPrimaryField(const std::string &label)\r\n```\r\nGets vertex primary field  \r\n获取顶点的主字段  \r\n\r\n返回  \r\nThe primary field.  主字段  \r\n\r\n```cpp\r\nstd::pair Count()\r\n```\r\nGet the total number of vertex and edge  \r\n获取顶点和边的总数  \r\n\r\n返回"
            },
            {
                "content": "field_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nsize_t GetNumVertices()\r\n```\r\nGets the number of vertices.  \r\n获取顶点的数量。\r\n\r\n返回  \r\nThe number of vertices.  顶点的数量  \r\n\r\n```cpp\r\nconst std::string &GetVertexPrimaryField(const std::string &label)\r\n```\r\nGets vertex primary field  \r\n获取顶点的主字段  \r\n\r\n返回  \r\nThe primary field.  主字段  \r\n\r\n```cpp\r\nstd::pair Count()\r\n```\r\nGet the total number of vertex and edge  \r\n获取顶点和边的总数  \r\n\r\n返回  \r\nstd::pair object, first element is vertex number, second is edge number.  \r\n返回一个 std::pair 对象，第一个元素是顶点数量，第二个元素是边的数量。  \r\n\r\n```cpp\r\nstd::vector> CountDetail()\r\n```\r\nGet the total number of vertex or edge for each label  \r\n获取每个标签的顶点或边的总数  \r\n\r\n返回  \r\nstd::tuple object list, first element indicates whether it is VERTEX or EDGE, second is label name, third is number.  \r\n返回一个 std::tuple 对象列表，第一个元素指示它是 VERTEX 还是 EDGE，第二个是标签名称，第三个是数量。  \r\n\r\n### Private Functions\r\n\r\n#### explicit Transaction(lgraph::Transaction&&)  \r\n显式事务\r\n\r\n### Private Members"
            },
            {
                "content": "返回一个 std::pair 对象，第一个元素是顶点数量，第二个元素是边的数量。  \r\n\r\n```cpp\r\nstd::vector> CountDetail()\r\n```\r\nGet the total number of vertex or edge for each label  \r\n获取每个标签的顶点或边的总数  \r\n\r\n返回  \r\nstd::tuple object list, first element indicates whether it is VERTEX or EDGE, second is label name, third is number.  \r\n返回一个 std::tuple 对象列表，第一个元素指示它是 VERTEX 还是 EDGE，第二个是标签名称，第三个是数量。  \r\n\r\n### Private Functions\r\n\r\n#### explicit Transaction(lgraph::Transaction&&)  \r\n显式事务\r\n\r\n### Private Members\r\n\r\n#### std::shared_ptr txn_  \r\n共享指针类型的事务  \r\n\r\n### Friends\r\n\r\n#### friend class GraphDB  \r\n友元类 GraphDB  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_types\r\n\r\nnamespace lgraph_api\r\n\r\n### Typedefs\r\n\r\ntypedef std::vector> EdgeConstraints  \r\n// Edge constraints type define  \r\n// 边约束类型定义\r\n\r\n### Enums\r\n\r\nenum class AccessLevel"
            },
            {
                "content": "返回一个 std::tuple 对象列表，第一个元素指示它是 VERTEX 还是 EDGE，第二个是标签名称，第三个是数量。  \r\n\r\n### Private Functions\r\n\r\n#### explicit Transaction(lgraph::Transaction&&)  \r\n显式事务\r\n\r\n### Private Members\r\n\r\n#### std::shared_ptr txn_  \r\n共享指针类型的事务  \r\n\r\n### Friends\r\n\r\n#### friend class GraphDB  \r\n友元类 GraphDB  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_types\r\n\r\nnamespace lgraph_api\r\n\r\n### Typedefs\r\n\r\ntypedef std::vector> EdgeConstraints  \r\n// Edge constraints type define  \r\n// 边约束类型定义\r\n\r\n### Enums\r\n\r\nenum class AccessLevel  \r\n// Access level a user or role has on a graph. NONE: no permission. READ: read-only, no write access. WRITE: can read and write vertex and edge, but cannot change meta data such as schema or access. FULL: full access, can modify schema, grant access to other users, or even delete this graph.\r\n// 用户或角色在图上的访问级别。NONE：没有权限。READ：只读，没有写入权限。WRITE：可以读取和写入顶点和边，但不能更改元数据，如模式或访问。FULL：完全访问，可以修改模式，授予其他用户访问权限，甚至删除此图。\r\n\r\nValues:\r\n\r\n- enumerator NONE  \r\n- enumerator READ  \r\n- enumerator WRITE  \r\n- enumerator FULL"
            },
            {
                "content": "// Access level a user or role has on a graph. NONE: no permission. READ: read-only, no write access. WRITE: can read and write vertex and edge, but cannot change meta data such as schema or access. FULL: full access, can modify schema, grant access to other users, or even delete this graph.\r\n// 用户或角色在图上的访问级别。NONE：没有权限。READ：只读，没有写入权限。WRITE：可以读取和写入顶点和边，但不能更改元数据，如模式或访问。FULL：完全访问，可以修改模式，授予其他用户访问权限，甚至删除此图。\r\n\r\nValues:\r\n\r\n- enumerator NONE  \r\n- enumerator READ  \r\n- enumerator WRITE  \r\n- enumerator FULL  \r\n\r\nenum class FieldAccessLevel  \r\n// Field access level.  \r\n// 字段访问级别。\r\n\r\nValues:\r\n\r\n- enumerator NONE  \r\n- enumerator READ  \r\n- enumerator WRITE  \r\n\r\nenum class GraphQueryType  \r\n// Graph query type.  \r\n// 图查询类型。\r\n\r\nValues:\r\n\r\n- enumerator CYPHER  \r\n- enumerator GQL  \r\n\r\nenum FieldType  \r\n// Field and value types.  \r\n// 字段和值类型。\r\n\r\nValues:\r\n\r\n- enumerator NUL  \r\n- enumerator NUL  \r\n- enumerator NUL  \r\n- enumerator BOOL  \r\n- enumerator INT8  \r\n- enumerator INT16  \r\n- enumerator INT32  \r\n- enumerator INT64"
            },
            {
                "content": "enum class FieldAccessLevel  \r\n// Field access level.  \r\n// 字段访问级别。\r\n\r\nValues:\r\n\r\n- enumerator NONE  \r\n- enumerator READ  \r\n- enumerator WRITE  \r\n\r\nenum class GraphQueryType  \r\n// Graph query type.  \r\n// 图查询类型。\r\n\r\nValues:\r\n\r\n- enumerator CYPHER  \r\n- enumerator GQL  \r\n\r\nenum FieldType  \r\n// Field and value types.  \r\n// 字段和值类型。\r\n\r\nValues:\r\n\r\n- enumerator NUL  \r\n- enumerator NUL  \r\n- enumerator NUL  \r\n- enumerator BOOL  \r\n- enumerator INT8  \r\n- enumerator INT16  \r\n- enumerator INT32  \r\n- enumerator INT64  \r\n- enumerator FLOAT  \r\n- enumerator DOUBLE  \r\n- enumerator DATE  \r\n- enumerator DATETIME  \r\n- enumerator STRING  \r\n- enumerator BLOB  \r\n- enumerator POINT  \r\n- enumerator POINT  \r\n- enumerator LINESTRING  \r\n- enumerator LINESTRING  \r\n- enumerator POLYGON  \r\n- enumerator POLYGON  \r\n- enumerator SPATIAL  \r\n- enumerator FLOAT_VECTOR  \r\n\r\nenum class LGraphType : uint16_t  \r\n// a type of value used in result entry and parameter in procedure or plugin signature  \r\n// 在结果条目和过程或插件签名中使用的值类型。\r\n\r\n- Param INTEGER"
            },
            {
                "content": "- enumerator FLOAT  \r\n- enumerator DOUBLE  \r\n- enumerator DATE  \r\n- enumerator DATETIME  \r\n- enumerator STRING  \r\n- enumerator BLOB  \r\n- enumerator POINT  \r\n- enumerator POINT  \r\n- enumerator LINESTRING  \r\n- enumerator LINESTRING  \r\n- enumerator POLYGON  \r\n- enumerator POLYGON  \r\n- enumerator SPATIAL  \r\n- enumerator FLOAT_VECTOR  \r\n\r\nenum class LGraphType : uint16_t  \r\n// a type of value used in result entry and parameter in procedure or plugin signature  \r\n// 在结果条目和过程或插件签名中使用的值类型。\r\n\r\n- Param INTEGER  \r\n- Param FLOAT  \r\n- Param DOUBLE  \r\n- Param BOOLEAN  \r\n- Param STRING  \r\n- Param MAP  \r\n    \r\n- Param NODE  \r\n  VertexIterator, VertexId  \r\n- Param RELATIONSHIP  \r\n  InEdgeIterator || OutEdgeIterator, EdgeUid  \r\n- Param PATH  \r\n  lgraph_api::Path  \r\n- Param LIST  \r\n    \r\n- Param ANY  \r\n  like Object in Java, its procedure author’s responsibility to check the underlying concrete type whether valid in runtime.  \r\n  类似于Java中的对象，程序作者负责在运行时检查底层具体类型是否有效。\r\n\r\nValues:\r\n\r\n- enumerator NUL  \r\n- enumerator INTEGER"
            },
            {
                "content": "- Param FLOAT  \r\n- Param DOUBLE  \r\n- Param BOOLEAN  \r\n- Param STRING  \r\n- Param MAP  \r\n    \r\n- Param NODE  \r\n  VertexIterator, VertexId  \r\n- Param RELATIONSHIP  \r\n  InEdgeIterator || OutEdgeIterator, EdgeUid  \r\n- Param PATH  \r\n  lgraph_api::Path  \r\n- Param LIST  \r\n    \r\n- Param ANY  \r\n  like Object in Java, its procedure author’s responsibility to check the underlying concrete type whether valid in runtime.  \r\n  类似于Java中的对象，程序作者负责在运行时检查底层具体类型是否有效。\r\n\r\nValues:\r\n\r\n- enumerator NUL  \r\n- enumerator INTEGER  \r\n- enumerator FLOAT  \r\n- enumerator DOUBLE  \r\n- enumerator BOOLEAN  \r\n- enumerator STRING  \r\n- enumerator NODE  \r\n- enumerator RELATIONSHIP  \r\n- enumerator PATH  \r\n- enumerator LIST  \r\n- enumerator MAP  \r\n- enumerator ANY  \r\n\r\nenum PluginCodeType  \r\n// Type of code given when loading a new plugin.  \r\n// 加载新插件时给定的代码类型。\r\n\r\nValues:\r\n\r\n- enumerator PY  \r\n- enumerator SO  \r\n- enumerator CPP  \r\n- enumerator ZIP  \r\n\r\nenum class IndexType  \r\n// index type  \r\n// 索引类型。\r\n\r\nValues:\r\n\r\n- enumerator NonuniqueIndex"
            },
            {
                "content": "- enumerator FLOAT  \r\n- enumerator DOUBLE  \r\n- enumerator BOOLEAN  \r\n- enumerator STRING  \r\n- enumerator NODE  \r\n- enumerator RELATIONSHIP  \r\n- enumerator PATH  \r\n- enumerator LIST  \r\n- enumerator MAP  \r\n- enumerator ANY  \r\n\r\nenum PluginCodeType  \r\n// Type of code given when loading a new plugin.  \r\n// 加载新插件时给定的代码类型。\r\n\r\nValues:\r\n\r\n- enumerator PY  \r\n- enumerator SO  \r\n- enumerator CPP  \r\n- enumerator ZIP  \r\n\r\nenum class IndexType  \r\n// index type  \r\n// 索引类型。\r\n\r\nValues:\r\n\r\n- enumerator NonuniqueIndex  \r\n  this is not unique index  \r\n  // 这不是唯一索引\r\n- enumerator GlobalUniqueIndex  \r\n  this is a global unique index  \r\n  // 这是一个全局唯一索引\r\n- enumerator PairUniqueIndex  \r\n  this is a pair unique index, for edge index only key of pair unique index is one of the follow case : if src_vid < dst_vid ,key is (index field value + src_vid + dst_vid) if src_vid > dst_vid ,key is (index field value + dst_vid + src_vid)"
            },
            {
                "content": "enum class IndexType  \r\n// index type  \r\n// 索引类型。\r\n\r\nValues:\r\n\r\n- enumerator NonuniqueIndex  \r\n  this is not unique index  \r\n  // 这不是唯一索引\r\n- enumerator GlobalUniqueIndex  \r\n  this is a global unique index  \r\n  // 这是一个全局唯一索引\r\n- enumerator PairUniqueIndex  \r\n  this is a pair unique index, for edge index only key of pair unique index is one of the follow case : if src_vid < dst_vid ,key is (index field value + src_vid + dst_vid) if src_vid > dst_vid ,key is (index field value + dst_vid + src_vid)  \r\n  // 这是一个对唯一索引，仅边索引的对唯一索引的键是以下情况之一：如果src_vid < dst_vid，则键为（索引字段值 + src_vid + dst_vid），如果src_vid > dst_vid，则键为（索引字段值 + dst_vid + src_vid）\r\n\r\nenum class CompositeIndexType  \r\n\r\nValues:\r\n\r\n- enumerator UniqueIndex  \r\n  this is unique composite index  \r\n  // 这是唯一复合索引\r\n- enumerator NonUniqueIndex  \r\n  this is not unique composite index  \r\n  // 这不是唯一复合索引\r\n\r\n### Functions\r\n\r\nstatic inline std::string to_string(const AccessLevel &v)  \r\n// Convert AccessLevel to string.  \r\n// 将AccessLevel转换为字符串"
            },
            {
                "content": "// 这是一个对唯一索引，仅边索引的对唯一索引的键是以下情况之一：如果src_vid < dst_vid，则键为（索引字段值 + src_vid + dst_vid），如果src_vid > dst_vid，则键为（索引字段值 + dst_vid + src_vid）\r\n\r\nenum class CompositeIndexType  \r\n\r\nValues:\r\n\r\n- enumerator UniqueIndex  \r\n  this is unique composite index  \r\n  // 这是唯一复合索引\r\n- enumerator NonUniqueIndex  \r\n  this is not unique composite index  \r\n  // 这不是唯一复合索引\r\n\r\n### Functions\r\n\r\nstatic inline std::string to_string(const AccessLevel &v)  \r\n// Convert AccessLevel to string.  \r\n// 将AccessLevel转换为字符串\r\nstatic inline std::string to_string(const FieldAccessLevel &v)  \r\n// Convert FieldAccessLevel to string.  \r\n// 将FieldAccessLevel转换为字符串\r\nstatic inline std::string to_string(const GraphQueryType &v)  \r\n// Convert GraphQueryType to string.  \r\n// 将GraphQueryType转换为字符串\r\ninline const std::string to_string(FieldType v)  \r\n// Get the name of the given FieldType.  \r\n// 获取给定FieldType的名称。\r\n\r\n抛出  \r\nstd::runtime_error – when an unrecognizable FieldType is given.  \r\n// 当给定不可识别的FieldType时抛出。\r\n\r\n参数  \r\nv – A FieldType.  \r\n// v – 一个FieldType。"
            },
            {
                "content": "// Convert FieldAccessLevel to string.  \r\n// 将FieldAccessLevel转换为字符串\r\nstatic inline std::string to_string(const GraphQueryType &v)  \r\n// Convert GraphQueryType to string.  \r\n// 将GraphQueryType转换为字符串\r\ninline const std::string to_string(FieldType v)  \r\n// Get the name of the given FieldType.  \r\n// 获取给定FieldType的名称。\r\n\r\n抛出  \r\nstd::runtime_error – when an unrecognizable FieldType is given.  \r\n// 当给定不可识别的FieldType时抛出。\r\n\r\n参数  \r\nv – A FieldType.  \r\n// v – 一个FieldType。\r\n\r\n返回  \r\nName of the given FieldType.  \r\n// 给定FieldType的名称。\r\n\r\ninline auto LGraphTypeIsField(LGraphType type) -> bool  \r\n// Check if the type is a field type.  \r\n// 检查该类型是否为字段类型\r\ninline auto LGraphTypeIsGraphElement(LGraphType type) -> bool  \r\n// Check if the type is a graph element type.  \r\n// 检查该类型是否为图形元素类型\r\ninline auto LGraphTypeIsCollection(LGraphType type) -> bool  \r\n// Check if the type is a collection type.  \r\n// 检查该类型是否为集合类型\r\ninline auto LGraphTypeIsAny(LGraphType type) -> bool  \r\n// Check if the type is ANY type.  \r\n// 检查该类型是否为ANY类型"
            },
            {
                "content": "// 给定FieldType的名称。\r\n\r\ninline auto LGraphTypeIsField(LGraphType type) -> bool  \r\n// Check if the type is a field type.  \r\n// 检查该类型是否为字段类型\r\ninline auto LGraphTypeIsGraphElement(LGraphType type) -> bool  \r\n// Check if the type is a graph element type.  \r\n// 检查该类型是否为图形元素类型\r\ninline auto LGraphTypeIsCollection(LGraphType type) -> bool  \r\n// Check if the type is a collection type.  \r\n// 检查该类型是否为集合类型\r\ninline auto LGraphTypeIsAny(LGraphType type) -> bool  \r\n// Check if the type is ANY type.  \r\n// 检查该类型是否为ANY类型\r\ninline const std::string to_string(LGraphType type)  \r\n// Convert LGraphType to string.  \r\n// 将LGraphType转换为字符串\r\ninline std::string PluginCodeTypeStr(PluginCodeType code_type)  \r\n// Get the name of plugin code types.  \r\n// 获取插件代码类型的名称。\r\n\r\nstruct CompositeIndexSpec  \r\n#include   \r\n// A composite index specifier.  \r\n// 复合索引说明符。\r\n\r\nPublic Members\r\n\r\n- std::string label  \r\n  label name  \r\n  // 标签名称\r\n- std::vector fields  \r\n  fields name  \r\n  // 字段名称\r\n- CompositeIndexType type"
            },
            {
                "content": "// 检查该类型是否为ANY类型\r\ninline const std::string to_string(LGraphType type)  \r\n// Convert LGraphType to string.  \r\n// 将LGraphType转换为字符串\r\ninline std::string PluginCodeTypeStr(PluginCodeType code_type)  \r\n// Get the name of plugin code types.  \r\n// 获取插件代码类型的名称。\r\n\r\nstruct CompositeIndexSpec  \r\n#include   \r\n// A composite index specifier.  \r\n// 复合索引说明符。\r\n\r\nPublic Members\r\n\r\n- std::string label  \r\n  label name  \r\n  // 标签名称\r\n- std::vector fields  \r\n  fields name  \r\n  // 字段名称\r\n- CompositeIndexType type  \r\n\r\nstruct EdgeOptions : public LabelOptions  \r\n#include   \r\n// Edge label options, contain fields only edge have  \r\n// 边标签选项，仅包含边具有的字段。\r\n\r\nPublic Types\r\n\r\nenum class TemporalFieldOrder  \r\n// Order of temporal field.  \r\n// 时间字段的顺序。\r\n\r\nValues:\r\n\r\n- enumerator ASC  \r\n- enumerator DESC  \r\n\r\nPublic Functions\r\n\r\nEdgeOptions() = default  \r\n// Default constructor.  \r\n// 默认构造函数\r\ninline explicit EdgeOptions(const EdgeConstraints &edge_constraints)  \r\n// Construct EdgeOptions with edge constraints.  \r\n// 根据边约束构造EdgeOptions"
            },
            {
                "content": "#include   \r\n// Edge label options, contain fields only edge have  \r\n// 边标签选项，仅包含边具有的字段。\r\n\r\nPublic Types\r\n\r\nenum class TemporalFieldOrder  \r\n// Order of temporal field.  \r\n// 时间字段的顺序。\r\n\r\nValues:\r\n\r\n- enumerator ASC  \r\n- enumerator DESC  \r\n\r\nPublic Functions\r\n\r\nEdgeOptions() = default  \r\n// Default constructor.  \r\n// 默认构造函数\r\ninline explicit EdgeOptions(const EdgeConstraints &edge_constraints)  \r\n// Construct EdgeOptions with edge constraints.  \r\n// 根据边约束构造EdgeOptions\r\ninline virtual std::string to_string() const  \r\n// Convert EdgeOptions to string.  \r\n// 将EdgeOptions转换为字符串\r\ninline virtual void clear()  \r\n// Clear EdgeOptions.  \r\n// 清除EdgeOptions\r\n\r\nPublic Members\r\n\r\n- EdgeConstraints edge_constraints  \r\n- std::string temporal_field  \r\n- enum lgraph_api::EdgeOptions::TemporalFieldOrder temporal_field_order = TemporalFieldOrder::ASC  \r\n\r\nPublic Static Functions\r\n\r\nstatic inline std::string to_string(const TemporalFieldOrder &v)  \r\n// Convert TemporalFieldOrder to string.  \r\n// 将TemporalFieldOrder转换为字符串"
            },
            {
                "content": "// Convert EdgeOptions to string.  \r\n// 将EdgeOptions转换为字符串\r\ninline virtual void clear()  \r\n// Clear EdgeOptions.  \r\n// 清除EdgeOptions\r\n\r\nPublic Members\r\n\r\n- EdgeConstraints edge_constraints  \r\n- std::string temporal_field  \r\n- enum lgraph_api::EdgeOptions::TemporalFieldOrder temporal_field_order = TemporalFieldOrder::ASC  \r\n\r\nPublic Static Functions\r\n\r\nstatic inline std::string to_string(const TemporalFieldOrder &v)  \r\n// Convert TemporalFieldOrder to string.  \r\n// 将TemporalFieldOrder转换为字符串\r\n\r\n### struct EdgeUid\r\n\r\n#include \r\n\r\n#### Public Functions\r\n\r\ninline EdgeUid()  \r\n// Default constructor for EdgeUid.  \r\n// EdgeUid的默认构造函数\r\ninline EdgeUid(int64_t s, int64_t d, uint16_t l, int64_t t, int64_t e)  \r\n// Constructor for EdgeUid with parameters.  \r\n// 带参数的EdgeUid构造函数\r\ninline void Reverse()  \r\n// Reverses side of this edge  \r\n// 反转此边的方向\r\n\r\ninline bool operator==(const EdgeUid &rhs) const  \r\n// Equality operator for EdgeUid.  \r\n// EdgeUid的相等运算符\r\ninline bool operator!=(const EdgeUid &rhs) const"
            },
            {
                "content": "### struct EdgeUid\r\n\r\n#include \r\n\r\n#### Public Functions\r\n\r\ninline EdgeUid()  \r\n// Default constructor for EdgeUid.  \r\n// EdgeUid的默认构造函数\r\ninline EdgeUid(int64_t s, int64_t d, uint16_t l, int64_t t, int64_t e)  \r\n// Constructor for EdgeUid with parameters.  \r\n// 带参数的EdgeUid构造函数\r\ninline void Reverse()  \r\n// Reverses side of this edge  \r\n// 反转此边的方向\r\n\r\ninline bool operator==(const EdgeUid &rhs) const  \r\n// Equality operator for EdgeUid.  \r\n// EdgeUid的相等运算符\r\ninline bool operator!=(const EdgeUid &rhs) const  \r\n// Inequality operator for EdgeUid.  \r\n// EdgeUid的不等运算符\r\ninline bool operator<(const EdgeUid &rhs) const  \r\n// Less than operator for EdgeUid.  \r\n// EdgeUid的小于运算符\r\ninline bool operator>(const EdgeUid &rhs) const  \r\n// Greater than operator for EdgeUid.  \r\n// EdgeUid的大于运算符\r\ninline std::string ToString() const  \r\n// Get string representation of this object  \r\n// 获取该对象的字符串表示\r\n\r\n#### Public Members\r\n\r\n- int64_t src  \r\n  source vertex id  \r\n  // 源顶点ID\r\n- int64_t dst  \r\n  destination vertex id  \r\n  // 目的顶点ID"
            },
            {
                "content": "// Inequality operator for EdgeUid.  \r\n// EdgeUid的不等运算符\r\ninline bool operator<(const EdgeUid &rhs) const  \r\n// Less than operator for EdgeUid.  \r\n// EdgeUid的小于运算符\r\ninline bool operator>(const EdgeUid &rhs) const  \r\n// Greater than operator for EdgeUid.  \r\n// EdgeUid的大于运算符\r\ninline std::string ToString() const  \r\n// Get string representation of this object  \r\n// 获取该对象的字符串表示\r\n\r\n#### Public Members\r\n\r\n- int64_t src  \r\n  source vertex id  \r\n  // 源顶点ID\r\n- int64_t dst  \r\n  destination vertex id  \r\n  // 目的顶点ID\r\n- uint16_t lid  \r\n  label id  \r\n  // 标签ID\r\n- int64_t tid  \r\n  timestamp  \r\n  // 时间戳\r\n- int64_t eid  \r\n  additional edge id to distinguish edges with the same tid  \r\n  // 额外的边ID以区分具有相同时间戳的边\r\n\r\n#### Public Static Functions\r\n\r\nstatic inline EdgeUid AnyEdge()  \r\n// Get a generic edge identifier.  \r\n// 获取通用边标识符\r\n\r\n---\r\n\r\n### struct Hash\r\n\r\n#include \r\n\r\n#### Public Functions\r\n\r\ninline size_t operator()(const EdgeUid &edgeUid) const  \r\n// Hash function for EdgeUid.  \r\n// EdgeUid的哈希函数\r\n\r\n---"
            },
            {
                "content": "// 目的顶点ID\r\n- uint16_t lid  \r\n  label id  \r\n  // 标签ID\r\n- int64_t tid  \r\n  timestamp  \r\n  // 时间戳\r\n- int64_t eid  \r\n  additional edge id to distinguish edges with the same tid  \r\n  // 额外的边ID以区分具有相同时间戳的边\r\n\r\n#### Public Static Functions\r\n\r\nstatic inline EdgeUid AnyEdge()  \r\n// Get a generic edge identifier.  \r\n// 获取通用边标识符\r\n\r\n---\r\n\r\n### struct Hash\r\n\r\n#include \r\n\r\n#### Public Functions\r\n\r\ninline size_t operator()(const EdgeUid &edgeUid) const  \r\n// Hash function for EdgeUid.  \r\n// EdgeUid的哈希函数\r\n\r\n---\r\n\r\n### struct InEdgeSortOrder\r\n\r\n#include   \r\n// Comparator for EdgeUid of in-coming edges.  \r\n// 传入边的EdgeUid的比较器。\r\n\r\n#### Public Functions\r\n\r\ninline bool operator()(const EdgeUid &lhs, const EdgeUid &rhs) const  \r\n// Compare two EdgeUid for ordering.  \r\n// 比较两个EdgeUid以进行排序\r\n\r\n---\r\n\r\n### struct OutEdgeSortOrder\r\n\r\n#include   \r\n// Comparator for EdgeUid of out-going edges.  \r\n// 传出边的EdgeUid的比较器。\r\n\r\n#### Public Functions\r\n\r\ninline bool operator()(const EdgeUid &lhs, const EdgeUid &rhs) const"
            },
            {
                "content": "---\r\n\r\n### struct InEdgeSortOrder\r\n\r\n#include   \r\n// Comparator for EdgeUid of in-coming edges.  \r\n// 传入边的EdgeUid的比较器。\r\n\r\n#### Public Functions\r\n\r\ninline bool operator()(const EdgeUid &lhs, const EdgeUid &rhs) const  \r\n// Compare two EdgeUid for ordering.  \r\n// 比较两个EdgeUid以进行排序\r\n\r\n---\r\n\r\n### struct OutEdgeSortOrder\r\n\r\n#include   \r\n// Comparator for EdgeUid of out-going edges.  \r\n// 传出边的EdgeUid的比较器。\r\n\r\n#### Public Functions\r\n\r\ninline bool operator()(const EdgeUid &lhs, const EdgeUid &rhs) const  \r\n// Compare two EdgeUid for ordering.  \r\n// 比较两个EdgeUid以进行排序\r\n\r\n---\r\n\r\n### struct FieldData\r\n\r\n#include   \r\n// A class that represents variant type.  \r\n// 表示变体类型的类。\r\n\r\n#### Public Functions\r\n\r\ninline FieldData()  \r\n// Default constructor.  \r\n// 默认构造函数\r\ninline explicit FieldData(bool b)  \r\n// Construct FieldData from bool.  \r\n// 从布尔值构造FieldData\r\ninline explicit FieldData(int8_t integer)  \r\n// Construct FieldData from int8_t.  \r\n// 从int8_t构造FieldData\r\ninline explicit FieldData(int16_t integer)"
            },
            {
                "content": "// Compare two EdgeUid for ordering.  \r\n// 比较两个EdgeUid以进行排序\r\n\r\n---\r\n\r\n### struct FieldData\r\n\r\n#include   \r\n// A class that represents variant type.  \r\n// 表示变体类型的类。\r\n\r\n#### Public Functions\r\n\r\ninline FieldData()  \r\n// Default constructor.  \r\n// 默认构造函数\r\ninline explicit FieldData(bool b)  \r\n// Construct FieldData from bool.  \r\n// 从布尔值构造FieldData\r\ninline explicit FieldData(int8_t integer)  \r\n// Construct FieldData from int8_t.  \r\n// 从int8_t构造FieldData\r\ninline explicit FieldData(int16_t integer)  \r\n// Construct FieldData from int16_t.  \r\n// 从int16_t构造FieldData\r\ninline explicit FieldData(int32_t integer)  \r\n// Construct FieldData from int32_t.  \r\n// 从int32_t构造FieldData\r\ninline explicit FieldData(int64_t integer)  \r\n// Construct FieldData from int64_t.  \r\n// 从int64_t构造FieldData\r\ninline explicit FieldData(float real)  \r\n// Construct FieldData from float.  \r\n// 从浮点数构造FieldData\r\ninline explicit FieldData(double real)  \r\n// Construct FieldData from double.  \r\n// 从双精度浮点数构造FieldData"
            },
            {
                "content": "// Construct FieldData from int16_t.  \r\n// 从int16_t构造FieldData\r\ninline explicit FieldData(int32_t integer)  \r\n// Construct FieldData from int32_t.  \r\n// 从int32_t构造FieldData\r\ninline explicit FieldData(int64_t integer)  \r\n// Construct FieldData from int64_t.  \r\n// 从int64_t构造FieldData\r\ninline explicit FieldData(float real)  \r\n// Construct FieldData from float.  \r\n// 从浮点数构造FieldData\r\ninline explicit FieldData(double real)  \r\n// Construct FieldData from double.  \r\n// 从双精度浮点数构造FieldData\r\ninline explicit FieldData(const Date &d)  \r\n// Construct FieldData from Date.  \r\n// 从日期构造FieldData\r\ninline explicit FieldData(const DateTime &d)  \r\n// Construct FieldData from DateTime.  \r\n// 从日期时间构造FieldData\r\ninline explicit FieldData(const std::string &buf)  \r\n// Construct FieldData from std::string.  \r\n// 从std::string构造FieldData\r\ninline explicit FieldData(std::string &&str)  \r\n// Construct FieldData from std::string (move).  \r\n// 从std::string（移动）构造FieldData\r\ninline explicit FieldData(const char *buf)"
            },
            {
                "content": "inline explicit FieldData(const Date &d)  \r\n// Construct FieldData from Date.  \r\n// 从日期构造FieldData\r\ninline explicit FieldData(const DateTime &d)  \r\n// Construct FieldData from DateTime.  \r\n// 从日期时间构造FieldData\r\ninline explicit FieldData(const std::string &buf)  \r\n// Construct FieldData from std::string.  \r\n// 从std::string构造FieldData\r\ninline explicit FieldData(std::string &&str)  \r\n// Construct FieldData from std::string (move).  \r\n// 从std::string（移动）构造FieldData\r\ninline explicit FieldData(const char *buf)  \r\n// Construct FieldData from C-string.  \r\n// 从C字符串构造FieldData\r\ninline explicit FieldData(const char *buf, size_t s)  \r\n// Construct FieldData from C-string with size.  \r\n// 从具有大小的C字符串构造FieldData\r\ninline explicit FieldData(const Point &p)  \r\n// Construct FieldData from Cartesian Point.  \r\n// 从笛卡尔点构造FieldData\r\ninline explicit FieldData(const Point &p)  \r\n// Construct FieldData from Wgs84 Point.  \r\n// 从Wgs84点构造FieldData\r\ninline explicit FieldData(const LineString &l)"
            },
            {
                "content": "// Construct FieldData from C-string.  \r\n// 从C字符串构造FieldData\r\ninline explicit FieldData(const char *buf, size_t s)  \r\n// Construct FieldData from C-string with size.  \r\n// 从具有大小的C字符串构造FieldData\r\ninline explicit FieldData(const Point &p)  \r\n// Construct FieldData from Cartesian Point.  \r\n// 从笛卡尔点构造FieldData\r\ninline explicit FieldData(const Point &p)  \r\n// Construct FieldData from Wgs84 Point.  \r\n// 从Wgs84点构造FieldData\r\ninline explicit FieldData(const LineString &l)  \r\n// Construct FieldData from Cartesian LineString.  \r\n// 从笛卡尔线段构造FieldData\r\ninline explicit FieldData(const LineString &l)  \r\n// Construct FieldData from Wgs84 LineString.  \r\n// 从Wgs84线段构造FieldData\r\ninline explicit FieldData(const Polygon &p)  \r\n// Construct FieldData from Cartesian Polygon.  \r\n// 从笛卡尔多边形构造FieldData\r\ninline explicit FieldData(const Polygon &p)  \r\n// Construct FieldData from Wgs84 Polygon.  \r\n// 从Wgs84多边形构造FieldData\r\ninline explicit FieldData(const Spatial &s)  \r\n// Construct FieldData from Cartesian Spatial."
            },
            {
                "content": "// 从笛卡尔线段构造FieldData\r\ninline explicit FieldData(const LineString &l)  \r\n// Construct FieldData from Wgs84 LineString.  \r\n// 从Wgs84线段构造FieldData\r\ninline explicit FieldData(const Polygon &p)  \r\n// Construct FieldData from Cartesian Polygon.  \r\n// 从笛卡尔多边形构造FieldData\r\ninline explicit FieldData(const Polygon &p)  \r\n// Construct FieldData from Wgs84 Polygon.  \r\n// 从Wgs84多边形构造FieldData\r\ninline explicit FieldData(const Spatial &s)  \r\n// Construct FieldData from Cartesian Spatial.  \r\n// 从笛卡尔空间构造FieldData\r\ninline explicit FieldData(const Spatial &s)  \r\n// Construct FieldData from Wgs84 Spatial.  \r\n// 从Wgs84空间构造FieldData\r\ninline explicit FieldData(const std::vector &fv)  \r\n// Construct FieldData from a vector of floats.  \r\n// 从浮点数向量构造FieldData\r\ninline explicit FieldData(std::vector &&fv)  \r\n// Construct FieldData from a vector of floats (move).  \r\n// 从浮点数向量（移动）构造FieldData\r\ninline ~FieldData()  \r\n// Destructor.  \r\n// 析构函数\r\ninline FieldData(const FieldData &rhs)  \r\n// Copy constructor.  \r\n// 拷贝构造函数"
            },
            {
                "content": "inline explicit FieldData(const Spatial &s)  \r\n// Construct FieldData from Wgs84 Spatial.  \r\n// 从Wgs84空间构造FieldData\r\ninline explicit FieldData(const std::vector &fv)  \r\n// Construct FieldData from a vector of floats.  \r\n// 从浮点数向量构造FieldData\r\ninline explicit FieldData(std::vector &&fv)  \r\n// Construct FieldData from a vector of floats (move).  \r\n// 从浮点数向量（移动）构造FieldData\r\ninline ~FieldData()  \r\n// Destructor.  \r\n// 析构函数\r\ninline FieldData(const FieldData &rhs)  \r\n// Copy constructor.  \r\n// 拷贝构造函数\r\ninline FieldData(FieldData &&rhs)  \r\n// Move constructor.  \r\n// 移动构造函数\r\ninline FieldData &operator=(const FieldData &rhs)  \r\n// Copy assignment operator.  \r\n// 拷贝赋值运算符\r\ninline FieldData &operator=(FieldData &&rhs)  \r\n// Move assignment operator.  \r\n// 移动赋值运算符\r\n\r\ninline int64_t integer() const  \r\n// Access the FieldData as int64. Valid only when the FieldData is of INT8, INT16, INT32, or INT64 types.  \r\n// 将FieldData作为int64访问。仅当FieldData为INT8、INT16、INT32或INT64类型时有效。\r\n\r\n抛出"
            },
            {
                "content": "// 拷贝构造函数\r\ninline FieldData(FieldData &&rhs)  \r\n// Move constructor.  \r\n// 移动构造函数\r\ninline FieldData &operator=(const FieldData &rhs)  \r\n// Copy assignment operator.  \r\n// 拷贝赋值运算符\r\ninline FieldData &operator=(FieldData &&rhs)  \r\n// Move assignment operator.  \r\n// 移动赋值运算符\r\n\r\ninline int64_t integer() const  \r\n// Access the FieldData as int64. Valid only when the FieldData is of INT8, INT16, INT32, or INT64 types.  \r\n// 将FieldData作为int64访问。仅当FieldData为INT8、INT16、INT32或INT64类型时有效。\r\n\r\n抛出  \r\nstd::bad_cast – Thrown when the FieldData is not of int types.  \r\n// 当FieldData不是整数类型时抛出。\r\n\r\n返回  \r\nAn int64_t.  \r\n// 一个int64_t。\r\n\r\ninline double real() const  \r\n// Access the FieldData as a double. The FieldData must be of FLOAT or DOUBLE types.\r\n// 将FieldData作为双精度浮点数访问。FieldData必须是FLOAT或DOUBLE类型。\r\n\r\n// 抛出  \r\nstd::bad_cast – Thrown if the FieldData is not of FLOAT or DOUBLE types.\r\n// 抛出std::bad_cast – 如果FieldData不是FLOAT或DOUBLE类型，则抛出此异常。\r\n\r\n// 返回  \r\nA double.\r\n// 返回一个双精度浮点数。\r\n\r\ninline const std::string &string() const"
            },
            {
                "content": "// 当FieldData不是整数类型时抛出。\r\n\r\n返回  \r\nAn int64_t.  \r\n// 一个int64_t。\r\n\r\ninline double real() const  \r\n// Access the FieldData as a double. The FieldData must be of FLOAT or DOUBLE types.\r\n// 将FieldData作为双精度浮点数访问。FieldData必须是FLOAT或DOUBLE类型。\r\n\r\n// 抛出  \r\nstd::bad_cast – Thrown if the FieldData is not of FLOAT or DOUBLE types.\r\n// 抛出std::bad_cast – 如果FieldData不是FLOAT或DOUBLE类型，则抛出此异常。\r\n\r\n// 返回  \r\nA double.\r\n// 返回一个双精度浮点数。\r\n\r\ninline const std::string &string() const  \r\n// Access the FieldData as std::string. Valid only for STRING, BLOB and SPATIAL. BLOB data is returned as-is, since std::string can also hold byte array.\r\n// 将FieldData作为std::string访问。仅适用于STRING、BLOB和SPATIAL。BLOB数据原样返回，因为std::string也可以保存字节数组。\r\n\r\n// 抛出  \r\nstd::bad_cast – Thrown when a bad cast error condition occurs.\r\n// 抛出std::bad_cast – 当发生错误转换时抛出此异常。\r\n\r\n// 返回  \r\nA reference to a const std::string.\r\n// 返回对const std::string的引用。\r\n\r\ninline bool AsBool() const  \r\n// Convert FieldData to bool.\r\n// 将FieldData转换为布尔值。\r\n\r\ninline int8_t AsInt8() const"
            },
            {
                "content": "// 将FieldData作为std::string访问。仅适用于STRING、BLOB和SPATIAL。BLOB数据原样返回，因为std::string也可以保存字节数组。\r\n\r\n// 抛出  \r\nstd::bad_cast – Thrown when a bad cast error condition occurs.\r\n// 抛出std::bad_cast – 当发生错误转换时抛出此异常。\r\n\r\n// 返回  \r\nA reference to a const std::string.\r\n// 返回对const std::string的引用。\r\n\r\ninline bool AsBool() const  \r\n// Convert FieldData to bool.\r\n// 将FieldData转换为布尔值。\r\n\r\ninline int8_t AsInt8() const  \r\n// Convert FieldData to INT8.\r\n// 将FieldData转换为INT8。\r\n\r\ninline int16_t AsInt16() const  \r\n// Convert FieldData to INT16.\r\n// 将FieldData转换为INT16。\r\n\r\ninline int32_t AsInt32() const  \r\n// Convert FieldData to INT32.\r\n// 将FieldData转换为INT32。\r\n\r\ninline int64_t AsInt64() const  \r\n// Convert FieldData to INT64.\r\n// 将FieldData转换为INT64。\r\n\r\ninline float AsFloat() const  \r\n// Convert FieldData to float.\r\n// 将FieldData转换为浮点数。\r\n\r\ninline double AsDouble() const  \r\n// Convert FieldData to double.\r\n// 将FieldData转换为双精度浮点数。\r\n\r\ninline inline ::lgraph_api::Date AsDate () const  \r\n// Convert FieldData to Date.\r\n// 将FieldData转换为日期。"
            },
            {
                "content": "// 将FieldData转换为INT16。\r\n\r\ninline int32_t AsInt32() const  \r\n// Convert FieldData to INT32.\r\n// 将FieldData转换为INT32。\r\n\r\ninline int64_t AsInt64() const  \r\n// Convert FieldData to INT64.\r\n// 将FieldData转换为INT64。\r\n\r\ninline float AsFloat() const  \r\n// Convert FieldData to float.\r\n// 将FieldData转换为浮点数。\r\n\r\ninline double AsDouble() const  \r\n// Convert FieldData to double.\r\n// 将FieldData转换为双精度浮点数。\r\n\r\ninline inline ::lgraph_api::Date AsDate () const  \r\n// Convert FieldData to Date.\r\n// 将FieldData转换为日期。\r\n\r\ninline inline ::lgraph_api::DateTime AsDateTime () const  \r\n// Convert FieldData to DateTime.\r\n// 将FieldData转换为日期时间。\r\n\r\ninline std::string AsString() const  \r\n// Convert FieldData to std::string.\r\n// 将FieldData转换为std::string。\r\n\r\ninline std::string AsBlob() const  \r\n// Convert FieldData to BLOB.\r\n// 将FieldData转换为BLOB。\r\n\r\ninline std::string AsBase64Blob() const  \r\n// Convert FieldData to Base64 BLOB.\r\n// 将FieldData转换为Base64 BLOB。\r\n\r\ninline inline ::lgraph_api::SRID GetSRID () const  \r\n// Get the SRID from the FieldData."
            },
            {
                "content": "// Convert FieldData to DateTime.\r\n// 将FieldData转换为日期时间。\r\n\r\ninline std::string AsString() const  \r\n// Convert FieldData to std::string.\r\n// 将FieldData转换为std::string。\r\n\r\ninline std::string AsBlob() const  \r\n// Convert FieldData to BLOB.\r\n// 将FieldData转换为BLOB。\r\n\r\ninline std::string AsBase64Blob() const  \r\n// Convert FieldData to Base64 BLOB.\r\n// 将FieldData转换为Base64 BLOB。\r\n\r\ninline inline ::lgraph_api::SRID GetSRID () const  \r\n// Get the SRID from the FieldData.\r\n// 从FieldData中获取SRID。\r\n\r\ninline inline ::lgraph_api::Point<::lgraph_api::Wgs84 > AsWgsPoint () const  \r\n// Convert FieldData to WGS84 Point.\r\n// 将FieldData转换为WGS84坐标点。\r\n\r\ninline inline ::lgraph_api::Point<::lgraph_api::Cartesian > AsCartesianPoint () const  \r\n// Convert FieldData to Cartesian Point.\r\n// 将FieldData转换为笛卡尔坐标点。\r\n\r\ninline inline ::lgraph_api::LineString<::lgraph_api::Wgs84 > AsWgsLineString () const  \r\n// Convert FieldData to WGS84 LineString.\r\n// 将FieldData转换为WGS84线串。"
            },
            {
                "content": "// 从FieldData中获取SRID。\r\n\r\ninline inline ::lgraph_api::Point<::lgraph_api::Wgs84 > AsWgsPoint () const  \r\n// Convert FieldData to WGS84 Point.\r\n// 将FieldData转换为WGS84坐标点。\r\n\r\ninline inline ::lgraph_api::Point<::lgraph_api::Cartesian > AsCartesianPoint () const  \r\n// Convert FieldData to Cartesian Point.\r\n// 将FieldData转换为笛卡尔坐标点。\r\n\r\ninline inline ::lgraph_api::LineString<::lgraph_api::Wgs84 > AsWgsLineString () const  \r\n// Convert FieldData to WGS84 LineString.\r\n// 将FieldData转换为WGS84线串。\r\n\r\ninline inline ::lgraph_api::LineString<::lgraph_api::Cartesian > AsCartesianLineString () const  \r\n// Convert FieldData to Cartesian LineString.\r\n// 将FieldData转换为笛卡尔线串。\r\n\r\ninline inline ::lgraph_api::Polygon<::lgraph_api::Wgs84 > AsWgsPolygon () const  \r\n// Convert FieldData to WGS84 Polygon.\r\n// 将FieldData转换为WGS84多边形。\r\n\r\ninline inline ::lgraph_api::Polygon<::lgraph_api::Cartesian > AsCartesianPolygon () const  \r\n// Convert FieldData to Cartesian Polygon.\r\n// 将FieldData转换为笛卡尔多边形。"
            },
            {
                "content": "inline inline ::lgraph_api::LineString<::lgraph_api::Cartesian > AsCartesianLineString () const  \r\n// Convert FieldData to Cartesian LineString.\r\n// 将FieldData转换为笛卡尔线串。\r\n\r\ninline inline ::lgraph_api::Polygon<::lgraph_api::Wgs84 > AsWgsPolygon () const  \r\n// Convert FieldData to WGS84 Polygon.\r\n// 将FieldData转换为WGS84多边形。\r\n\r\ninline inline ::lgraph_api::Polygon<::lgraph_api::Cartesian > AsCartesianPolygon () const  \r\n// Convert FieldData to Cartesian Polygon.\r\n// 将FieldData转换为笛卡尔多边形。\r\n\r\ninline inline ::lgraph_api::Spatial<::lgraph_api::Wgs84 > AsWgsSpatial () const  \r\n// Convert FieldData to WGS84 Spatial data.\r\n// 将FieldData转换为WGS84空间数据。\r\n\r\ninline inline ::lgraph_api::Spatial<::lgraph_api::Cartesian > AsCartesianSpatial () const  \r\n// Convert FieldData to Cartesian Spatial data.\r\n// 将FieldData转换为笛卡尔空间数据。\r\n\r\ninline std::vector AsFloatVector() const  \r\n// Convert FieldData to a vector of floats.\r\n// 将FieldData转换为浮点数向量。\r\n\r\nstd::any ToBolt() const  \r\n// Convert FieldData to a Bolt representation."
            },
            {
                "content": "// Convert FieldData to WGS84 Spatial data.\r\n// 将FieldData转换为WGS84空间数据。\r\n\r\ninline inline ::lgraph_api::Spatial<::lgraph_api::Cartesian > AsCartesianSpatial () const  \r\n// Convert FieldData to Cartesian Spatial data.\r\n// 将FieldData转换为笛卡尔空间数据。\r\n\r\ninline std::vector AsFloatVector() const  \r\n// Convert FieldData to a vector of floats.\r\n// 将FieldData转换为浮点数向量。\r\n\r\nstd::any ToBolt() const  \r\n// Convert FieldData to a Bolt representation.\r\n// 将FieldData转换为Bolt表示。\r\n\r\ninline std::string ToString(const std::string &null_value = \"NUL\") const  \r\n// Get string representation of this FieldData.\r\n// 获取此FieldData的字符串表示。\r\n\r\ninline bool operator==(const FieldData &rhs) const  \r\n// Check for equality between two FieldData objects.\r\n// 检查两个FieldData对象是否相等。\r\n\r\ninline bool operator!=(const FieldData &rhs) const  \r\n// Check for inequality between two FieldData objects.\r\n// 检查两个FieldData对象是否不相等。\r\n\r\ninline bool operator>(const FieldData &rhs) const  \r\n// Compare if this FieldData is greater than another FieldData."
            },
            {
                "content": "// Get string representation of this FieldData.\r\n// 获取此FieldData的字符串表示。\r\n\r\ninline bool operator==(const FieldData &rhs) const  \r\n// Check for equality between two FieldData objects.\r\n// 检查两个FieldData对象是否相等。\r\n\r\ninline bool operator!=(const FieldData &rhs) const  \r\n// Check for inequality between two FieldData objects.\r\n// 检查两个FieldData对象是否不相等。\r\n\r\ninline bool operator>(const FieldData &rhs) const  \r\n// Compare if this FieldData is greater than another FieldData.\r\n// 比较此FieldData是否大于另一个FieldData。\r\n\r\ninline bool operator>=(const FieldData &rhs) const  \r\n// Compare if this FieldData is greater than or equal to another FieldData.\r\n// 比较此FieldData是否大于或等于另一个FieldData。\r\n\r\ninline bool operator<(const FieldData &rhs) const  \r\n// Compare if this FieldData is less than another FieldData.\r\n// 比较此FieldData是否小于另一个FieldData。\r\n\r\ninline bool operator<=(const FieldData &rhs) const  \r\n// Compare if this FieldData is less than or equal to another FieldData.\r\n// 比较此FieldData是否小于或等于另一个FieldData。"
            },
            {
                "content": "inline bool operator>=(const FieldData &rhs) const  \r\n// Compare if this FieldData is greater than or equal to another FieldData.\r\n// 比较此FieldData是否大于或等于另一个FieldData。\r\n\r\ninline bool operator<(const FieldData &rhs) const  \r\n// Compare if this FieldData is less than another FieldData.\r\n// 比较此FieldData是否小于另一个FieldData。\r\n\r\ninline bool operator<=(const FieldData &rhs) const  \r\n// Compare if this FieldData is less than or equal to another FieldData.\r\n// 比较此FieldData是否小于或等于另一个FieldData。\r\n\r\ninline FieldType GetType() const  \r\n// Get the type of the FieldData.\r\n// 获取FieldData的类型。\r\n\r\ninline bool is_null() const  \r\n// Check if this FieldData is null.\r\n// 检查此FieldData是否为空。\r\n\r\ninline bool is_buf() const  \r\n// Check if this FieldData is a buffer type.\r\n// 检查此FieldData是否为缓冲区类型。\r\n\r\ninline bool is_empty_buf() const  \r\n// Check if this FieldData is an empty buffer.\r\n// 检查此FieldData是否为空缓冲区。\r\n\r\ninline bool IsNull() const  \r\n// Query if this object is null.\r\n// 查询此对象是否为空。\r\n\r\ninline bool IsBool() const"
            },
            {
                "content": "inline FieldType GetType() const  \r\n// Get the type of the FieldData.\r\n// 获取FieldData的类型。\r\n\r\ninline bool is_null() const  \r\n// Check if this FieldData is null.\r\n// 检查此FieldData是否为空。\r\n\r\ninline bool is_buf() const  \r\n// Check if this FieldData is a buffer type.\r\n// 检查此FieldData是否为缓冲区类型。\r\n\r\ninline bool is_empty_buf() const  \r\n// Check if this FieldData is an empty buffer.\r\n// 检查此FieldData是否为空缓冲区。\r\n\r\ninline bool IsNull() const  \r\n// Query if this object is null.\r\n// 查询此对象是否为空。\r\n\r\ninline bool IsBool() const  \r\n// Query if this object is bool.\r\n// 查询此对象是否为布尔值。\r\n\r\ninline bool IsBlob() const  \r\n// Query if this object is BLOB.\r\n// 查询此对象是否为BLOB。\r\n\r\ninline bool IsString() const  \r\n// Query if this object is string.\r\n// 查询此对象是否为字符串。\r\n\r\ninline bool IsInt8() const  \r\n// Query if this object is INT8.\r\n// 查询此对象是否为INT8。\r\n\r\ninline bool IsInt16() const  \r\n// Query if this object is INT16.\r\n// 查询此对象是否为INT16。\r\n\r\ninline bool IsInt32() const  \r\n// Query if this object is INT32.\r\n// 查询此对象是否为INT32。\r\n\r\ninline bool IsInt64() const"
            },
            {
                "content": "// 查询此对象是否为布尔值。\r\n\r\ninline bool IsBlob() const  \r\n// Query if this object is BLOB.\r\n// 查询此对象是否为BLOB。\r\n\r\ninline bool IsString() const  \r\n// Query if this object is string.\r\n// 查询此对象是否为字符串。\r\n\r\ninline bool IsInt8() const  \r\n// Query if this object is INT8.\r\n// 查询此对象是否为INT8。\r\n\r\ninline bool IsInt16() const  \r\n// Query if this object is INT16.\r\n// 查询此对象是否为INT16。\r\n\r\ninline bool IsInt32() const  \r\n// Query if this object is INT32.\r\n// 查询此对象是否为INT32。\r\n\r\ninline bool IsInt64() const  \r\n// Query if this object is INT64.\r\n// 查询此对象是否为INT64。\r\n\r\ninline bool IsInteger() const  \r\n// Is this a INT8, INT16, INT32 or INT64?\r\n// 这是否为INT8、INT16、INT32或INT64？\r\n\r\ninline bool IsFloat() const  \r\n// Query if this object is float.\r\n// 查询此对象是否为浮点数。\r\n\r\ninline bool IsDouble() const  \r\n// Query if this object is double.\r\n// 查询此对象是否为双精度浮点数。\r\n\r\ninline bool IsReal() const  \r\n// Is this a FLOAT or DOUBLE?\r\n// 这是否为FLOAT或DOUBLE？\r\n\r\ninline bool IsDate() const  \r\n// Query if this object is date.\r\n// 查询此对象是否为日期。\r\n\r\ninline bool IsDateTime() const"
            },
            {
                "content": "// 查询此对象是否为INT64。\r\n\r\ninline bool IsInteger() const  \r\n// Is this a INT8, INT16, INT32 or INT64?\r\n// 这是否为INT8、INT16、INT32或INT64？\r\n\r\ninline bool IsFloat() const  \r\n// Query if this object is float.\r\n// 查询此对象是否为浮点数。\r\n\r\ninline bool IsDouble() const  \r\n// Query if this object is double.\r\n// 查询此对象是否为双精度浮点数。\r\n\r\ninline bool IsReal() const  \r\n// Is this a FLOAT or DOUBLE?\r\n// 这是否为FLOAT或DOUBLE？\r\n\r\ninline bool IsDate() const  \r\n// Query if this object is date.\r\n// 查询此对象是否为日期。\r\n\r\ninline bool IsDateTime() const  \r\n// Query if this object is date time.\r\n// 查询此对象是否为日期时间。\r\n\r\ninline bool IsPoint() const  \r\n// Query if this object is Point.\r\n// 查询此对象是否为点。\r\n\r\ninline bool IsLineString() const  \r\n// Query if this object is LineString.\r\n// 查询此对象是否为线串。\r\n\r\ninline bool IsPolygon() const  \r\n// Query if this object is Polygon.\r\n// 查询此对象是否为多边形。\r\n\r\ninline bool IsSpatial() const  \r\n// Query if this object is spatial.\r\n// 查询此对象是否为空间数据。\r\n\r\ninline bool IsFloatVector() const  \r\n// Query if this object is float vector.\r\n// 查询此对象是否为浮点数向量。"
            },
            {
                "content": "// 查询此对象是否为日期时间。\r\n\r\ninline bool IsPoint() const  \r\n// Query if this object is Point.\r\n// 查询此对象是否为点。\r\n\r\ninline bool IsLineString() const  \r\n// Query if this object is LineString.\r\n// 查询此对象是否为线串。\r\n\r\ninline bool IsPolygon() const  \r\n// Query if this object is Polygon.\r\n// 查询此对象是否为多边形。\r\n\r\ninline bool IsSpatial() const  \r\n// Query if this object is spatial.\r\n// 查询此对象是否为空间数据。\r\n\r\ninline bool IsFloatVector() const  \r\n// Query if this object is float vector.\r\n// 查询此对象是否为浮点数向量。\r\n\r\n#### Public Members\r\n\r\n- FieldType type  \r\n// The type of the FieldData.  \r\n// FieldData的类型。\r\n\r\n- bool boolean  \r\n// Boolean value of the FieldData.  \r\n// FieldData的布尔值。\r\n\r\n- int8_t int8  \r\n// INT8 value of the FieldData.  \r\n// FieldData的INT8值。\r\n\r\n- int16_t int16  \r\n// INT16 value of the FieldData.  \r\n// FieldData的INT16值。\r\n\r\n- int32_t int32  \r\n// INT32 value of the FieldData.  \r\n// FieldData的INT32值。\r\n\r\n- int64_t int64  \r\n// INT64 value of the FieldData.  \r\n// FieldData的INT64值。\r\n\r\n- float sp  \r\n// FLOAT value of the FieldData."
            },
            {
                "content": "- FieldType type  \r\n// The type of the FieldData.  \r\n// FieldData的类型。\r\n\r\n- bool boolean  \r\n// Boolean value of the FieldData.  \r\n// FieldData的布尔值。\r\n\r\n- int8_t int8  \r\n// INT8 value of the FieldData.  \r\n// FieldData的INT8值。\r\n\r\n- int16_t int16  \r\n// INT16 value of the FieldData.  \r\n// FieldData的INT16值。\r\n\r\n- int32_t int32  \r\n// INT32 value of the FieldData.  \r\n// FieldData的INT32值。\r\n\r\n- int64_t int64  \r\n// INT64 value of the FieldData.  \r\n// FieldData的INT64值。\r\n\r\n- float sp  \r\n// FLOAT value of the FieldData.  \r\n// FieldData的FLOAT值。\r\n\r\n- double dp  \r\n// DOUBLE value of the FieldData.  \r\n// FieldData的DOUBLE值。\r\n\r\n- std::string *buf  \r\n// Buffer of the FieldData.  \r\n// FieldData的缓冲区。\r\n\r\n- std::vector *vp  \r\n// Vector of floats in the FieldData.  \r\n// FieldData中的浮点数向量。\r\n\r\n- union lgraph_api::FieldData::[anonymous] data  \r\n// Anonymous union to hold different types of data.\r\n// 匿名联合用于存放不同类型的数据。\r\n\r\n#### Public Static Functions\r\n\r\nstatic inline FieldData Bool(bool b)  // 创建一个布尔值的字段数据"
            },
            {
                "content": "// FLOAT value of the FieldData.  \r\n// FieldData的FLOAT值。\r\n\r\n- double dp  \r\n// DOUBLE value of the FieldData.  \r\n// FieldData的DOUBLE值。\r\n\r\n- std::string *buf  \r\n// Buffer of the FieldData.  \r\n// FieldData的缓冲区。\r\n\r\n- std::vector *vp  \r\n// Vector of floats in the FieldData.  \r\n// FieldData中的浮点数向量。\r\n\r\n- union lgraph_api::FieldData::[anonymous] data  \r\n// Anonymous union to hold different types of data.\r\n// 匿名联合用于存放不同类型的数据。\r\n\r\n#### Public Static Functions\r\n\r\nstatic inline FieldData Bool(bool b)  // 创建一个布尔值的字段数据\r\nstatic inline FieldData Int8(int8_t i)  // 创建一个8位整数的字段数据\r\nstatic inline FieldData Int16(int16_t i)  // 创建一个16位整数的字段数据\r\nstatic inline FieldData Int32(int32_t i)  // 创建一个32位整数的字段数据\r\nstatic inline FieldData Int64(int64_t i)  // 创建一个64位整数的字段数据\r\nstatic inline FieldData Float(float d)  // 创建一个浮点数的字段数据\r\nstatic inline FieldData Double(double d)  // 创建一个双精度浮点数的字段数据\r\nstatic inline FieldData Date(const std::string &str)  // 创建一个日期的字段数据，从字符串转换"
            },
            {
                "content": "static inline FieldData Bool(bool b)  // 创建一个布尔值的字段数据\r\nstatic inline FieldData Int8(int8_t i)  // 创建一个8位整数的字段数据\r\nstatic inline FieldData Int16(int16_t i)  // 创建一个16位整数的字段数据\r\nstatic inline FieldData Int32(int32_t i)  // 创建一个32位整数的字段数据\r\nstatic inline FieldData Int64(int64_t i)  // 创建一个64位整数的字段数据\r\nstatic inline FieldData Float(float d)  // 创建一个浮点数的字段数据\r\nstatic inline FieldData Double(double d)  // 创建一个双精度浮点数的字段数据\r\nstatic inline FieldData Date(const std::string &str)  // 创建一个日期的字段数据，从字符串转换\r\nstatic inline FieldData Date(const ::lgraph_api::Date &d)  // 创建一个日期的字段数据，从日期对象转换\r\nstatic inline FieldData DateTime(const std::string &str)  // 创建一个日期时间的字段数据，从字符串转换\r\nstatic inline FieldData DateTime(const ::lgraph_api::DateTime &d)  // 创建一个日期时间的字段数据，从日期时间对象转换\r\nstatic inline FieldData String(const std::string &str)  // 创建一个字符串的字段数据\r\nstatic inline FieldData String(std::string &&str)  // 创建一个字符串的字段数据，从右值引用\r\nstatic inline FieldData String(const char *str)  // 创建一个字符串的字段数据，从C风格字符串"
            },
            {
                "content": "static inline FieldData Date(const ::lgraph_api::Date &d)  // 创建一个日期的字段数据，从日期对象转换\r\nstatic inline FieldData DateTime(const std::string &str)  // 创建一个日期时间的字段数据，从字符串转换\r\nstatic inline FieldData DateTime(const ::lgraph_api::DateTime &d)  // 创建一个日期时间的字段数据，从日期时间对象转换\r\nstatic inline FieldData String(const std::string &str)  // 创建一个字符串的字段数据\r\nstatic inline FieldData String(std::string &&str)  // 创建一个字符串的字段数据，从右值引用\r\nstatic inline FieldData String(const char *str)  // 创建一个字符串的字段数据，从C风格字符串\r\nstatic inline FieldData String(const char *p, size_t s)  // 创建一个字符串的字段数据，从C风格字符串及其大小\r\nstatic inline FieldData Point(const ::lgraph_api::Point &p)  // 创建一个笛卡尔坐标点的字段数据\r\nstatic inline FieldData Point(const ::lgraph_api::Point &p)  // 创建一个WGS84坐标点的字段数据\r\nstatic inline FieldData Point(const std::string &str)  // 创建一个点的字段数据，从字符串转换\r\nstatic inline FieldData LineString(const ::lgraph_api::LineString &l)  // 创建一个笛卡尔坐标线串的字段数据\r\nstatic inline FieldData LineString(const ::lgraph_api::LineString &l)  // 创建一个WGS84坐标线串的字段数据"
            },
            {
                "content": "static inline FieldData Point(const ::lgraph_api::Point &p)  // 创建一个笛卡尔坐标点的字段数据\r\nstatic inline FieldData Point(const ::lgraph_api::Point &p)  // 创建一个WGS84坐标点的字段数据\r\nstatic inline FieldData Point(const std::string &str)  // 创建一个点的字段数据，从字符串转换\r\nstatic inline FieldData LineString(const ::lgraph_api::LineString &l)  // 创建一个笛卡尔坐标线串的字段数据\r\nstatic inline FieldData LineString(const ::lgraph_api::LineString &l)  // 创建一个WGS84坐标线串的字段数据\r\nstatic inline FieldData LineString(const std::string &str)  // 创建一个线串的字段数据，从字符串转换\r\nstatic inline FieldData Polygon(const ::lgraph_api::Polygon &p)  // 创建一个笛卡尔坐标多边形的字段数据\r\nstatic inline FieldData Polygon(const ::lgraph_api::Polygon &p)  // 创建一个WGS84坐标多边形的字段数据\r\nstatic inline FieldData Polygon(const std::string &str)  // 创建一个多边形的字段数据，从字符串转换\r\nstatic inline FieldData Spatial(const ::lgraph_api::Spatial &s)  // 创建一个笛卡尔坐标空间数据的字段数据\r\nstatic inline FieldData Spatial(const ::lgraph_api::Spatial &s)  // 创建一个WGS84坐标空间数据的字段数据"
            },
            {
                "content": "static inline FieldData Polygon(const ::lgraph_api::Polygon &p)  // 创建一个笛卡尔坐标多边形的字段数据\r\nstatic inline FieldData Polygon(const ::lgraph_api::Polygon &p)  // 创建一个WGS84坐标多边形的字段数据\r\nstatic inline FieldData Polygon(const std::string &str)  // 创建一个多边形的字段数据，从字符串转换\r\nstatic inline FieldData Spatial(const ::lgraph_api::Spatial &s)  // 创建一个笛卡尔坐标空间数据的字段数据\r\nstatic inline FieldData Spatial(const ::lgraph_api::Spatial &s)  // 创建一个WGS84坐标空间数据的字段数据\r\nstatic inline FieldData Spatial(const std::string &str)  // 创建一个空间数据的字段数据，从字符串转换\r\nstatic inline FieldData FloatVector(const std::vector &fv)  // 创建一个浮点向量的字段数据\r\nstatic inline FieldData Blob(const std::string &str)  // 从字符串构建BLOB字段数据\r\nstatic inline FieldData Blob(std::string &&str)  // 从右值引用字符串构建BLOB字段数据\r\nstatic inline FieldData Blob(const std::vector &str)  // 从uint8_t的向量构建BLOB字段数据, 将其视为字节数组。\r\nConstructs a Blob from vector of uint8_t, treated as byte array.\r\n\r\nstatic inline FieldData BlobFromBase64(const std::string &base64_encoded)  // 从Base64编码的字符串构建BLOB字段数据"
            },
            {
                "content": "static inline FieldData FloatVector(const std::vector &fv)  // 创建一个浮点向量的字段数据\r\nstatic inline FieldData Blob(const std::string &str)  // 从字符串构建BLOB字段数据\r\nstatic inline FieldData Blob(std::string &&str)  // 从右值引用字符串构建BLOB字段数据\r\nstatic inline FieldData Blob(const std::vector &str)  // 从uint8_t的向量构建BLOB字段数据, 将其视为字节数组。\r\nConstructs a Blob from vector of uint8_t, treated as byte array.\r\n\r\nstatic inline FieldData BlobFromBase64(const std::string &base64_encoded)  // 从Base64编码的字符串构建BLOB字段数据\r\nConstructs a BLOB from Base64 encoded string.\r\n\r\n#### Private Static Functions\r\n\r\nstatic inline bool IsBufType(FieldType t)  // 查询“t”是否为BLOB或STRING类型\r\nQuery if ‘t’ is BLOB or STRING\r\n\r\nstatic inline bool IsInteger(FieldType t)  // 查询“t”是否为INT8, 16, 32或者64类型\r\nQuery if ‘t’ is INT8, 16, 32, or 64\r\n\r\nstatic inline bool IsReal(FieldType t)  // 查询“t”是否为FLOAT或DOUBLE类型\r\nQuery if ‘t’ is FLLOAT or DOUBLE\r\n\r\n### struct FieldSpec\r\n\r\n#include   // 引入lgraph_types.h文件\r\nSpecification for a field.\r\n\r\n#### Public Functions"
            },
            {
                "content": "#### Private Static Functions\r\n\r\nstatic inline bool IsBufType(FieldType t)  // 查询“t”是否为BLOB或STRING类型\r\nQuery if ‘t’ is BLOB or STRING\r\n\r\nstatic inline bool IsInteger(FieldType t)  // 查询“t”是否为INT8, 16, 32或者64类型\r\nQuery if ‘t’ is INT8, 16, 32, or 64\r\n\r\nstatic inline bool IsReal(FieldType t)  // 查询“t”是否为FLOAT或DOUBLE类型\r\nQuery if ‘t’ is FLLOAT or DOUBLE\r\n\r\n### struct FieldSpec\r\n\r\n#include   // 引入lgraph_types.h文件\r\nSpecification for a field.\r\n\r\n#### Public Functions\r\n\r\ninline FieldSpec()  // 默认构造函数\r\ninline FieldSpec(const std::string &n, FieldType t, bool nu)  // 构造函数\r\nConstructor  \r\n\r\n**参数**  \r\nn – Field name  // 字段名称  \r\n\r\nt – Field type  // 字段类型  \r\n\r\nnu – True if field is optional  // 如果字段是可选的则为真  \r\n\r\ninline FieldSpec(std::string &&n, FieldType t, bool nu)  // 从右值引用构造函数\r\ninline bool operator==(const FieldSpec &rhs) const  // 重载相等运算符\r\ninline std::string ToString() const  // 获取FieldSpec的字符串表示\r\nGet the string representation of the FieldSpec.\r\n\r\n#### Public Members\r\n\r\n- std::string name  // 字段的名称"
            },
            {
                "content": "inline FieldSpec(const std::string &n, FieldType t, bool nu)  // 构造函数\r\nConstructor  \r\n\r\n**参数**  \r\nn – Field name  // 字段名称  \r\n\r\nt – Field type  // 字段类型  \r\n\r\nnu – True if field is optional  // 如果字段是可选的则为真  \r\n\r\ninline FieldSpec(std::string &&n, FieldType t, bool nu)  // 从右值引用构造函数\r\ninline bool operator==(const FieldSpec &rhs) const  // 重载相等运算符\r\ninline std::string ToString() const  // 获取FieldSpec的字符串表示\r\nGet the string representation of the FieldSpec.\r\n\r\n#### Public Members\r\n\r\n- std::string name  // 字段的名称\r\n  name of the field  \r\n- FieldType type  // 字段的类型\r\n  type of that field  \r\n- bool optional  // 该字段是否可选？\r\n  is this field optional?  \r\n\r\n---\r\n\r\n### struct IndexSpec\r\n\r\n#include   \r\nAn index specifier. // 索引说明符\r\n\r\n#### Public Members\r\n\r\n- std::string label  \r\n  label name  // 标签名称  \r\n- std::string field  \r\n  field name  // 字段名称  \r\n- IndexType type  // 索引类型  \r\n\r\n---\r\n\r\n### struct LabelOptions\r\n\r\n#include   \r\nLabel options, base class, define some common fields and methods // 标签选项，基类，定义一些通用字段和方法"
            },
            {
                "content": "name of the field  \r\n- FieldType type  // 字段的类型\r\n  type of that field  \r\n- bool optional  // 该字段是否可选？\r\n  is this field optional?  \r\n\r\n---\r\n\r\n### struct IndexSpec\r\n\r\n#include   \r\nAn index specifier. // 索引说明符\r\n\r\n#### Public Members\r\n\r\n- std::string label  \r\n  label name  // 标签名称  \r\n- std::string field  \r\n  field name  // 字段名称  \r\n- IndexType type  // 索引类型  \r\n\r\n---\r\n\r\n### struct LabelOptions\r\n\r\n#include   \r\nLabel options, base class, define some common fields and methods // 标签选项，基类，定义一些通用字段和方法\r\n\r\n**Subclassed by** EdgeOptions, VertexOptions // 由 EdgeOptions 和 VertexOptions 继承\r\n\r\n#### Public Functions\r\n\r\nvirtual std::string to_string() const = 0  \r\n// 返回对象的字符串表示形式  \r\nvirtual void clear() = 0  \r\n// 清除对象的状态  \r\ninline virtual ~LabelOptions()  \r\n// 析构函数  \r\n\r\n#### Public Members\r\n\r\n- bool detach_property = false  \r\n// 是否分离属性  \r\n\r\n---\r\n\r\n### struct Parameter\r\n\r\n#include   \r\nThe parameter of procedure/plugin // 过程/插件的参数\r\n\r\n#### Public Members\r\n\r\n- std::string name  \r\n  name of the parameter  // 参数名称  \r\n- int index"
            },
            {
                "content": "#### Public Functions\r\n\r\nvirtual std::string to_string() const = 0  \r\n// 返回对象的字符串表示形式  \r\nvirtual void clear() = 0  \r\n// 清除对象的状态  \r\ninline virtual ~LabelOptions()  \r\n// 析构函数  \r\n\r\n#### Public Members\r\n\r\n- bool detach_property = false  \r\n// 是否分离属性  \r\n\r\n---\r\n\r\n### struct Parameter\r\n\r\n#include   \r\nThe parameter of procedure/plugin // 过程/插件的参数\r\n\r\n#### Public Members\r\n\r\n- std::string name  \r\n  name of the parameter  // 参数名称  \r\n- int index  \r\n  index of the parameter list in which the parameter stay  // 参数在参数列表中的索引  \r\n\r\n---\r\n\r\n### struct RoleInfo\r\n\r\n#include   \r\nInformation about the role. // 角色的信息\r\n\r\n#### Public Members\r\n\r\n- std::string desc  \r\n  description  // 描述  \r\n- std::map graph_access  \r\n  access levels on different graphs  // 在不同图上的访问级别  \r\n- bool disabled = false  \r\n  is this role disabled?  // 此角色是否被禁用?  \r\n\r\n---\r\n\r\n### struct SigSpec\r\n\r\n#include   \r\n\r\n#### Public Members\r\n\r\n- std::vector input_list  \r\n// 输入参数列表  \r\n- std::vector result_list  \r\n  input parameter list  // 输入参数列表  \r\n\r\n---"
            },
            {
                "content": "---\r\n\r\n### struct RoleInfo\r\n\r\n#include   \r\nInformation about the role. // 角色的信息\r\n\r\n#### Public Members\r\n\r\n- std::string desc  \r\n  description  // 描述  \r\n- std::map graph_access  \r\n  access levels on different graphs  // 在不同图上的访问级别  \r\n- bool disabled = false  \r\n  is this role disabled?  // 此角色是否被禁用?  \r\n\r\n---\r\n\r\n### struct SigSpec\r\n\r\n#include   \r\n\r\n#### Public Members\r\n\r\n- std::vector input_list  \r\n// 输入参数列表  \r\n- std::vector result_list  \r\n  input parameter list  // 输入参数列表  \r\n\r\n---\r\n\r\n### struct UserInfo\r\n\r\n#include   \r\nInformation about the user. // 用户的信息\r\n\r\n#### Public Members\r\n\r\n- std::string desc  \r\n  description of the user  // 用户的描述  \r\n- std::set roles  \r\n  roles of this user  // 此用户的角色  \r\n- bool disabled = false  \r\n  is this user disabled?  // 此用户是否被禁用?  \r\n- size_t memory_limit  \r\n  memory limit for this user  // 此用户的内存限制  \r\n\r\n---\r\n\r\n### struct VectorIndexSpec\r\n\r\n#include   \r\n\r\n#### Public Members\r\n\r\n- std::string label  \r\n// 标签  \r\n- std::string field  \r\n// 字段  \r\n- std::string index_type  \r\n// 索引类型"
            },
            {
                "content": "#include   \r\nInformation about the user. // 用户的信息\r\n\r\n#### Public Members\r\n\r\n- std::string desc  \r\n  description of the user  // 用户的描述  \r\n- std::set roles  \r\n  roles of this user  // 此用户的角色  \r\n- bool disabled = false  \r\n  is this user disabled?  // 此用户是否被禁用?  \r\n- size_t memory_limit  \r\n  memory limit for this user  // 此用户的内存限制  \r\n\r\n---\r\n\r\n### struct VectorIndexSpec\r\n\r\n#include   \r\n\r\n#### Public Members\r\n\r\n- std::string label  \r\n// 标签  \r\n- std::string field  \r\n// 字段  \r\n- std::string index_type  \r\n// 索引类型  \r\n- int dimension  \r\n// 维度  \r\n- std::string distance_type  \r\n// 距离类型  \r\n- int hnsm_m  \r\n// hnsm 的 m 值  \r\n- int hnsm_ef_construction  \r\n// hnsm 的 ef_construction 值  \r\n\r\n---\r\n\r\n### struct VertexOptions : public LabelOptions\r\n\r\n#include   \r\nVertex label options, contain fields only vertex have // 顶点标签选项，仅包含顶点拥有的字段\r\n\r\n#### Public Functions\r\n\r\nVertexOptions() = default  \r\n// 默认构造函数  \r\ninline explicit VertexOptions(const std::string &primary_field)  \r\n// 带有主字段的显式构造函数"
            },
            {
                "content": "- std::string index_type  \r\n// 索引类型  \r\n- int dimension  \r\n// 维度  \r\n- std::string distance_type  \r\n// 距离类型  \r\n- int hnsm_m  \r\n// hnsm 的 m 值  \r\n- int hnsm_ef_construction  \r\n// hnsm 的 ef_construction 值  \r\n\r\n---\r\n\r\n### struct VertexOptions : public LabelOptions\r\n\r\n#include   \r\nVertex label options, contain fields only vertex have // 顶点标签选项，仅包含顶点拥有的字段\r\n\r\n#### Public Functions\r\n\r\nVertexOptions() = default  \r\n// 默认构造函数  \r\ninline explicit VertexOptions(const std::string &primary_field)  \r\n// 带有主字段的显式构造函数  \r\ninline virtual std::string to_string() const  \r\n// 返回对象的字符串表示形式  \r\ninline virtual void clear()  \r\n// 清除对象的状态  \r\n\r\n#### Public Members\r\n\r\n- std::string primary_field  \r\n// 主字段  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_utils\r\n\r\n### Typedefs\r\n```cpp\r\nusing json = nlohmann::json // 使用 nlohmann::json 作为 json 的类型别名\r\n```\r\n\r\n### Namespace lgraph_api\r\n\r\n### Functions\r\n```cpp\r\ndouble get_time() \r\n```\r\nGet current time.  // 获取当前时间。\r\n\r\n返回  \r\nDigit value of current time.  // 当前时间的数字值。\r\n\r\n```cpp"
            },
            {
                "content": "inline virtual std::string to_string() const  \r\n// 返回对象的字符串表示形式  \r\ninline virtual void clear()  \r\n// 清除对象的状态  \r\n\r\n#### Public Members\r\n\r\n- std::string primary_field  \r\n// 主字段  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_utils\r\n\r\n### Typedefs\r\n```cpp\r\nusing json = nlohmann::json // 使用 nlohmann::json 作为 json 的类型别名\r\n```\r\n\r\n### Namespace lgraph_api\r\n\r\n### Functions\r\n```cpp\r\ndouble get_time() \r\n```\r\nGet current time.  // 获取当前时间。\r\n\r\n返回  \r\nDigit value of current time.  // 当前时间的数字值。\r\n\r\n```cpp\r\nvoid split_string(std::string origin_string, std::vector ⊂_strings, std::string string_delimiter) \r\n```\r\nSplit the original string by format.  //按照某种格式分割原始字符串。\r\n\r\n参数  \r\norigin_string – Original string to be split.  // 原始字符串。  \r\nsub_strings – Split substring.  // 分割后的子字符串。  \r\nstring_delimiter – Split format.  // 分割格式。\r\n\r\n```cpp\r\nstd::string rc4(std::string &input, std::string key, std::string mode) \r\n```\r\nEncrypt the input string in RC4 format.  // 使用 RC4 格式加密输入字符串。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。"
            },
            {
                "content": "```\r\nSplit the original string by format.  //按照某种格式分割原始字符串。\r\n\r\n参数  \r\norigin_string – Original string to be split.  // 原始字符串。  \r\nsub_strings – Split substring.  // 分割后的子字符串。  \r\nstring_delimiter – Split format.  // 分割格式。\r\n\r\n```cpp\r\nstd::string rc4(std::string &input, std::string key, std::string mode) \r\n```\r\nEncrypt the input string in RC4 format.  // 使用 RC4 格式加密输入字符串。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。  \r\nkey – Encryption key.  // 加密密钥。  \r\nmode – Encryption mode.  // 加密模式。\r\n\r\n返回  \r\nEncrypted string.  // 加密后的字符串。\r\n\r\n```cpp\r\nstd::string encode_base64(const std::string input) \r\n```\r\nEncode the input string in Base64 format.  // 将输入字符串编码为 Base64 格式。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。\r\n\r\n返回  \r\nEncrypted string.  // 编码后的字符串。\r\n\r\n```cpp\r\nstd::string decode_base64(const std::string input) \r\n```\r\nDecode the input string in Base64 format.  // 将输入字符串解码为 Base64 格式。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。\r\n\r\n返回  \r\nDecrypted string.  // 解码后的字符串。\r\n\r\n```cpp\r\nvoid *alloc_buffer(size_t bytes) \r\n```"
            },
            {
                "content": "```cpp\r\nstd::string encode_base64(const std::string input) \r\n```\r\nEncode the input string in Base64 format.  // 将输入字符串编码为 Base64 格式。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。\r\n\r\n返回  \r\nEncrypted string.  // 编码后的字符串。\r\n\r\n```cpp\r\nstd::string decode_base64(const std::string input) \r\n```\r\nDecode the input string in Base64 format.  // 将输入字符串解码为 Base64 格式。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。\r\n\r\n返回  \r\nDecrypted string.  // 解码后的字符串。\r\n\r\n```cpp\r\nvoid *alloc_buffer(size_t bytes) \r\n```\r\nAllocate memory with size in bytes.  // 按字节数分配内存。\r\n\r\n参数  \r\nbytes – Size in bytes of requested memory.  // 请求内存的字节大小。\r\n\r\n返回  \r\nPointer of allocated memory.  // 分配内存的指针。\r\n\r\n```cpp\r\nvoid dealloc_buffer(void *buffer, size_t bytes) \r\n```\r\nFree memory with size in bytes.  // 按字节数释放内存。\r\n\r\n参数  \r\nbuffer – Pointer of memory to free.  // 要释放的内存指针。  \r\nbytes – Size in bytes of requested memory.  // 请求内存的字节大小。\r\n\r\n```cpp\r\ntemplate\r\nvoid parse_from_json(DataType &value, const char *key, json &input) \r\n```"
            },
            {
                "content": "```\r\nAllocate memory with size in bytes.  // 按字节数分配内存。\r\n\r\n参数  \r\nbytes – Size in bytes of requested memory.  // 请求内存的字节大小。\r\n\r\n返回  \r\nPointer of allocated memory.  // 分配内存的指针。\r\n\r\n```cpp\r\nvoid dealloc_buffer(void *buffer, size_t bytes) \r\n```\r\nFree memory with size in bytes.  // 按字节数释放内存。\r\n\r\n参数  \r\nbuffer – Pointer of memory to free.  // 要释放的内存指针。  \r\nbytes – Size in bytes of requested memory.  // 请求内存的字节大小。\r\n\r\n```cpp\r\ntemplate\r\nvoid parse_from_json(DataType &value, const char *key, json &input) \r\n```\r\nParse parameter from `nlohmann::json`.  // 从 `nlohmann::json` 中解析参数。\r\n\r\n参数  \r\nvalue – [out] Value to store parameter.  // [输出] 存储参数的值。  \r\nkey – Key of the parameter in the input.  // 输入中参数的键。  \r\ninput – Input JSON.  // 输入的 JSON。\r\n\r\n```cpp\r\ntemplate\r\nvoid parse_from_json(std::vector &value, const char *key, json &input) \r\n```\r\nParse vector parameter from `nlohmann::json`.  // 从 `nlohmann::json` 中解析向量参数。\r\n\r\n参数  \r\nvalue – [out] Value to store parameter.  // [输出] 存储参数的值。"
            },
            {
                "content": "```\r\nParse parameter from `nlohmann::json`.  // 从 `nlohmann::json` 中解析参数。\r\n\r\n参数  \r\nvalue – [out] Value to store parameter.  // [输出] 存储参数的值。  \r\nkey – Key of the parameter in the input.  // 输入中参数的键。  \r\ninput – Input JSON.  // 输入的 JSON。\r\n\r\n```cpp\r\ntemplate\r\nvoid parse_from_json(std::vector &value, const char *key, json &input) \r\n```\r\nParse vector parameter from `nlohmann::json`.  // 从 `nlohmann::json` 中解析向量参数。\r\n\r\n参数  \r\nvalue – [out] Value to store parameter.  // [输出] 存储参数的值。  \r\nkey – Key of the parameter in the input.  // 输入中参数的键。  \r\ninput – Input JSON.  // 输入的 JSON。\r\n\r\n```cpp\r\nsize_t GetVidFromNodeString(const std::string &node_string) \r\n```\r\nParse vid from the node passed in by Cypher. For V2 procedure.  // 从 Cypher 传入的节点中解析 vid。适用于 V2 过程。\r\n\r\n参数  \r\nnode_string – [in] Node.  // 节点。\r\n\r\n返回  \r\nvid.  // vid。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_vertex_index_iterator\r\n\r\n### Namespace\r\n- `lgraph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIndexIterator\r\n```cpp\r\n#include \r\n```"
            },
            {
                "content": "key – Key of the parameter in the input.  // 输入中参数的键。  \r\ninput – Input JSON.  // 输入的 JSON。\r\n\r\n```cpp\r\nsize_t GetVidFromNodeString(const std::string &node_string) \r\n```\r\nParse vid from the node passed in by Cypher. For V2 procedure.  // 从 Cypher 传入的节点中解析 vid。适用于 V2 过程。\r\n\r\n参数  \r\nnode_string – [in] Node.  // 节点。\r\n\r\n返回  \r\nvid.  // vid。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_vertex_index_iterator\r\n\r\n### Namespace\r\n- `lgraph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIndexIterator\r\n```cpp\r\n#include \r\n```\r\n`VertexIndexIterator` can be used to access a set of vertices that has the same indexed value. If the index is unique (that is, each vertex has a unique index value), then each `VertexIndexIterator` will only have one `VertexId`, and will become invalid after `Next()` is called.\r\n\r\n`VertexIndexIterator` 可以用于访问具有相同索引值的一组顶点。如果索引是唯一的（即每个顶点有一个唯一的索引值），那么每个 `VertexIndexIterator` 只会有一个 `VertexId`，并且在调用 `Next()` 后会变得无效。"
            },
            {
                "content": "- `lgraph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIndexIterator\r\n```cpp\r\n#include \r\n```\r\n`VertexIndexIterator` can be used to access a set of vertices that has the same indexed value. If the index is unique (that is, each vertex has a unique index value), then each `VertexIndexIterator` will only have one `VertexId`, and will become invalid after `Next()` is called.\r\n\r\n`VertexIndexIterator` 可以用于访问具有相同索引值的一组顶点。如果索引是唯一的（即每个顶点有一个唯一的索引值），那么每个 `VertexIndexIterator` 只会有一个 `VertexId`，并且在调用 `Next()` 后会变得无效。\r\n\r\nA `VertexIndexIterator` is valid iff it points to a valid `(index_value, vid)` pair; otherwise, it is invalid. Calling member functions on an invalid `VertexIndexIterator` throws an exception, except for the `IsValid()` function.\r\n\r\n`VertexIndexIterator` 是有效的当且仅当它指向一个有效的 `(index_value, vid)` 对；否则，它是无效的。在无效的 `VertexIndexIterator` 上调用成员函数会抛出异常，除了 `IsValid()` 函数。\r\n\r\n#### Public Functions\r\n```cpp\r\nVertexIndexIterator(VertexIndexIterator &&rhs)\r\n```\r\n构造函数，移动构造 `VertexIndexIterator`。\r\n\r\n```cpp"
            },
            {
                "content": "A `VertexIndexIterator` is valid iff it points to a valid `(index_value, vid)` pair; otherwise, it is invalid. Calling member functions on an invalid `VertexIndexIterator` throws an exception, except for the `IsValid()` function.\r\n\r\n`VertexIndexIterator` 是有效的当且仅当它指向一个有效的 `(index_value, vid)` 对；否则，它是无效的。在无效的 `VertexIndexIterator` 上调用成员函数会抛出异常，除了 `IsValid()` 函数。\r\n\r\n#### Public Functions\r\n```cpp\r\nVertexIndexIterator(VertexIndexIterator &&rhs)\r\n```\r\n构造函数，移动构造 `VertexIndexIterator`。\r\n\r\n```cpp\r\nVertexIndexIterator &operator=(VertexIndexIterator&&)\r\n```\r\n移动赋值运算符。\r\n\r\n```cpp\r\n~VertexIndexIterator()\r\n```\r\n析构函数。\r\n\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this iterator.\r\n\r\n关闭此迭代器。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid, i.e., the Key and Vid can be queried.\r\n\r\n查询此迭代器是否有效，即 Key 和 Vid 是否可以被查询。\r\n\r\n返回  \r\nTrue if valid, false if not.\r\n\r\n返回  \r\n如果有效则返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```"
            },
            {
                "content": "```\r\n构造函数，移动构造 `VertexIndexIterator`。\r\n\r\n```cpp\r\nVertexIndexIterator &operator=(VertexIndexIterator&&)\r\n```\r\n移动赋值运算符。\r\n\r\n```cpp\r\n~VertexIndexIterator()\r\n```\r\n析构函数。\r\n\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this iterator.\r\n\r\n关闭此迭代器。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid, i.e., the Key and Vid can be queried.\r\n\r\n查询此迭代器是否有效，即 Key 和 Vid 是否可以被查询。\r\n\r\n返回  \r\nTrue if valid, false if not.\r\n\r\n返回  \r\n如果有效则返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next vertex id in the list, which consists of all the valid vertex ids of the iterator and is sorted from small to large. If we hit the end of the list, the iterator will become invalid and false is returned.\r\n\r\n移动到列表中的下一个顶点 id，该列表由迭代器的所有有效顶点 id 组成，并按从小到大排序。如果到达列表末尾，则迭代器将变得无效，返回 false。\r\n\r\n返回  \r\nTrue if it succeeds, otherwise false.\r\n\r\n返回  \r\n如果成功则返回 true，否则返回 false。\r\n\r\n```cpp\r\nFieldData GetIndexValue() const\r\n```"
            },
            {
                "content": "返回  \r\n如果有效则返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next vertex id in the list, which consists of all the valid vertex ids of the iterator and is sorted from small to large. If we hit the end of the list, the iterator will become invalid and false is returned.\r\n\r\n移动到列表中的下一个顶点 id，该列表由迭代器的所有有效顶点 id 组成，并按从小到大排序。如果到达列表末尾，则迭代器将变得无效，返回 false。\r\n\r\n返回  \r\nTrue if it succeeds, otherwise false.\r\n\r\n返回  \r\n如果成功则返回 true，否则返回 false。\r\n\r\n```cpp\r\nFieldData GetIndexValue() const\r\n```\r\nGets the current index value. The vids are sorted in `(IndexValue, Vid)` order. When `Next()` is called, the iterator moves from one vid to next, possibly moving from one IndexValue to another. This function tells the IndexValue currently pointed to.\r\n\r\n获取当前的索引值。vids 按 `(IndexValue, Vid)` 顺序排序。当调用 `Next()` 时，迭代器从一个 vid 移动到下一个，可能会从一个 IndexValue 移动到另一个。此函数返回当前指向的 IndexValue。\r\n\r\n返回  \r\nThe key.\r\n\r\n返回  \r\n键（key）。\r\n\r\n```cpp\r\nint64_t GetVid() const\r\n```\r\nGets the current vertex id.\r\n\r\n获取当前顶点 id。\r\n\r\n返回  \r\nThe current vertex id."
            },
            {
                "content": "获取当前的索引值。vids 按 `(IndexValue, Vid)` 顺序排序。当调用 `Next()` 时，迭代器从一个 vid 移动到下一个，可能会从一个 IndexValue 移动到另一个。此函数返回当前指向的 IndexValue。\r\n\r\n返回  \r\nThe key.\r\n\r\n返回  \r\n键（key）。\r\n\r\n```cpp\r\nint64_t GetVid() const\r\n```\r\nGets the current vertex id.\r\n\r\n获取当前顶点 id。\r\n\r\n返回  \r\nThe current vertex id.\r\n\r\n返回  \r\n当前顶点 id。\r\n\r\n#### Private Functions\r\n```cpp\r\nVertexIndexIterator(lgraph::VertexIndexIterator &⁢, const std::shared_ptr &txn)\r\n```\r\n\r\n```cpp\r\nVertexIndexIterator(const VertexIndexIterator&) = delete\r\n```\r\n拷贝构造函数被删除，禁止使用拷贝构造。\r\n\r\n```cpp\r\nVertexIndexIterator &operator=(const VertexIndexIterator&) = delete\r\n```\r\n拷贝赋值运算符被删除，禁止使用拷贝赋值。\r\n\r\n#### Private Members\r\n- `std::unique_ptr it_`\r\n- `std::shared_ptr txn_`\r\n\r\n#### Friends\r\n- `friend class Transaction`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_vertex_iterator\r\n\r\n### Namespace\r\n- `lgraph`\r\n- `graph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIterator\r\n```cpp\r\n#include \r\n```\r\n`VertexIterator` can be used to iterate through vertices in the DB. Vertices are sorted according to vertex id in the DB."
            },
            {
                "content": "VertexIndexIterator &operator=(const VertexIndexIterator&) = delete\r\n```\r\n拷贝赋值运算符被删除，禁止使用拷贝赋值。\r\n\r\n#### Private Members\r\n- `std::unique_ptr it_`\r\n- `std::shared_ptr txn_`\r\n\r\n#### Friends\r\n- `friend class Transaction`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_vertex_iterator\r\n\r\n### Namespace\r\n- `lgraph`\r\n- `graph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIterator\r\n```cpp\r\n#include \r\n```\r\n`VertexIterator` can be used to iterate through vertices in the DB. Vertices are sorted according to vertex id in the DB.  \r\n`VertexIterator`可以用来遍历数据库中的顶点。顶点根据数据库中的顶点ID进行排序。\r\n\r\nA `VertexIterator` is valid iff it points to a valid vertex. Calling method functions on an invalid `VertexIterator` throws an `InvalidIterator`, except for the `IsValid()` and `Goto()` functions.  \r\n当`VertexIterator`指向一个有效顶点时，才被认为是有效的。对无效的`VertexIterator`调用方法函数将抛出`InvalidIterator`，但`IsValid()`和`Goto()`函数除外。\r\n\r\nThe following operations invalidate a `VertexIterator`:  \r\n以下操作将使`VertexIterator`无效：\r\n- Constructing a `VertexIterator` for a non-existing vertex."
            },
            {
                "content": "A `VertexIterator` is valid iff it points to a valid vertex. Calling method functions on an invalid `VertexIterator` throws an `InvalidIterator`, except for the `IsValid()` and `Goto()` functions.  \r\n当`VertexIterator`指向一个有效顶点时，才被认为是有效的。对无效的`VertexIterator`调用方法函数将抛出`InvalidIterator`，但`IsValid()`和`Goto()`函数除外。\r\n\r\nThe following operations invalidate a `VertexIterator`:  \r\n以下操作将使`VertexIterator`无效：\r\n- Constructing a `VertexIterator` for a non-existing vertex.  \r\n  为不存在的顶点构造`VertexIterator`。\r\n- Calling `Goto()` with the id of a non-existing vertex.  \r\n  使用不存在的顶点ID调用`Goto()`。\r\n- Calling `Next()` on the last vertex.  \r\n  在最后一个顶点上调用`Next()`。\r\n- Calling `Delete()` on the last vertex.  \r\n  在最后一个顶点上调用`Delete()`。\r\n\r\n#### Public Functions\r\n```cpp\r\nVertexIterator(VertexIterator &&rhs)\r\n```\r\n```cpp\r\nVertexIterator &operator=(VertexIterator &&rhs)\r\n```\r\n```cpp\r\n~VertexIterator()\r\n```\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this iterator.  \r\n关闭此迭代器。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next vertex.  \r\n移动到下一个顶点。\r\n\r\n抛出"
            },
            {
                "content": "使用不存在的顶点ID调用`Goto()`。\r\n- Calling `Next()` on the last vertex.  \r\n  在最后一个顶点上调用`Next()`。\r\n- Calling `Delete()` on the last vertex.  \r\n  在最后一个顶点上调用`Delete()`。\r\n\r\n#### Public Functions\r\n```cpp\r\nVertexIterator(VertexIterator &&rhs)\r\n```\r\n```cpp\r\nVertexIterator &operator=(VertexIterator &&rhs)\r\n```\r\n```cpp\r\n~VertexIterator()\r\n```\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this iterator.  \r\n关闭此迭代器。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next vertex.  \r\n移动到下一个顶点。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nTrue if it succeeds, otherwise return false (no more vertex) and invalidate the iterator.  \r\n如果成功则返回True，否则返回false（没有更多顶点）并使迭代器无效。\r\n\r\n```cpp\r\nbool Goto(int64_t vid, bool nearest = false)\r\n```\r\nGoto the vertex with id `src`. If there is no vertex with exactly the same vid, and `nearest==true`, go to the next vertex with id >= vid; otherwise, return false and invalidate the iterator."
            },
            {
                "content": "`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nTrue if it succeeds, otherwise return false (no more vertex) and invalidate the iterator.  \r\n如果成功则返回True，否则返回false（没有更多顶点）并使迭代器无效。\r\n\r\n```cpp\r\nbool Goto(int64_t vid, bool nearest = false)\r\n```\r\nGoto the vertex with id `src`. If there is no vertex with exactly the same vid, and `nearest==true`, go to the next vertex with id >= vid; otherwise, return false and invalidate the iterator.  \r\n跳转到ID为`src`的顶点。如果没有与给定vid完全相同的顶点，并且`nearest==true`，则跳转到ID >= vid的下一个顶点；否则返回false并使迭代器无效。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出\r\n\r\n参数  \r\n`vid` – Vertex id of the vertex to go.  // 要跳转的顶点ID  \r\n`nearest` – (Optional) True to go to the closest vertex with id >= vid.  // （可选）如果设置为True，跳转到ID >= vid的最近顶点\r\n\r\n返回  \r\nTrue if it succeeds, otherwise false (no such vertex).  \r\n如果成功则返回True，否则返回false（没有这样的顶点）。\r\n\r\n```cpp\r\nint64_t GetId() const\r\n```\r\nGets the vertex id.  \r\n获取顶点ID。\r\n\r\n抛出"
            },
            {
                "content": "抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出\r\n\r\n参数  \r\n`vid` – Vertex id of the vertex to go.  // 要跳转的顶点ID  \r\n`nearest` – (Optional) True to go to the closest vertex with id >= vid.  // （可选）如果设置为True，跳转到ID >= vid的最近顶点\r\n\r\n返回  \r\nTrue if it succeeds, otherwise false (no such vertex).  \r\n如果成功则返回True，否则返回false（没有这样的顶点）。\r\n\r\n```cpp\r\nint64_t GetId() const\r\n```\r\nGets the vertex id.  \r\n获取顶点ID。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe id.  \r\n返回ID。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator() const\r\n```\r\nGets an `OutEdgeIterator` pointing to the first out-going edge.  \r\n获取指向第一个出边的`OutEdgeIterator`。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe `OutEdgeIterator`.  \r\n返回`OutEdgeIterator`。\r\n\r\n```cpp"
            },
            {
                "content": "`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe id.  \r\n返回ID。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator() const\r\n```\r\nGets an `OutEdgeIterator` pointing to the first out-going edge.  \r\n获取指向第一个出边的`OutEdgeIterator`。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe `OutEdgeIterator`.  \r\n返回`OutEdgeIterator`。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const EdgeUid &euid, bool nearest = false) const\r\n```\r\nReturns an `OutEdgeIterator` pointing to the edge specified by `euid`. If there is no such edge, and `nearest==false`, an invalid iterator is returned. If the specified out-edge does not exist, and `nearest==true`, get the first out-edge that sorts after the specified one.  \r\n返回指向由`euid`指定的边的`OutEdgeIterator`。如果没有这样的边，并且`nearest==false`，则返回无效迭代器。如果指定的出边不存在并且`nearest==true`，则获取排序在指定边之后的第一个出边。\r\n\r\n抛出"
            },
            {
                "content": "```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const EdgeUid &euid, bool nearest = false) const\r\n```\r\nReturns an `OutEdgeIterator` pointing to the edge specified by `euid`. If there is no such edge, and `nearest==false`, an invalid iterator is returned. If the specified out-edge does not exist, and `nearest==true`, get the first out-edge that sorts after the specified one.  \r\n返回指向由`euid`指定的边的`OutEdgeIterator`。如果没有这样的边，并且`nearest==false`，则返回无效迭代器。如果指定的出边不存在并且`nearest==true`，则获取排序在指定边之后的第一个出边。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n参数  \r\n`euid` – The Edge Unique Id.  // 边的唯一ID  \r\n`nearest` – (Optional) If set to true and the specified edge does not exist, get the edge that sorts right after it.  // （可选）如果设置为true且指定边不存在，则获取排序在其后面的边。\r\n\r\n返回  \r\nThe out edge iterator.  \r\n出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator() const\r\n```"
            },
            {
                "content": "抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n参数  \r\n`euid` – The Edge Unique Id.  // 边的唯一ID  \r\n`nearest` – (Optional) If set to true and the specified edge does not exist, get the edge that sorts right after it.  // （可选）如果设置为true且指定边不存在，则获取排序在其后面的边。\r\n\r\n返回  \r\nThe out edge iterator.  \r\n出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator() const\r\n```\r\nGets an `InEdgeIterator` pointing to the first in-coming edge.  \r\n获取指向第一个入边的`InEdgeIterator`。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe `InEdgeIterator`.  \r\n返回`InEdgeIterator`。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const EdgeUid &euid, bool nearest = false) const\r\n```"
            },
            {
                "content": "The out edge iterator.  \r\n出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator() const\r\n```\r\nGets an `InEdgeIterator` pointing to the first in-coming edge.  \r\n获取指向第一个入边的`InEdgeIterator`。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe `InEdgeIterator`.  \r\n返回`InEdgeIterator`。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const EdgeUid &euid, bool nearest = false) const\r\n```\r\nReturns an `InEdgeIterator` pointing to the edge specified by `euid`. If there is no such edge and `nearest==false`, an invalid iterator is returned. If the specified edge does not exist and `nearest==true`, get the edge that sorts right after it.  \r\n返回指向由`euid`指定的边的`InEdgeIterator`。如果没有这样的边并且`nearest==false`，则返回无效迭代器。如果指定的边不存在并且`nearest==true`，则获取排序在其后面的边。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出"
            },
            {
                "content": "```\r\nReturns an `InEdgeIterator` pointing to the edge specified by `euid`. If there is no such edge and `nearest==false`, an invalid iterator is returned. If the specified edge does not exist and `nearest==true`, get the edge that sorts right after it.  \r\n返回指向由`euid`指定的边的`InEdgeIterator`。如果没有这样的边并且`nearest==false`，则返回无效迭代器。如果指定的边不存在并且`nearest==true`，则获取排序在其后面的边。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n参数  \r\n`euid` – The Edge Unique Id.  // 边的唯一ID  \r\n`nearest` – (Optional) If set to true and the specified edge does not exist, get the edge that sorts right after it.  // （可选）如果设置为true且指定边不存在，则获取排序在其后面的边。\r\n\r\n返回  \r\nThe `InEdgeIterator`.  \r\n返回`InEdgeIterator`。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid.  \r\n查询此迭代器是否有效。\r\n\r\n返回  \r\nTrue if valid, false if not.  \r\n如果有效，则返回True；否则返回false。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```"
            },
            {
                "content": "参数  \r\n`euid` – The Edge Unique Id.  // 边的唯一ID  \r\n`nearest` – (Optional) If set to true and the specified edge does not exist, get the edge that sorts right after it.  // （可选）如果设置为true且指定边不存在，则获取排序在其后面的边。\r\n\r\n返回  \r\nThe `InEdgeIterator`.  \r\n返回`InEdgeIterator`。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid.  \r\n查询此迭代器是否有效。\r\n\r\n返回  \r\nTrue if valid, false if not.  \r\n如果有效，则返回True；否则返回false。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this vertex.  \r\n获取此顶点的标签。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe label.  \r\n标签。\r\n\r\n```cpp\r\nsize_t GetLabelId() const\r\n```\r\nGets label id of this vertex.  \r\n获取此顶点的标签ID。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe label identifier.  \r\n标签标识符。\r\n\r\n```cpp"
            },
            {
                "content": "抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe label.  \r\n标签。\r\n\r\n```cpp\r\nsize_t GetLabelId() const\r\n```\r\nGets label id of this vertex.  \r\n获取此顶点的标签ID。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe label identifier.  \r\n标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  // 字段名称列表\r\n\r\n返回  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp"
            },
            {
                "content": "标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  // 字段名称列表\r\n\r\n返回  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_name` – Field name.  // 字段名称\r\n\r\n返回  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```"
            },
            {
                "content": "```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_name` – Field name.  // 字段名称\r\n\r\n返回  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_ids` – List of ids for the fields.  // 字段ID列表\r\n\r\n返回  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n抛出"
            },
            {
                "content": "```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_ids` – List of ids for the fields.  // 字段ID列表\r\n\r\n返回  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_id` – Field ID.  // 字段ID\r\n\r\n返回  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by `field_name`.  \r\n通过 `field_name` 获取指定的字段。\r\n\r\n抛出"
            },
            {
                "content": "获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_id` – Field ID.  // 字段ID\r\n\r\n返回  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by `field_name`.  \r\n通过 `field_name` 获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_name` – Filename of the file.  \r\n字段的名称。\r\n\r\n返回  \r\nThe indexed value.  \r\n索引值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id.  \r\n通过字段 ID 获取指定的字段。\r\n\r\n抛出"
            },
            {
                "content": "通过 `field_name` 获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_name` – Filename of the file.  \r\n字段的名称。\r\n\r\n返回  \r\nThe indexed value.  \r\n索引值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id.  \r\n通过字段 ID 获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`fid` – The field id.  \r\n字段 ID。\r\n\r\n返回  \r\nThe indexed value.  \r\n索引值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of the current vertex.  \r\n获取当前顶点的所有字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction."
            },
            {
                "content": "当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`fid` – The field id.  \r\n字段 ID。\r\n\r\n返回  \r\nThe indexed value.  \r\n索引值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of the current vertex.  \r\n获取当前顶点的所有字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n返回  \r\nAll fields.  \r\n所有字段。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。"
            },
            {
                "content": "`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n返回  \r\nAll fields.  \r\n所有字段。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_name` – Field name.  \r\n字段名。  \r\n`field_value` – Field value.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。"
            },
            {
                "content": "在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_name` – Field name.  \r\n字段名。  \r\n`field_value` – Field value.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_id` – Field id.  \r\n字段 ID。  \r\n`field_value` – Field value.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。"
            },
            {
                "content": "`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_id` – Field id.  \r\n字段 ID。  \r\n`field_value` – Field value.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  \r\n字段名称列表。  \r\n`field_value_strings` – The field value strings.  \r\n字段值字符串。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。"
            },
            {
                "content": "当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  \r\n字段名称列表。  \r\n`field_value_strings` – The field value strings.  \r\n字段值字符串。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  \r\n字段名称列表。  \r\n`field_values` – The field values.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```"
            },
            {
                "content": "当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  \r\n字段名称列表。  \r\n`field_values` – The field values.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_ids` – List of identifiers for the fields.  \r\n字段的标识符列表。  \r\n`field_values` – The field values.  \r\n字段值。\r\n\r\n```cpp"
            },
            {
                "content": "设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_ids` – List of identifiers for the fields.  \r\n字段的标识符列表。  \r\n`field_values` – The field values.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector ListSrcVids(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nList source vids. Each source vid is stored only once in the result.  \r\n列出源 vid。每个源 vid 在结果中只存储一次。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of vids to return.  \r\n（可选）返回的 vid 数量限制。"
            },
            {
                "content": "字段值。\r\n\r\n```cpp\r\nstd::vector ListSrcVids(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nList source vids. Each source vid is stored only once in the result.  \r\n列出源 vid。每个源 vid 在结果中只存储一次。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of vids to return.  \r\n（可选）返回的 vid 数量限制。  \r\n`more_to_go` – [out] (Optional) If non-null, returns whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nList of source vids.  \r\n源 vid 列表。\r\n\r\n```cpp\r\nstd::vector ListDstVids(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nList destination vids. Each vid is stored only once in the result.  \r\n列出目标 vid。每个 vid 在结果中只存储一次。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid."
            },
            {
                "content": "[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nList of source vids.  \r\n源 vid 列表。\r\n\r\n```cpp\r\nstd::vector ListDstVids(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nList destination vids. Each vid is stored only once in the result.  \r\n列出目标 vid。每个 vid 在结果中只存储一次。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit of the number of vids to return.  \r\n（可选）返回的 vid 数量限制。  \r\n`more_to_go` – [out] (Optional) If non-null, returns whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nList of destination vids.  \r\n目标 vid 列表。\r\n\r\n```cpp\r\nsize_t GetNumInEdges(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nGets number of incoming edges, stopping on limit. This function can come in handy if we need to filter on large vertexes.  \r\n获取传入边的数量，在限制时停止。如果我们需要对大型顶点进行过滤，这个函数可能会很有用。\r\n\r\n抛出"
            },
            {
                "content": "（可选）返回的 vid 数量限制。  \r\n`more_to_go` – [out] (Optional) If non-null, returns whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nList of destination vids.  \r\n目标 vid 列表。\r\n\r\n```cpp\r\nsize_t GetNumInEdges(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nGets number of incoming edges, stopping on limit. This function can come in handy if we need to filter on large vertexes.  \r\n获取传入边的数量，在限制时停止。如果我们需要对大型顶点进行过滤，这个函数可能会很有用。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of in-coming edges to count. When the limit is reached, `n_limit` is returned.  \r\n（可选）要计算的传入边的数量限制。当达到限制时，返回 `n_limit`。  \r\n`more_to_go` – [out] (Optional) If non-null, return whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nNumber of incoming edges.  \r\n传入边的数量。\r\n\r\n```cpp"
            },
            {
                "content": "`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of in-coming edges to count. When the limit is reached, `n_limit` is returned.  \r\n（可选）要计算的传入边的数量限制。当达到限制时，返回 `n_limit`。  \r\n`more_to_go` – [out] (Optional) If non-null, return whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nNumber of incoming edges.  \r\n传入边的数量。\r\n\r\n```cpp\r\nsize_t GetNumOutEdges(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nGets number of out-going edges, stopping on limit. This function can come in handy if we need to filter on large vertexes.  \r\n获取传出边的数量，在限制时停止。如果我们需要对大型顶点进行过滤，这个函数可能会很有用。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数"
            },
            {
                "content": "返回  \r\nNumber of incoming edges.  \r\n传入边的数量。\r\n\r\n```cpp\r\nsize_t GetNumOutEdges(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nGets number of out-going edges, stopping on limit. This function can come in handy if we need to filter on large vertexes.  \r\n获取传出边的数量，在限制时停止。如果我们需要对大型顶点进行过滤，这个函数可能会很有用。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of out-going edges to count. When the limit is reached, `n_limit` is returned and `limit_exceeded` is set to true.  \r\n（可选）要计算的传出边的数量限制。当达到限制时，返回 `n_limit`，并将 `limit_exceeded` 设置为 true。  \r\n`more_to_go` – [out] (Optional) If non-null, return whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nNumber of out-going edges.  \r\n传出边的数量。\r\n\r\n```cpp\r\nvoid Delete(size_t *n_in_edges = nullptr, size_t *n_out_edges = nullptr)\r\n```"
            },
            {
                "content": "当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of out-going edges to count. When the limit is reached, `n_limit` is returned and `limit_exceeded` is set to true.  \r\n（可选）要计算的传出边的数量限制。当达到限制时，返回 `n_limit`，并将 `limit_exceeded` 设置为 true。  \r\n`more_to_go` – [out] (Optional) If non-null, return whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nNumber of out-going edges.  \r\n传出边的数量。\r\n\r\n```cpp\r\nvoid Delete(size_t *n_in_edges = nullptr, size_t *n_out_edges = nullptr)\r\n```\r\nDeletes this vertex, also deletes all incoming and outgoing edges of this vertex. The iterator will point to the next vertex by vid if there is any.  \r\n删除该顶点，同时删除该顶点的所有传入和传出边。如果有下一个顶点，迭代器将指向其 vid。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。\r\n\r\n参数"
            },
            {
                "content": "```\r\nDeletes this vertex, also deletes all incoming and outgoing edges of this vertex. The iterator will point to the next vertex by vid if there is any.  \r\n删除该顶点，同时删除该顶点的所有传入和传出边。如果有下一个顶点，迭代器将指向其 vid。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。\r\n\r\n参数  \r\n`n_in_edges` – [out] (Optional) If non-null, the number of in edges the vertex had.  \r\n[输出]（可选）如果不为 null，该顶点的传入边数量。  \r\n`n_out_edges` – [out] (Optional) If non-null, the number of out edges the vertex had.  \r\n[输出]（可选）如果不为 null，该顶点的传出边数量。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet the string representation of this vertex.  \r\n获取该顶点的字符串表示。\r\n\r\n#### Private Functions\r\n```cpp\r\nVertexIterator(lgraph::graph::VertexIterator&&, const std::shared_ptr&)\r\n```\r\n\r\n```cpp\r\nVertexIterator(const VertexIterator&) = delete\r\n```\r\n\r\n```cpp"
            },
            {
                "content": "[输出]（可选）如果不为 null，该顶点的传入边数量。  \r\n`n_out_edges` – [out] (Optional) If non-null, the number of out edges the vertex had.  \r\n[输出]（可选）如果不为 null，该顶点的传出边数量。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet the string representation of this vertex.  \r\n获取该顶点的字符串表示。\r\n\r\n#### Private Functions\r\n```cpp\r\nVertexIterator(lgraph::graph::VertexIterator&&, const std::shared_ptr&)\r\n```\r\n\r\n```cpp\r\nVertexIterator(const VertexIterator&) = delete\r\n```\r\n\r\n```cpp\r\nVertexIterator &operator=(const VertexIterator&) = delete\r\n```\r\n\r\n#### Private Members\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\n\r\n#### Friends\r\nfriend class Transaction\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_base\r\n\r\n这是TuGraph图分析引擎的实现。图分析引擎是一个通用的处理引擎，适用于实现各种图分析算法，例如PageRank、ShortestPath等。\r\n\r\n### Defines\r\n- **THREAD_WORKING**  \r\n  - 线程工作模式。\r\n  \r\n- **THREAD_STEALING**  \r\n  - 线程窃取模式。\r\n\r\n- **VERTEX_BATCH_SIZE**  \r\n  - 顶点批处理大小。\r\n\r\n- **WORD_OFFSET(i)**  \r\n  - 字的偏移量宏定义。\r\n\r\n- **BIT_OFFSET(i)**  \r\n  - 位的偏移量宏定义。\r\n\r\n### Functions"
            },
            {
                "content": "```\r\n\r\n#### Private Members\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\n\r\n#### Friends\r\nfriend class Transaction\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_base\r\n\r\n这是TuGraph图分析引擎的实现。图分析引擎是一个通用的处理引擎，适用于实现各种图分析算法，例如PageRank、ShortestPath等。\r\n\r\n### Defines\r\n- **THREAD_WORKING**  \r\n  - 线程工作模式。\r\n  \r\n- **THREAD_STEALING**  \r\n  - 线程窃取模式。\r\n\r\n- **VERTEX_BATCH_SIZE**  \r\n  - 顶点批处理大小。\r\n\r\n- **WORD_OFFSET(i)**  \r\n  - 字的偏移量宏定义。\r\n\r\n- **BIT_OFFSET(i)**  \r\n  - 位的偏移量宏定义。\r\n\r\n### Functions\r\n- union @5 `__attribute__ ((packed))`  \r\n  - 定义一个打包的联合体。\r\n\r\n### Variables\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- `size_t src`  \r\n  - 边的源顶点标识符。\r\n\r\n- `size_t dst`  \r\n  - 边的目的顶点标识符。\r\n\r\n### Namespaces\r\n- `namespace lgraph_api`  \r\n  - 图形API的命名空间。\r\n\r\n- `namespace olap`  \r\n  - OLAP的命名空间。\r\n\r\n#### Enums\r\n- **enum EdgeDirectionPolicy**  \r\n  定义图的边方向策略。该策略确定图的对称性和无向特性。\r\n\r\n  **Values:**\r\n  - **enumerator DUAL_DIRECTION**  \r\n    图是非对称的。输入文件中的边是出边。反向边形成入边。"
            },
            {
                "content": "### Functions\r\n- union @5 `__attribute__ ((packed))`  \r\n  - 定义一个打包的联合体。\r\n\r\n### Variables\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- `size_t src`  \r\n  - 边的源顶点标识符。\r\n\r\n- `size_t dst`  \r\n  - 边的目的顶点标识符。\r\n\r\n### Namespaces\r\n- `namespace lgraph_api`  \r\n  - 图形API的命名空间。\r\n\r\n- `namespace olap`  \r\n  - OLAP的命名空间。\r\n\r\n#### Enums\r\n- **enum EdgeDirectionPolicy**  \r\n  定义图的边方向策略。该策略确定图的对称性和无向特性。\r\n\r\n  **Values:**\r\n  - **enumerator DUAL_DIRECTION**  \r\n    图是非对称的。输入文件中的边是出边。反向边形成入边。\r\n  \r\n  - **enumerator MAKE_SYMMETRIC**  \r\n    图是对称的，但输入文件是非对称的。出边和入边是相同的。\r\n  \r\n  - **enumerator INPUT_SYMMETRIC**  \r\n    图和输入文件都是对称的。出边和入边是相同的。\r\n\r\n#### Functions\r\n- **template struct lgraph_api::olap::AdjUnit `__attribute__ ((packed))`**  \r\n  - 定义相邻边的结构，使用EdgeData作为权重类型。\r\n\r\n- **template<> struct lgraph_api::olap::AdjUnit< Empty > `__attribute__ ((packed))`**  \r\n  - 对于无权图的特化AdjUnit结构定义。\r\n\r\n- **template static ReducedSum reduce_plus(ReducedSum a, ReducedSum b)**  \r\n  默认的归约函数，使用加法运算符。"
            },
            {
                "content": "- **enumerator MAKE_SYMMETRIC**  \r\n    图是对称的，但输入文件是非对称的。出边和入边是相同的。\r\n  \r\n  - **enumerator INPUT_SYMMETRIC**  \r\n    图和输入文件都是对称的。出边和入边是相同的。\r\n\r\n#### Functions\r\n- **template struct lgraph_api::olap::AdjUnit `__attribute__ ((packed))`**  \r\n  - 定义相邻边的结构，使用EdgeData作为权重类型。\r\n\r\n- **template<> struct lgraph_api::olap::AdjUnit< Empty > `__attribute__ ((packed))`**  \r\n  - 对于无权图的特化AdjUnit结构定义。\r\n\r\n- **template static ReducedSum reduce_plus(ReducedSum a, ReducedSum b)**  \r\n  默认的归约函数，使用加法运算符。\r\n\r\n- **template T ForEachVertex(GraphDB &db, Transaction &txn, std::vector &workers, const std::vector &vertices, std::function work, std::function reduce, size_t parallel_factor = 8)**  \r\n  遍历每个顶点并执行指定的工作。\r\n\r\n- **template std::vector ForEachVertex(GraphDB &db, Transaction &txn, std::vector &workers, const std::vector &vertices, std::function work, size_t parallel_factor = 8)**  \r\n  遍历每个顶点并生成结果向量。\r\n\r\n#### Variables\r\n- **struct lgraph_api::olap::EdgeStringUnit `__attribute__`**  \r\n  - 表示一个带有字符串类型顶点的边的结构。"
            },
            {
                "content": "- **template T ForEachVertex(GraphDB &db, Transaction &txn, std::vector &workers, const std::vector &vertices, std::function work, std::function reduce, size_t parallel_factor = 8)**  \r\n  遍历每个顶点并执行指定的工作。\r\n\r\n- **template std::vector ForEachVertex(GraphDB &db, Transaction &txn, std::vector &workers, const std::vector &vertices, std::function work, size_t parallel_factor = 8)**  \r\n  遍历每个顶点并生成结果向量。\r\n\r\n#### Variables\r\n- **struct lgraph_api::olap::EdgeStringUnit `__attribute__`**  \r\n  - 表示一个带有字符串类型顶点的边的结构。\r\n\r\n- **static constexpr size_t MAX_NUM_EDGES = 1ul << 36**  \r\n  最大边数。如果需要，可以更改此值。\r\n\r\n- **template class AdjList**  \r\n  ```cpp\r\n  #include \r\n  ```\r\n  - 表示一个邻接列表的类。\r\n\r\n##### Public Functions\r\n- **inline AdjList()**  \r\n  - 默认构造函数。\r\n\r\n- **inline AdjUnit *begin()**  \r\n  - 获取邻接列表的开始迭代器。\r\n\r\n- **inline AdjUnit *end()**  \r\n  - 获取邻接列表的结束迭代器。\r\n\r\n- **inline AdjUnit &operator[](size_t i)**  \r\n  - 通过索引获取邻接单位。\r\n\r\n##### Private Functions\r\n- **inline AdjList(AdjUnit *begin, AdjUnit *end)**  \r\n  - 私有构造函数，用于初始化邻接列表。"
            },
            {
                "content": "- **static constexpr size_t MAX_NUM_EDGES = 1ul << 36**  \r\n  最大边数。如果需要，可以更改此值。\r\n\r\n- **template class AdjList**  \r\n  ```cpp\r\n  #include \r\n  ```\r\n  - 表示一个邻接列表的类。\r\n\r\n##### Public Functions\r\n- **inline AdjList()**  \r\n  - 默认构造函数。\r\n\r\n- **inline AdjUnit *begin()**  \r\n  - 获取邻接列表的开始迭代器。\r\n\r\n- **inline AdjUnit *end()**  \r\n  - 获取邻接列表的结束迭代器。\r\n\r\n- **inline AdjUnit &operator[](size_t i)**  \r\n  - 通过索引获取邻接单位。\r\n\r\n##### Private Functions\r\n- **inline AdjList(AdjUnit *begin, AdjUnit *end)**  \r\n  - 私有构造函数，用于初始化邻接列表。\r\n\r\n##### Private Members\r\n- `AdjUnit *begin_`  \r\n  - 邻接列表的开始指针。\r\n\r\n- `AdjUnit *end_`  \r\n  - 邻接列表的结束指针。\r\n\r\n##### Friends\r\n- **friend class OlapBase< EdgeData >**  \r\n  - 允许OlapBase作为朋友类访问内部成员。\r\n\r\n- **template struct AdjUnit**  \r\n```cpp\r\n#include \r\n```\r\nAdjUnit表示一个带有EdgeData作为权重类型的相邻边。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template<> struct AdjUnit**  \r\n```cpp\r\n#include \r\n```\r\n#### Public Functions"
            },
            {
                "content": "##### Private Members\r\n- `AdjUnit *begin_`  \r\n  - 邻接列表的开始指针。\r\n\r\n- `AdjUnit *end_`  \r\n  - 邻接列表的结束指针。\r\n\r\n##### Friends\r\n- **friend class OlapBase< EdgeData >**  \r\n  - 允许OlapBase作为朋友类访问内部成员。\r\n\r\n- **template struct AdjUnit**  \r\n```cpp\r\n#include \r\n```\r\nAdjUnit表示一个带有EdgeData作为权重类型的相邻边。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template<> struct AdjUnit**  \r\n```cpp\r\n#include \r\n```\r\n#### Public Functions\r\n- **template<> union lgraph_api::olap::AdjUnit< Empty >::@4 `__attribute__ ((packed))`**  \r\n  - 对无权连接单位的定义。\r\n\r\n#### Public Members\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `Empty edge_data`  \r\n  - 无权边数据。\r\n\r\n- **template struct EdgeStringUnit**  \r\n```cpp\r\n#include \r\n```\r\nEdgeStringUnit表示一个带有EdgeData作为权重类型的边，顶点为字符串类型。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `std::string src`  \r\n  - 源顶点的字符串形式。\r\n\r\n- `std::string dst`  \r\n  - 目标顶点的字符串形式。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。"
            },
            {
                "content": "- **template<> union lgraph_api::olap::AdjUnit< Empty >::@4 `__attribute__ ((packed))`**  \r\n  - 对无权连接单位的定义。\r\n\r\n#### Public Members\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `Empty edge_data`  \r\n  - 无权边数据。\r\n\r\n- **template struct EdgeStringUnit**  \r\n```cpp\r\n#include \r\n```\r\nEdgeStringUnit表示一个带有EdgeData作为权重类型的边，顶点为字符串类型。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `std::string src`  \r\n  - 源顶点的字符串形式。\r\n\r\n- `std::string dst`  \r\n  - 目标顶点的字符串形式。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template struct EdgeUnit**  \r\n```cpp\r\n#include \r\n```\r\nEdgeUnit表示一个带有EdgeData作为权重类型的边。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `size_t src`  \r\n  - 源顶点的标识符。\r\n\r\n- `size_t dst`  \r\n  - 目标顶点的标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template<> struct EdgeUnit**  \r\n```cpp\r\n#include \r\n```\r\n#### Public Functions\r\n- **template<> union lgraph_api::olap::EdgeUnit< Empty >::@6 `__attribute__ ((packed))`**  \r\n  - 对于无权图的连接单位的联合定义。\r\n\r\n#### Public Members\r\n- `size_t src`  \r\n  - 源顶点的标识符。"
            },
            {
                "content": "- **template struct EdgeUnit**  \r\n```cpp\r\n#include \r\n```\r\nEdgeUnit表示一个带有EdgeData作为权重类型的边。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `size_t src`  \r\n  - 源顶点的标识符。\r\n\r\n- `size_t dst`  \r\n  - 目标顶点的标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template<> struct EdgeUnit**  \r\n```cpp\r\n#include \r\n```\r\n#### Public Functions\r\n- **template<> union lgraph_api::olap::EdgeUnit< Empty >::@6 `__attribute__ ((packed))`**  \r\n  - 对于无权图的连接单位的联合定义。\r\n\r\n#### Public Members\r\n- `size_t src`  \r\n  - 源顶点的标识符。\r\n\r\n- `size_t dst`  \r\n  - 目标顶点的标识符。\r\n\r\n- `Empty edge_data`  \r\n  - 无权边数据。\r\n\r\n- **struct Empty**  \r\n```cpp\r\n#include \r\n```\r\nEmpty用于表示无权图。\r\n\r\n- **template class OlapBase**  \r\n```cpp\r\n#include \r\n```\r\nAdjList允许对AdjUnit进行基于范围的循环。\r\n\r\n**Graph**\r\n\r\nEdgeData用于表示边的权重（默认类型是Empty，表示无权图）。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\nEdgeData – 图实例表示从txt文件加载的静态（子）图。内部组织使用压缩稀疏矩阵格式，优化了只读访问。\r\n\r\n**EdgeData** – 边数据的类型。\r\n\r\n**Subclassed by** OlapOnDB< EdgeData >\r\n\r\n#### Public Functions\r\n\r\n- **inline OlapBase()**  \r\n  - 图的构造函数。"
            },
            {
                "content": "- `size_t dst`  \r\n  - 目标顶点的标识符。\r\n\r\n- `Empty edge_data`  \r\n  - 无权边数据。\r\n\r\n- **struct Empty**  \r\n```cpp\r\n#include \r\n```\r\nEmpty用于表示无权图。\r\n\r\n- **template class OlapBase**  \r\n```cpp\r\n#include \r\n```\r\nAdjList允许对AdjUnit进行基于范围的循环。\r\n\r\n**Graph**\r\n\r\nEdgeData用于表示边的权重（默认类型是Empty，表示无权图）。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\nEdgeData – 图实例表示从txt文件加载的静态（子）图。内部组织使用压缩稀疏矩阵格式，优化了只读访问。\r\n\r\n**EdgeData** – 边数据的类型。\r\n\r\n**Subclassed by** OlapOnDB< EdgeData >\r\n\r\n#### Public Functions\r\n\r\n- **inline OlapBase()**  \r\n  - 图的构造函数。\r\n\r\n- **inline virtual bool CheckKillThisTask()**  \r\n  - 检查是否需要终止此任务。\r\n\r\n- **inline size_t OutDegree(size_t vid)**  \r\n  - 访问某个顶点的出度。\r\n  \r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的出度。\r\n\r\n- **inline size_t InDegree(size_t vid)**  \r\n  - 访问某个顶点的入度。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的入度。\r\n\r\n- **inline AdjList OutEdges(size_t vid)**  \r\n  - 访问某个顶点的出边。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的出边。\r\n\r\n- **inline AdjList InEdges(size_t vid)**"
            },
            {
                "content": "- **inline virtual bool CheckKillThisTask()**  \r\n  - 检查是否需要终止此任务。\r\n\r\n- **inline size_t OutDegree(size_t vid)**  \r\n  - 访问某个顶点的出度。\r\n  \r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的出度。\r\n\r\n- **inline size_t InDegree(size_t vid)**  \r\n  - 访问某个顶点的入度。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的入度。\r\n\r\n- **inline AdjList OutEdges(size_t vid)**  \r\n  - 访问某个顶点的出边。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的出边。\r\n\r\n- **inline AdjList InEdges(size_t vid)**  \r\n  - 访问某个顶点的入边。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的入边。\r\n\r\n- **inline void Transpose()**  \r\n  - 转置图。\r\n\r\n- **inline size_t NumVertices()**  \r\n  - 获取图中顶点的数量。\r\n\r\n  **返回**  \r\n  图中顶点的数量。\r\n\r\n- **inline size_t NumEdges()**  \r\n  - 获取图中边的数量。\r\n\r\n  **返回**  \r\n  图中边的数量。\r\n\r\n- **template inline ParallelVector AllocVertexArray()**  \r\n  - 分配一个类型为VertexData的顶点数组。\r\n\r\n  **模板参数**  \r\n  VertexData – 顶点数据的类型。\r\n\r\n  **返回**  \r\n  返回一个类型为VertexData的ParallelVector。"
            },
            {
                "content": "- 访问某个顶点的入边。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的入边。\r\n\r\n- **inline void Transpose()**  \r\n  - 转置图。\r\n\r\n- **inline size_t NumVertices()**  \r\n  - 获取图中顶点的数量。\r\n\r\n  **返回**  \r\n  图中顶点的数量。\r\n\r\n- **inline size_t NumEdges()**  \r\n  - 获取图中边的数量。\r\n\r\n  **返回**  \r\n  图中边的数量。\r\n\r\n- **template inline ParallelVector AllocVertexArray()**  \r\n  - 分配一个类型为VertexData的顶点数组。\r\n\r\n  **模板参数**  \r\n  VertexData – 顶点数据的类型。\r\n\r\n  **返回**  \r\n  返回一个类型为VertexData的ParallelVector。\r\n\r\n- **inline ParallelBitset AllocVertexSubset()**  \r\n  - 分配一个由ParallelBitset表示的顶点子集。\r\n\r\n  **返回**  \r\n  返回大小为|V|的图的ParallelBitset。\r\n\r\n- **inline void AcquireVertexLock(size_t vid)**  \r\n  - 锁定某个顶点以确保并发更新的正确性。\r\n\r\n  **参数**  \r\n  vid – 要锁定的顶点ID（在图中）。\r\n\r\n- **inline void ReleaseVertexLock(size_t vid)**\r\n  - Unlock some vertex to ensure correct concurrent updates.  // 解锁某个顶点以确保正确的并发更新。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the Graph) to unlock.  // 要解锁的顶点ID（在图中）。\r\n\r\n- **inline VertexLockGuard GuardVertexLock(size_t vid)**"
            },
            {
                "content": "- 分配一个由ParallelBitset表示的顶点子集。\r\n\r\n  **返回**  \r\n  返回大小为|V|的图的ParallelBitset。\r\n\r\n- **inline void AcquireVertexLock(size_t vid)**  \r\n  - 锁定某个顶点以确保并发更新的正确性。\r\n\r\n  **参数**  \r\n  vid – 要锁定的顶点ID（在图中）。\r\n\r\n- **inline void ReleaseVertexLock(size_t vid)**\r\n  - Unlock some vertex to ensure correct concurrent updates.  // 解锁某个顶点以确保正确的并发更新。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the Graph) to unlock.  // 要解锁的顶点ID（在图中）。\r\n\r\n- **inline VertexLockGuard GuardVertexLock(size_t vid)**\r\n  - Get a VertexLockGuard of some vertex.  // 获取某个顶点的 VertexLockGuard。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the Graph) to lock/unlock.  // 要锁定/解锁的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  A VertexLockGuard corresponding to the specified vertex.  // 与指定顶点对应的 VertexLockGuard。\r\n\r\n- **inline bool IfSparse(ParallelBitset &active_vertices)**\r\n  - Judging whether it is sparse mode or dense mode according to the number of vertices.  // 根据顶点的数量判断是稀疏模式还是密集模式。\r\n\r\n  **参数**  \r\n  active_vertices – The ParallelBitset of active_vertices.  // 活动顶点的 ParallelBitset。"
            },
            {
                "content": "**参数**  \r\n  vid – The vertex id (in the Graph) to lock/unlock.  // 要锁定/解锁的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  A VertexLockGuard corresponding to the specified vertex.  // 与指定顶点对应的 VertexLockGuard。\r\n\r\n- **inline bool IfSparse(ParallelBitset &active_vertices)**\r\n  - Judging whether it is sparse mode or dense mode according to the number of vertices.  // 根据顶点的数量判断是稀疏模式还是密集模式。\r\n\r\n  **参数**  \r\n  active_vertices – The ParallelBitset of active_vertices.  // 活动顶点的 ParallelBitset。\r\n\r\n- **inline void set_num_vertices(size_t vertices)**\r\n  - Assign vertices to the first loaded graph.  // 将顶点分配给第一个加载的图形。\r\n\r\n  **参数**  \r\n  vertices – The vertex id (in the Graph) to lock/unlock.  // 要锁定/解锁的顶点ID（在图中）。\r\n\r\n- **inline void LoadFromArray(char *edge_array, size_t input_vertices, size_t input_edges, EdgeDirectionPolicy edge_direction_policy)**\r\n  - Load graph data from edge_array.  // 从 edge_array 加载图形数据。\r\n\r\n  **参数**  \r\n  edge_array – [in] The data in this array is read into the graph.  // [输入] 此数组中的数据将读取到图形中。"
            },
            {
                "content": "- Assign vertices to the first loaded graph.  // 将顶点分配给第一个加载的图形。\r\n\r\n  **参数**  \r\n  vertices – The vertex id (in the Graph) to lock/unlock.  // 要锁定/解锁的顶点ID（在图中）。\r\n\r\n- **inline void LoadFromArray(char *edge_array, size_t input_vertices, size_t input_edges, EdgeDirectionPolicy edge_direction_policy)**\r\n  - Load graph data from edge_array.  // 从 edge_array 加载图形数据。\r\n\r\n  **参数**  \r\n  edge_array – [in] The data in this array is read into the graph.  // [输入] 此数组中的数据将读取到图形中。  \r\n  input_vertices – The number of vertices in the input graph data.  // 输入图形数据中的顶点数量。  \r\n  input_edges – The number of edges in the input graph data.  // 输入图形数据中的边缘数量。  \r\n  edge_direction_policy – Graph data loading method.  // 图形数据加载方法。\r\n\r\n- **template inline ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n  - Execute a parallel-for loop in the range [lower, upper).  // 在区间 [lower, upper) 执行并行 for 循环。\r\n\r\n  **抛出**"
            },
            {
                "content": "input_vertices – The number of vertices in the input graph data.  // 输入图形数据中的顶点数量。  \r\n  input_edges – The number of edges in the input graph data.  // 输入图形数据中的边缘数量。  \r\n  edge_direction_policy – Graph data loading method.  // 图形数据加载方法。\r\n\r\n- **template inline ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n  - Execute a parallel-for loop in the range [lower, upper).  // 在区间 [lower, upper) 执行并行 for 循环。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  ReducedSum – Type of the reduced sum.  // 减少总和的类型。\r\n\r\n  **参数**  \r\n  work – The function describing the work.  // 描述工作的函数。  \r\n  lower – The lower bound of the range (inclusive).  // 范围的下界（包含）。  \r\n  upper – The upper bound of the range (exclusive).  // 范围的上界（不包含）。  \r\n  zero – (Optional) The initial value for reduction.  // （可选）用于缩减的初始值。"
            },
            {
                "content": "**抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  ReducedSum – Type of the reduced sum.  // 减少总和的类型。\r\n\r\n  **参数**  \r\n  work – The function describing the work.  // 描述工作的函数。  \r\n  lower – The lower bound of the range (inclusive).  // 范围的下界（包含）。  \r\n  upper – The upper bound of the range (exclusive).  // 范围的上界（不包含）。  \r\n  zero – (Optional) The initial value for reduction.  // （可选）用于缩减的初始值。  \r\n  reduce – (Optional) The function describing the reduction logic.  // （可选）描述减少逻辑的函数。\r\n\r\n  **返回**  \r\n  A reduction value.  // 一个减少值。\r\n\r\n- **template inline ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper, Algorithm algorithm, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n\r\n- **template inline ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n  - Process a set of active vertices in parallel.  // 并行处理一组活动顶点。"
            },
            {
                "content": "**返回**  \r\n  A reduction value.  // 一个减少值。\r\n\r\n- **template inline ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper, Algorithm algorithm, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n\r\n- **template inline ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n  - Process a set of active vertices in parallel.  // 并行处理一组活动顶点。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  ReducedSum – Type of the reduced sum.  // 减少总和的类型。\r\n\r\n  **参数**  \r\n  work – The function describing each vertex’s work.  // 描述每个顶点工作的函数。  \r\n  active_vertices – [inout] The active vertex set.  // [输入输出] 活动顶点集。  \r\n  zero – (Optional) The initial value for reduction.  // （可选）用于缩减的初始值。  \r\n  reduce – (Optional) The function describing the reduction logic.  // （可选）描述减少逻辑的函数。\r\n\r\n  **返回**  \r\n  A reduction value.  // 一个减少值。"
            },
            {
                "content": "**模板参数**  \r\n  ReducedSum – Type of the reduced sum.  // 减少总和的类型。\r\n\r\n  **参数**  \r\n  work – The function describing each vertex’s work.  // 描述每个顶点工作的函数。  \r\n  active_vertices – [inout] The active vertex set.  // [输入输出] 活动顶点集。  \r\n  zero – (Optional) The initial value for reduction.  // （可选）用于缩减的初始值。  \r\n  reduce – (Optional) The function describing the reduction logic.  // （可选）描述减少逻辑的函数。\r\n\r\n  **返回**  \r\n  A reduction value.  // 一个减少值。\r\n\r\n- **template inline ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices, Algorithm algorithm, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n\r\n#### Protected Functions\r\n\r\n- **inline virtual void Construct()**  // 构造函数。\r\n\r\n#### Protected Attributes\r\n\r\n- `size_t num_vertices_`  // 顶点数量。\r\n- `size_t num_edges_`  // 边的数量。\r\n- `size_t edge_data_size_`  // 边数据大小。\r\n- `size_t adj_unit_size_`  // 邻接单元大小。\r\n- `size_t edge_unit_size_`  // 边单元大小。\r\n- `EdgeDirectionPolicy edge_direction_policy_`  // 边方向策略。\r\n- `EdgeUnit *edge_list_`  // 边列表。"
            },
            {
                "content": "#### Protected Functions\r\n\r\n- **inline virtual void Construct()**  // 构造函数。\r\n\r\n#### Protected Attributes\r\n\r\n- `size_t num_vertices_`  // 顶点数量。\r\n- `size_t num_edges_`  // 边的数量。\r\n- `size_t edge_data_size_`  // 边数据大小。\r\n- `size_t adj_unit_size_`  // 邻接单元大小。\r\n- `size_t edge_unit_size_`  // 边单元大小。\r\n- `EdgeDirectionPolicy edge_direction_policy_`  // 边方向策略。\r\n- `EdgeUnit *edge_list_`  // 边列表。\r\n- `ParallelVector out_degree_`  // 出度。\r\n- `ParallelVector in_degree_`  // 入度。\r\n- `ParallelVector out_index_`  // 出索引。\r\n- `ParallelVector in_index_`  // 入索引。\r\n- `ParallelVector> out_edges_`  // 出边。\r\n- `ParallelVector> in_edges_`  // 入边。\r\n- `ParallelVector lock_array_`  // 锁数组。\r\n\r\n#### class ParallelBitset\r\n\r\n```cpp\r\n#include \r\n```\r\nParallelBitset implements the concurrent bitset data structure, which is usually used to represent active vertex sets.  // ParallelBitset 实现了并发位集数据结构，通常用于表示活动顶点集。\r\n\r\n##### Public Functions\r\n\r\n- **explicit ParallelBitset(size_t size)**\r\n  - Construct a ParallelBitset.  // 构造一个 ParallelBitset。"
            },
            {
                "content": "- `ParallelVector in_index_`  // 入索引。\r\n- `ParallelVector> out_edges_`  // 出边。\r\n- `ParallelVector> in_edges_`  // 入边。\r\n- `ParallelVector lock_array_`  // 锁数组。\r\n\r\n#### class ParallelBitset\r\n\r\n```cpp\r\n#include \r\n```\r\nParallelBitset implements the concurrent bitset data structure, which is usually used to represent active vertex sets.  // ParallelBitset 实现了并发位集数据结构，通常用于表示活动顶点集。\r\n\r\n##### Public Functions\r\n\r\n- **explicit ParallelBitset(size_t size)**\r\n  - Construct a ParallelBitset.  // 构造一个 ParallelBitset。\r\n\r\n  **参数**  \r\n  size – The size of the bitset (i.e. the number of bits).  // 位集的大小（即位数）。\r\n\r\n- **ParallelBitset(const ParallelBitset &rhs) = delete**  // 禁止复制构造函数。\r\n\r\n- **inline ParallelBitset &operator=(ParallelBitset &&rhs)**  // 移动赋值运算符。\r\n\r\n- **inline ParallelBitset(ParallelBitset &&rhs)**  // 移动构造函数。\r\n\r\n- **inline ParallelBitset()**  // 默认构造函数。\r\n\r\n- **~ParallelBitset()**  // 析构函数。\r\n\r\n- **void Clear()**\r\n  - Clear the bitset.  // 清除位集。\r\n\r\n- **void Fill()**\r\n  - Fill the bitset.  // 填充位集。"
            },
            {
                "content": "**参数**  \r\n  size – The size of the bitset (i.e. the number of bits).  // 位集的大小（即位数）。\r\n\r\n- **ParallelBitset(const ParallelBitset &rhs) = delete**  // 禁止复制构造函数。\r\n\r\n- **inline ParallelBitset &operator=(ParallelBitset &&rhs)**  // 移动赋值运算符。\r\n\r\n- **inline ParallelBitset(ParallelBitset &&rhs)**  // 移动构造函数。\r\n\r\n- **inline ParallelBitset()**  // 默认构造函数。\r\n\r\n- **~ParallelBitset()**  // 析构函数。\r\n\r\n- **void Clear()**\r\n  - Clear the bitset.  // 清除位集。\r\n\r\n- **void Fill()**\r\n  - Fill the bitset.  // 填充位集。\r\n\r\n- **bool Has(size_t i)**\r\n  - Test a specified bit.  // 测试指定的位。\r\n\r\n  **参数**  \r\n  i – The bit to test.  // 要测试的位。\r\n\r\n  **返回**  \r\n  Whether the bit is set or not.  // 位是否被设置。\r\n\r\n- **bool Add(size_t i)**\r\n  - Set a specified bit.  // 设置指定的位。\r\n\r\n  **参数**  \r\n  i – The bit to set.  // 要设置的位。\r\n\r\n  **返回**  \r\n  Whether the operation is a true addition or not.  // 操作是否是真正的添加。\r\n\r\n- **void Swap(ParallelBitset &other)**\r\n  - Swap the current bitset with another one.  // 将当前位集与另一个位集交换。\r\n\r\n  **参数**"
            },
            {
                "content": "- **bool Has(size_t i)**\r\n  - Test a specified bit.  // 测试指定的位。\r\n\r\n  **参数**  \r\n  i – The bit to test.  // 要测试的位。\r\n\r\n  **返回**  \r\n  Whether the bit is set or not.  // 位是否被设置。\r\n\r\n- **bool Add(size_t i)**\r\n  - Set a specified bit.  // 设置指定的位。\r\n\r\n  **参数**  \r\n  i – The bit to set.  // 要设置的位。\r\n\r\n  **返回**  \r\n  Whether the operation is a true addition or not.  // 操作是否是真正的添加。\r\n\r\n- **void Swap(ParallelBitset &other)**\r\n  - Swap the current bitset with another one.  // 将当前位集与另一个位集交换。\r\n\r\n  **参数**  \r\n  other – [inout] The other bitset to swap with.  // [输入输出] 另一个待交换的位集。\r\n\r\n- **inline uint64_t *Data()**  // 获取数据指针。\r\n\r\n- **inline size_t Size()**  // 获取当前大小。\r\n\r\n##### Private Members\r\n\r\n- `uint64_t *data_`  // 数据指针。\r\n- `size_t size_`  // 大小。\r\n\r\n---\r\n\r\n#### template class ParallelVector\r\n\r\n```cpp\r\n#include \r\n```\r\nParallelVector aims to mimic std::vector. Note that the deletions other than clearing are not supported.  // ParallelVector 旨在模拟 std::vector。请注意，除了清除外，不支持其他删除操作。\r\n\r\n##### Public Functions"
            },
            {
                "content": "other – [inout] The other bitset to swap with.  // [输入输出] 另一个待交换的位集。\r\n\r\n- **inline uint64_t *Data()**  // 获取数据指针。\r\n\r\n- **inline size_t Size()**  // 获取当前大小。\r\n\r\n##### Private Members\r\n\r\n- `uint64_t *data_`  // 数据指针。\r\n- `size_t size_`  // 大小。\r\n\r\n---\r\n\r\n#### template class ParallelVector\r\n\r\n```cpp\r\n#include \r\n```\r\nParallelVector aims to mimic std::vector. Note that the deletions other than clearing are not supported.  // ParallelVector 旨在模拟 std::vector。请注意，除了清除外，不支持其他删除操作。\r\n\r\n##### Public Functions\r\n\r\n- **inline explicit ParallelVector(size_t capacity)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  capacity – The capacity of the vector.  // 向量的容量。\r\n\r\n- **inline explicit ParallelVector(size_t capacity, size_t size)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。"
            },
            {
                "content": "- Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  capacity – The capacity of the vector.  // 向量的容量。\r\n\r\n- **inline explicit ParallelVector(size_t capacity, size_t size)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  capacity – The capacity of the vector.  // 向量的容量。  \r\n  size – The initial size of the vector.  // 向量的初始大小。\r\n\r\n- **inline ParallelVector(T *data, size_t size)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **参数**  \r\n  data – The initial data of the vector.  // 向量的初始数据。  \r\n  size – The initial size of the vector. And the initial capacity equals initial size.  // 向量的初始大小，初始容量等于初始大小。\r\n\r\n- **ParallelVector(const ParallelVector &rhs) = delete**  // 禁止复制构造函数。\r\n\r\n- **inline ParallelVector(ParallelVector &&rhs)**  // 移动构造函数。"
            },
            {
                "content": "size – The initial size of the vector.  // 向量的初始大小。\r\n\r\n- **inline ParallelVector(T *data, size_t size)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **参数**  \r\n  data – The initial data of the vector.  // 向量的初始数据。  \r\n  size – The initial size of the vector. And the initial capacity equals initial size.  // 向量的初始大小，初始容量等于初始大小。\r\n\r\n- **ParallelVector(const ParallelVector &rhs) = delete**  // 禁止复制构造函数。\r\n\r\n- **inline ParallelVector(ParallelVector &&rhs)**  // 移动构造函数。\r\n\r\n- **inline ParallelVector &operator=(ParallelVector &&rhs)**  // 移动赋值运算符。\r\n\r\n- **inline ParallelVector()**\r\n  - Default constructor of ParallelVector.  // ParallelVector 的默认构造函数。\r\n\r\n- **inline void Destroy()**\r\n  - Destroy ParallelVector.  // 销毁 ParallelVector。\r\n\r\n- **inline ~ParallelVector()**  // 析构函数。\r\n\r\n- **inline T &operator[](size_t i)**  // 重载下标运算符。\r\n\r\n- **inline T *begin()**  // 返回开始迭代器。\r\n\r\n- **inline T *end()**  // 返回结束迭代器。\r\n\r\n- **inline T &Back()**  // 返回最后一个元素。\r\n\r\n- **inline T *Data()**  // 返回数据指针。"
            },
            {
                "content": "- **inline ParallelVector()**\r\n  - Default constructor of ParallelVector.  // ParallelVector 的默认构造函数。\r\n\r\n- **inline void Destroy()**\r\n  - Destroy ParallelVector.  // 销毁 ParallelVector。\r\n\r\n- **inline ~ParallelVector()**  // 析构函数。\r\n\r\n- **inline T &operator[](size_t i)**  // 重载下标运算符。\r\n\r\n- **inline T *begin()**  // 返回开始迭代器。\r\n\r\n- **inline T *end()**  // 返回结束迭代器。\r\n\r\n- **inline T &Back()**  // 返回最后一个元素。\r\n\r\n- **inline T *Data()**  // 返回数据指针。\r\n\r\n- **inline size_t Size()**  // 返回当前大小。\r\n\r\n- **inline size_t Capacity()**  // 返回容量。\r\n\r\n- **inline bool Destroyed()**  // 检查是否被销毁。\r\n\r\n- **inline void Resize(size_t size)**\r\n  - Change ParallelVector size. Note the new size should be larger than or equal to elder size.  // 改变 ParallelVector 的大小。注意新大小应大于或等于旧大小。\r\n\r\n  **参数**  \r\n  size – Value of new size.  // 新大小的值。\r\n\r\n- **inline void Resize(size_t size, const T &elem)**\r\n  - Change ParallelVector size and initialize the new element with elem. Note the new size should be larger than or equal to elder size."
            },
            {
                "content": "- **inline bool Destroyed()**  // 检查是否被销毁。\r\n\r\n- **inline void Resize(size_t size)**\r\n  - Change ParallelVector size. Note the new size should be larger than or equal to elder size.  // 改变 ParallelVector 的大小。注意新大小应大于或等于旧大小。\r\n\r\n  **参数**  \r\n  size – Value of new size.  // 新大小的值。\r\n\r\n- **inline void Resize(size_t size, const T &elem)**\r\n  - Change ParallelVector size and initialize the new element with elem. Note the new size should be larger than or equal to elder size.  \r\n  - 改变 ParallelVector 的大小，并用 elem 初始化新元素。注意新大小应该大于或等于旧大小。\r\n\r\n  **参数**  \r\n  size – Value of new size.  // 新大小的值  \r\n  elem – Initial value of new-added element.  // 新添加元素的初始值\r\n\r\n- **inline void Clear()**\r\n  - Clear all data and change size to 0.  \r\n  - 清除所有数据并将大小设置为 0。\r\n\r\n- **inline void ReAlloc(size_t capacity)**\r\n  - Destroy elder data and allocate with new capacity.  \r\n  - 销毁旧数据并分配新的容量。\r\n\r\n  **参数**  \r\n  capacity – New capacity value.  // 新的容量值\r\n\r\n- **inline void Fill(T elem)**\r\n  - Assign the vector’s elements with a common value."
            },
            {
                "content": "**参数**  \r\n  size – Value of new size.  // 新大小的值  \r\n  elem – Initial value of new-added element.  // 新添加元素的初始值\r\n\r\n- **inline void Clear()**\r\n  - Clear all data and change size to 0.  \r\n  - 清除所有数据并将大小设置为 0。\r\n\r\n- **inline void ReAlloc(size_t capacity)**\r\n  - Destroy elder data and allocate with new capacity.  \r\n  - 销毁旧数据并分配新的容量。\r\n\r\n  **参数**  \r\n  capacity – New capacity value.  // 新的容量值\r\n\r\n- **inline void Fill(T elem)**\r\n  - Assign the vector’s elements with a common value.  \r\n  - 将向量的元素赋值为一个公共值。\r\n\r\n  **参数**  \r\n  elem – The common value.  // 公共值\r\n\r\n  This action is performed in parallel, so you should not call it inside another parallel region (via Worker::Delegate).  \r\n  - 该操作是并行执行的，因此您不应在另一个并行区域内部调用它（通过 Worker::Delegate）。\r\n\r\n- **inline void Append(const T &elem, bool atomic = true)**\r\n  - Append an element to the vector.  \r\n  - 将一个元素附加到向量中。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  elem – The element.  // 元素"
            },
            {
                "content": "**参数**  \r\n  elem – The common value.  // 公共值\r\n\r\n  This action is performed in parallel, so you should not call it inside another parallel region (via Worker::Delegate).  \r\n  - 该操作是并行执行的，因此您不应在另一个并行区域内部调用它（通过 Worker::Delegate）。\r\n\r\n- **inline void Append(const T &elem, bool atomic = true)**\r\n  - Append an element to the vector.  \r\n  - 将一个元素附加到向量中。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  elem – The element.  // 元素  \r\n  atomic – (Optional) Whether atomic instructions should be used or not.  // （可选）是否使用原子指令。\r\n\r\n- **inline void Append(T *buf, size_t count, bool atomic = true)**\r\n  - Append an array of elements to the vector.  \r\n  - 将一组元素附加到向量中。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  buf – [inout] The array pointer.  // [输入输出] 数组指针  \r\n  count – The array length.  // 数组长度  \r\n  atomic – (Optional) True to atomic.  // （可选）是否为真以使用原子操作。"
            },
            {
                "content": "atomic – (Optional) Whether atomic instructions should be used or not.  // （可选）是否使用原子指令。\r\n\r\n- **inline void Append(T *buf, size_t count, bool atomic = true)**\r\n  - Append an array of elements to the vector.  \r\n  - 将一组元素附加到向量中。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  buf – [inout] The array pointer.  // [输入输出] 数组指针  \r\n  count – The array length.  // 数组长度  \r\n  atomic – (Optional) True to atomic.  // （可选）是否为真以使用原子操作。\r\n\r\n- **inline void Append(ParallelVector &other, bool atomic = true)**\r\n  - Append another vector of elements to this.  \r\n  - 将另一个元素向量附加到此向量。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  other – [inout] The other vector.  // [输入输出] 另一个向量  \r\n  atomic – (Optional) True to atomic.  // （可选）是否为真以使用原子操作。\r\n\r\n- **inline void Swap(ParallelVector &other)**\r\n  - Swap the current vector with another one.  \r\n  - 将当前向量与另一个向量交换。\r\n\r\n  **参数**"
            },
            {
                "content": "- **inline void Append(ParallelVector &other, bool atomic = true)**\r\n  - Append another vector of elements to this.  \r\n  - 将另一个元素向量附加到此向量。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  other – [inout] The other vector.  // [输入输出] 另一个向量  \r\n  atomic – (Optional) True to atomic.  // （可选）是否为真以使用原子操作。\r\n\r\n- **inline void Swap(ParallelVector &other)**\r\n  - Swap the current vector with another one.  \r\n  - 将当前向量与另一个向量交换。\r\n\r\n  **参数**  \r\n  other – [inout] The other vector to swap with.  // [输入输出] 要交换的另一个向量\r\n\r\n- **inline ParallelVector Copy()**\r\n  - Copy the current vector.  \r\n  - 复制当前向量。\r\n\r\n  **返回**  \r\n  A new vector with the same copied content.  // 一个新的向量，具有相同的复制内容。\r\n\r\n##### Private Members\r\n\r\n- `bool destroyed_`\r\n- `size_t capacity_`\r\n- `T *data_`\r\n- `size_t size_`\r\n\r\n---\r\n\r\n#### struct ThreadState\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\n##### Public Members\r\n\r\n- `size_t curr`\r\n- `size_t end`\r\n- `int state`\r\n\r\n---\r\n\r\n#### class VertexLockGuard"
            },
            {
                "content": "other – [inout] The other vector to swap with.  // [输入输出] 要交换的另一个向量\r\n\r\n- **inline ParallelVector Copy()**\r\n  - Copy the current vector.  \r\n  - 复制当前向量。\r\n\r\n  **返回**  \r\n  A new vector with the same copied content.  // 一个新的向量，具有相同的复制内容。\r\n\r\n##### Private Members\r\n\r\n- `bool destroyed_`\r\n- `size_t capacity_`\r\n- `T *data_`\r\n- `size_t size_`\r\n\r\n---\r\n\r\n#### struct ThreadState\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\n##### Public Members\r\n\r\n- `size_t curr`\r\n- `size_t end`\r\n- `int state`\r\n\r\n---\r\n\r\n#### class VertexLockGuard\r\n\r\n```cpp\r\n#include \r\n```\r\nThe VertexLockGuard automatically acquires the lock on construction and releases the lock on destruction.  \r\n- VertexLockGuard 在构造时自动获取锁，并在析构时释放锁。\r\n\r\n##### Public Functions\r\n\r\n- **explicit VertexLockGuard(volatile bool *lock)**\r\n\r\n- **VertexLockGuard(const VertexLockGuard &rhs) = delete**\r\n\r\n- **VertexLockGuard(VertexLockGuard &&rhs) = default**\r\n\r\n- **~VertexLockGuard()**\r\n\r\n##### Private Members\r\n\r\n- `bool *lock_`\r\n\r\n---\r\n\r\n#### class Worker\r\n\r\n```cpp\r\n#include \r\n```"
            },
            {
                "content": "```cpp\r\n#include \r\n```\r\nThe VertexLockGuard automatically acquires the lock on construction and releases the lock on destruction.  \r\n- VertexLockGuard 在构造时自动获取锁，并在析构时释放锁。\r\n\r\n##### Public Functions\r\n\r\n- **explicit VertexLockGuard(volatile bool *lock)**\r\n\r\n- **VertexLockGuard(const VertexLockGuard &rhs) = delete**\r\n\r\n- **VertexLockGuard(VertexLockGuard &&rhs) = default**\r\n\r\n- **~VertexLockGuard()**\r\n\r\n##### Private Members\r\n\r\n- `bool *lock_`\r\n\r\n---\r\n\r\n#### class Worker\r\n\r\n```cpp\r\n#include \r\n```\r\nAll the parallel tasks should be delegated through Worker to prevent a huge number of threads being populated via OpenMP.  \r\n- 所有并行任务应通过 Worker 委托，以防止通过 OpenMP 创建大量线程。\r\n\r\n##### Public Functions\r\n\r\n- **Worker()**\r\n\r\n- **~Worker()**\r\n\r\n- **void Delegate(const std::function &work)**\r\n  - Send some work to the Worker instance.  \r\n  - 向 Worker 实例发送一些工作。\r\n\r\n  **参数**  \r\n  work – The function describing the work.  // 描述工作的函数"
            },
            {
                "content": "- `bool *lock_`\r\n\r\n---\r\n\r\n#### class Worker\r\n\r\n```cpp\r\n#include \r\n```\r\nAll the parallel tasks should be delegated through Worker to prevent a huge number of threads being populated via OpenMP.  \r\n- 所有并行任务应通过 Worker 委托，以防止通过 OpenMP 创建大量线程。\r\n\r\n##### Public Functions\r\n\r\n- **Worker()**\r\n\r\n- **~Worker()**\r\n\r\n- **void Delegate(const std::function &work)**\r\n  - Send some work to the Worker instance.  \r\n  - 向 Worker 实例发送一些工作。\r\n\r\n  **参数**  \r\n  work – The function describing the work.  // 描述工作的函数\r\n\r\n  Exceptions can be thrown in the work function if necessary. Note that Delegate cannot be nested.  \r\n  - 如果需要，可以在工作函数中抛出异常。请注意，Delegate 不能嵌套。\r\n\r\n- **template inline void DelegateCompute(const std::function &work, Compute &compute)**\r\n\r\n##### Public Static Functions\r\n\r\n- **static std::shared_ptr &SharedWorker()**\r\n  - Get the global (shared) worker.  \r\n  - 获取全局（共享） Worker。\r\n\r\n  **返回**  \r\n  A shared pointer to the global Worker instance.  // 指向全局 Worker 实例的共享指针。\r\n\r\n##### Private Members\r\n\r\n- `bool stopping_`"
            },
            {
                "content": "- 如果需要，可以在工作函数中抛出异常。请注意，Delegate 不能嵌套。\r\n\r\n- **template inline void DelegateCompute(const std::function &work, Compute &compute)**\r\n\r\n##### Public Static Functions\r\n\r\n- **static std::shared_ptr &SharedWorker()**\r\n  - Get the global (shared) worker.  \r\n  - 获取全局（共享） Worker。\r\n\r\n  **返回**  \r\n  A shared pointer to the global Worker instance.  // 指向全局 Worker 实例的共享指针。\r\n\r\n##### Private Members\r\n\r\n- `bool stopping_`\r\n- `bool has_work_`\r\n- `std::mutex mutex_`\r\n- `std::condition_variable cv_`\r\n- `std::shared_ptr> task_`\r\n- `std::thread worker_`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_on_db\r\n\r\nTuGraph OLAP interface. To implement a plugin that performs graph analytics on TuGraph, users can load a Snapshot from the database and then use the Gather-Apply-Scatter style interface to do the computation.\r\n\r\nTuGraph OLAP 接口。要实现一个在 TuGraph 上执行图分析的插件，用户可以从数据库加载一个快照，然后使用 Gather-Apply-Scatter 风格的接口进行计算。\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace olap\r\n```\r\n\r\n### Variables\r\n\r\n- **static constexpr size_t SNAPSHOT_PARALLEL = 1ul << 0**"
            },
            {
                "content": "- `std::thread worker_`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_on_db\r\n\r\nTuGraph OLAP interface. To implement a plugin that performs graph analytics on TuGraph, users can load a Snapshot from the database and then use the Gather-Apply-Scatter style interface to do the computation.\r\n\r\nTuGraph OLAP 接口。要实现一个在 TuGraph 上执行图分析的插件，用户可以从数据库加载一个快照，然后使用 Gather-Apply-Scatter 风格的接口进行计算。\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace olap\r\n```\r\n\r\n### Variables\r\n\r\n- **static constexpr size_t SNAPSHOT_PARALLEL = 1ul << 0**\r\n  - The available options for (graph construction) flags.\r\n  # （图构建）标志的可用选项。\r\n\r\n- **static constexpr size_t SNAPSHOT_UNDIRECTED = 1ul << 1**\r\n  # 无向图的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_IDMAPPING = 1ul << 2**\r\n  # ID映射的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_OUT_DEGREE = 1ul << 3**\r\n  - The following options are not implemented yet.\r\n  # 以下选项尚未实现。\r\n\r\n- **static constexpr size_t SNAPSHOT_IN_DEGREE = 1ul << 4**\r\n  # 入度的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_OUT_EDGES = 1ul << 5**\r\n  # 出边的标志。"
            },
            {
                "content": "# （图构建）标志的可用选项。\r\n\r\n- **static constexpr size_t SNAPSHOT_UNDIRECTED = 1ul << 1**\r\n  # 无向图的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_IDMAPPING = 1ul << 2**\r\n  # ID映射的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_OUT_DEGREE = 1ul << 3**\r\n  - The following options are not implemented yet.\r\n  # 以下选项尚未实现。\r\n\r\n- **static constexpr size_t SNAPSHOT_IN_DEGREE = 1ul << 4**\r\n  # 入度的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_OUT_EDGES = 1ul << 5**\r\n  # 出边的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_IN_EDGES = 1ul << 6**\r\n  # 入边的标志。\r\n\r\n- **template std::function edge_convert_default = [](OutEdgeIterator &eit, EdgeData &edge_data) -> bool { edge_data= 1;return true;}**\r\n  - Default Parser for weighted edges for graph.\r\n  # 图的加权边的默认解析器。\r\n\r\n  **Return**  \r\n  Edge is converted into graph or not.\r\n  # 边是否被转换为图。\r\n\r\n- **template std::function edge_convert_weight = [](OutEdgeIterator &eit, EdgeData &edge_data) -> bool { edge_data= eit.GetField(\"weight\").real();return true;}**"
            },
            {
                "content": "# 入边的标志。\r\n\r\n- **template std::function edge_convert_default = [](OutEdgeIterator &eit, EdgeData &edge_data) -> bool { edge_data= 1;return true;}**\r\n  - Default Parser for weighted edges for graph.\r\n  # 图的加权边的默认解析器。\r\n\r\n  **Return**  \r\n  Edge is converted into graph or not.\r\n  # 边是否被转换为图。\r\n\r\n- **template std::function edge_convert_weight = [](OutEdgeIterator &eit, EdgeData &edge_data) -> bool { edge_data= eit.GetField(\"weight\").real();return true;}**\r\n  - Example parser for extracting from edge property “weight”\r\n  # 用于从边属性“权重”中提取的示例解析器。\r\n\r\n  **Return**  \r\n  Edge is converted into graph or not.\r\n  # 边是否被转换为图。\r\n\r\n- **template class OlapOnDB : public lgraph_api::olap::OlapBase**\r\n  \r\n  ```cpp\r\n  #include \r\n  ```\r\n\r\n  Snapshot is a derived class of Graph. Snapshot instances represent static (sub)graphs exported from LightningGraph. The internal organization uses compressed sparse matrix formats which are optimized for read-only accesses."
            },
            {
                "content": "- Example parser for extracting from edge property “weight”\r\n  # 用于从边属性“权重”中提取的示例解析器。\r\n\r\n  **Return**  \r\n  Edge is converted into graph or not.\r\n  # 边是否被转换为图。\r\n\r\n- **template class OlapOnDB : public lgraph_api::olap::OlapBase**\r\n  \r\n  ```cpp\r\n  #include \r\n  ```\r\n\r\n  Snapshot is a derived class of Graph. Snapshot instances represent static (sub)graphs exported from LightningGraph. The internal organization uses compressed sparse matrix formats which are optimized for read-only accesses.\r\n  # Snapshot 是图的派生类。 Snapshot 实例表示从 LightningGraph 导出的静态（子）图。内部组织使用针对只读访问优化的压缩稀疏矩阵格式。\r\n\r\n  EdgeData is used for representing edge weights (the default type is Empty which is used for unweighted graphs).\r\n  # EdgeData 用于表示边权重（默认类型是 Empty，适用于无权图）。\r\n\r\n  **模板参数**  \r\n  EdgeData – Type of the edge data.\r\n  # EdgeData – 边数据的类型。\r\n\r\n### Public Functions\r\n\r\n- **inline OlapOnDB(GraphDB *db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**"
            },
            {
                "content": "# Snapshot 是图的派生类。 Snapshot 实例表示从 LightningGraph 导出的静态（子）图。内部组织使用针对只读访问优化的压缩稀疏矩阵格式。\r\n\r\n  EdgeData is used for representing edge weights (the default type is Empty which is used for unweighted graphs).\r\n  # EdgeData 用于表示边权重（默认类型是 Empty，适用于无权图）。\r\n\r\n  **模板参数**  \r\n  EdgeData – Type of the edge data.\r\n  # EdgeData – 边数据的类型。\r\n\r\n### Public Functions\r\n\r\n- **inline OlapOnDB(GraphDB *db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph with LightningGraph. For V1/V2 Procedures\r\n  # 使用 LightningGraph 生成图。用于 V1/V2 过程。\r\n\r\n- **inline OlapOnDB(GraphDB &db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph with LightningGraph. For V1 Procedures\r\n  # 使用 LightningGraph 生成图。用于 V1 过程。"
            },
            {
                "content": "- **inline OlapOnDB(GraphDB *db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph with LightningGraph. For V1/V2 Procedures\r\n  # 使用 LightningGraph 生成图。用于 V1/V2 过程。\r\n\r\n- **inline OlapOnDB(GraphDB &db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph with LightningGraph. For V1 Procedures\r\n  # 使用 LightningGraph 生成图。用于 V1 过程。\r\n\r\n  **Note**: Read-write transactions are not recommended here for safety, e.g., some vertices might be removed causing inconsistencies in the analysis, and vertex data extraction may not work for deleted vertices. The constructed graph should contain all vertices whose vertex_filter calls return true and all edges sourced from these vertices whose out_edge_filter calls return true. If SNAPSHOT_UNDIRECTED is specified, the graph will be made symmetric (i.e., reversed edges are also added to the graph)."
            },
            {
                "content": "**Note**: Read-write transactions are not recommended here for safety, e.g., some vertices might be removed causing inconsistencies in the analysis, and vertex data extraction may not work for deleted vertices. The constructed graph should contain all vertices whose vertex_filter calls return true and all edges sourced from these vertices whose out_edge_filter calls return true. If SNAPSHOT_UNDIRECTED is specified, the graph will be made symmetric (i.e., reversed edges are also added to the graph).\r\n  # 注意：这里不推荐使用读写事务以确保安全，例如，某些顶点可能会被删除，从而导致分析中的不一致性，并且顶点数据提取可能无法处理已删除的顶点。构建的图应该包含所有 vertex_filter 调用返回 true 的顶点，以及所有出自这些顶点的 out_edge_filter 调用返回 true 的边。如果指定了 SNAPSHOT_UNDIRECTED，则图将变为对称（即反向边也将被添加到图中）。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.\r\n  # std::runtime_error – 当发生运行时错误条件时抛出。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  txn – [inout] The transaction.  \r\n  flags – (Optional) The generation flags."
            },
            {
                "content": "# 注意：这里不推荐使用读写事务以确保安全，例如，某些顶点可能会被删除，从而导致分析中的不一致性，并且顶点数据提取可能无法处理已删除的顶点。构建的图应该包含所有 vertex_filter 调用返回 true 的顶点，以及所有出自这些顶点的 out_edge_filter 调用返回 true 的边。如果指定了 SNAPSHOT_UNDIRECTED，则图将变为对称（即反向边也将被添加到图中）。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.\r\n  # std::runtime_error – 当发生运行时错误条件时抛出。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  txn – [inout] The transaction.  \r\n  flags – (Optional) The generation flags.  \r\n  vertex_filter – [inout] (Optional) A function filtering vertices.  \r\n  out_edge_filter – [inout] (Optional) A function filtering out edges.\r\n\r\n- **inline OlapOnDB(GraphDB &db, Transaction &txn, std::vector> label_list, size_t flags = 0)**\r\n\r\n- **inline OlapOnDB(Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph without LightningGraph. For V2 Procedures\r\n  # 在没有 LightningGraph 的情况下生成图。用于 V2 过程。\r\n\r\n  **抛出**"
            },
            {
                "content": "vertex_filter – [inout] (Optional) A function filtering vertices.  \r\n  out_edge_filter – [inout] (Optional) A function filtering out edges.\r\n\r\n- **inline OlapOnDB(GraphDB &db, Transaction &txn, std::vector> label_list, size_t flags = 0)**\r\n\r\n- **inline OlapOnDB(Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph without LightningGraph. For V2 Procedures\r\n  # 在没有 LightningGraph 的情况下生成图。用于 V2 过程。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.\r\n  # std::runtime_error – 当发生运行时错误条件时抛出。\r\n\r\n  **参数**  \r\n  txn – [inout] The transaction.  \r\n  flags – (Optional) The generation flags.  \r\n  vertex_filter – [inout] (Optional) A function filtering vertices.  \r\n  out_edge_filter – [inout] (Optional) A function filtering out edges.\r\n\r\n- **OlapOnDB() = delete**\r\n\r\n- **OlapOnDB(const OlapOnDB &rhs) = delete**\r\n\r\n- **OlapOnDB(OlapOnDB &&rhs) = default**"
            },
            {
                "content": "**抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.\r\n  # std::runtime_error – 当发生运行时错误条件时抛出。\r\n\r\n  **参数**  \r\n  txn – [inout] The transaction.  \r\n  flags – (Optional) The generation flags.  \r\n  vertex_filter – [inout] (Optional) A function filtering vertices.  \r\n  out_edge_filter – [inout] (Optional) A function filtering out edges.\r\n\r\n- **OlapOnDB() = delete**\r\n\r\n- **OlapOnDB(const OlapOnDB &rhs) = delete**\r\n\r\n- **OlapOnDB(OlapOnDB &&rhs) = default**\r\n\r\n- **inline OlapOnDB &operator=(OlapOnDB &&rhs)**\r\n\r\n- **inline virtual ~OlapOnDB()**\r\n\r\n- **template inline ParallelVector ExtractVertexData(std::function extract)**\r\n  - Extract a vertex array from the graph.\r\n  # 从图中提取顶点数组。\r\n\r\n  **参数**  \r\n  extract – The function describing the extraction logic.\r\n  # extract – 描述提取逻辑的函数。\r\n\r\n  **返回**  \r\n  A ParallelVector containing each vertex’s extracted data.\r\n  # 一个包含每个顶点提取数据的 ParallelVector。"
            },
            {
                "content": "- **OlapOnDB(OlapOnDB &&rhs) = default**\r\n\r\n- **inline OlapOnDB &operator=(OlapOnDB &&rhs)**\r\n\r\n- **inline virtual ~OlapOnDB()**\r\n\r\n- **template inline ParallelVector ExtractVertexData(std::function extract)**\r\n  - Extract a vertex array from the graph.\r\n  # 从图中提取顶点数组。\r\n\r\n  **参数**  \r\n  extract – The function describing the extraction logic.\r\n  # extract – 描述提取逻辑的函数。\r\n\r\n  **返回**  \r\n  A ParallelVector containing each vertex’s extracted data.\r\n  # 一个包含每个顶点提取数据的 ParallelVector。\r\n\r\n- **template inline void WriteToFile(ParallelVector &vertex_data, const std::string &output_file, std::function output_filter = nullptr)**\r\n  - Write vertex data to a file.\r\n  # 将顶点数据写入文件。\r\n\r\n  **参数**  \r\n  vertex_data – The parallel vector storing the vertex data.  \r\n  output_file – The path to the output file.\r\n  # vertex_data – 存储顶点数据的并行向量。  \r\n  # output_file – 输出文件的路径。\r\n\r\n- **template inline void WriteToFile(bool detail_output, ParallelVector &vertex_data, const std::string &output_file, std::function output_filter = nullptr)**"
            },
            {
                "content": "- Write vertex data to a file.\r\n  # 将顶点数据写入文件。\r\n\r\n  **参数**  \r\n  vertex_data – The parallel vector storing the vertex data.  \r\n  output_file – The path to the output file.\r\n  # vertex_data – 存储顶点数据的并行向量。  \r\n  # output_file – 输出文件的路径。\r\n\r\n- **template inline void WriteToFile(bool detail_output, ParallelVector &vertex_data, const std::string &output_file, std::function output_filter = nullptr)**\r\n  - Write vertex data (include label, primary_field, field_data) to a file.\r\n  # 将顶点数据（包括标签、主字段、字段数据）写入文件。\r\n\r\n  **参数**  \r\n  detail_output – always true  \r\n  vertex_data – The parallel vector storing the vertex data.  \r\n  output_file – The path to the output file.\r\n  # detail_output – 始终为 true  \r\n  # vertex_data – 存储顶点数据的并行向量。  \r\n  # output_file – 输出文件的路径。\r\n\r\n- **template inline void WriteToGraphDB(ParallelVector &vertex_data, const std::string &vertex_field)**\r\n  - Write vertex data to the graph database.\r\n  # 将顶点数据写入图数据库。\r\n\r\n  **参数**  \r\n  vertex_data – [inout] The parallel vector storing the vertex data."
            },
            {
                "content": "**参数**  \r\n  detail_output – always true  \r\n  vertex_data – The parallel vector storing the vertex data.  \r\n  output_file – The path to the output file.\r\n  # detail_output – 始终为 true  \r\n  # vertex_data – 存储顶点数据的并行向量。  \r\n  # output_file – 输出文件的路径。\r\n\r\n- **template inline void WriteToGraphDB(ParallelVector &vertex_data, const std::string &vertex_field)**\r\n  - Write vertex data to the graph database.\r\n  # 将顶点数据写入图数据库。\r\n\r\n  **参数**  \r\n  vertex_data – [inout] The parallel vector storing the vertex data.  \r\n  vertex_field – [in] The name of the vertex field.\r\n  # vertex_data – [inout] 存储顶点数据的并行向量。  \r\n  # vertex_field – [in] 顶点字段的名称。\r\n\r\n- **inline int64_t OriginalVid(size_t vid)**\r\n  - Get the original vertex id (in LightningGraph) of some vertex.\r\n  # 获取某个顶点的原始顶点 ID（在 LightningGraph 中）。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the graph) to access.\r\n  # vid – 要访问的顶点 ID（在图中）。\r\n\r\n  **返回**  \r\n  The original id of the specified vertex in the graph.\r\n  # 指定顶点在图中的原始 ID。"
            },
            {
                "content": "vertex_field – [in] The name of the vertex field.\r\n  # vertex_data – [inout] 存储顶点数据的并行向量。  \r\n  # vertex_field – [in] 顶点字段的名称。\r\n\r\n- **inline int64_t OriginalVid(size_t vid)**\r\n  - Get the original vertex id (in LightningGraph) of some vertex.\r\n  # 获取某个顶点的原始顶点 ID（在 LightningGraph 中）。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the graph) to access.\r\n  # vid – 要访问的顶点 ID（在图中）。\r\n\r\n  **返回**  \r\n  The original id of the specified vertex in the graph.\r\n  # 指定顶点在图中的原始 ID。\r\n\r\n- **inline size_t MappedVid(size_t original_vid)**\r\n  - Get the mapped vertex id (in the graph) of some vertex.\r\n  # 获取某个顶点的映射顶点 ID（在图中）。\r\n\r\n  **参数**  \r\n  original_vid – The original vertex id (in LightningGraph) to access.\r\n  # original_vid – 要访问的原始顶点 ID（在 LightningGraph 中）。\r\n\r\n  **返回**  \r\n  The mapped id of the specified vertex (in LightningGraph).\r\n  # 指定顶点（在 LightningGraph 中）的映射 ID。\r\n\r\n- **inline Transaction &GetTransaction()**\r\n\r\n### Private Functions\r\n\r\n- **inline void Init(size_t num_vertices)**"
            },
            {
                "content": "- **inline size_t MappedVid(size_t original_vid)**\r\n  - Get the mapped vertex id (in the graph) of some vertex.\r\n  # 获取某个顶点的映射顶点 ID（在图中）。\r\n\r\n  **参数**  \r\n  original_vid – The original vertex id (in LightningGraph) to access.\r\n  # original_vid – 要访问的原始顶点 ID（在 LightningGraph 中）。\r\n\r\n  **返回**  \r\n  The mapped id of the specified vertex (in LightningGraph).\r\n  # 指定顶点（在 LightningGraph 中）的映射 ID。\r\n\r\n- **inline Transaction &GetTransaction()**\r\n\r\n### Private Functions\r\n\r\n- **inline void Init(size_t num_vertices)**\r\n\r\n- **inline virtual bool CheckKillThisTask()**\r\n  - This decision formula is used to determine whether to stop the algorithm running in OlapOnDB.\r\n  # 此决策公式用于确定是否停止在 OlapOnDB 中运行的算法。\r\n\r\n- **inline virtual void Construct()**\r\n\r\n- **inline void ConstructWithVid()**\r\n\r\n- **inline void ConstructWithDegree()**\r\n\r\n### Private Members\r\n\r\n- `GraphDB *db_`\r\n- `Transaction &txn_`\r\n- `ParallelVector original_vids_`\r\n- `cuckoohash_map vid_map_`\r\n- `size_t flags_`\r\n- `std::function vertex_filter_`"
            },
            {
                "content": "- **inline virtual bool CheckKillThisTask()**\r\n  - This decision formula is used to determine whether to stop the algorithm running in OlapOnDB.\r\n  # 此决策公式用于确定是否停止在 OlapOnDB 中运行的算法。\r\n\r\n- **inline virtual void Construct()**\r\n\r\n- **inline void ConstructWithVid()**\r\n\r\n- **inline void ConstructWithDegree()**\r\n\r\n### Private Members\r\n\r\n- `GraphDB *db_`\r\n- `Transaction &txn_`\r\n- `ParallelVector original_vids_`\r\n- `cuckoohash_map vid_map_`\r\n- `size_t flags_`\r\n- `std::function vertex_filter_`\r\n- `std::function out_edge_filter_`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_profile\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace olap\r\n```\r\n在这里定义了 `lgraph_api` 和 `olap` 命名空间，便于对相应的功能进行组织和管理。\r\n\r\n### class MemUsage\r\n\r\n```cpp\r\n#include \r\n```\r\n该行包含了 `olap_profile.h` 头文件，这通常包含了 `MemUsage` 类的声明和其他相关的定义。\r\n\r\n### Public Functions\r\n\r\n- **inline MemUsage()**\r\n  - 构造函数，用于初始化 `MemUsage` 类的实例。\r\n\r\n- **inline int64_t getMaxMemUsage()**\r\n  - 获取最大的内存使用量，返回类型为64位整数。\r\n\r\n- **void reset()**\r\n  - 重置内存使用记录，将已记录的内存信息清零。"
            },
            {
                "content": "- `std::function out_edge_filter_`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_profile\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace olap\r\n```\r\n在这里定义了 `lgraph_api` 和 `olap` 命名空间，便于对相应的功能进行组织和管理。\r\n\r\n### class MemUsage\r\n\r\n```cpp\r\n#include \r\n```\r\n该行包含了 `olap_profile.h` 头文件，这通常包含了 `MemUsage` 类的声明和其他相关的定义。\r\n\r\n### Public Functions\r\n\r\n- **inline MemUsage()**\r\n  - 构造函数，用于初始化 `MemUsage` 类的实例。\r\n\r\n- **inline int64_t getMaxMemUsage()**\r\n  - 获取最大的内存使用量，返回类型为64位整数。\r\n\r\n- **void reset()**\r\n  - 重置内存使用记录，将已记录的内存信息清零。\r\n\r\n- **void startMemRecord(unsigned int interval = 1000)**\r\n  - 开始内存使用记录，接受一个参数 `interval`（默认1000毫秒），用来指定记录频率。\r\n\r\n- **void print()**\r\n  - 打印内存使用记录的详细信息，方便用户查看内存情况。\r\n\r\n### Private Functions\r\n\r\n- **int parseMemLine(char *line)**\r\n  - 解析内存使用的文本行，返回解析得到的内存值，通常用于将字符串转换为数字。\r\n\r\n### Private Members\r\n\r\n- `size_t maxMemUsage`\r\n  - 私有成员变量，用于存储最大的内存使用量，类型为 `size_t`，通常用于表示存储大小。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/CSS-Attack/refs/heads/main/python_api.md",
        "chunks": [
            {
                "content": "# TuGraph 嵌入模式 Python API 文档概述\r\n\r\n## 介绍\r\n\r\nTuGraph 是一个图数据库，与 SQLite 和 Neo4j 类似，支持嵌入式模式。在嵌入式模式下，TuGraph 作为一个库运行，允许用户编写应用程序并调用库函数来创建、查询和修改图数据。数据交换在同一进程中进行，操作简单且高效。\r\n\r\n与 SQLite 和 Noe4j 类似，TuGraph 可以在嵌入式模式下工作。 在嵌入式模式下，它就像一个库。 您可以编写自己的应用程序并调用库函数来创建、查询和修改图。 在这种情况下，应用程序和图数据库之间的所有数据交换都在同一个进程中进行。 它非常简单高效。\r\n\r\n这是 TuGraph 嵌入模式的 python API 文档。 通过嵌入式API，用户可以打开或创建数据库，然后查询或修改数据库。\r\n\r\n## 接口\r\n\r\n以下是 TuGraph 嵌入模式的 Python API 类及其成员的详细介绍：\r\n\r\n### `liblgraph_python_api.AccessLevel`\r\n表示用户在图上的访问权限。  \r\n*Access that a user has on a graph.*\r\n\r\n- **成员 Members**:\r\n  - `NONE`: 无权限. *No access.*\r\n  - `READ`: 只读权限. *Read-only access.*\r\n  - `WRITE`: 写权限. *Write access.*\r\n  - `FULL`: 完全权限. *Full access.*\r\n- **属性 Property**:\r\n  - `name`: 访问级别名称. *Name of the access level.*\r\n\r\n\r\n### `liblgraph_python_api.EdgeUid`\r\n表示边的标识符。  \r\n*Edge identifier.*\r\n\r\n- **属性 Property**:\r\n  - `dst`: 目标顶点 ID. *Destination vertex ID.*\r\n  - `eid`: 边的 ID. *ID of the edge.*\r\n  - `lid`: 边的标签 ID. *Label ID of the edge.*\r\n  - `src`: 源顶点 ID. *Source vertex ID.*"
            },
            {
                "content": "- **成员 Members**:\r\n  - `NONE`: 无权限. *No access.*\r\n  - `READ`: 只读权限. *Read-only access.*\r\n  - `WRITE`: 写权限. *Write access.*\r\n  - `FULL`: 完全权限. *Full access.*\r\n- **属性 Property**:\r\n  - `name`: 访问级别名称. *Name of the access level.*\r\n\r\n\r\n### `liblgraph_python_api.EdgeUid`\r\n表示边的标识符。  \r\n*Edge identifier.*\r\n\r\n- **属性 Property**:\r\n  - `dst`: 目标顶点 ID. *Destination vertex ID.*\r\n  - `eid`: 边的 ID. *ID of the edge.*\r\n  - `lid`: 边的标签 ID. *Label ID of the edge.*\r\n  - `src`: 源顶点 ID. *Source vertex ID.*\r\n  - `tid`: 边的时间 ID. *Temporal ID of the edge.*\r\n\r\n  \r\n\r\n### `liblgraph_python_api.FieldData`\r\n表示字段值的数据类型。  \r\n*FieldData is the data type of field value.*\r\n\r\n- **方法 Methods**:\r\n  - `AsBlob(self: liblgraph_python_api.FieldData) → bytes`: 返回 BLOB 类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as BLOB, throws exception on type mismatch.*\r\n  - `AsBool(self: liblgraph_python_api.FieldData) → bool`: 返回布尔类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as bool, throws exception on type mismatch.*"
            },
            {
                "content": "- `tid`: 边的时间 ID. *Temporal ID of the edge.*\r\n\r\n  \r\n\r\n### `liblgraph_python_api.FieldData`\r\n表示字段值的数据类型。  \r\n*FieldData is the data type of field value.*\r\n\r\n- **方法 Methods**:\r\n  - `AsBlob(self: liblgraph_python_api.FieldData) → bytes`: 返回 BLOB 类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as BLOB, throws exception on type mismatch.*\r\n  - `AsBool(self: liblgraph_python_api.FieldData) → bool`: 返回布尔类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as bool, throws exception on type mismatch.*\r\n  - `AsDate(self: liblgraph_python_api.FieldData) → datetime.datetime`: 返回日期类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as date, throws exception on type mismatch.*\r\n  - `AsDateTime(self: liblgraph_python_api.FieldData) → datetime.datetime`: 返回日期时间类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as datetime, throws exception on type mismatch.*\r\n  - `AsDouble(self: liblgraph_python_api.FieldData) → float`: 返回双精度浮点数类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as double, throws exception on type mismatch.*"
            },
            {
                "content": "- `AsDate(self: liblgraph_python_api.FieldData) → datetime.datetime`: 返回日期类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as date, throws exception on type mismatch.*\r\n  - `AsDateTime(self: liblgraph_python_api.FieldData) → datetime.datetime`: 返回日期时间类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as datetime, throws exception on type mismatch.*\r\n  - `AsDouble(self: liblgraph_python_api.FieldData) → float`: 返回双精度浮点数类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as double, throws exception on type mismatch.*\r\n  - `AsFloat(self: liblgraph_python_api.FieldData) → float`: 返回单精度浮点数类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as float, throws exception on type mismatch.*\r\n  - `AsInt16(self: liblgraph_python_api.FieldData) → int`: 返回 16 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int16, throws exception on type mismatch.*\r\n  - `AsInt32(self: liblgraph_python_api.FieldData) → int`: 返回 32 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int32, throws exception on type mismatch.*\r\n  - `AsInt64(self: liblgraph_python_api.FieldData) → int`: 返回 64 位整型值，如果类型不匹配则抛出异常."
            },
            {
                "content": "*Get value as float, throws exception on type mismatch.*\r\n  - `AsInt16(self: liblgraph_python_api.FieldData) → int`: 返回 16 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int16, throws exception on type mismatch.*\r\n  - `AsInt32(self: liblgraph_python_api.FieldData) → int`: 返回 32 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int32, throws exception on type mismatch.*\r\n  - `AsInt64(self: liblgraph_python_api.FieldData) → int`: 返回 64 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int64, throws exception on type mismatch.*\r\n  - `AsInt8(self: liblgraph_python_api.FieldData) → int`: 返回 8 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int8, throws exception on type mismatch.*\r\n  - `AsString(self: liblgraph_python_api.FieldData) → str`: 返回字符串值，如果类型不匹配则抛出异常.  \r\n    *Get value as string, throws exception on type mismatch.*\r\n    - `static Blob(arg0: bytes) → liblgraph_python_api.FieldData`: 创建 BLOB 值.  \r\n    *Make a BLOB value.*\r\n  - `static Bool(arg0: bool) → liblgraph_python_api.FieldData`: 创建布尔值.  \r\n    *Make a BOOL value.*"
            },
            {
                "content": "- `AsInt8(self: liblgraph_python_api.FieldData) → int`: 返回 8 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int8, throws exception on type mismatch.*\r\n  - `AsString(self: liblgraph_python_api.FieldData) → str`: 返回字符串值，如果类型不匹配则抛出异常.  \r\n    *Get value as string, throws exception on type mismatch.*\r\n    - `static Blob(arg0: bytes) → liblgraph_python_api.FieldData`: 创建 BLOB 值.  \r\n    *Make a BLOB value.*\r\n  - `static Bool(arg0: bool) → liblgraph_python_api.FieldData`: 创建布尔值.  \r\n    *Make a BOOL value.*\r\n  - `static Date(*args, **kwargs)`: 重载函数.  \r\n    *Overloaded function.*\r\n    - `1.Date(arg0: str) → liblgraph_python_api.FieldData`: 创建日期值.  \r\n      *Make a DATE value.*\r\n    - `2.Date(arg0: datetime.datetime) → liblgraph_python_api.FieldData`: 创建日期值.  \r\n      *Make a DATE value.*\r\n  - `static DateTime(*args, **kwargs)`: 重载函数.  \r\n    *Overloaded function.*\r\n    - `1.DateTime(arg0: str) → liblgraph_python_api.FieldData`: 创建日期时间值.  \r\n      *Make a DATETIME value.*"
            },
            {
                "content": "*Make a BOOL value.*\r\n  - `static Date(*args, **kwargs)`: 重载函数.  \r\n    *Overloaded function.*\r\n    - `1.Date(arg0: str) → liblgraph_python_api.FieldData`: 创建日期值.  \r\n      *Make a DATE value.*\r\n    - `2.Date(arg0: datetime.datetime) → liblgraph_python_api.FieldData`: 创建日期值.  \r\n      *Make a DATE value.*\r\n  - `static DateTime(*args, **kwargs)`: 重载函数.  \r\n    *Overloaded function.*\r\n    - `1.DateTime(arg0: str) → liblgraph_python_api.FieldData`: 创建日期时间值.  \r\n      *Make a DATETIME value.*\r\n    - `2.DateTime(arg0: datetime.datetime) → liblgraph_python_api.FieldData`: 创建日期时间值.  \r\n      *Make a DATETIME value.*\r\n  - `static Double(arg0: float) → liblgraph_python_api.FieldData`: 创建双精度浮点数值.  \r\n    *Make a DOUBLE value.*\r\n  - `static Float(arg0: float) → liblgraph_python_api.FieldData`: 创建单精度浮点数值.  \r\n    *Make a FLOAT value.*\r\n  - `static Int16(arg0: int) → liblgraph_python_api.FieldData`: 创建 16 位整型值.  \r\n    *Make a INT16 value.*\r\n  - `static Int32(arg0: int) → liblgraph_python_api.FieldData`: 创建 32 位整型值."
            },
            {
                "content": "*Make a DATETIME value.*\r\n  - `static Double(arg0: float) → liblgraph_python_api.FieldData`: 创建双精度浮点数值.  \r\n    *Make a DOUBLE value.*\r\n  - `static Float(arg0: float) → liblgraph_python_api.FieldData`: 创建单精度浮点数值.  \r\n    *Make a FLOAT value.*\r\n  - `static Int16(arg0: int) → liblgraph_python_api.FieldData`: 创建 16 位整型值.  \r\n    *Make a INT16 value.*\r\n  - `static Int32(arg0: int) → liblgraph_python_api.FieldData`: 创建 32 位整型值.  \r\n    *Make a INT32 value.*\r\n  - `static Int64(arg0: int) → liblgraph_python_api.FieldData`: 创建 64 位整型值.  \r\n    *Make a INT64 value.*\r\n  - `static Int8(arg0: int) → liblgraph_python_api.FieldData`: 创建 8 位整型值.  \r\n    *Make a INT8 value.*\r\n  - `static String(arg0: str) → liblgraph_python_api.FieldData`: 创建字符串值.  \r\n    *Make a STRING value.*\r\n  - `ToPython(self: liblgraph_python_api.FieldData) → object`: 转换为相应的 Python 类型.  \r\n    *Convert to corresponding Python type.*\r\n  - `get(self: liblgraph_python_api.FieldData) → object`: 获取字段值.  \r\n    *Get the field value.*"
            },
            {
                "content": "*Make a INT64 value.*\r\n  - `static Int8(arg0: int) → liblgraph_python_api.FieldData`: 创建 8 位整型值.  \r\n    *Make a INT8 value.*\r\n  - `static String(arg0: str) → liblgraph_python_api.FieldData`: 创建字符串值.  \r\n    *Make a STRING value.*\r\n  - `ToPython(self: liblgraph_python_api.FieldData) → object`: 转换为相应的 Python 类型.  \r\n    *Convert to corresponding Python type.*\r\n  - `get(self: liblgraph_python_api.FieldData) → object`: 获取字段值.  \r\n    *Get the field value.*\r\n  - `isNull(self: liblgraph_python_api.FieldData) → bool`: 检查字段是否为 null.  \r\n    *Check if the field is null.*\r\n  - `set(self: liblgraph_python_api.FieldData, arg0: object) → None`: 设置字段值.  \r\n    *Set the field value.*\r\n\r\n  \r\n\r\n### `liblgraph_python_api.FieldSpec`\r\n表示字段的规格。  \r\n*Represents the specifications of a field.*\r\n\r\n- **属性 Property**:\r\n  - `name`: 字段名称. *Name of this field.*\r\n  - `nullable`: 字段是否可以为空. *Whether this field can be null.*\r\n  - `type`: 字段类型（例如 INT8, FLOAT, STRING）. *Type of this field, INT8, INT16, …, FLOAT, DOUBLE, STRING.*"
            },
            {
                "content": "*Check if the field is null.*\r\n  - `set(self: liblgraph_python_api.FieldData, arg0: object) → None`: 设置字段值.  \r\n    *Set the field value.*\r\n\r\n  \r\n\r\n### `liblgraph_python_api.FieldSpec`\r\n表示字段的规格。  \r\n*Represents the specifications of a field.*\r\n\r\n- **属性 Property**:\r\n  - `name`: 字段名称. *Name of this field.*\r\n  - `nullable`: 字段是否可以为空. *Whether this field can be null.*\r\n  - `type`: 字段类型（例如 INT8, FLOAT, STRING）. *Type of this field, INT8, INT16, …, FLOAT, DOUBLE, STRING.*\r\n\r\n\r\n### `liblgraph_python_api.FieldType`\r\n表示 FieldData 的数据类型。  \r\n*Data type of FieldData.*\r\n\r\n- **成员 Members**:\r\n  - `NUL`: 空值类型.  \r\n    *Null type.*\r\n  - `BOOL`: 布尔类型.  \r\n    *Boolean type.*\r\n  - `INT8`: 8 位整型.  \r\n    *8-bit integer type.*\r\n  - `INT16`: 16 位整型.  \r\n    *16-bit integer type.*\r\n  - `INT32`: 32 位整型.  \r\n    *32-bit integer type.*\r\n  - `INT64`: 64 位整型.  \r\n    *64-bit integer type.*\r\n  - `FLOAT`: 单精度浮点数.  \r\n    *Float type.*\r\n  - `DOUBLE`: 双精度浮点数.  \r\n    *Double type.*\r\n  - `DATE`: 日期类型.  \r\n    *Date type.*"
            },
            {
                "content": "表示 FieldData 的数据类型。  \r\n*Data type of FieldData.*\r\n\r\n- **成员 Members**:\r\n  - `NUL`: 空值类型.  \r\n    *Null type.*\r\n  - `BOOL`: 布尔类型.  \r\n    *Boolean type.*\r\n  - `INT8`: 8 位整型.  \r\n    *8-bit integer type.*\r\n  - `INT16`: 16 位整型.  \r\n    *16-bit integer type.*\r\n  - `INT32`: 32 位整型.  \r\n    *32-bit integer type.*\r\n  - `INT64`: 64 位整型.  \r\n    *64-bit integer type.*\r\n  - `FLOAT`: 单精度浮点数.  \r\n    *Float type.*\r\n  - `DOUBLE`: 双精度浮点数.  \r\n    *Double type.*\r\n  - `DATE`: 日期类型.  \r\n    *Date type.*\r\n  - `DATETIME`: 日期时间类型.  \r\n    *DateTime type.*\r\n  - `STRING`: 字符串类型.  \r\n    *String type.*\r\n  - `BLOB`: 二进制大对象类型.  \r\n    *BLOB type.*\r\n\r\n- **属性 Property**:\r\n  - `name`: 数据类型名称.  \r\n    *Name of the data type.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.Galaxy`\r\n一个银河是一个 TuGraph 实例，持有多个 GraphDB。银河存储在一个目录中，管理用户和 GraphDB。每个 (用户, GraphDB) 对可以具有不同的访问级别。您可以使用 `db = Galaxy.OpenGraph(graph)` 打开一个图。由于 Python 中的垃圾回收是自动的，完成后需要使用 `Galaxy.Close()` 关闭银河。"
            },
            {
                "content": "*Double type.*\r\n  - `DATE`: 日期类型.  \r\n    *Date type.*\r\n  - `DATETIME`: 日期时间类型.  \r\n    *DateTime type.*\r\n  - `STRING`: 字符串类型.  \r\n    *String type.*\r\n  - `BLOB`: 二进制大对象类型.  \r\n    *BLOB type.*\r\n\r\n- **属性 Property**:\r\n  - `name`: 数据类型名称.  \r\n    *Name of the data type.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.Galaxy`\r\n一个银河是一个 TuGraph 实例，持有多个 GraphDB。银河存储在一个目录中，管理用户和 GraphDB。每个 (用户, GraphDB) 对可以具有不同的访问级别。您可以使用 `db = Galaxy.OpenGraph(graph)` 打开一个图。由于 Python 中的垃圾回收是自动的，完成后需要使用 `Galaxy.Close()` 关闭银河。  \r\n*A galaxy is a TuGraph instance that holds multiple GraphDBs. A galaxy is stored in a directory and manages users and GraphDBs. Each (user, GraphDB) pair can have different access levels. You can use `db = Galaxy.OpenGraph(graph)` to open a graph. Since garbage collection in Python is automatic, you need to close the galaxy with `Galaxy.Close()` when you are done with it.*\r\n\r\n- **方法 Methods**:\r\n  - `Close(self: liblgraph_python_api.Galaxy) → None`: 关闭此银河.  \r\n    *Closes this galaxy.*"
            },
            {
                "content": "*A galaxy is a TuGraph instance that holds multiple GraphDBs. A galaxy is stored in a directory and manages users and GraphDBs. Each (user, GraphDB) pair can have different access levels. You can use `db = Galaxy.OpenGraph(graph)` to open a graph. Since garbage collection in Python is automatic, you need to close the galaxy with `Galaxy.Close()` when you are done with it.*\r\n\r\n- **方法 Methods**:\r\n  - `Close(self: liblgraph_python_api.Galaxy) → None`: 关闭此银河.  \r\n    *Closes this galaxy.*\r\n  \r\n  - `CreateGraph(self: liblgraph_python_api.Galaxy, name: str, description: str = '', max_size: int = 4398046511104) → bool`: 创建一个图。  \r\n    `name`: 图的名称.  \r\n    `description`: 图的描述.  \r\n    `max_size`: 图的最大大小，默认 1TB.  \r\n    *Creates a graph. `name`: the name of the graph; `description`: description of the graph; `max_size`: maximum size of the graph, default 1TB.*\r\n  \r\n  - `CreateRole(self: liblgraph_python_api.Galaxy, name: str, desc: str) → bool`: 创建一个角色.  \r\n    `name`: 角色名称.  \r\n    `desc`: 角色描述."
            },
            {
                "content": "- `CreateGraph(self: liblgraph_python_api.Galaxy, name: str, description: str = '', max_size: int = 4398046511104) → bool`: 创建一个图。  \r\n    `name`: 图的名称.  \r\n    `description`: 图的描述.  \r\n    `max_size`: 图的最大大小，默认 1TB.  \r\n    *Creates a graph. `name`: the name of the graph; `description`: description of the graph; `max_size`: maximum size of the graph, default 1TB.*\r\n  \r\n  - `CreateRole(self: liblgraph_python_api.Galaxy, name: str, desc: str) → bool`: 创建一个角色.  \r\n    `name`: 角色名称.  \r\n    `desc`: 角色描述.  \r\n    *Create a role. `name`: name of the role; `desc`: description of the role.*\r\n  \r\n  - `CreateUser(self: liblgraph_python_api.Galaxy, name: str, password: str, desc: str) → bool`: 创建一个新用户账户.  \r\n    `name`: 用户名称.  \r\n    `password`: 用户密码.  \r\n    `desc`: 此用户的描述.  \r\n    *Creates a new user account. `name`: name of the user; `password`: password for the user; `desc`: description of this user.*\r\n  \r\n  - `DeleteGraph(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除一个图.  \r\n    *Deletes a graph.*"
            },
            {
                "content": "*Create a role. `name`: name of the role; `desc`: description of the role.*\r\n  \r\n  - `CreateUser(self: liblgraph_python_api.Galaxy, name: str, password: str, desc: str) → bool`: 创建一个新用户账户.  \r\n    `name`: 用户名称.  \r\n    `password`: 用户密码.  \r\n    `desc`: 此用户的描述.  \r\n    *Creates a new user account. `name`: name of the user; `password`: password for the user; `desc`: description of this user.*\r\n  \r\n  - `DeleteGraph(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除一个图.  \r\n    *Deletes a graph.*\r\n  \r\n  - `DeleteRole(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除指定角色.  \r\n    *Deletes the specified role.*\r\n  \r\n  - `DeleteUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除用户账户.  \r\n    *Deletes a user account.*\r\n  \r\n  - `DisableUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 禁用用户.  \r\n    *Disables a user.*\r\n  \r\n  - `EnableUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 启用用户.  \r\n    *Enables a user.*"
            },
            {
                "content": "*Deletes a graph.*\r\n  \r\n  - `DeleteRole(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除指定角色.  \r\n    *Deletes the specified role.*\r\n  \r\n  - `DeleteUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除用户账户.  \r\n    *Deletes a user account.*\r\n  \r\n  - `DisableUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 禁用用户.  \r\n    *Disables a user.*\r\n  \r\n  - `EnableUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 启用用户.  \r\n    *Enables a user.*\r\n  \r\n  - `GetUserInfo(self: liblgraph_python_api.Galaxy, arg0: str) → lgraph_api::UserInfo`: 获取指定用户的信息.  \r\n    *Get information of the specified user.*\r\n  \r\n  - `ListGraphs(self: liblgraph_python_api.Galaxy) → Dict[str, Tuple[str, int]]`: 列出图并返回字典 {名称:(描述, 最大大小)}.  \r\n    *Lists graphs and returns a dictionary of {name:(desc, max_size)}.*\r\n  \r\n  - `ListUsers(self: liblgraph_python_api.Galaxy) → Dict[str, lgraph_api::UserInfo]`: 列出所有用户及其是否为管理员.  \r\n    *Lists all users and whether they are admin.*"
            },
            {
                "content": "- `GetUserInfo(self: liblgraph_python_api.Galaxy, arg0: str) → lgraph_api::UserInfo`: 获取指定用户的信息.  \r\n    *Get information of the specified user.*\r\n  \r\n  - `ListGraphs(self: liblgraph_python_api.Galaxy) → Dict[str, Tuple[str, int]]`: 列出图并返回字典 {名称:(描述, 最大大小)}.  \r\n    *Lists graphs and returns a dictionary of {name:(desc, max_size)}.*\r\n  \r\n  - `ListUsers(self: liblgraph_python_api.Galaxy) → Dict[str, lgraph_api::UserInfo]`: 列出所有用户及其是否为管理员.  \r\n    *Lists all users and whether they are admin.*\r\n  \r\n  - `ModGraph(self: liblgraph_python_api.Galaxy, graph_name: str, mod_desc: bool, description: str, mod_size: bool, new_max_size: int) → bool`: 修改图.  \r\n    `mod_size`: 是否修改最大图大小.  \r\n    `new_max_size`: 新的图的最大大小（以字节为单位）.  \r\n    *Modifies a graph. `mod_size`: whether to modify max graph size; `new_max_size`: new maximum size of the graph, in bytes.*\r\n  \r\n  - `OpenGraph(self: liblgraph_python_api.Galaxy, graph: str, read_only: bool = False) → lgraph_api::GraphDB`: 打开一个图并返回 GraphDB 实例.  \r\n    `graph`: 图的名称."
            },
            {
                "content": "- `ModGraph(self: liblgraph_python_api.Galaxy, graph_name: str, mod_desc: bool, description: str, mod_size: bool, new_max_size: int) → bool`: 修改图.  \r\n    `mod_size`: 是否修改最大图大小.  \r\n    `new_max_size`: 新的图的最大大小（以字节为单位）.  \r\n    *Modifies a graph. `mod_size`: whether to modify max graph size; `new_max_size`: new maximum size of the graph, in bytes.*\r\n  \r\n  - `OpenGraph(self: liblgraph_python_api.Galaxy, graph: str, read_only: bool = False) → lgraph_api::GraphDB`: 打开一个图并返回 GraphDB 实例.  \r\n    `graph`: 图的名称.  \r\n    `read_only`: 是否以只读模式打开图.  \r\n    *Opens a graph and returns a GraphDB instance. `graph`: name of the graph; `read_only`: whether to open the graph in read-only mode.*\r\n  \r\n  - `SetCurrentUser(self: liblgraph_python_api.Galaxy, user: str, password: str) → None`: 验证用户密码并设置当前用户.  \r\n    `user`: 用户名.  \r\n    `password`: 用户密码.  \r\n    *Validate user password and set current user. `user`: user name; `password`: password of the user.*"
            },
            {
                "content": "`graph`: 图的名称.  \r\n    `read_only`: 是否以只读模式打开图.  \r\n    *Opens a graph and returns a GraphDB instance. `graph`: name of the graph; `read_only`: whether to open the graph in read-only mode.*\r\n  \r\n  - `SetCurrentUser(self: liblgraph_python_api.Galaxy, user: str, password: str) → None`: 验证用户密码并设置当前用户.  \r\n    `user`: 用户名.  \r\n    `password`: 用户密码.  \r\n    *Validate user password and set current user. `user`: user name; `password`: password of the user.*\r\n  \r\n  - `SetRoleAccessRights(self: liblgraph_python_api.Galaxy, arg0: str, arg1: Dict[str, liblgraph_python_api.AccessLevel]) → bool`: 设置指定角色的访问权限.  \r\n    *Set access rights for the specified role.*\r\n  \r\n  - `SetRoleAccessRightsIncremental(self: liblgraph_python_api.Galaxy, arg0: str, arg1: Dict[str, liblgraph_python_api.AccessLevel]) → bool`: 为指定角色设置增量访问权限，仅影响指定图.  \r\n    *Set access rights for the specified role, only affects the specified graphs.*\r\n  \r\n  - `SetRoleDesc(self: liblgraph_python_api.Galaxy, name: str, desc: str) → bool`: 设置指定角色的描述."
            },
            {
                "content": "*Set access rights for the specified role.*\r\n  \r\n  - `SetRoleAccessRightsIncremental(self: liblgraph_python_api.Galaxy, arg0: str, arg1: Dict[str, liblgraph_python_api.AccessLevel]) → bool`: 为指定角色设置增量访问权限，仅影响指定图.  \r\n    *Set access rights for the specified role, only affects the specified graphs.*\r\n  \r\n  - `SetRoleDesc(self: liblgraph_python_api.Galaxy, name: str, desc: str) → bool`: 设置指定角色的描述.  \r\n    `name`: 角色名称.  \r\n    `desc`: 角色描述.  \r\n    *Set description of the specified role. `name`: name of the role; `desc`: description of the role.*\r\n  \r\n  - `SetUser(self: liblgraph_python_api.Galaxy, user: str) → None`: 验证给定用户并设置当前用户.  \r\n    `user`: 用户名.  \r\n    *Validate the given user and set current user given in the user.*\r\n  \r\n  - `SetUserGraphAccess(self: liblgraph_python_api.Galaxy, user: str, graph: str, access: liblgraph_python_api.AccessLevel) → bool`: 设置指定用户在图上的访问级别.  \r\n    `user`: 用户名称.  \r\n    `graph`: 图的名称.  \r\n    `access`: 用户在该图上的访问级别."
            },
            {
                "content": "- `SetUser(self: liblgraph_python_api.Galaxy, user: str) → None`: 验证给定用户并设置当前用户.  \r\n    `user`: 用户名.  \r\n    *Validate the given user and set current user given in the user.*\r\n  \r\n  - `SetUserGraphAccess(self: liblgraph_python_api.Galaxy, user: str, graph: str, access: liblgraph_python_api.AccessLevel) → bool`: 设置指定用户在图上的访问级别.  \r\n    `user`: 用户名称.  \r\n    `graph`: 图的名称.  \r\n    `access`: 用户在该图上的访问级别.  \r\n    *Set the access level of the specified user on the graph. `user`: name of the user; `graph`: name of the graph; `access`: access level of the user on that graph.*\r\n  \r\n  - `SetUserPass(self: liblgraph_python_api.Galaxy, name: str, old_password: str = '', new_password: str) → bool`: 修改用户密码.  \r\n    `name`: 用户名称.  \r\n    `old_password`: 当前密码，在修改其他用户时不需要.  \r\n    `new_password`: 用户的新密码.  \r\n    *Modifies user password. `name`: name of the user; `old_password`: current password, not needed when modifying another user; `new_password`: new password for the user.*"
            },
            {
                "content": "- `SetUserPass(self: liblgraph_python_api.Galaxy, name: str, old_password: str = '', new_password: str) → bool`: 修改用户密码.  \r\n    `name`: 用户名称.  \r\n    `old_password`: 当前密码，在修改其他用户时不需要.  \r\n    `new_password`: 用户的新密码.  \r\n    *Modifies user password. `name`: name of the user; `old_password`: current password, not needed when modifying another user; `new_password`: new password for the user.*\r\n  \r\n  - `SetUserRoles(self: liblgraph_python_api.Galaxy, name: str, roles: List[str]) → bool`: 为指定用户设置角色.  \r\n    `name`: 用户名称.  \r\n    `roles`: 该用户的角色列表.  \r\n    *Set the roles for the specified user. `name`: name of the user; `roles`: list of roles for this user.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.GraphDB`\r\n图数据库类。GraphDB 存储图的数据，包括标签、顶点、边和索引。由于 Python 中的垃圾回收是自动的，您需要在生命周期结束时使用 `GraphDB.Close()` 关闭数据库。在关闭数据库之前，确保已提交或中止每个使用数据库的事务。"
            },
            {
                "content": "- `SetUserRoles(self: liblgraph_python_api.Galaxy, name: str, roles: List[str]) → bool`: 为指定用户设置角色.  \r\n    `name`: 用户名称.  \r\n    `roles`: 该用户的角色列表.  \r\n    *Set the roles for the specified user. `name`: name of the user; `roles`: list of roles for this user.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.GraphDB`\r\n图数据库类。GraphDB 存储图的数据，包括标签、顶点、边和索引。由于 Python 中的垃圾回收是自动的，您需要在生命周期结束时使用 `GraphDB.Close()` 关闭数据库。在关闭数据库之前，确保已提交或中止每个使用数据库的事务。  \r\n*The graph database class. A GraphDB stores the data about the graph, including labels, vertices, edges, and indexes. Since garbage collection in Python is automatic, you need to close the DB with `GraphDB.Close()` at the end of its lifetime. Make sure you have either committed or aborted every transaction that is using the DB before you close the DB.*\r\n\r\n- **方法 Methods**:\r\n  - `AddEdgeLabel(self: liblgraph_python_api.GraphDB, label_name: str, field_specs: List[liblgraph_python_api.FieldSpec], temporal_field: str = '', constraints: List[Tuple[str, str]] = []) → bool`: 添加边标签."
            },
            {
                "content": "- **方法 Methods**:\r\n  - `AddEdgeLabel(self: liblgraph_python_api.GraphDB, label_name: str, field_specs: List[liblgraph_python_api.FieldSpec], temporal_field: str = '', constraints: List[Tuple[str, str]] = []) → bool`: 添加边标签.  \r\n    *Adds an edge label.*\r\n  \r\n  - `AddVertexIndex(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str, is_unique: bool) → bool`: 添加索引.  \r\n    *Adds an index.*\r\n  \r\n  - `AddVertexLabel(self: liblgraph_python_api.GraphDB, label_name: str, field_specs: List[liblgraph_python_api.FieldSpec], primary_field: str) → bool`: 添加顶点标签.  \r\n    *Add a vertex label.*\r\n  \r\n  - `AlterEdgeLabelAddFields(self: liblgraph_python_api.GraphDB, label: str, add_fields: List[liblgraph_python_api.FieldSpec], default_values: List[liblgraph_python_api.FieldData]) → int`: 向边标签添加字段.  \r\n    `label`: 标签名称.  \r\n    `add_fields`: 新添加字段的 FieldSpec 列表.  \r\n    `default_values`: 新添加字段的默认值."
            },
            {
                "content": "- `AddVertexLabel(self: liblgraph_python_api.GraphDB, label_name: str, field_specs: List[liblgraph_python_api.FieldSpec], primary_field: str) → bool`: 添加顶点标签.  \r\n    *Add a vertex label.*\r\n  \r\n  - `AlterEdgeLabelAddFields(self: liblgraph_python_api.GraphDB, label: str, add_fields: List[liblgraph_python_api.FieldSpec], default_values: List[liblgraph_python_api.FieldData]) → int`: 向边标签添加字段.  \r\n    `label`: 标签名称.  \r\n    `add_fields`: 新添加字段的 FieldSpec 列表.  \r\n    `default_values`: 新添加字段的默认值.  \r\n    *Add fields to an edge label. `label`: name of the label; `add_fields`: list of FieldSpec for the newly added fields; `default_values`: default values of the added fields.*\r\n  \r\n  - `AlterEdgeLabelDelFields(self: liblgraph_python_api.GraphDB, label: str, del_fields: List[str]) → int`: 从边标签中删除字段.  \r\n    `label`: 标签名称.  \r\n    `del_fields`: 字段名称列表.  \r\n    *Delete fields from an edge label. `label`: name of the label; `del_fields`: list of field names.*"
            },
            {
                "content": "`default_values`: 新添加字段的默认值.  \r\n    *Add fields to an edge label. `label`: name of the label; `add_fields`: list of FieldSpec for the newly added fields; `default_values`: default values of the added fields.*\r\n  \r\n  - `AlterEdgeLabelDelFields(self: liblgraph_python_api.GraphDB, label: str, del_fields: List[str]) → int`: 从边标签中删除字段.  \r\n    `label`: 标签名称.  \r\n    `del_fields`: 字段名称列表.  \r\n    *Delete fields from an edge label. `label`: name of the label; `del_fields`: list of field names.*\r\n  \r\n  - `AlterEdgeLabelModFields(self: liblgraph_python_api.GraphDB, label: str, mod_fields: List[liblgraph_python_api.FieldSpec]) → int`: 修改边标签中的字段.  \r\n    `label`: 标签名称.  \r\n    `mod_fields`: 修改字段的 FieldSpec 列表.  \r\n    *Modify fields in an edge label. `label`: name of the label; `mod_fields`: list of FieldSpec for the modified fields.*\r\n  \r\n  - `AlterEdgeLabelModifyConstraints(self: liblgraph_python_api.GraphDB, label_name: str, constraints: List[Tuple[str, str]]) → bool`: 修改边约束.  \r\n    *Modify edge constraints.*"
            },
            {
                "content": "`label`: 标签名称.  \r\n    `mod_fields`: 修改字段的 FieldSpec 列表.  \r\n    *Modify fields in an edge label. `label`: name of the label; `mod_fields`: list of FieldSpec for the modified fields.*\r\n  \r\n  - `AlterEdgeLabelModifyConstraints(self: liblgraph_python_api.GraphDB, label_name: str, constraints: List[Tuple[str, str]]) → bool`: 修改边约束.  \r\n    *Modify edge constraints.*\r\n  \r\n  - `AlterVertexLabelAddFields(self: liblgraph_python_api.GraphDB, label: str, add_fields: List[liblgraph_python_api.FieldSpec], default_values: List[liblgraph_python_api.FieldData]) → int`: 向顶点标签添加字段.  \r\n    `label`: 标签名称.  \r\n    `add_fields`: 新添加字段的 FieldSpec 列表.  \r\n    `default_values`: 新添加字段的默认值.  \r\n    *Add fields to a vertex label. `label`: name of the label; `add_fields`: list of FieldSpec for the newly added fields; `default_values`: default values of the added fields.*\r\n  \r\n  - `AlterVertexLabelDelFields(self: liblgraph_python_api.GraphDB, label: str, del_fields: List[str]) → int`: 从顶点标签中删除字段.  \r\n    `label`: 标签名称."
            },
            {
                "content": "`label`: 标签名称.  \r\n    `add_fields`: 新添加字段的 FieldSpec 列表.  \r\n    `default_values`: 新添加字段的默认值.  \r\n    *Add fields to a vertex label. `label`: name of the label; `add_fields`: list of FieldSpec for the newly added fields; `default_values`: default values of the added fields.*\r\n  \r\n  - `AlterVertexLabelDelFields(self: liblgraph_python_api.GraphDB, label: str, del_fields: List[str]) → int`: 从顶点标签中删除字段.  \r\n    `label`: 标签名称.  \r\n    `del_fields`: 字段名称列表.  \r\n    *Delete fields from a vertex label. `label`: name of the label; `del_fields`: list of field names.*\r\n  \r\n  - `AlterVertexLabelModFields(self: liblgraph_python_api.GraphDB, label: str, mod_fields: List[liblgraph_python_api.FieldSpec]) → int`: 修改顶点标签中的字段.  \r\n    `label`: 标签名称.  \r\n    `mod_fields`: 修改字段的 FieldSpec 列表.  \r\n    *Modify fields in a vertex label. `label`: name of the label; `mod_fields`: list of FieldSpec for the modified fields.*\r\n  \r\n  - `Close(self: liblgraph_python_api.GraphDB) → None`: 关闭数据库.  \r\n    *Closes the DB.*"
            },
            {
                "content": "- `AlterVertexLabelModFields(self: liblgraph_python_api.GraphDB, label: str, mod_fields: List[liblgraph_python_api.FieldSpec]) → int`: 修改顶点标签中的字段.  \r\n    `label`: 标签名称.  \r\n    `mod_fields`: 修改字段的 FieldSpec 列表.  \r\n    *Modify fields in a vertex label. `label`: name of the label; `mod_fields`: list of FieldSpec for the modified fields.*\r\n  \r\n  - `Close(self: liblgraph_python_api.GraphDB) → None`: 关闭数据库.  \r\n    *Closes the DB.*\r\n  \r\n  - `CreateReadTxn(self: liblgraph_python_api.GraphDB) → lgraph_api::Transaction`: 创建读取事务.  \r\n    *Create a read transaction.*\r\n  \r\n  - `CreateWriteTxn(self: liblgraph_python_api.GraphDB, optimistic: bool = False) → lgraph_api::Transaction`: 创建写事务.  \r\n    *Create a write transaction.*\r\n  \r\n  - `DeleteEdgeLabel(self: liblgraph_python_api.GraphDB, label_name: str) → int`: 删除边标签.  \r\n    *Deletes an edge label.*\r\n  \r\n  - `DeleteVertexIndex(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str) → bool`: 删除指定索引.  \r\n    *Deletes the specified index.*"
            },
            {
                "content": "*Create a read transaction.*\r\n  \r\n  - `CreateWriteTxn(self: liblgraph_python_api.GraphDB, optimistic: bool = False) → lgraph_api::Transaction`: 创建写事务.  \r\n    *Create a write transaction.*\r\n  \r\n  - `DeleteEdgeLabel(self: liblgraph_python_api.GraphDB, label_name: str) → int`: 删除边标签.  \r\n    *Deletes an edge label.*\r\n  \r\n  - `DeleteVertexIndex(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str) → bool`: 删除指定索引.  \r\n    *Deletes the specified index.*\r\n  \r\n  - `DeleteVertexLabel(self: liblgraph_python_api.GraphDB, label_name: str) → int`: 删除顶点标签.  \r\n    *Deletes a vertex label.*\r\n  \r\n  - `DropAllData(self: liblgraph_python_api.GraphDB) → None`: 删除数据库中的所有数据. 所有顶点、边、标签和索引将被删除.  \r\n    *Drop all the data in this DB. All vertices, edges, labels, and indexes will be dropped.*\r\n  \r\n  - `DropAllVertex(self: liblgraph_python_api.GraphDB) → None`: 删除数据库中的所有顶点和边. 标签和索引（尽管由于顶点的删除，索引内容将被清除）将被保留."
            },
            {
                "content": "*Deletes the specified index.*\r\n  \r\n  - `DeleteVertexLabel(self: liblgraph_python_api.GraphDB, label_name: str) → int`: 删除顶点标签.  \r\n    *Deletes a vertex label.*\r\n  \r\n  - `DropAllData(self: liblgraph_python_api.GraphDB) → None`: 删除数据库中的所有数据. 所有顶点、边、标签和索引将被删除.  \r\n    *Drop all the data in this DB. All vertices, edges, labels, and indexes will be dropped.*\r\n  \r\n  - `DropAllVertex(self: liblgraph_python_api.GraphDB) → None`: 删除数据库中的所有顶点和边. 标签和索引（尽管由于顶点的删除，索引内容将被清除）将被保留.  \r\n    *Drops all the vertices and edges in this DB. Labels and indexes (though index contents will be cleared due to deletion of vertices) will be preserved.*\r\n  \r\n  - `EstimateNumVertices(self: liblgraph_python_api.GraphDB) → int`: 获取顶点数量的估算值. 如果有顶点删除，这可能不准确.  \r\n    *Gets an estimation of the number of vertices. This can be inaccurate if there were vertex removals.*\r\n  \r\n  - `Flush(self: liblgraph_python_api.GraphDB) → None`: 刷新写入的数据到磁盘.  \r\n    *Flushes written data into disk.*"
            },
            {
                "content": "*Drops all the vertices and edges in this DB. Labels and indexes (though index contents will be cleared due to deletion of vertices) will be preserved.*\r\n  \r\n  - `EstimateNumVertices(self: liblgraph_python_api.GraphDB) → int`: 获取顶点数量的估算值. 如果有顶点删除，这可能不准确.  \r\n    *Gets an estimation of the number of vertices. This can be inaccurate if there were vertex removals.*\r\n  \r\n  - `Flush(self: liblgraph_python_api.GraphDB) → None`: 刷新写入的数据到磁盘.  \r\n    *Flushes written data into disk.*\r\n  \r\n  - `GetDescription(self: liblgraph_python_api.GraphDB) → str`: 获取图的描述.  \r\n    *Gets description of the graph.*\r\n  \r\n  - `GetMaxSize(self: liblgraph_python_api.GraphDB) → int`: 获取图的最大大小.  \r\n    *Gets maximum size of the graph.*\r\n  \r\n  - `IsVertexIndexed(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str) → bool`: 判断指定字段是否已索引.  \r\n    *Tells whether the specified field is indexed.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.InEdgeIterator`\r\n`InEdgeIterator` 可用于迭代目标顶点的所有入边。入边按 (dst, label, src, eid) 的顺序排序。"
            },
            {
                "content": "*Gets description of the graph.*\r\n  \r\n  - `GetMaxSize(self: liblgraph_python_api.GraphDB) → int`: 获取图的最大大小.  \r\n    *Gets maximum size of the graph.*\r\n  \r\n  - `IsVertexIndexed(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str) → bool`: 判断指定字段是否已索引.  \r\n    *Tells whether the specified field is indexed.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.InEdgeIterator`\r\n`InEdgeIterator` 可用于迭代目标顶点的所有入边。入边按 (dst, label, src, eid) 的顺序排序。  \r\n*InEdgeIterator can be used to iterate through all the incoming edges of the destination vertex. Incoming edges are sorted in (dst, label, src, eid) order.*\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.InEdgeIterator) → None`: 删除当前边。如果有下一个出边，迭代器将指向下一个出边.  \r\n    *Deletes the current edge. The iterator will point to the next out edge if there is any.*\r\n  \r\n  - `GetAllFields(self: liblgraph_python_api.InEdgeIterator) → dict`: 获取所有字段值并返回为字典.  \r\n    *Gets all the field values and returns as a dict.*"
            },
            {
                "content": "- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.InEdgeIterator) → None`: 删除当前边。如果有下一个出边，迭代器将指向下一个出边.  \r\n    *Deletes the current edge. The iterator will point to the next out edge if there is any.*\r\n  \r\n  - `GetAllFields(self: liblgraph_python_api.InEdgeIterator) → dict`: 获取所有字段值并返回为字典.  \r\n    *Gets all the field values and returns as a dict.*\r\n  \r\n  - `GetDst(self: liblgraph_python_api.InEdgeIterator) → int`: 返回目标顶点的 ID.  \r\n    *Returns the id of the destination vertex.*\r\n  \r\n  - `GetEdgeId(self: liblgraph_python_api.InEdgeIterator) → int`: 返回当前边的 ID. 边 ID 在相同的 (src, dst) 集合中是唯一的.  \r\n    *Returns the id of the current edge. Edge id is unique across the same (src, dst) set.*\r\n  \r\n  - `GetField(*args, **kwargs)`: 重载函数.\r\n    1. `GetField(self: liblgraph_python_api.InEdgeIterator, field_name: str) → object`: 获取指定字段名称的字段值.  \r\n       *Gets the field value of the field specified by field_name.*\r\n    2. `GetField(self: liblgraph_python_api.InEdgeIterator, field_id: int) → object`: 获取指定字段 ID 的字段值."
            },
            {
                "content": "*Returns the id of the current edge. Edge id is unique across the same (src, dst) set.*\r\n  \r\n  - `GetField(*args, **kwargs)`: 重载函数.\r\n    1. `GetField(self: liblgraph_python_api.InEdgeIterator, field_name: str) → object`: 获取指定字段名称的字段值.  \r\n       *Gets the field value of the field specified by field_name.*\r\n    2. `GetField(self: liblgraph_python_api.InEdgeIterator, field_id: int) → object`: 获取指定字段 ID 的字段值.  \r\n       *Gets the field value of the field specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`: 重载函数.\r\n    1. `GetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str]) → list`: 获取指定字段名称的字段值.  \r\n       *Gets field values of the fields specified by field_names.*\r\n    2. `GetFields(self: liblgraph_python_api.InEdgeIterator, field_ids: List[int]) → list`: 获取指定字段 ID 的字段值.  \r\n       *Gets field values of the fields specified by field_ids.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.InEdgeIterator) → str`: 返回边标签的名称.  \r\n    *Returns the name of the edge label.*"
            },
            {
                "content": "1. `GetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str]) → list`: 获取指定字段名称的字段值.  \r\n       *Gets field values of the fields specified by field_names.*\r\n    2. `GetFields(self: liblgraph_python_api.InEdgeIterator, field_ids: List[int]) → list`: 获取指定字段 ID 的字段值.  \r\n       *Gets field values of the fields specified by field_ids.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.InEdgeIterator) → str`: 返回边标签的名称.  \r\n    *Returns the name of the edge label.*\r\n  \r\n  - `GetLabelId(self: liblgraph_python_api.InEdgeIterator) → int`: 返回边标签的 ID.  \r\n    *Returns the id of the edge label.*\r\n  \r\n  - `GetSrc(self: liblgraph_python_api.InEdgeIterator) → int`: 返回源顶点的 ID.  \r\n    *Returns the id of the source vertex.*\r\n  \r\n  - `GetUid(self: liblgraph_python_api.InEdgeIterator) → liblgraph_python_api.EdgeUid`: 返回边的 EdgeUid.  \r\n    *Returns the EdgeUid of the edge.*\r\n  \r\n  - `Goto(self: liblgraph_python_api.InEdgeIterator, euid: liblgraph_python_api.EdgeUid, nearest: bool) → bool`: 转到由 euid 指定的入边."
            },
            {
                "content": "*Returns the id of the edge label.*\r\n  \r\n  - `GetSrc(self: liblgraph_python_api.InEdgeIterator) → int`: 返回源顶点的 ID.  \r\n    *Returns the id of the source vertex.*\r\n  \r\n  - `GetUid(self: liblgraph_python_api.InEdgeIterator) → liblgraph_python_api.EdgeUid`: 返回边的 EdgeUid.  \r\n    *Returns the EdgeUid of the edge.*\r\n  \r\n  - `Goto(self: liblgraph_python_api.InEdgeIterator, euid: liblgraph_python_api.EdgeUid, nearest: bool) → bool`: 转到由 euid 指定的入边.  \r\n    *Goes to the in edge specified by euid.*\r\n  \r\n  - `IsValid(self: liblgraph_python_api.InEdgeIterator) → bool`: 告诉迭代器是否有效.  \r\n    *Tells whether the iterator is valid.*\r\n  \r\n  - `Next(self: liblgraph_python_api.InEdgeIterator) → bool`: 转到当前目标顶点的下一个入边。如果没有更多的入边，迭代器将变得无效.  \r\n    *Goes to the next in edge to current destination vertex. If there are no more in edges left, the iterator becomes invalid.*\r\n  \r\n  - `SetField(self: liblgraph_python_api.InEdgeIterator, field_name: str, field_value_object: object) → None`: 设置指定字段.  \r\n    *Sets the specified field.*"
            },
            {
                "content": "*Tells whether the iterator is valid.*\r\n  \r\n  - `Next(self: liblgraph_python_api.InEdgeIterator) → bool`: 转到当前目标顶点的下一个入边。如果没有更多的入边，迭代器将变得无效.  \r\n    *Goes to the next in edge to current destination vertex. If there are no more in edges left, the iterator becomes invalid.*\r\n  \r\n  - `SetField(self: liblgraph_python_api.InEdgeIterator, field_name: str, field_value_object: object) → None`: 设置指定字段.  \r\n    *Sets the specified field.*\r\n  \r\n  - `SetFields(*args, **kwargs)`: 重载函数.\r\n    1. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str], field_value_strings: List[str]) → None`: 使用字符串表示的字段值设置指定字段.  \r\n       *Sets the fields specified by field_names with field values in string representation.*\r\n    2. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`: 使用新值设置指定字段.  \r\n       *Sets the fields specified by field_names with new values.*"
            },
            {
                "content": "1. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str], field_value_strings: List[str]) → None`: 使用字符串表示的字段值设置指定字段.  \r\n       *Sets the fields specified by field_names with field values in string representation.*\r\n    2. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`: 使用新值设置指定字段.  \r\n       *Sets the fields specified by field_names with new values.*\r\n    3. `SetFields(self: liblgraph_python_api.InEdgeIterator, value_dict: dict) → None`: 设置字段值，如 value_dict 中所示.  \r\n       *Sets the fields with values as specified in value_dict.*\r\n    4. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`: 使用字段值设置指定字段 ID.  \r\n       *Sets the fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.InEdgeIterator) → str`: 返回当前边的字符串表示."
            },
            {
                "content": "3. `SetFields(self: liblgraph_python_api.InEdgeIterator, value_dict: dict) → None`: 设置字段值，如 value_dict 中所示.  \r\n       *Sets the fields with values as specified in value_dict.*\r\n    4. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`: 使用字段值设置指定字段 ID.  \r\n       *Sets the fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.InEdgeIterator) → str`: 返回当前边的字符串表示.  \r\n    *Returns the string representation of the current edge.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.IndexSpec`\r\n`IndexSpec` 是索引规范。  \r\n*Index specification.*\r\n\r\n- **属性 Properties**:\r\n  - `field`: 字段的名称.  \r\n    *Name of the field.*\r\n  \r\n  - `label`: 标签的名称.  \r\n    *Name of the label.*\r\n  \r\n  - `unique`: 指示索引值是否唯一.  \r\n    *Whether the indexed values are unique.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.LGraphType`\r\n`LGraphType` 表示图数据库中的数据类型。  \r\n*Data types in the graph database.*\r\n\r\n- **成员 Members**:\r\n  - `NUL`: 表示空值.  \r\n    *NUL*"
            },
            {
                "content": "### `liblgraph_python_api.IndexSpec`\r\n`IndexSpec` 是索引规范。  \r\n*Index specification.*\r\n\r\n- **属性 Properties**:\r\n  - `field`: 字段的名称.  \r\n    *Name of the field.*\r\n  \r\n  - `label`: 标签的名称.  \r\n    *Name of the label.*\r\n  \r\n  - `unique`: 指示索引值是否唯一.  \r\n    *Whether the indexed values are unique.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.LGraphType`\r\n`LGraphType` 表示图数据库中的数据类型。  \r\n*Data types in the graph database.*\r\n\r\n- **成员 Members**:\r\n  - `NUL`: 表示空值.  \r\n    *NUL*\r\n  \r\n  - `INTEGER`: 整数类型.  \r\n    *INTEGER*\r\n  \r\n  - `FLOAT`: 浮点数类型.  \r\n    *FLOAT*\r\n  \r\n  - `DOUBLE`: 双精度浮点数类型.  \r\n    *DOUBLE*\r\n  \r\n  - `BOOLEAN`: 布尔类型.  \r\n    *BOOLEAN*\r\n  \r\n  - `STRING`: 字符串类型.  \r\n    *STRING*\r\n  \r\n  - `NODE`: 节点类型.  \r\n    *NODE*\r\n  \r\n  - `RELATIONSHIP`: 关系类型.  \r\n    *RELATIONSHIP*\r\n  \r\n  - `PATH`: 路径类型.  \r\n    *PATH*\r\n  \r\n  - `LIST`: 列表类型.  \r\n    *LIST*\r\n  \r\n  - `MAP`: 映射类型.  \r\n    *MAP*\r\n  \r\n  - `ANY`: 任意类型.  \r\n    *ANY*\r\n\r\n- **属性 Property**:\r\n  - `name`: 数据类型的名称.  \r\n    *Name of the data type.*"
            },
            {
                "content": "*INTEGER*\r\n  \r\n  - `FLOAT`: 浮点数类型.  \r\n    *FLOAT*\r\n  \r\n  - `DOUBLE`: 双精度浮点数类型.  \r\n    *DOUBLE*\r\n  \r\n  - `BOOLEAN`: 布尔类型.  \r\n    *BOOLEAN*\r\n  \r\n  - `STRING`: 字符串类型.  \r\n    *STRING*\r\n  \r\n  - `NODE`: 节点类型.  \r\n    *NODE*\r\n  \r\n  - `RELATIONSHIP`: 关系类型.  \r\n    *RELATIONSHIP*\r\n  \r\n  - `PATH`: 路径类型.  \r\n    *PATH*\r\n  \r\n  - `LIST`: 列表类型.  \r\n    *LIST*\r\n  \r\n  - `MAP`: 映射类型.  \r\n    *MAP*\r\n  \r\n  - `ANY`: 任意类型.  \r\n    *ANY*\r\n\r\n- **属性 Property**:\r\n  - `name`: 数据类型的名称.  \r\n    *Name of the data type.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.OutEdgeIterator`\r\n`OutEdgeIterator` 用于遍历源顶点的所有出边.  \r\n*Iterates through all the outgoing edges of the source vertex.*\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.OutEdgeIterator) → None`  \r\n    删除当前边. 如果还有其他出边，迭代器将指向下一个出边.  \r\n    *Deletes the current edge; the iterator points to the next outgoing edge if available.*\r\n\r\n  - `GetAllFields(self: liblgraph_python_api.OutEdgeIterator) → dict`  \r\n    获取所有字段值并返回为字典.  \r\n    *Gets all field values and returns them as a dict.*"
            },
            {
                "content": "`OutEdgeIterator` 用于遍历源顶点的所有出边.  \r\n*Iterates through all the outgoing edges of the source vertex.*\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.OutEdgeIterator) → None`  \r\n    删除当前边. 如果还有其他出边，迭代器将指向下一个出边.  \r\n    *Deletes the current edge; the iterator points to the next outgoing edge if available.*\r\n\r\n  - `GetAllFields(self: liblgraph_python_api.OutEdgeIterator) → dict`  \r\n    获取所有字段值并返回为字典.  \r\n    *Gets all field values and returns them as a dict.*\r\n\r\n  - `GetDst(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回目标顶点的 ID.  \r\n    *Returns the id of the destination vertex.*\r\n\r\n  - `GetEdgeId(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回当前边的 ID. 边 ID 在相同 (src, dst) 集合中是唯一的.  \r\n    *Returns the id of the current edge; edge id is unique across the same (src, dst) set.*\r\n\r\n  - `GetField(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `GetField(self: liblgraph_python_api.OutEdgeIterator, field_name: str) → object`  \r\n       获取指定字段名的字段值."
            },
            {
                "content": "返回目标顶点的 ID.  \r\n    *Returns the id of the destination vertex.*\r\n\r\n  - `GetEdgeId(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回当前边的 ID. 边 ID 在相同 (src, dst) 集合中是唯一的.  \r\n    *Returns the id of the current edge; edge id is unique across the same (src, dst) set.*\r\n\r\n  - `GetField(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `GetField(self: liblgraph_python_api.OutEdgeIterator, field_name: str) → object`  \r\n       获取指定字段名的字段值.  \r\n       *Gets the field value specified by field_name.*\r\n    2. `GetField(self: liblgraph_python_api.OutEdgeIterator, field_id: int) → object`  \r\n       获取指定字段 ID 的字段值.  \r\n       *Gets the field value specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `GetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str]) → list`  \r\n       获取指定字段名的字段值.  \r\n       *Gets field values for the specified field_names.*"
            },
            {
                "content": "获取指定字段名的字段值.  \r\n       *Gets the field value specified by field_name.*\r\n    2. `GetField(self: liblgraph_python_api.OutEdgeIterator, field_id: int) → object`  \r\n       获取指定字段 ID 的字段值.  \r\n       *Gets the field value specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `GetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str]) → list`  \r\n       获取指定字段名的字段值.  \r\n       *Gets field values for the specified field_names.*\r\n    2. `GetFields(self: liblgraph_python_api.OutEdgeIterator, field_ids: List[int]) → list`  \r\n       获取指定字段 ID 的字段值.  \r\n       *Gets field values for the specified field_ids.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.OutEdgeIterator) → str`  \r\n    返回边的标签名称.  \r\n    *Returns the name of the edge label.*\r\n\r\n  - `GetLabelId(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回边标签的 ID.  \r\n    *Returns the id of the edge label.*\r\n\r\n  - `GetSrc(self: liblgraph_python_api.OutEdgeIterator) → int`"
            },
            {
                "content": "2. `GetFields(self: liblgraph_python_api.OutEdgeIterator, field_ids: List[int]) → list`  \r\n       获取指定字段 ID 的字段值.  \r\n       *Gets field values for the specified field_ids.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.OutEdgeIterator) → str`  \r\n    返回边的标签名称.  \r\n    *Returns the name of the edge label.*\r\n\r\n  - `GetLabelId(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回边标签的 ID.  \r\n    *Returns the id of the edge label.*\r\n\r\n  - `GetSrc(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回源顶点的 ID.  \r\n    *Returns the id of the source vertex.*\r\n\r\n  - `GetUid(self: liblgraph_python_api.OutEdgeIterator) → liblgraph_python_api.EdgeUid`  \r\n    返回边的 EdgeUid.  \r\n    *Returns the EdgeUid of the edge.*\r\n\r\n  - `Goto(self: liblgraph_python_api.OutEdgeIterator, euid: liblgraph_python_api.EdgeUid, nearest: bool = False) → bool`  \r\n    跳转到指定的出边.  \r\n    *Goes to the outgoing edge specified by euid.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.OutEdgeIterator) → bool`  \r\n    检查迭代器是否有效."
            },
            {
                "content": "返回源顶点的 ID.  \r\n    *Returns the id of the source vertex.*\r\n\r\n  - `GetUid(self: liblgraph_python_api.OutEdgeIterator) → liblgraph_python_api.EdgeUid`  \r\n    返回边的 EdgeUid.  \r\n    *Returns the EdgeUid of the edge.*\r\n\r\n  - `Goto(self: liblgraph_python_api.OutEdgeIterator, euid: liblgraph_python_api.EdgeUid, nearest: bool = False) → bool`  \r\n    跳转到指定的出边.  \r\n    *Goes to the outgoing edge specified by euid.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.OutEdgeIterator) → bool`  \r\n    检查迭代器是否有效.  \r\n    *Tells whether the iterator is valid.*\r\n\r\n  - `Next(self: liblgraph_python_api.OutEdgeIterator) → bool`  \r\n    跳转到当前源顶点的下一个出边. 如果没有更多的出边，迭代器变为无效.  \r\n    *Goes to the next outgoing edge from the current source vertex.*\r\n\r\n  - `SetField(self: liblgraph_python_api.OutEdgeIterator, field_name: str, field_value_object: object) → None`  \r\n    设置指定字段的值.  \r\n    *Sets the specified field.*\r\n\r\n  - `SetFields(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:"
            },
            {
                "content": "检查迭代器是否有效.  \r\n    *Tells whether the iterator is valid.*\r\n\r\n  - `Next(self: liblgraph_python_api.OutEdgeIterator) → bool`  \r\n    跳转到当前源顶点的下一个出边. 如果没有更多的出边，迭代器变为无效.  \r\n    *Goes to the next outgoing edge from the current source vertex.*\r\n\r\n  - `SetField(self: liblgraph_python_api.OutEdgeIterator, field_name: str, field_value_object: object) → None`  \r\n    设置指定字段的值.  \r\n    *Sets the specified field.*\r\n\r\n  - `SetFields(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str], field_value_strings: List[str]) → None`  \r\n       用字符串表示的字段值设置指定字段名.  \r\n       *Sets fields specified by field_names with field values in string representation.*\r\n    2. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       用 FieldData 设置指定字段名的字段值.  \r\n       *Sets fields specified by field_names with field values in FieldData.*"
            },
            {
                "content": "1. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str], field_value_strings: List[str]) → None`  \r\n       用字符串表示的字段值设置指定字段名.  \r\n       *Sets fields specified by field_names with field values in string representation.*\r\n    2. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       用 FieldData 设置指定字段名的字段值.  \r\n       *Sets fields specified by field_names with field values in FieldData.*\r\n    3. `SetFields(self: liblgraph_python_api.OutEdgeIterator, value_dict: dict) → None`  \r\n       根据字典设置字段值.  \r\n       *Sets field values as specified in value_dict.*\r\n    4. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       设置指定字段 ID 的字段值.  \r\n       *Sets fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.OutEdgeIterator) → str`  \r\n    返回当前边的字符串表示."
            },
            {
                "content": "3. `SetFields(self: liblgraph_python_api.OutEdgeIterator, value_dict: dict) → None`  \r\n       根据字典设置字段值.  \r\n       *Sets field values as specified in value_dict.*\r\n    4. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       设置指定字段 ID 的字段值.  \r\n       *Sets fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.OutEdgeIterator) → str`  \r\n    返回当前边的字符串表示.  \r\n    *Returns the string representation of the current edge.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.PluginErrorCode`\r\n`PluginErrorCode` 表示插件的错误代码.  \r\n*ErrorCode of the plugin.*\r\n\r\n- **成员 Members**:\r\n  - `SUCCESS`  \r\n    表示成功.  \r\n    *Indicates success.*\r\n  \r\n  - `INPUT_ERR`  \r\n    表示输入错误.  \r\n    *Indicates input error.*\r\n  \r\n  - `INTERNAL_ERR`  \r\n    表示内部错误.  \r\n    *Indicates internal error.*\r\n  \r\n  - `SUCCESS_WITH_SIGNATURE`  \r\n    表示成功但有签名.  \r\n    *Indicates success with signature.*\r\n\r\n- **属性 Property**:\r\n  - `name`"
            },
            {
                "content": "### `liblgraph_python_api.PluginErrorCode`\r\n`PluginErrorCode` 表示插件的错误代码.  \r\n*ErrorCode of the plugin.*\r\n\r\n- **成员 Members**:\r\n  - `SUCCESS`  \r\n    表示成功.  \r\n    *Indicates success.*\r\n  \r\n  - `INPUT_ERR`  \r\n    表示输入错误.  \r\n    *Indicates input error.*\r\n  \r\n  - `INTERNAL_ERR`  \r\n    表示内部错误.  \r\n    *Indicates internal error.*\r\n  \r\n  - `SUCCESS_WITH_SIGNATURE`  \r\n    表示成功但有签名.  \r\n    *Indicates success with signature.*\r\n\r\n- **属性 Property**:\r\n  - `name`  \r\n    获取错误代码的名称.  \r\n    *Gets the name of the error code.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.Transaction`\r\n`Transaction` 代表一个图数据库事务.在嵌入模式下，所有操作都在事务中执行，因此享有事务的优势，如原子性和隔离性。您可以随时提交或中止事务，而无需担心其已产生的副作用。事务可以被提交或中止，之后它将被销毁并变得无效。在关闭相应的 GraphDB 之前，请确保您已经销毁了每个事务。事务还会跟踪已创建的迭代器，并在销毁期间释放所有迭代器。"
            },
            {
                "content": "- `INTERNAL_ERR`  \r\n    表示内部错误.  \r\n    *Indicates internal error.*\r\n  \r\n  - `SUCCESS_WITH_SIGNATURE`  \r\n    表示成功但有签名.  \r\n    *Indicates success with signature.*\r\n\r\n- **属性 Property**:\r\n  - `name`  \r\n    获取错误代码的名称.  \r\n    *Gets the name of the error code.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.Transaction`\r\n`Transaction` 代表一个图数据库事务.在嵌入模式下，所有操作都在事务中执行，因此享有事务的优势，如原子性和隔离性。您可以随时提交或中止事务，而无需担心其已产生的副作用。事务可以被提交或中止，之后它将被销毁并变得无效。在关闭相应的 GraphDB 之前，请确保您已经销毁了每个事务。事务还会跟踪已创建的迭代器，并在销毁期间释放所有迭代器。  \r\n*In embedded mode, all operations are performed in transactions, enjoying atomicity and isolation. You can commit or abort a transaction at any time without worrying about the side effects it has already made. Transactions can be either committed or aborted, after which they become invalid. Make sure you have destructed every transaction before closing the corresponding GraphDB. Transactions also track the created iterators and release all iterators during destruction.*\r\n\r\n- **方法 Methods**:"
            },
            {
                "content": "*In embedded mode, all operations are performed in transactions, enjoying atomicity and isolation. You can commit or abort a transaction at any time without worrying about the side effects it has already made. Transactions can be either committed or aborted, after which they become invalid. Make sure you have destructed every transaction before closing the corresponding GraphDB. Transactions also track the created iterators and release all iterators during destruction.*\r\n\r\n- **方法 Methods**:\r\n  - `Abort(self: liblgraph_python_api.Transaction) → None`  \r\n    放弃当前事务.  \r\n    *Aborts the current transaction.*\r\n\r\n  - `AddEdge(*args, **kwargs)`  \r\n    添加边. 有多个重载版本:  \r\n    1. `AddEdge(self, src: int, dst: int, label_name: str, field_names: List[str], field_value_strings: List[str]) → liblgraph_python_api.EdgeUid`  \r\n       从 `src` 到 `dst` 添加边，返回新边的 ID。 添加边从 `src` 到 `dst`，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。"
            },
            {
                "content": "- **方法 Methods**:\r\n  - `Abort(self: liblgraph_python_api.Transaction) → None`  \r\n    放弃当前事务.  \r\n    *Aborts the current transaction.*\r\n\r\n  - `AddEdge(*args, **kwargs)`  \r\n    添加边. 有多个重载版本:  \r\n    1. `AddEdge(self, src: int, dst: int, label_name: str, field_names: List[str], field_value_strings: List[str]) → liblgraph_python_api.EdgeUid`  \r\n       从 `src` 到 `dst` 添加边，返回新边的 ID。 添加边从 `src` 到 `dst`，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。  \r\n       *Adds an edge from src to dst with the specified label name, field names, and field values in string format. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n\r\n    2. `AddEdge(self, src: int, dst: int, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签名、字段名和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。"
            },
            {
                "content": "*Adds an edge from src to dst with the specified label name, field names, and field values in string format. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n\r\n    2. `AddEdge(self, src: int, dst: int, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签名、字段名和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds an edge from src to dst with the specified label name, field names, and field values. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n \r\n    3. `AddEdge(self, src: int, dst: int, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签 ID、字段 ID 和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。"
            },
            {
                "content": "*Adds an edge from src to dst with the specified label name, field names, and field values. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n \r\n    3. `AddEdge(self, src: int, dst: int, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签 ID、字段 ID 和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds an edge from src to dst with the specified label id, field ids, and field values. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n\r\n    4. `AddEdge(self, src: int, dst: int, label_name: str, value_dict: dict) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签，并填充 `value_dict` 中给定的值。返回新添加边的 ID。未在 `value_dict` 中的字段被视为 null。"
            },
            {
                "content": "添加边从 `src` 到 `dst`，使用指定的标签 ID、字段 ID 和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds an edge from src to dst with the specified label id, field ids, and field values. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n\r\n    4. `AddEdge(self, src: int, dst: int, label_name: str, value_dict: dict) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签，并填充 `value_dict` 中给定的值。返回新添加边的 ID。未在 `value_dict` 中的字段被视为 null。  \r\n      *Adds an edge from src to dst with the specified label, and fill it with the values given in value_dict. Returns the id of the newly added edge. Fields that are not in value_dict are considered null.*\r\n\r\n\r\n  - `AddVertex(*args, **kwargs)`  \r\n    添加顶点. 有多个重载版本:  \r\n    1. `AddVertex(self, label_name: str, field_names: List[str], field_value_strings: List[str]) → int`  \r\n       添加顶点，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。"
            },
            {
                "content": "*Adds an edge from src to dst with the specified label, and fill it with the values given in value_dict. Returns the id of the newly added edge. Fields that are not in value_dict are considered null.*\r\n\r\n\r\n  - `AddVertex(*args, **kwargs)`  \r\n    添加顶点. 有多个重载版本:  \r\n    1. `AddVertex(self, label_name: str, field_names: List[str], field_value_strings: List[str]) → int`  \r\n       添加顶点，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label name, field names, and field values in string format. Returns the id of the newly added vertex. Fields that are not in field_names are considered null.*\r\n\r\n    2. `AddVertex(self, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → int`  \r\n       添加顶点，使用指定的标签名、字段名和字段值。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。"
            },
            {
                "content": "添加顶点，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label name, field names, and field values in string format. Returns the id of the newly added vertex. Fields that are not in field_names are considered null.*\r\n\r\n    2. `AddVertex(self, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → int`  \r\n       添加顶点，使用指定的标签名、字段名和字段值。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label name, field names, and field values. Returns the id of the newly added vertex. Fields that are not in field_names are considered null.*\r\n\r\n    3. `AddVertex(self, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → int`  \r\n       添加顶点，使用指定的标签 ID、字段 ID 和字段值。返回新添加顶点的 ID。未在 `field_ids` 中的字段被视为 null。"
            },
            {
                "content": "添加顶点，使用指定的标签名、字段名和字段值。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label name, field names, and field values. Returns the id of the newly added vertex. Fields that are not in field_names are considered null.*\r\n\r\n    3. `AddVertex(self, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → int`  \r\n       添加顶点，使用指定的标签 ID、字段 ID 和字段值。返回新添加顶点的 ID。未在 `field_ids` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label ids, field ids, and field values. Returns the id of the newly added vertex. Fields that are not in field_ids are considered null.*\r\n\r\n    4. `AddVertex(self, label_name: str, value_dict: dict) → int`  \r\n       添加顶点，使用指定的标签名，并根据 `value_dict` 中指定的值进行设置。返回新添加顶点的 ID。未在字典中指定的字段被视为 null。  \r\n      *Adds a vertex with the specified label name and set the value as specified in value_dict. Returns the id of the newly added vertex. Fields that are not specified in the dict are considered null.*"
            },
            {
                "content": "4. `AddVertex(self, label_name: str, value_dict: dict) → int`  \r\n       添加顶点，使用指定的标签名，并根据 `value_dict` 中指定的值进行设置。返回新添加顶点的 ID。未在字典中指定的字段被视为 null。  \r\n      *Adds a vertex with the specified label name and set the value as specified in value_dict. Returns the id of the newly added vertex. Fields that are not specified in the dict are considered null.*\r\n\r\n\r\n  - `Commit(self: liblgraph_python_api.Transaction) → None`  \r\n    提交当前事务.  \r\n    *Commits the current transaction.*\r\n\r\n  - `DumpGraph(self: liblgraph_python_api.Transaction) → None`  \r\n    打印整个图的字符串表示.  \r\n    *Prints the string representation of the whole graph.*\r\n\r\n  - `GetEdgeFieldId(*args, **kwargs)`  \r\n    获取边字段 ID. 有多个重载版本:  \r\n    1. `GetEdgeFieldId(self, label_id: int, field_name: str) → int`  \r\n       获取与此 (label_id, field_name) 关联的边字段 ID。  \r\n      *Gets the edge field id associated with this (label_id, field_name).*\r\n    2. `GetEdgeFieldId(self, label_id: int, field_names: List[str]) → List[int]`  \r\n       获取多个字段的边字段 ID."
            },
            {
                "content": "打印整个图的字符串表示.  \r\n    *Prints the string representation of the whole graph.*\r\n\r\n  - `GetEdgeFieldId(*args, **kwargs)`  \r\n    获取边字段 ID. 有多个重载版本:  \r\n    1. `GetEdgeFieldId(self, label_id: int, field_name: str) → int`  \r\n       获取与此 (label_id, field_name) 关联的边字段 ID。  \r\n      *Gets the edge field id associated with this (label_id, field_name).*\r\n    2. `GetEdgeFieldId(self, label_id: int, field_names: List[str]) → List[int]`  \r\n       获取多个字段的边字段 ID.\r\n       *Gets the edge field ids associated with this (label_id, field_names).*\r\n\r\n  - `GetEdgeLabelId(self: liblgraph_python_api.Transaction, label_name: str) → int`  \r\n    获取边标签 ID.  \r\n    *Gets the edge label ID associated with this label.*\r\n\r\n  - `GetEdgeSchema(self: liblgraph_python_api.Transaction, label_name: str) → List[liblgraph_python_api.FieldSpec]`  \r\n    获取边标签的模式说明.  \r\n    *Gets the schema specification of the edge label.*\r\n\r\n  - `GetInEdgeIterator(*args, **kwargs)`  \r\n    获取入边迭代器. 有多个重载版本:"
            },
            {
                "content": "*Gets the edge field ids associated with this (label_id, field_names).*\r\n\r\n  - `GetEdgeLabelId(self: liblgraph_python_api.Transaction, label_name: str) → int`  \r\n    获取边标签 ID.  \r\n    *Gets the edge label ID associated with this label.*\r\n\r\n  - `GetEdgeSchema(self: liblgraph_python_api.Transaction, label_name: str) → List[liblgraph_python_api.FieldSpec]`  \r\n    获取边标签的模式说明.  \r\n    *Gets the schema specification of the edge label.*\r\n\r\n  - `GetInEdgeIterator(*args, **kwargs)`  \r\n    获取入边迭代器. 有多个重载版本:  \r\n    1. `GetInEdgeIterator(self, euid: liblgraph_python_api.EdgeUid, nearest: bool) → lgraph_api::InEdgeIterator`  \r\n       获取指向具有 EdgeUid==euid 的入边的 InEdgeIterator。  \r\n      *Gets an InEdgeIterator pointing to the in-edge of vertex dst with EdgeUid==euid.*\r\n\r\n    2. `GetInEdgeIterator(self, src: int, dst: int, label_id: int) → lgraph_api::InEdgeIterator`  \r\n        获取从 src 到 dst 的 InEdgeIterator，标签由 label_id 指定。  \r\n      *Gets an InEdgeIterator from src to dst with the label specified by label_id.*"
            },
            {
                "content": "1. `GetInEdgeIterator(self, euid: liblgraph_python_api.EdgeUid, nearest: bool) → lgraph_api::InEdgeIterator`  \r\n       获取指向具有 EdgeUid==euid 的入边的 InEdgeIterator。  \r\n      *Gets an InEdgeIterator pointing to the in-edge of vertex dst with EdgeUid==euid.*\r\n\r\n    2. `GetInEdgeIterator(self, src: int, dst: int, label_id: int) → lgraph_api::InEdgeIterator`  \r\n        获取从 src 到 dst 的 InEdgeIterator，标签由 label_id 指定。  \r\n      *Gets an InEdgeIterator from src to dst with the label specified by label_id.*\r\n\r\n\r\n  - `GetNumEdgeLabels(self: liblgraph_python_api.Transaction) → int`  \r\n    获取边标签数量.  \r\n    *Gets the number of edge labels.*\r\n\r\n  - `GetNumVertexLabels(self: liblgraph_python_api.Transaction) → int`  \r\n    获取顶点标签数量.  \r\n    *Gets the number of vertex labels.*\r\n\r\n  - `GetOutEdgeIterator(*args, **kwargs)`  \r\n    获取指向源顶点的出边迭代器。  \r\n    *Gets an OutEdgeIterator pointing to the out-edge of vertex src.*"
            },
            {
                "content": "*Gets an InEdgeIterator from src to dst with the label specified by label_id.*\r\n\r\n\r\n  - `GetNumEdgeLabels(self: liblgraph_python_api.Transaction) → int`  \r\n    获取边标签数量.  \r\n    *Gets the number of edge labels.*\r\n\r\n  - `GetNumVertexLabels(self: liblgraph_python_api.Transaction) → int`  \r\n    获取顶点标签数量.  \r\n    *Gets the number of vertex labels.*\r\n\r\n  - `GetOutEdgeIterator(*args, **kwargs)`  \r\n    获取指向源顶点的出边迭代器。  \r\n    *Gets an OutEdgeIterator pointing to the out-edge of vertex src.*\r\n    1. `GetOutEdgeIterator(self, euid: liblgraph_python_api.EdgeUid, nearest: bool) → lgraph_api::OutEdgeIterator`  \r\n       获取指向具有 EdgeUid==euid 的出边的 OutEdgeIterator。  \r\n      *Gets an OutEdgeIterator pointing to the out-edge of vertex src with EdgeUid==euid.*\r\n\r\n    2. `GetOutEdgeIterator(self, src: int, dst: int, label_id: int) → lgraph_api::OutEdgeIterator`  \r\n       获取从 src 到 dst 的 OutEdgeIterator，标签由 label_id 指定。  \r\n      *Gets an OutEdgeIterator from src to dst with the label specified by label_id.*"
            },
            {
                "content": "获取指向具有 EdgeUid==euid 的出边的 OutEdgeIterator。  \r\n      *Gets an OutEdgeIterator pointing to the out-edge of vertex src with EdgeUid==euid.*\r\n\r\n    2. `GetOutEdgeIterator(self, src: int, dst: int, label_id: int) → lgraph_api::OutEdgeIterator`  \r\n       获取从 src 到 dst 的 OutEdgeIterator，标签由 label_id 指定。  \r\n      *Gets an OutEdgeIterator from src to dst with the label specified by label_id.*\r\n\r\n\r\n  - `GetVertexByUniqueIndex(*args, **kwargs)`  \r\n    通过唯一索引获取顶点迭代器. 有多个重载版本:  \r\n    1. `GetVertexByUniqueIndex(self, label_name: str, field_name: str, field_value_string: str) → lgraph_api::VertexIterator`  \r\n       *Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_name specifies the name of the indexed label. field_name specifies the name of the indexed field. field_value_string specifies the string representation of the indexed field value.*\r\n    2. `GetVertexByUniqueIndex(self, label_name: str, field_name: str, field_value: object) → lgraph_api::VertexIterator`"
            },
            {
                "content": "*Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_name specifies the name of the indexed label. field_name specifies the name of the indexed field. field_value_string specifies the string representation of the indexed field value.*\r\n    2. `GetVertexByUniqueIndex(self, label_name: str, field_name: str, field_value: object) → lgraph_api::VertexIterator`  \r\n       *Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_name specifies the name of the indexed label. field_name specifies the name of the indexed field. field_value specifies the indexed field value.*\r\n    3. `GetVertexByUniqueIndex(self, label_id: int, field_id: int, field_value: liblgraph_python_api.FieldData) → lgraph_api::VertexIterator`"
            },
            {
                "content": "*Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_name specifies the name of the indexed label. field_name specifies the name of the indexed field. field_value specifies the indexed field value.*\r\n    3. `GetVertexByUniqueIndex(self, label_id: int, field_id: int, field_value: liblgraph_python_api.FieldData) → lgraph_api::VertexIterator`  \r\n       *Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. field_value is a FieldData specifying the indexed field value. *\r\n\r\n  - `GetVertexFieldId(self: liblgraph_python_api.Transaction, label_id: int, field_name: str) → int`  \r\n    获取与此 (label_id, field_name) 关联的顶点字段 ID。  \r\n    *Gets the vertex field ID associated with this (label_id, field_name).*\r\n\r\n  - `GetVertexFieldIds(self: liblgraph_python_api.Transaction, label_id: int, field_names: List[str]) → List[int]`"
            },
            {
                "content": "- `GetVertexFieldId(self: liblgraph_python_api.Transaction, label_id: int, field_name: str) → int`  \r\n    获取与此 (label_id, field_name) 关联的顶点字段 ID。  \r\n    *Gets the vertex field ID associated with this (label_id, field_name).*\r\n\r\n  - `GetVertexFieldIds(self: liblgraph_python_api.Transaction, label_id: int, field_names: List[str]) → List[int]`  \r\n    获取与此 (label_id, field_names) 关联的顶点字段 ID。  \r\n    *Gets the vertex field IDs associated with this (label_id, field_names).*\r\n\r\n  - `GetVertexIndexIterator(*args, **kwargs)`  \r\n    获取顶点索引迭代器. 有多个重载版本:  \r\n    1. `GetVertexIndexIterator(self, label_id: int, field_id: int, key_start: liblgraph_python_api.FieldData, key_end: liblgraph_python_api.FieldData) → lgraph_api::VertexIndexIterator`"
            },
            {
                "content": "- `GetVertexFieldIds(self: liblgraph_python_api.Transaction, label_id: int, field_names: List[str]) → List[int]`  \r\n    获取与此 (label_id, field_names) 关联的顶点字段 ID。  \r\n    *Gets the vertex field IDs associated with this (label_id, field_names).*\r\n\r\n  - `GetVertexIndexIterator(*args, **kwargs)`  \r\n    获取顶点索引迭代器. 有多个重载版本:  \r\n    1. `GetVertexIndexIterator(self, label_id: int, field_id: int, key_start: liblgraph_python_api.FieldData, key_end: liblgraph_python_api.FieldData) → lgraph_api::VertexIndexIterator`  \r\n       Gets an VertexIndexIterator pointing to the indexed item which has index value [key_start, key_end]. key_start=key_end=v returns an iterator pointing to all vertexes that has field value v. label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. key_start is a FieldData containing the minimum indexed value. key_end is a FieldData containing the maximum indexed value."
            },
            {
                "content": "Gets an VertexIndexIterator pointing to the indexed item which has index value [key_start, key_end]. key_start=key_end=v returns an iterator pointing to all vertexes that has field value v. label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. key_start is a FieldData containing the minimum indexed value. key_end is a FieldData containing the maximum indexed value.\r\n    2. `GetVertexIndexIterator(self, label_id: int, field_id: int, value: liblgraph_python_api.FieldData) → lgraph_api::VertexIndexIterator`  \r\n       label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. value is a FieldData containing the indexed value.\r\n\r\n  - `GetVertexIterator(*args, **kwargs)`  \r\n    获取顶点迭代器. 有多个重载版本:  \r\n    1. `GetVertexIterator(self: liblgraph_python_api.Transaction) → lgraph_api::VertexIterator`  \r\n       返回指向第一个顶点的迭代器.  \r\n    2. `GetVertexIterator(self: liblgraph_python_api.Transaction, vid: int) → lgraph_api::VertexIterator`"
            },
            {
                "content": "label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. value is a FieldData containing the indexed value.\r\n\r\n  - `GetVertexIterator(*args, **kwargs)`  \r\n    获取顶点迭代器. 有多个重载版本:  \r\n    1. `GetVertexIterator(self: liblgraph_python_api.Transaction) → lgraph_api::VertexIterator`  \r\n       返回指向第一个顶点的迭代器.  \r\n    2. `GetVertexIterator(self: liblgraph_python_api.Transaction, vid: int) → lgraph_api::VertexIterator`  \r\n       返回指向指定顶点的迭代器.  \r\n\r\n  - `GetVertexLabelId(self: liblgraph_python_api.Transaction, label_name: str) → int`  \r\n    获取顶点标签 ID.  \r\n    *Gets the vertex label ID associated with this label.*\r\n\r\n  - `GetVertexSchema(self: liblgraph_python_api.Transaction, label_name: str) → List[liblgraph_python_api.FieldSpec]`  \r\n    获取顶点标签的模式说明.  \r\n    *Gets the schema specification of the vertex label.*\r\n\r\n  - `IsReadOnly(self: liblgraph_python_api.Transaction) → bool`  \r\n    检查事务是否为只读.  \r\n    *Checks if the transaction is read-only.*"
            },
            {
                "content": "- `GetVertexLabelId(self: liblgraph_python_api.Transaction, label_name: str) → int`  \r\n    获取顶点标签 ID.  \r\n    *Gets the vertex label ID associated with this label.*\r\n\r\n  - `GetVertexSchema(self: liblgraph_python_api.Transaction, label_name: str) → List[liblgraph_python_api.FieldSpec]`  \r\n    获取顶点标签的模式说明.  \r\n    *Gets the schema specification of the vertex label.*\r\n\r\n  - `IsReadOnly(self: liblgraph_python_api.Transaction) → bool`  \r\n    检查事务是否为只读.  \r\n    *Checks if the transaction is read-only.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.Transaction) → bool`  \r\n    检查事务是否有效.  \r\n    *Checks if the transaction is valid.*\r\n\r\n  - `IsVertexIndexed(self: liblgraph_python_api.Transaction, label_name: str, field_name: str) → bool`  \r\n    检查指定字段是否被索引.  \r\n    *Tells whether the specified field is indexed.*\r\n\r\n  - `ListEdgeLabels(self: liblgraph_python_api.Transaction) → List[str]`  \r\n    获取所有边标签的列表.  \r\n    *Gets the list of all edge labels in the DB.*"
            },
            {
                "content": "*Checks if the transaction is read-only.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.Transaction) → bool`  \r\n    检查事务是否有效.  \r\n    *Checks if the transaction is valid.*\r\n\r\n  - `IsVertexIndexed(self: liblgraph_python_api.Transaction, label_name: str, field_name: str) → bool`  \r\n    检查指定字段是否被索引.  \r\n    *Tells whether the specified field is indexed.*\r\n\r\n  - `ListEdgeLabels(self: liblgraph_python_api.Transaction) → List[str]`  \r\n    获取所有边标签的列表.  \r\n    *Gets the list of all edge labels in the DB.*\r\n\r\n  - `ListVertexLabels(self: liblgraph_python_api.Transaction) → List[str]`  \r\n    获取所有顶点标签的列表.  \r\n    *Gets the list of all vertex labels in the DB.*\r\n\r\n  - `UpsertEdge(*args, **kwargs)`  \r\n    更新或插入边. 有多个重载版本:  \r\n    \r\n    1. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, field_names: List[str], field_value_strings: List[str]) → bool`"
            },
            {
                "content": "获取所有边标签的列表.  \r\n    *Gets the list of all edge labels in the DB.*\r\n\r\n  - `ListVertexLabels(self: liblgraph_python_api.Transaction) → List[str]`  \r\n    获取所有顶点标签的列表.  \r\n    *Gets the list of all vertex labels in the DB.*\r\n\r\n  - `UpsertEdge(*args, **kwargs)`  \r\n    更新或插入边. 有多个重载版本:  \r\n    \r\n    1. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, field_names: List[str], field_value_strings: List[str]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签名、字段名和字段值（字符串格式）。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label name, field names, and field values in string format. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in field_names are considered null.*"
            },
            {
                "content": "从 `src` 到 `dst` 插入或更新一条边，使用指定的标签名、字段名和字段值（字符串格式）。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label name, field names, and field values in string format. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in field_names are considered null.*\r\n\r\n    2. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签 ID、字段 ID 和字段值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。"
            },
            {
                "content": "2. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签 ID、字段 ID 和字段值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label id, field ids, and field values. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in field_names are considered null.*\r\n\r\n    3. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签名、字段名和字段值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。"
            },
            {
                "content": "3. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签名、字段名和字段值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label name, field names, and field values. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in field_names are considered null.*\r\n\r\n    4. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, value_dict: dict) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签，并填充 `value_dict` 中给定的值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `value_dict` 中的字段被视为 null。"
            },
            {
                "content": "4. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, value_dict: dict) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签，并填充 `value_dict` 中给定的值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `value_dict` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label, and fill it with the values given in value_dict. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in value_dict are considered null.*\r\n \r\n\r\n  - `VertexToString(self: liblgraph_python_api.Transaction, vid: int) → str`  \r\n    返回指定顶点的字符串表示.  \r\n    *Returns the string representation of the vertex specified by vid.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.VertexIndexIterator`\r\n`VertexIndexIterator` 用于检索索引顶点的 ID。顶点 ID 按照 (index_value, vertex_id) 的升序排序。"
            },
            {
                "content": "- `VertexToString(self: liblgraph_python_api.Transaction, vid: int) → str`  \r\n    返回指定顶点的字符串表示.  \r\n    *Returns the string representation of the vertex specified by vid.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.VertexIndexIterator`\r\n`VertexIndexIterator` 用于检索索引顶点的 ID。顶点 ID 按照 (index_value, vertex_id) 的升序排序。\r\n *VertexIndexIterator can be used to retrieve the id of indexed vertices. Vertex ids are sorted in ascending order of (index_value, vertex_id).*\r\n- **方法 Methods**:\r\n  - `GetIndexValue(self: liblgraph_python_api.VertexIndexIterator) → liblgraph_python_api.FieldData`  \r\n    获取索引值。由于顶点 ID 按照 (index_value, vertex_id) 的顺序排序，调用 `Next()` 可能会改变当前的索引值。\r\n    *Gets the indexed value. Since vertex ids are sorted in (index_value, vertex_id) order, calling Next() may change the current indexed value.*\r\n\r\n  - `GetVid(self: liblgraph_python_api.VertexIndexIterator) → int`  \r\n    获取当前指向的顶点 ID。\r\n    *Gets the id of the vertex currently pointed to.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.VertexIndexIterator) → bool`"
            },
            {
                "content": "获取索引值。由于顶点 ID 按照 (index_value, vertex_id) 的顺序排序，调用 `Next()` 可能会改变当前的索引值。\r\n    *Gets the indexed value. Since vertex ids are sorted in (index_value, vertex_id) order, calling Next() may change the current indexed value.*\r\n\r\n  - `GetVid(self: liblgraph_python_api.VertexIndexIterator) → int`  \r\n    获取当前指向的顶点 ID。\r\n    *Gets the id of the vertex currently pointed to.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.VertexIndexIterator) → bool`  \r\n    检查此迭代器是否有效。\r\n    *Tells whether this iterator is valid.*\r\n\r\n  - `Next(self: liblgraph_python_api.VertexIndexIterator) → bool`  \r\n    移动到下一个索引的顶点 ID。如果在指定的键范围内没有更多顶点，迭代器将变为无效。\r\n    *Goes to the next indexed vid. If there is no more vertex within the specified key range, the iterator becomes invalid.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.VertexIterator`\r\n`VertexIterator` 可以用来检索一个顶点的信息，或扫描多个顶点。顶点按照其 ID 的升序排列。\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.VertexIterator) → Tuple[int, int]`  \r\n    删除当前顶点。如果有下一个顶点，迭代器将指向下一个顶点。"
            },
            {
                "content": "- `Next(self: liblgraph_python_api.VertexIndexIterator) → bool`  \r\n    移动到下一个索引的顶点 ID。如果在指定的键范围内没有更多顶点，迭代器将变为无效。\r\n    *Goes to the next indexed vid. If there is no more vertex within the specified key range, the iterator becomes invalid.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.VertexIterator`\r\n`VertexIterator` 可以用来检索一个顶点的信息，或扫描多个顶点。顶点按照其 ID 的升序排列。\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.VertexIterator) → Tuple[int, int]`  \r\n    删除当前顶点。如果有下一个顶点，迭代器将指向下一个顶点。  \r\n    *Deletes current vertex. The iterator will point to the next vertex if there is any.*\r\n\r\n  - `GetAllFields(self: liblgraph_python_api.VertexIterator) → dict`  \r\n    获取所有字段值，并以字典形式返回。  \r\n    *Gets all the field values and return as a dict.*\r\n\r\n  - `GetField(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetField(self: liblgraph_python_api.VertexIterator, field_name: str) → object`  \r\n       获取指定字段名的字段值。  \r\n       *Gets the field value of the field specified by field_name.*"
            },
            {
                "content": "*Deletes current vertex. The iterator will point to the next vertex if there is any.*\r\n\r\n  - `GetAllFields(self: liblgraph_python_api.VertexIterator) → dict`  \r\n    获取所有字段值，并以字典形式返回。  \r\n    *Gets all the field values and return as a dict.*\r\n\r\n  - `GetField(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetField(self: liblgraph_python_api.VertexIterator, field_name: str) → object`  \r\n       获取指定字段名的字段值。  \r\n       *Gets the field value of the field specified by field_name.*\r\n\r\n    2. `GetField(self: liblgraph_python_api.VertexIterator, field_id: int) → object`  \r\n       获取指定字段 ID 的字段值。  \r\n       *Gets the field value of the field specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str]) → list`  \r\n       获取指定字段名的字段值。  \r\n       *Gets the field values of the fields specified by field_names.*\r\n\r\n    2. `GetFields(self: liblgraph_python_api.VertexIterator, field_ids: List[int]) → list`  \r\n       获取指定字段 ID 的字段值。"
            },
            {
                "content": "获取指定字段 ID 的字段值。  \r\n       *Gets the field value of the field specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str]) → list`  \r\n       获取指定字段名的字段值。  \r\n       *Gets the field values of the fields specified by field_names.*\r\n\r\n    2. `GetFields(self: liblgraph_python_api.VertexIterator, field_ids: List[int]) → list`  \r\n       获取指定字段 ID 的字段值。  \r\n       *Gets the field values of the fields specified by field_ids.*\r\n\r\n  - `GetId(self: liblgraph_python_api.VertexIterator) → int`  \r\n    获取此顶点的整数 ID。GraphDB 为每个顶点分配一个整数 ID。  \r\n    *Gets the integer id of this vertex. GraphDB assigns an integer id for each vertex.*\r\n\r\n  - `GetInEdgeIterator(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetInEdgeIterator(self: liblgraph_python_api.VertexIterator) → lgraph_api::InEdgeIterator`  \r\n       获取指向此顶点的第一个入边的 InEdgeIterator。  \r\n       *Gets an InEdgeIterator pointing to the first in-coming edge of this edge.*"
            },
            {
                "content": "- `GetId(self: liblgraph_python_api.VertexIterator) → int`  \r\n    获取此顶点的整数 ID。GraphDB 为每个顶点分配一个整数 ID。  \r\n    *Gets the integer id of this vertex. GraphDB assigns an integer id for each vertex.*\r\n\r\n  - `GetInEdgeIterator(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetInEdgeIterator(self: liblgraph_python_api.VertexIterator) → lgraph_api::InEdgeIterator`  \r\n       获取指向此顶点的第一个入边的 InEdgeIterator。  \r\n       *Gets an InEdgeIterator pointing to the first in-coming edge of this edge.*\r\n\r\n    2. `GetInEdgeIterator(self: liblgraph_python_api.VertexIterator, arg0: liblgraph_python_api.EdgeUid, arg1: bool) → lgraph_api::InEdgeIterator`  \r\n       获取 EdgeUid 为 euid 的此顶点的入边 InEdgeIterator。  \r\n       *Gets an InEdgeIterator pointing to the in-edge of this vertex with EdgeUid==euid.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.VertexIterator) → str`  \r\n    获取当前顶点的标签名。  \r\n    *Gets the label name of current vertex.*\r\n\r\n  - `GetLabelId(self: liblgraph_python_api.VertexIterator) → int`  \r\n    获取当前顶点的标签 ID。"
            },
            {
                "content": "获取 EdgeUid 为 euid 的此顶点的入边 InEdgeIterator。  \r\n       *Gets an InEdgeIterator pointing to the in-edge of this vertex with EdgeUid==euid.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.VertexIterator) → str`  \r\n    获取当前顶点的标签名。  \r\n    *Gets the label name of current vertex.*\r\n\r\n  - `GetLabelId(self: liblgraph_python_api.VertexIterator) → int`  \r\n    获取当前顶点的标签 ID。  \r\n    *Gets the label id of current vertex.*\r\n\r\n  - `GetNumInEdges(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[int, bool]`  \r\n    获取此顶点的入边数量。n_limit 指定扫描的最大边数。返回一个包含入边数量和一个布尔值的元组，指示是否超过限制。  \r\n    *Gets the number of in-coming edges of this vertex. n_limit specifies the maximum number of edges to scan. Returns a tuple containing the number of in-edges and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `GetNumOutEdges(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[int, bool]`  \r\n    获取此顶点的出边数量。n_limit 指定扫描的最大顶点数。返回一个包含出边数量和一个布尔值的元组，指示是否超过限制。"
            },
            {
                "content": "获取此顶点的入边数量。n_limit 指定扫描的最大边数。返回一个包含入边数量和一个布尔值的元组，指示是否超过限制。  \r\n    *Gets the number of in-coming edges of this vertex. n_limit specifies the maximum number of edges to scan. Returns a tuple containing the number of in-edges and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `GetNumOutEdges(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[int, bool]`  \r\n    获取此顶点的出边数量。n_limit 指定扫描的最大顶点数。返回一个包含出边数量和一个布尔值的元组，指示是否超过限制。  \r\n    *Gets the number of out edges of this vertex. n_limit specifies the maximum number of vids to scan. Returns a tuple containing the number of out-edges and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `GetOutEdgeIterator(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetOutEdgeIterator(self: liblgraph_python_api.VertexIterator) → lgraph_api::OutEdgeIterator`  \r\n       获取指向此顶点的第一个出边的 OutEdgeIterator。  \r\n       *Gets an OutEdgeIterator pointing to the first out-going edge of this edge.*"
            },
            {
                "content": "*Gets the number of out edges of this vertex. n_limit specifies the maximum number of vids to scan. Returns a tuple containing the number of out-edges and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `GetOutEdgeIterator(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetOutEdgeIterator(self: liblgraph_python_api.VertexIterator) → lgraph_api::OutEdgeIterator`  \r\n       获取指向此顶点的第一个出边的 OutEdgeIterator。  \r\n       *Gets an OutEdgeIterator pointing to the first out-going edge of this edge.*\r\n\r\n    2. `GetOutEdgeIterator(self: liblgraph_python_api.VertexIterator, arg0: liblgraph_python_api.EdgeUid, arg1: bool) → lgraph_api::OutEdgeIterator`  \r\n       获取 EdgeUid 为 euid 的此顶点的出边 OutEdgeIterator。  \r\n       *Gets an OutEdgeIterator pointing to the out-edge of this vertex with EdgeUid==euid.*\r\n\r\n  - `Goto(self: liblgraph_python_api.VertexIterator, vid: int, nearest: bool) → bool`  \r\n    转到指定 ID 的顶点。如果 nearest==true，转到 ID >= vid 的最近顶点。"
            },
            {
                "content": "2. `GetOutEdgeIterator(self: liblgraph_python_api.VertexIterator, arg0: liblgraph_python_api.EdgeUid, arg1: bool) → lgraph_api::OutEdgeIterator`  \r\n       获取 EdgeUid 为 euid 的此顶点的出边 OutEdgeIterator。  \r\n       *Gets an OutEdgeIterator pointing to the out-edge of this vertex with EdgeUid==euid.*\r\n\r\n  - `Goto(self: liblgraph_python_api.VertexIterator, vid: int, nearest: bool) → bool`  \r\n    转到指定 ID 的顶点。如果 nearest==true，转到 ID >= vid 的最近顶点。  \r\n    *Goes to the vertex specified by vid. If nearest==true, go to the nearest vertex with id>=vid.*\r\n    \r\n  - `IsValid(self: liblgraph_python_api.VertexIterator) → bool`  \r\n    检查当前迭代器是否有效。  \r\n    *Checks if the current iterator is valid.*\r\n\r\n  - `ListDstVids(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[List[int], bool]`  \r\n    列出所有出边的目标顶点 ID。n_limit 指定返回的最大顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。"
            },
            {
                "content": "转到指定 ID 的顶点。如果 nearest==true，转到 ID >= vid 的最近顶点。  \r\n    *Goes to the vertex specified by vid. If nearest==true, go to the nearest vertex with id>=vid.*\r\n    \r\n  - `IsValid(self: liblgraph_python_api.VertexIterator) → bool`  \r\n    检查当前迭代器是否有效。  \r\n    *Checks if the current iterator is valid.*\r\n\r\n  - `ListDstVids(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[List[int], bool]`  \r\n    列出所有出边的目标顶点 ID。n_limit 指定返回的最大顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。  \r\n    *Lists all destination vids of the out edges. n_limit specifies the maximum number of vids to return. Returns a tuple containing a list of vids and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `ListSrcVids(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[List[int], bool]`  \r\n    列出所有入边的源顶点 ID。n_limit 指定返回的最大源顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。"
            },
            {
                "content": "列出所有出边的目标顶点 ID。n_limit 指定返回的最大顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。  \r\n    *Lists all destination vids of the out edges. n_limit specifies the maximum number of vids to return. Returns a tuple containing a list of vids and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `ListSrcVids(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[List[int], bool]`  \r\n    列出所有入边的源顶点 ID。n_limit 指定返回的最大源顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。  \r\n    *Lists all source vids of the in edges. n_limit specifies the maximum number of src vids to return. Returns a tuple containing a list of vids and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `Next(self: liblgraph_python_api.VertexIterator) → bool`  \r\n    转到 ID 大于 {current_vid} 的下一个顶点。  \r\n    *Goes to the next vertex with id>{current_vid}.*\r\n\r\n  - `SetField(self: liblgraph_python_api.VertexIterator, field_name: str, field_value_object: object) → None`  \r\n    设置指定字段的值。  \r\n    *Sets the specified field.*"
            },
            {
                "content": "- `Next(self: liblgraph_python_api.VertexIterator) → bool`  \r\n    转到 ID 大于 {current_vid} 的下一个顶点。  \r\n    *Goes to the next vertex with id>{current_vid}.*\r\n\r\n  - `SetField(self: liblgraph_python_api.VertexIterator, field_name: str, field_value_object: object) → None`  \r\n    设置指定字段的值。  \r\n    *Sets the specified field.*\r\n\r\n  - `SetFields(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `SetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str], field_value_strings: List[str]) → None`  \r\n       使用字符串表示形式的字段值设置指定字段名的字段。  \r\n       *Sets the fields specified by field_names with field values in string representation.*\r\n\r\n    2. `SetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       使用新值设置指定字段名的字段。  \r\n       *Sets the fields specified by field_names with new values.*\r\n\r\n    3. `SetFields(self: liblgraph_python_api.VertexIterator, value_dict: dict) → None`  \r\n       使用 value_dict 中指定的值设置字段。"
            },
            {
                "content": "使用字符串表示形式的字段值设置指定字段名的字段。  \r\n       *Sets the fields specified by field_names with field values in string representation.*\r\n\r\n    2. `SetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       使用新值设置指定字段名的字段。  \r\n       *Sets the fields specified by field_names with new values.*\r\n\r\n    3. `SetFields(self: liblgraph_python_api.VertexIterator, value_dict: dict) → None`  \r\n       使用 value_dict 中指定的值设置字段。  \r\n       *Sets the fields with values as specified in value_dict.*\r\n\r\n    4. `SetFields(self: liblgraph_python_api.VertexIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       使用字段值设置指定字段 ID 的字段。  \r\n       *Sets the fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.VertexIterator) → str`  \r\n    返回当前顶点的字符串表示，包括属性和边。  \r\n    *Returns the string representation of current vertex, including properties and edges.*"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/1.guide.md",
        "chunks": [
            {
                "content": "# 文档地图\n\n> 这里是文档地图，帮助用户快速学习和使用TuGraph社区版。\n\n## 快速上手\n\n> 可以先了解[什么是图](./2.introduction/1.what-is-graph.md)、图[可以做什么](./2.introduction/8.scenarios.md)、以及[什么是TuGraph](./2.introduction/3.what-is-tugraph.md)。\n\n> 基于[阿里云计算巢](5.installation&running/5.cloud-deployment.md)或[Docker方式](5.installation&running/3.docker-deployment.md)快速部署TuGraph。\n\n> 通过产品内置的场景上手体验：[电影](./3.quick-start/2.demo/1.movie.md)、[流浪地球](./3.quick-start/2.demo/2.wandering-earth.md)、[三体](./3.quick-start/2.demo/3.the-three-body.md)、[三国](./3.quick-start/2.demo/4.three-kingdoms.md)。\n\n> 可视化操作手册看这里：[可视化操作手册](./4.user-guide/1.tugraph-browser.md)、[可视化操作手册（旧版）](./4.user-guide/2.tugraph-browser-legacy.md)。\n\n## 开发指南\n\n> 通过客户端访问TuGraph：[Bolt Client](7.client-tools/5.bolt-client.md)\n\n> 查询语言、语句创建图模型看这里：[Cypher API](8.query/1.cypher.md).\n\n> 存储过程和算法介绍看这里：[Procedure API (POG API)](9.olap&procedure/1.procedure/1.procedure.md)、[OLAP API](9.olap&procedure/2.olap/1.tutorial.md)。\n\n> C++/Python开发存储过程接口看这里：[C++/Python Procedure API](9.olap&procedure/1.procedure/index.rst)。"
            },
            {
                "content": "> 可视化操作手册看这里：[可视化操作手册](./4.user-guide/1.tugraph-browser.md)、[可视化操作手册（旧版）](./4.user-guide/2.tugraph-browser-legacy.md)。\n\n## 开发指南\n\n> 通过客户端访问TuGraph：[Bolt Client](7.client-tools/5.bolt-client.md)\n\n> 查询语言、语句创建图模型看这里：[Cypher API](8.query/1.cypher.md).\n\n> 存储过程和算法介绍看这里：[Procedure API (POG API)](9.olap&procedure/1.procedure/1.procedure.md)、[OLAP API](9.olap&procedure/2.olap/1.tutorial.md)。\n\n> C++/Python开发存储过程接口看这里：[C++/Python Procedure API](9.olap&procedure/1.procedure/index.rst)。\n\n## 参与社区贡献\n\n> 在开始贡献前，可以先了解[如何贡献](12.contributor-manual/1.contributing.md)\n\n> 如果想了解社区角色的划分，请访问[社区角色](12.contributor-manual/2.community-roles.md)\n\n## 主要仓库\n\n> TuGraph-DB 仓库: [https://github.com/TuGraph-family/tugraph-db](https://github.com/TuGraph-family/tugraph-db)\n\n> 可视化界面: [https://github.com/TuGraph-family/tugraph-db-browser](https://github.com/TuGraph-family/tugraph-db-browser)\n\n> 基于twitter数据的简单测试方法: [https://github.com/TuGraph-family/gdbms-microbenchmark](https://github.com/TuGraph-family/gdbms-microbenchmark)"
            },
            {
                "content": "> 在开始贡献前，可以先了解[如何贡献](12.contributor-manual/1.contributing.md)\n\n> 如果想了解社区角色的划分，请访问[社区角色](12.contributor-manual/2.community-roles.md)\n\n## 主要仓库\n\n> TuGraph-DB 仓库: [https://github.com/TuGraph-family/tugraph-db](https://github.com/TuGraph-family/tugraph-db)\n\n> 可视化界面: [https://github.com/TuGraph-family/tugraph-db-browser](https://github.com/TuGraph-family/tugraph-db-browser)\n\n> 基于twitter数据的简单测试方法: [https://github.com/TuGraph-family/gdbms-microbenchmark](https://github.com/TuGraph-family/gdbms-microbenchmark)\n\n> 基于标准LDBC-SNB的测试方法: [https://github.com/TuGraph-family/tugraph-snb-interactive](https://github.com/TuGraph-family/tugraph-snb-interactive)\n\n> TuGraph-Analytics 仓库: [https://github.com/TuGraph-family/tugraph-analytics](https://github.com/TuGraph-family/tugraph-analytics)\n\n## 视频中心\n\n> [TuGraph快速上手](https://space.bilibili.com/1196053065/channel/seriesdetail?sid=2593741)\n\n> [TuGraph技术分享集合](https://space.bilibili.com/1196053065/channel/seriesdetail?sid=3009777)"
            },
            {
                "content": "> 基于标准LDBC-SNB的测试方法: [https://github.com/TuGraph-family/tugraph-snb-interactive](https://github.com/TuGraph-family/tugraph-snb-interactive)\n\n> TuGraph-Analytics 仓库: [https://github.com/TuGraph-family/tugraph-analytics](https://github.com/TuGraph-family/tugraph-analytics)\n\n## 视频中心\n\n> [TuGraph快速上手](https://space.bilibili.com/1196053065/channel/seriesdetail?sid=2593741)\n\n> [TuGraph技术分享集合](https://space.bilibili.com/1196053065/channel/seriesdetail?sid=3009777)\n\n> [3分钟读懂图计算](https://www.bilibili.com/video/BV15U4y1r7AW/)\n\n## TuGraph最新版本"
            },
            {
                "content": "| 描述                  | 文件                                         | 链接                                                                                                                                                                                              |\n|---------------------|--------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| CentOS7 安装包         | tugraph-4.5.0-1.el7.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)                                                                                      |"
            },
            {
                "content": "| CentOS7 安装包         | tugraph-4.5.0-1.el7.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)                                                                                      |\n| CentOS8 安装包         | tugraph-4.5.0-1.el8.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el8.x86_64.rpm)                                                                                      |\n| Ubuntu18.04 安装包     | tugraph-4.5.0-1.x86_64.deb                 | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)                                                                                          |"
            },
            {
                "content": "| Ubuntu18.04 安装包     | tugraph-4.5.0-1.x86_64.deb                 | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)                                                                                          |\n| CentOS7 预安装镜像       | tugraph-runtime-centos7-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)                   |\n| CentOS8 预安装镜像       | tugraph-runtime-centos8-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)                   |"
            },
            {
                "content": "| CentOS8 预安装镜像       | tugraph-runtime-centos8-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)                   |\n| Ubuntu18.04 预安装镜像   | tugraph-runtime-ubuntu18.04-4.5.0.tar      | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)           |\n| CentOS7 精简安装包       | tugraph-mini-4.5.0-1.el7.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)                                                                                 |"
            },
            {
                "content": "| CentOS7 精简安装包       | tugraph-mini-4.5.0-1.el7.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)                                                                                 |\n| CentOS8 精简安装包       | tugraph-mini-4.5.0-1.el8.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)                                                                                 |\n| Ubuntu18.04 精简安装包   | tugraph-mini-4.5.0-1.x86_64.deb            | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)                                                                                     |"
            },
            {
                "content": "| Ubuntu18.04 精简安装包   | tugraph-mini-4.5.0-1.x86_64.deb            | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)                                                                                     |\n| CentOS7 精简预安装镜像     | tugraph-mini-runtime-centos7-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos7-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos7)         |\n| CentOS8 精简预安装镜像     | tugraph-mini-runtime-centos8-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)         |"
            },
            {
                "content": "| CentOS8 精简预安装镜像     | tugraph-mini-runtime-centos8-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)         |\n| Ubuntu18.04 精简预安装镜像 | tugraph-mini-runtime-ubuntu18.04-4.5.0.tar | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-ubuntu18.04-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-ubuntu18.04) |\n| CentOS7 编译镜像        | tugraph-compile-centos7-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)          |"
            },
            {
                "content": "| CentOS7 编译镜像        | tugraph-compile-centos7-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)          |\n| CentOS8 编译镜像        | tugraph-compile-centos8-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos8-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos8)          |\n| Ubuntu18.04 编译镜像    | tugraph-compile-ubuntu18.04-1.3.2.tar      | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-ubuntu18.04-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-ubuntu18.04)  |"
            },
            {
                "content": "版本更新日志见：[链接](https://github.com/TuGraph-family/tugraph-db/blob/master/release/CHANGELOG_CN.md )。\n\n如果您不清楚使用安装包和镜像，请参考 [环境和版本选择](13.best-practices/4.selection.md)。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/development_guide.md",
        "chunks": [
            {
                "content": "# 业务开发指南\n## 连接tugraph-db\n### 驱动连接\ntugraph-db兼容neo4j的通讯协议，因此可以使用neo4j的驱动连接tugraph-db的server。\n\n[bolt driver 使用介绍](./7.client-tools/5.bolt-client.md)\n\n[bolt driver 使用例子](https://github.com/TuGraph-family/tugraph-db/tree/master/demo/Bolt)\n\n### 终端连接\n驱动是业务代码里面使用的，对于服务器上终端访问，可以使用cli客户端。\n\n[console client 使用介绍](./7.client-tools/6.bolt-console-client.md)\n\n## 子图操作\n### 创建子图\n```\nCALL dbms.graph.createGraph('graph1')\n```\n### 删除子图\n```\nCALL dbms.graph.deleteGraph('graph1')\n```\n### 清空子图\n#### 删除所有的点边数据和图schema\n```\nCALL db.dropDB()\n```\n#### 只删除所有点边数据, 保留图schema\n```\nCALL db.dropAllVertex()\n```\n### 查看图schema\n```\nCALL dbms.graph.getGraphSchema()\n```\n### 列出所有子图\n```\nCALL dbms.graph.listGraphs()\n```\n\n### 刷新子图文件系统缓存数据\n```\nCALL db.flushDB()\n```"
            },
            {
                "content": "### 终端连接\n驱动是业务代码里面使用的，对于服务器上终端访问，可以使用cli客户端。\n\n[console client 使用介绍](./7.client-tools/6.bolt-console-client.md)\n\n## 子图操作\n### 创建子图\n```\nCALL dbms.graph.createGraph('graph1')\n```\n### 删除子图\n```\nCALL dbms.graph.deleteGraph('graph1')\n```\n### 清空子图\n#### 删除所有的点边数据和图schema\n```\nCALL db.dropDB()\n```\n#### 只删除所有点边数据, 保留图schema\n```\nCALL db.dropAllVertex()\n```\n### 查看图schema\n```\nCALL dbms.graph.getGraphSchema()\n```\n### 列出所有子图\n```\nCALL dbms.graph.listGraphs()\n```\n\n### 刷新子图文件系统缓存数据\n```\nCALL db.flushDB()\n```\n\n## 点类型操作\n### 创建点类型\n如下json定义了一个点类型，名字是`node1`。\n```json\n{\n\t\"label\": \"node1\",\n\t\"primary\": \"id\",\n\t\"type\": \"VERTEX\",\n\t\"detach_property\": true,\n\t\"properties\": [{\n\t\t\"name\": \"id\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false\n\t}, {\n\t\t\"name\": \"name\",\n\t\t\"type\": \"STRING\",\n\t\t\"optional\": false,\n\t\t\"index\": true\n\t}, {\n\t\t\"name\": \"num\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false,\n\t\t\"index\": true,\n\t\t\"unique\": true\n\t}, {\n\t\t\"name\": \"desc\",\n\t\t\"type\": \"STRING\",\n\t\t\"optional\": true\n\t}]\n}"
            },
            {
                "content": "### 刷新子图文件系统缓存数据\n```\nCALL db.flushDB()\n```\n\n## 点类型操作\n### 创建点类型\n如下json定义了一个点类型，名字是`node1`。\n```json\n{\n\t\"label\": \"node1\",\n\t\"primary\": \"id\",\n\t\"type\": \"VERTEX\",\n\t\"detach_property\": true,\n\t\"properties\": [{\n\t\t\"name\": \"id\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false\n\t}, {\n\t\t\"name\": \"name\",\n\t\t\"type\": \"STRING\",\n\t\t\"optional\": false,\n\t\t\"index\": true\n\t}, {\n\t\t\"name\": \"num\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false,\n\t\t\"index\": true,\n\t\t\"unique\": true\n\t}, {\n\t\t\"name\": \"desc\",\n\t\t\"type\": \"STRING\",\n\t\t\"optional\": true\n\t}]\n}\n\n```\n把上面这个json序列化成字符串，作为参数传入，建议使用驱动的参数化特性，避免自己拼接语句。\n```\nCALL db.createVertexLabelByJson($json_data)\n```\n\n### 查看点类型schema\n```\nCALL db.getVertexSchema('node1')\n```\n\n### 删除点类型\n>该操作会同步删除所有该类型的点数据，数据量大的时候，有时间消耗。\n\n如下例子删除点类型`node1`以及该类型的所有点数据。\n```\nCALL db.deleteLabel('vertex', 'node1')\n```\n\n### 点类型添加字段\n>该操作会同步变更所有该类型点的属性数据，数据量大的时候，有时间消耗。"
            },
            {
                "content": "```\n把上面这个json序列化成字符串，作为参数传入，建议使用驱动的参数化特性，避免自己拼接语句。\n```\nCALL db.createVertexLabelByJson($json_data)\n```\n\n### 查看点类型schema\n```\nCALL db.getVertexSchema('node1')\n```\n\n### 删除点类型\n>该操作会同步删除所有该类型的点数据，数据量大的时候，有时间消耗。\n\n如下例子删除点类型`node1`以及该类型的所有点数据。\n```\nCALL db.deleteLabel('vertex', 'node1')\n```\n\n### 点类型添加字段\n>该操作会同步变更所有该类型点的属性数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，一次添加了两个字段：`field1`，字符串类型，可选，默认值是 `null`; `field2`，`int64`类型，必选，默认值是0.\n```\nCALL db.alterLabelAddFields('vertex', 'node1', ['field1', string, null ,true], ['field2', int64, 0, false])\n```\n\n### 点类型删除字段\n>该操作会同步变更所有该类型点的属性数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，一次删除了两个字段: `field1` 和 `field2`。\n```\nCALL db.alterLabelDelFields('vertex', 'node1', ['field1', 'field2'])\n```\n\n### 点类型添加索引\n>该操作会同步构建索引数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，给`field1`字段添加了一个非唯一索引。\n```\nCALL db.addIndex('node1', 'field1', false)\n```\n如下例子，对于点类型`node1`，给`field2`字段添加了一个唯一索引。\n```\nCALL db.addIndex('node1', 'field2', true)\n```"
            },
            {
                "content": "### 点类型删除字段\n>该操作会同步变更所有该类型点的属性数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，一次删除了两个字段: `field1` 和 `field2`。\n```\nCALL db.alterLabelDelFields('vertex', 'node1', ['field1', 'field2'])\n```\n\n### 点类型添加索引\n>该操作会同步构建索引数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，给`field1`字段添加了一个非唯一索引。\n```\nCALL db.addIndex('node1', 'field1', false)\n```\n如下例子，对于点类型`node1`，给`field2`字段添加了一个唯一索引。\n```\nCALL db.addIndex('node1', 'field2', true)\n```\n\n### 点类型删除索引\n如下例子，对于点类型`node1`，删除字段`field1`上的索引。\n```\nCALL db.deleteIndex('node1', 'field1')\n```\n\n\n## 边类型操作\n### 创建边类型"
            },
            {
                "content": "### 点类型添加索引\n>该操作会同步构建索引数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，给`field1`字段添加了一个非唯一索引。\n```\nCALL db.addIndex('node1', 'field1', false)\n```\n如下例子，对于点类型`node1`，给`field2`字段添加了一个唯一索引。\n```\nCALL db.addIndex('node1', 'field2', true)\n```\n\n### 点类型删除索引\n如下例子，对于点类型`node1`，删除字段`field1`上的索引。\n```\nCALL db.deleteIndex('node1', 'field1')\n```\n\n\n## 边类型操作\n### 创建边类型\n\n如下json定义了一个边的schema，名字是`edge1`。\n```json\n{\n  \"label\": \"edge1\",\n  \"type\": \"EDGE\",\n  \"detach_property\": true,\n  \"constraints\": [\n    [\"node1\", \"node2\"]\n  ],\n  \"properties\": [{\n    \"name\": \"id\",\n    \"type\": \"INT32\",\n    \"optional\": false\n  }, {\n    \"name\": \"name\",\n    \"type\": \"STRING\",\n    \"optional\": false,\n    \"index\": true\n  }, {\n    \"name\": \"num\",\n    \"type\": \"INT32\",\n    \"optional\": false,\n    \"index\": true,\n    \"unique\": true\n  }, {\n    \"name\": \"desc\",\n    \"type\": \"STRING\",\n    \"optional\": true\n  }]\n}\n```\n把上面这个json序列化成字符串，作为参数传入，建议使用驱动的参数化特性，避免自己拼接语句。\n```\nCALL db.createEdgeLabelByJson($json_data)\n```\n### 查看边类型schema\n```\nCALL db.getEdgeSchema('edge1')\n```"
            },
            {
                "content": "### 删除边类型\n>该操作会同步删除所有该类型的边，数据量大的时候，有时间消耗。\n\n如下例子，删除边类型`edge1`以及该类型的所有边数据。\n```\nCALL db.deleteLabel('edge', 'edge1')\n```\n\n### 边类型添加字段\n>该操作会同步变更所有该类型边的属性数据，数据量大的时候，有时间消耗。\n\n如下例子，对于边类型`edge1`，一次添加了两个字段: `field1`，字符串类型，可选，默认值是 `null`; `field2`，`int64`类型，必选，默认值是`0`.\n```\nCALL db.alterLabelAddFields('edge', 'edge1', ['field1', string, null ,true], ['field2', int64, 0, false])\n```\n\n### 边类型删除字段\n>该操作会同步变更所有该类型边的属性数据，数据量大的时候，有时间消耗。\n\n如下操作，对于边类型`edge1`，一次删除了两个字段: `field1` 和 `field2`。\n```\nCALL db.alterLabelDelFields('edge', 'edge1', ['field1', 'field2'])\n```\n\n### 边类型添加索引\n>该操作会同步构建索引数据，数据量大的时候，有时间消耗。\n\n如下例子，对于边类型`edge1`，给字段`field1`添加了一个非唯一索引。\n```\nCALL db.addEdgeIndex('edge1', 'field1', false, false)\n```\n如下例子，对于边类型`edge1`，给字段`field2`添加了一个唯一索引。\n```\nCALL db.addEdgeIndex('edge1', 'field2', true, false)\n```\n\n### 边类型删除索引\n如下例子，对于边类型`edge1`，删除字段`field1`上的索引。\n```\nCALL db.deleteEdgeIndex('edge1', 'field1')\n```\n\n## 实时查看当前点边数据量\n如下例子返回所有的点边类型，以及每种类型当前的数据量是多少。\n\n读的是统计数据，轻操作。\n```\nCALL dbms.meta.countDetail()\n```"
            },
            {
                "content": "### 边类型添加索引\n>该操作会同步构建索引数据，数据量大的时候，有时间消耗。\n\n如下例子，对于边类型`edge1`，给字段`field1`添加了一个非唯一索引。\n```\nCALL db.addEdgeIndex('edge1', 'field1', false, false)\n```\n如下例子，对于边类型`edge1`，给字段`field2`添加了一个唯一索引。\n```\nCALL db.addEdgeIndex('edge1', 'field2', true, false)\n```\n\n### 边类型删除索引\n如下例子，对于边类型`edge1`，删除字段`field1`上的索引。\n```\nCALL db.deleteEdgeIndex('edge1', 'field1')\n```\n\n## 实时查看当前点边数据量\n如下例子返回所有的点边类型，以及每种类型当前的数据量是多少。\n\n读的是统计数据，轻操作。\n```\nCALL dbms.meta.countDetail()\n```\n\n## 导入数据\n### 批量upsert点数据\n如果不存在就插入点，如果存在就更新点的属性，根据点的主键字段值判断是否存在。\n\n第二个参数是一个`list`类型，每个`list`里面的元素是个`map`类型，每个`map`里面是点的字段和对应的值。\n\n推荐使用driver里面的参数化特性，第二个参数直接传入一个 `list`结构体，避免自己构造语句。\n```\nCALL db.upsertVertex('node1', [{id:1, name:'name1'},{id:2, name:'name2'}])\n```\n### 批量upsert边数据\n如果两点之间不存在某条类型的边就插入，如果存在就更新该边的属性，也就是两点之间同类型的边只能有一条。\n\n第四个参数是一个`list`类型，每个数组里面的元素是个`map`类型，每个`map`里面是：边的起点类型主键字段和对应的值、边的终点类型主键字段和对应的值、边类型自身的属性字段和值。每个map里面至少有两个元素。\n\n第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。"
            },
            {
                "content": "第二个参数是一个`list`类型，每个`list`里面的元素是个`map`类型，每个`map`里面是点的字段和对应的值。\n\n推荐使用driver里面的参数化特性，第二个参数直接传入一个 `list`结构体，避免自己构造语句。\n```\nCALL db.upsertVertex('node1', [{id:1, name:'name1'},{id:2, name:'name2'}])\n```\n### 批量upsert边数据\n如果两点之间不存在某条类型的边就插入，如果存在就更新该边的属性，也就是两点之间同类型的边只能有一条。\n\n第四个参数是一个`list`类型，每个数组里面的元素是个`map`类型，每个`map`里面是：边的起点类型主键字段和对应的值、边的终点类型主键字段和对应的值、边类型自身的属性字段和值。每个map里面至少有两个元素。\n\n第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。\n\n注：第二个参数和第三个参数中配置的起点和终点的主键字段并不是起点和终点schema中的主键字段名，只是起一个占位和区别的作用，方便识别第四个参数中哪个字段代表起点和终点的主键字段。\n\n推荐使用driver里面的参数化特性，避免自己构造语句。\n```\nCALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}])\n```"
            },
            {
                "content": "第四个参数是一个`list`类型，每个数组里面的元素是个`map`类型，每个`map`里面是：边的起点类型主键字段和对应的值、边的终点类型主键字段和对应的值、边类型自身的属性字段和值。每个map里面至少有两个元素。\n\n第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。\n\n注：第二个参数和第三个参数中配置的起点和终点的主键字段并不是起点和终点schema中的主键字段名，只是起一个占位和区别的作用，方便识别第四个参数中哪个字段代表起点和终点的主键字段。\n\n推荐使用driver里面的参数化特性，避免自己构造语句。\n```\nCALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}])\n```\n\n### 批量upsert边数据-根据边的属性确定唯一\n上面描述的upsert逻辑是两点之间同类型的边只能有一条，如果要求两点之间同类型的边可以有多条，并且根据边上的某个属性来确定唯一，需要在原来的基础上多加一个字段，如下：\n```\nCALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}], 'score')\n```\n在最后多了一个字段`score`, 逻辑变成：如果两点之间不存在一条`edge1`类型的边，并且`score`值等于某个值，就插入；否则就更新改边的属性。\n边上的`score`字段需要提前加上一个特殊的`pair unique`索引，如下：\n```\nCALL db.addEdgeIndex('edge1', 'score', false, true)\n```\n\n### DataX\n\nhttps://github.com/ljcui/DataX/tree/bolt 自行编译。"
            },
            {
                "content": "### DataX\n\nhttps://github.com/ljcui/DataX/tree/bolt 自行编译。\n\n这个DataX实现的 tugraph writer 内部调用的是上面描述的`db.upsertVertex`和`db.upsertEdge`，\ntugraph reader 内部调用的是TuGraph 的 bolt client，支持流式读取，\n具体使用方式见[TuGraph-DataX 使用介绍](./6.utility-tools/7.tugraph-datax.md)\n\n### 离线脱机导入数据\n如果你有子图的schema以及子图里面所有的点边数据（csv或者json格式），可以利用`lgraph_import`工具离线将这些数据生成图数据。\n\n该方式适合初始阶段，先灌进去一批全量数据。注意server要停机，导入完再启动server，可以看到生成的子图数据。\n\n参考 [lgraph_import 使用介绍](./6.utility-tools/1.data-import.md) 中的**离线全量导入**部分\n\n## 导出数据\n\n### 在线远程流式导出数据\n[lgraph_cli 使用介绍](./7.client-tools/6.bolt-console-client.md)\n\nCSV 格式\n```\necho \"match(n:person) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format csv > output.txt\n```\nJSON 格式\n```\necho \"match(n:person) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format json > output.txt\n\n```\n### 本地导出整个图的所有数据\n[lgraph_export 使用介绍](./6.utility-tools/2.data-export.md)"
            },
            {
                "content": "### 在线远程流式导出数据\n[lgraph_cli 使用介绍](./7.client-tools/6.bolt-console-client.md)\n\nCSV 格式\n```\necho \"match(n:person) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format csv > output.txt\n```\nJSON 格式\n```\necho \"match(n:person) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format json > output.txt\n\n```\n### 本地导出整个图的所有数据\n[lgraph_export 使用介绍](./6.utility-tools/2.data-export.md)\n\nCSV 格式\n```\nlgraph_export -d your_db_path -e export_data -g default -f json -u admin -p 73@TuGraph\n```\nJSON 格式\n```\nlgraph_export -d your_db_path -e export_data -g default -f json -u admin -p 73@TuGraph\n```\n\n### 跨版本迁移数据\n[lgraph_export 使用介绍](./6.utility-tools/2.data-export.md)\n\n对于不兼容的版本之间迁移数据，可以使用`lgraph_export`将旧版本server里面的数据全部导出成文本（里面包含图schema以及所有的点边数据），然后再选择合适的方法将这些文本数据导入到新版本。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/README_CN.md",
        "chunks": [
            {
                "content": "# TuGraph\n\n[![Release](https://shields.io/github/v/release/tugraph-family/tugraph-db.svg?logo=stackblitz&label=Version&color=red)](https://github.com/TuGraph-family/tugraph-db/releases)\n[![UT&&IT](https://github.com/TuGraph-family/tugraph-db/actions/workflows/ci.yml/badge.svg)](https://github.com/TuGraph-family/tugraph-db/actions/workflows/ci.yml)\n[![Documentation Status](https://readthedocs.org/projects/tugraph-db/badge/?version=latest)](https://tugraph-db.readthedocs.io/en/latest/?badge=latest)\n[![Commit](https://badgen.net/github/last-commit/tugraph-family/tugraph-db/master?icon=git&label=Commit)](https://github.com/TuGraph-family/tugraph-db/commits/master)\n[![codecov](https://codecov.io/gh/TuGraph-family/tugraph-db/branch/master/graph/badge.svg?token=JH78ARWZAQ)](https://codecov.io/gh/TuGraph-family/tugraph-db)"
            },
            {
                "content": "[![Star](https://shields.io/github/stars/tugraph-family/tugraph-db?logo=startrek&label=Star&color=yellow)](https://github.com/TuGraph-family/tugraph-db/stargazers)\n[![Fork](https://shields.io/github/forks/tugraph-family/tugraph-db?logo=forgejo&label=Fork&color=orange)](https://github.com/TuGraph-family/tugraph-db/forks)\n[![Contributor](https://shields.io/github/contributors/tugraph-family/tugraph-db?logo=actigraph&label=Contributor&color=abcdef)](https://github.com/TuGraph-family/tugraph-db/contributors)\n[![Docker](https://shields.io/docker/pulls/tugraph/tugraph-runtime-centos7?logo=docker&label=Docker&color=blue)](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7/tags)\n[![License](https://shields.io/github/license/tugraph-family/tugraph-db?logo=apache&label=License&color=blue)](https://www.apache.org/licenses/LICENSE-2.0.html)"
            },
            {
                "content": "[![EN](https://shields.io/badge/Docs-English-blue?logo=readme)](https://tugraph-db.readthedocs.io/en/latest)\n[![CN](https://shields.io/badge/Docs-中文-blue?logo=readme)](https://tugraph-db.readthedocs.io/zh-cn/latest)\n\n[[English Version]](README.md)\n\n:mega: **TuGraph 现在在阿里云计算巢提供[免费试用](https://computenest.console.aliyun.com/user/cn-hangzhou/serviceInstanceCreate?ServiceId=service-7b50ea3d20e643da95bf&ServiceVersion=1&isTrial=true) 可参见 [操作指引](https://aliyun-computenest.github.io/quickstart-tugraph/)**。\n\n## 1. 简介\nTuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。\n\n主要功能：\n\n- 标签属性图模型\n- 完善的 ACID 事务处理\n- 内置 34 图分析算法\n- 支持全文/主键/二级索引\n- OpenCypher 图查询语言\n- 基于 C++/Python 的存储过程\n\n性能和可扩展性：\n\n- LDBC SNB世界记录保持者 (2022/9/1 https://ldbcouncil.org/benchmarks/snb/)\n- 支持存储多达数十TB的数据\n- 每秒访问数百万个顶点\n- 快速批量导入\n\nTuGraph的文档在[链接](https://tugraph-db.readthedocs.io/zh_CN/latest)，欢迎访问我们的[官网](https://www.tugraph.org)。\n\n## 2. 快速上手"
            },
            {
                "content": "## 1. 简介\nTuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。\n\n主要功能：\n\n- 标签属性图模型\n- 完善的 ACID 事务处理\n- 内置 34 图分析算法\n- 支持全文/主键/二级索引\n- OpenCypher 图查询语言\n- 基于 C++/Python 的存储过程\n\n性能和可扩展性：\n\n- LDBC SNB世界记录保持者 (2022/9/1 https://ldbcouncil.org/benchmarks/snb/)\n- 支持存储多达数十TB的数据\n- 每秒访问数百万个顶点\n- 快速批量导入\n\nTuGraph的文档在[链接](https://tugraph-db.readthedocs.io/zh_CN/latest)，欢迎访问我们的[官网](https://www.tugraph.org)。\n\n## 2. 快速上手\n\n一个简单的方法是使用docker进行设置，可以在[DockerHub](https://hub.docker.com/u/tugraph)中找到, 名称为`tugraph/tugraph-runtime-[os]:[tugraph version]`,\n例如， `tugraph/tugraph-runtime-centos7:3.3.0`。\n\n更多详情请参考 [快速上手文档](./docs/zh-CN/source/3.quick-start/1.preparation.md) 和 [业务开发指南](./docs/zh-CN/source/development_guide.md).\n\n## 3. 从源代码编译\n\n建议在Linux系统中构建TuGraph，Docker环境是个不错的选择。如果您想设置一个新的环境，请参考[Dockerfile](ci/images).\n\n以下是编译TuGraph的步骤：\n\n1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤\n2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`\n3. `make`\n4. `make package` 或者 `cpack --config CPackConfig.cmake`"
            },
            {
                "content": "更多详情请参考 [快速上手文档](./docs/zh-CN/source/3.quick-start/1.preparation.md) 和 [业务开发指南](./docs/zh-CN/source/development_guide.md).\n\n## 3. 从源代码编译\n\n建议在Linux系统中构建TuGraph，Docker环境是个不错的选择。如果您想设置一个新的环境，请参考[Dockerfile](ci/images).\n\n以下是编译TuGraph的步骤：\n\n1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤\n2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`\n3. `make`\n4. `make package` 或者 `cpack --config CPackConfig.cmake`\n\n示例：`tugraph/tugraph-compile-centos7`Docker环境\n\n```bash\n$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git\n$ cd tugraph-db\n$ deps/build_deps.sh\n$ mkdir build && cd build\n$ cmake .. -DOURSYSTEM=centos7\n$ make\n$ make package\n```\n\n## 4. 开发\n\n我们已为在DockerHub中编译准备了环境docker镜像，可以帮助开发人员轻松入门，名称为 `tugraph/tugraph-compile-[os]:[compile version]`, 例如， `tugraph/tugraph-compile-centos7:1.1.0`。\n\n可以访问 [技术规划](docs/zh-CN/source/12.contributor-manual/5.roadmap.md) 来了解TuGraph进展。\n\n如需贡献，请阅读 [如何贡献](docs/zh-CN/source/12.contributor-manual/1.contributing.md)。"
            },
            {
                "content": "## 4. 开发\n\n我们已为在DockerHub中编译准备了环境docker镜像，可以帮助开发人员轻松入门，名称为 `tugraph/tugraph-compile-[os]:[compile version]`, 例如， `tugraph/tugraph-compile-centos7:1.1.0`。\n\n可以访问 [技术规划](docs/zh-CN/source/12.contributor-manual/5.roadmap.md) 来了解TuGraph进展。\n\n如需贡献，请阅读 [如何贡献](docs/zh-CN/source/12.contributor-manual/1.contributing.md)。\n\n注意：如果您想贡献代码，需要签署[个人贡献者许可协议](docs/zh-CN/source/12.contributor-manual/3.individual-cla.md)或者[公司贡献者许可协议](docs/zh-CN/source/12.contributor-manual/4.corporate-cla.md)。\n\n## 5. 合作伙伴\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 5. 联系我们\n\n官网: [tugraph.tech](https://tugraph.tech)\n\nSlack (在线开发沟通):\n[TuGraph.slack](https://join.slack.com/t/tugraph/shared_invite/zt-1hha8nuli-bqdkwn~w4zH1vlk0QvqIfg)\n\n通过钉钉群、微信群、微信公众号、邮箱和电话联系我们:\n![contacts](./docs/images/contact-zh.png)"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/1.what-is-graph.md",
        "chunks": [
            {
                "content": "# 什么是图\n\n> 本文面向初学者，介绍图（Graph）的基本概念。\n\n我们今天介绍的图，是图论中使用点和边表示的图（Graph），而非图像的图（Image）。\n\n![alt what is graph](../../../images/what-is-graph.png)\n\n图的基本元素是点和边，其中点表示事物或实体，边表示点之间的关联关系。\n\n如上图左侧所示，点表示的有公司、员工、项目。边表示的是他们之间的关系，包括：公司和员工之间的雇佣关系，员工和员工之间的好友关系，项目和员工之间的参与关系。除此之外，点和边上可以附加属性，比如员工的工号，雇佣的时间，这样的图是属性图。也就是说，我们可以用图的方式来抽象地表示实体及其关联关系，图有非常丰富的表达能力。\n\n除了上述的员工图谱，图还可以用于金融、工业、医疗等各个领域。在实际应用中，图的规模越来越大，比如金融交易图，点边规模可能到达百亿，与其同时，基于图的查询通常会复杂，最典型的是K跳查询，每增加一跳访问的数据都呈指数增长。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/2.what-is-gdbms.md",
        "chunks": [
            {
                "content": "# 什么是图数据库\n\n> 本文主要介绍什么是图数据库，图数据库相比于关系型数据库的优势，以及两者特点的对比。\n\n## 1. 图数据库介绍\n\n图数据库是基于图模型的数据库。与关系型数据库相比，图数据库真正注重“关系”。图数据库的主要功能是管理图数据，因此需要支持高效的点、边查询和更新；为方便用户使用，通常还需要增加对事务（transaction）的支持，以确保并发操作下的正常运行。\n\n## 2. 图数据库相比较于关系型数据库的优势\n\n图数据库的功能是传统关系型数据库的扩展。与关系型数据库仅支持的“表结构”相比，图数据库所支持的“图结构”更为灵活。图数据库在基于图的增加、删除、查询和修改方面采用不同于其他数据库的设计。在图数据操作抽象上，采用基于点的视角，例如点通过其所有“出边”（从一个点出发，连接到其他点的边）访问其邻接点。这是图数据库系统设计的核心。\n\n图数据库的独特性体现在以下三个方面:\n\n### 2.1. 性能\n\n在关联关系处理上，使用关系型数据库不可避免地要使用表的JOIN操作，这会对性能产生较大影响；而图数据库则直接跳转访问类指针，操作关联数据的效率更高，比关系型数据库提高2到4个数量级的性能。\n\n### 2.2. 兼容性\n\n现实中，项目进程通常不断演变，数据的内容甚至数据格式也在不断变化。在关系型数据库中，这意味着表结构的变化或建立多个新表，对源数据的修改非常大。而在图数据库中，仅需添加新的点、边和属性，并将其设置为对应的类型即可。从本质上说，一个表代表一种类型的数据，一个点代表一个特定的数据。这意味着关系型数据库更关注数据类型，而图数据库更关注数据个体及其关联关系。\n\n### 2.3. 直观性\n\n使用图的方式表达现实世界的关系更直接和自然，在万物互联的时代尤为突出。如果使用关系型数据，先建立实体表，再建立关系表，最后映射数据，需要高度的抽象思维。在图数据上进行分析查询时，可以直观地通过点边连接的拓扑结构找到所需数据，无需任何专业知识。\n\n## 3. 图数据库与关系型数据库对比"
            },
            {
                "content": "图数据库的独特性体现在以下三个方面:\n\n### 2.1. 性能\n\n在关联关系处理上，使用关系型数据库不可避免地要使用表的JOIN操作，这会对性能产生较大影响；而图数据库则直接跳转访问类指针，操作关联数据的效率更高，比关系型数据库提高2到4个数量级的性能。\n\n### 2.2. 兼容性\n\n现实中，项目进程通常不断演变，数据的内容甚至数据格式也在不断变化。在关系型数据库中，这意味着表结构的变化或建立多个新表，对源数据的修改非常大。而在图数据库中，仅需添加新的点、边和属性，并将其设置为对应的类型即可。从本质上说，一个表代表一种类型的数据，一个点代表一个特定的数据。这意味着关系型数据库更关注数据类型，而图数据库更关注数据个体及其关联关系。\n\n### 2.3. 直观性\n\n使用图的方式表达现实世界的关系更直接和自然，在万物互联的时代尤为突出。如果使用关系型数据，先建立实体表，再建立关系表，最后映射数据，需要高度的抽象思维。在图数据上进行分析查询时，可以直观地通过点边连接的拓扑结构找到所需数据，无需任何专业知识。\n\n## 3. 图数据库与关系型数据库对比\n\n| 分类         | 模型   | 优势                                   | 劣势                                     | 举例           |\n| ------------ | ------ | -------------------------------------- | ---------------------------------------- | -------------- |\n| 关系型数据库 | 表结构 | 数据高度结构化，一致性强，软件成熟度高 | 面向多跳的关联关系查询低效或不支持       | MySQL、Oracle  |\n| 图数据库     | 图结构 | 针对关联关系的建模建模和操作效率非常高 | 高度结构化的数据处理能力不及关系型数据库 | Neo4j、TuGraph |"
            },
            {
                "content": "## 3. 图数据库与关系型数据库对比\n\n| 分类         | 模型   | 优势                                   | 劣势                                     | 举例           |\n| ------------ | ------ | -------------------------------------- | ---------------------------------------- | -------------- |\n| 关系型数据库 | 表结构 | 数据高度结构化，一致性强，软件成熟度高 | 面向多跳的关联关系查询低效或不支持       | MySQL、Oracle  |\n| 图数据库     | 图结构 | 针对关联关系的建模建模和操作效率非常高 | 高度结构化的数据处理能力不及关系型数据库 | Neo4j、TuGraph |\n\n总之，面对海量数据的存储和处理问题，传统的关系数据库已经无法满足大部分的日常数据存储需求。图数据库技术可以将关系信息存储为实体，灵活拓展数据模型。由于提供了对关联数据最直接的表达方式和图模型对异构数据的天然包容性，图数据库技术必将成为未来最热点的技术之一，为企业提供存储和分析大规模图数据的有力支持。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/3.what-is-tugraph.md",
        "chunks": [
            {
                "content": "# 什么是TuGraph\n\n> 本文主要介绍TuGraph社区版的主要功能和特性，以及TuGraph企业版和社区版的差异。\n\n## 1. 简介\n\nTuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，解决了图数据分析面临的大数据量、高吞吐率和低延迟等重大挑战，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。\n\n## 2. TuGraph社区版\n\n2022年9月，TuGraph单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，支持TB级别的数据规模，为用户管理和分析复杂关联数据提供了高效、易用、可靠的平台。\n\nTuGraph社区版于2022年9月开源，提供了完整的图数据库基础功能和成熟的产品设计（如ACID兼容的事务、编程API和配套工具等），适用于单实例部署。社区版支持TB级别的数据规模，为用户管理和分析复杂关联数据提供了高效、易用、可靠的平台，是学习TuGraph和实现小型项目的理想选择。\n\n## 3. TuGraph特性\n\nTuGraph是支持大数据量、低延迟查找和快速图分析功能的高效图数据库。TuGraph也是基于磁盘的数据库，支持存储多达数十TB的数据。TuGraph提供多种API，使用户能够轻松构建应用程序，并使其易于扩展和优化。\n\n它具有如下功能特征：\n\n- 属性图模型\n- 实时增删查改\n- 多重图（点间允许多重边）\n- 多图（大图与多个子图）\n- 完善的ACID事务处理，隔离级别为可串行化（serializable）\n- 点边索引\n- 混合事务和分析处理（HTAP），支持图查询、图分析、图学习\n- 主流图查询语言（OpenCypher、ISO GQL等）\n- 支持OLAP API，内置30多种图分析算法\n- 基于C++/Python的存储过程，含事务内并行Traversal API\n- 提供图可视化工具\n\n在性能和可扩展性方面的支持：\n\n- 千万点/秒的高吞吐率\n- TB级大容量\n- 高可用性支持\n- 高性能批量导入\n- 在线/离线的备份恢复\n\n## 4. TuGraph企业版"
            },
            {
                "content": "## 3. TuGraph特性\n\nTuGraph是支持大数据量、低延迟查找和快速图分析功能的高效图数据库。TuGraph也是基于磁盘的数据库，支持存储多达数十TB的数据。TuGraph提供多种API，使用户能够轻松构建应用程序，并使其易于扩展和优化。\n\n它具有如下功能特征：\n\n- 属性图模型\n- 实时增删查改\n- 多重图（点间允许多重边）\n- 多图（大图与多个子图）\n- 完善的ACID事务处理，隔离级别为可串行化（serializable）\n- 点边索引\n- 混合事务和分析处理（HTAP），支持图查询、图分析、图学习\n- 主流图查询语言（OpenCypher、ISO GQL等）\n- 支持OLAP API，内置30多种图分析算法\n- 基于C++/Python的存储过程，含事务内并行Traversal API\n- 提供图可视化工具\n\n在性能和可扩展性方面的支持：\n\n- 千万点/秒的高吞吐率\n- TB级大容量\n- 高可用性支持\n- 高性能批量导入\n- 在线/离线的备份恢复\n\n## 4. TuGraph企业版\n\n企业版对商业化功能支持更加完善，包括分布式集群架构，覆盖探索、研发、服务、运维管理全生命周期的一站式图平台，在线、近线、离线的图计算引擎，支持流式、大数据类数据源，多地多中心的部署形态，以及专家支持服务等。企业版是商业化解决方案的理想选择。\n\n如需商业支持，请联系我们：\n\n- 电话：400-903-0809\n- 邮件：tugraph@service.alipay.com\n- 官网：https://tugraph.antgroup.com"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/4.schema.md",
        "chunks": [
            {
                "content": "# TuGraph图模型说明\n## 1. 数据模型\n\n### 1.1. 图模型\n\nTuGraph是一个具备多图能力的强类型、有向属性图数据库。\n\n- 图项目：每个数据库服务可以承载多个图项目（多图），每个图项目可以有自己的访问控制配置，数据库管理员可以创建或删除指定图项目。\n- 点：指实体，一般用于表达现实中的实体对象，如一部电影、一个演员。\n    - 主键：用户自定义的点数据主键，默认唯一索引，在对应的点类型中唯一。\n    - VID：点在存储层自动分配图项目中的唯一ID，用户不可修改。\n    - 上限：每个图项目存储最多2^(40)个点数据。\n- 边：用于表达点与点之间的关系，如演员出演电影。\n    - 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。\n    - 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。\n    - 上限：两个点数据之间存储最多2^(32)条边数据。\n- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。\n- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。\n    - 指定边的起/终点类型：可限制边的起点和终点点类型，支持同类型边的起点和终点的点类型不同，如个人转账给公司、公司转账给公司；当指定边的起/终点类型后，可增加多组起/终点类型，不可删除已限制的起/终点类型。\n    - 无限制模式：支持不指定边的起点和终点的点类型，任意两个点类型间均可创建该类型的边数据。注：当指定边的起/终点类型后无法再采用无限制模式。\n\n### 1.2. 数据类型\n\nTuGraph支持多种可用于属性的数据类型。具体支持的数据类型如下："
            },
            {
                "content": "| **数据类型** | **最小值**          | **最大值**          | **描述**                            |\n| ------------ | ------------------- | ------------------- | ----------------------------------- |\n| BOOL         | false               | true                | 布尔值                              |\n| INT8         | -128                | 127                 | 8位整型                          |\n| INT16        | -32768              | 32767               | 16位整型                         |\n| INT32        | - 2^31              | 2^31 - 1            | 32位整型                         |\n| INT64        | - 2^63              | 2^63 - 1            | 64位整型                         |\n| DATE         | 0000-00-00          | 9999-12-31          | \"YYYY-MM-DD\" 格式的日期             |\n| DATETIME     | 0000-00-00 00:00:00.000000 | 9999-12-31 23:59:59.999999 | \"YYYY-MM-DD HH:mm:ss[.ffffff]\" 格式的日期时间 |\n| FLOAT        |                     |                     | 32位浮点数                       |"
            },
            {
                "content": "| INT32        | - 2^31              | 2^31 - 1            | 32位整型                         |\n| INT64        | - 2^63              | 2^63 - 1            | 64位整型                         |\n| DATE         | 0000-00-00          | 9999-12-31          | \"YYYY-MM-DD\" 格式的日期             |\n| DATETIME     | 0000-00-00 00:00:00.000000 | 9999-12-31 23:59:59.999999 | \"YYYY-MM-DD HH:mm:ss[.ffffff]\" 格式的日期时间 |\n| FLOAT        |                     |                     | 32位浮点数                       |\n| DOUBLE       |                     |                     | 64位浮点数                       |\n| STRING       |                     |                     | 不定长度的字符串                    |\n| BLOB         |                     |                     | 二进制数据（在输入输出时使用Base64编码） |\n| POINT        |                     |                     | EWKB格式数据，表示点              |\n| LINESTRING   |                     |                     | EWKB格式数据，表示线              |\n| POLYGON      |                     |                     | EWKB格式数据，表示面(多边形)       |"
            },
            {
                "content": "| STRING       |                     |                     | 不定长度的字符串                    |\n| BLOB         |                     |                     | 二进制数据（在输入输出时使用Base64编码） |\n| POINT        |                     |                     | EWKB格式数据，表示点              |\n| LINESTRING   |                     |                     | EWKB格式数据，表示线              |\n| POLYGON      |                     |                     | EWKB格式数据，表示面(多边形)       |\n| FLOAT_VECTOR |                     |                     | 包含32位浮点数的动态向量               |"
            },
            {
                "content": "### 1.3. 索引\n\nTuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：\n- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。\n- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。\n- BLOB类型的属性不能建立索引。\n\nTuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：\n\n#### 1.3.1 普通索引\n##### 1.3.1.1 点索引\n###### 1.3.1.1.1 unique索引\n\n点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，\nunique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。\nprimary作为特殊的unique索引，因此最大key的长度也是480bytes。\n\n###### 1.3.1.1.2 non_unique索引\n\n点的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，\n在同一个图中，相同label的点的该属性可以存在相同的值。\n由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，\n在用户指定的key后面加上了索引key相同的一组vid的最大值。\n每个vid是5bytes长度，因此non_unique索引key最大长度是475bytes。\n但是，不同于unique索引，超过475bytes也可以建立non_unique索引。\n只不过在对这样的属性建立索引时会只截取**前475bytes**作为索引key（属性本身存储的值不受影响）。\n并且，在通过迭代器遍历时，也是先自动截取查询值的前475bytes再进行遍历，\n所以结果可能和预期不一致，需要用户再过滤。\n\n##### 1.3.1.2 边索引\n\n###### 1.3.1.2.1 unique索引"
            },
            {
                "content": "###### 1.3.1.1.2 non_unique索引\n\n点的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，\n在同一个图中，相同label的点的该属性可以存在相同的值。\n由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，\n在用户指定的key后面加上了索引key相同的一组vid的最大值。\n每个vid是5bytes长度，因此non_unique索引key最大长度是475bytes。\n但是，不同于unique索引，超过475bytes也可以建立non_unique索引。\n只不过在对这样的属性建立索引时会只截取**前475bytes**作为索引key（属性本身存储的值不受影响）。\n并且，在通过迭代器遍历时，也是先自动截取查询值的前475bytes再进行遍历，\n所以结果可能和预期不一致，需要用户再过滤。\n\n##### 1.3.1.2 边索引\n\n###### 1.3.1.2.1 unique索引\n\n和点类似，边的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的边的该属性不会存在相同的值，\nunique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。\n\n###### 1.3.1.2.2 pair_unique索引\n\npair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，\n相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，\n索引在用户指定的key后面加上了起点和终点的vid，每个vid是5bytes长度。\n因此最大key的长度是470bytes，**超过470bytes的属性不能建立pair_unique索引**。\n\n###### 1.3.1.2.3 non_unique索引"
            },
            {
                "content": "##### 1.3.1.2 边索引\n\n###### 1.3.1.2.1 unique索引\n\n和点类似，边的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的边的该属性不会存在相同的值，\nunique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。\n\n###### 1.3.1.2.2 pair_unique索引\n\npair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，\n相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，\n索引在用户指定的key后面加上了起点和终点的vid，每个vid是5bytes长度。\n因此最大key的长度是470bytes，**超过470bytes的属性不能建立pair_unique索引**。\n\n###### 1.3.1.2.3 non_unique索引\n\n和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，\n在同一个图中，相同label的边的该属性可以存在相同的值。\n由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，\n在用户指定的key后面加上了索引key相同的一组eid的最大值。\n每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。\n但是，不同于unique索引，超过456bytes也可以建立non_unique索引。\n只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。\n并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，\n所以结果可能和预期不一致，需要用户再过滤。\n\n#### 1.3.2 组合索引\n\n目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：\n1. 建立组合索引的属性个数在2到16个之间（含）\n2. 唯一组合索引的属性长度之和不能超过480-2*(属性个数-1)字节，非唯一组合索引的属性长度之和不能超过475-2*(属性个数-1)字节"
            },
            {
                "content": "#### 1.3.2 组合索引\n\n目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：\n1. 建立组合索引的属性个数在2到16个之间（含）\n2. 唯一组合索引的属性长度之和不能超过480-2*(属性个数-1)字节，非唯一组合索引的属性长度之和不能超过475-2*(属性个数-1)字节\n\n##### 1.3.2.1 唯一索引\n\n和点的普通唯一索引类似，点的组合唯一索引指的是全局唯一的索引，即若一组属性设置了unique索引，\n在同一个图中，相同label的点的该组属性不会存在相同的值。\n由于底层存储设计，组合索引key需要保存属性的长度，因此，\n组合唯一索引key的最大长度是480-2*(属性个数-1) bytes，**超过的属性不能建立唯一索引**。\n\n##### 1.3.2.2 非唯一索引\n\n和点的普通非唯一索引类似，点的非唯一索引指的是非全局唯一的索引，即若一组属性设置了非唯一索引，\n在同一个图中，相同label的点的该组属性可以存在相同的值。\n由于非唯一索引一个key可能映射到多个值，为了加速查找和写入，\n在用户指定的key后面加上了索引key相同的一组vid的最大值。\n每个vid是5bytes长度，因此non_unique索引key最大长度是475-2*(属性个数-1) bytes，\n**超过的属性不能建立非唯一索引**。\n\n## 2. 图项目、点、边、属性命名规则和建议\n\n### 2.1 命名规则\n图项目、点、边和属性是识别符。该节描述了在TuGraph中识别符的允许的语法。\n下面的表描述了每类识别符的最大长度和允许的字符。\n\n|**识别符** |**长度** |**允许的字符**|\n|---------  |---------  |---------  |\n|用户、角色、图项目\t|1-64字符\t|允许中文、字母、数字、下划线，且首字符不为数字|\n|点类型、边类型、属性\t|1~256字符\t|允许中文、字母、数字、下划线，且首字符不为数字|\n\n### 2.2 使用限制\n\n|**描述**|\t**最大个数**|\n|-------- |--------- |\n|用户数、角色数\t|65536|\n|图项目的个数\t|4096|\n|每个图项目的点和边类型数量之和\t|4096|\n|每个点或边类型的属性数量\t|1024|"
            },
            {
                "content": "## 2. 图项目、点、边、属性命名规则和建议\n\n### 2.1 命名规则\n图项目、点、边和属性是识别符。该节描述了在TuGraph中识别符的允许的语法。\n下面的表描述了每类识别符的最大长度和允许的字符。\n\n|**识别符** |**长度** |**允许的字符**|\n|---------  |---------  |---------  |\n|用户、角色、图项目\t|1-64字符\t|允许中文、字母、数字、下划线，且首字符不为数字|\n|点类型、边类型、属性\t|1~256字符\t|允许中文、字母、数字、下划线，且首字符不为数字|\n\n### 2.2 使用限制\n\n|**描述**|\t**最大个数**|\n|-------- |--------- |\n|用户数、角色数\t|65536|\n|图项目的个数\t|4096|\n|每个图项目的点和边类型数量之和\t|4096|\n|每个点或边类型的属性数量\t|1024|\n\n注：\n1、特殊字符和关键字说明：使用特殊字符或非保留关键字时，需要使用反单引号/backquote（``）进行引用；\n\n示例： ```match (`match`:match) return `match`.id limit 1```\n\n2、大小写敏感性：TuGraph大小写敏感；\n\n3、图项目、点/边、属性名称之间可以重复使用，同一点或边下的属性名称不可以重复；\n\n4、属性名字保留关键字：SRC_ID / DST_ID / SKIP\n\n\n### 2.3 命名建议\n|**识别符**|**描述**|**建议**|\n|-------|-------|--------|\n|图项目\t|字母或中文开头\t|如graph123、project123等|\n|点/边类型\t|字母或中文开头，使用下划线区分单词\t|如person、act_in等|\n|属性\t|字母或中文\t|如name、age等|"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/5.characteristics/1.performance-oriented.md",
        "chunks": [
            {
                "content": "# 性能优先\n\n> 此文档主要介绍 TuGraph 性能优先的设计理念。\n\n## 1.简介\n\nTuGraph目前是世界上最快的图数据库，在图数据库标准评测LDBC SNB Interactive位居榜首（2023.3）。TuGraph的设计基于性能优先，致力于打造高性能的单机图数据库。该文档是TuGraph基于性能优先在存储层的核心设计。\n\n## 2.图操作的特性\n\n在属性图上的操作涉及读、写及其属性，对一些特殊的属性比如时间戳也访问模式也会影响到整体性能。这里通过对一些图操作特性的规律总结，来指导最终的性能。\n\n我们观察到很多图应用有类似的数据访问模式。例如，在信贷风险控制中，我们使用递归路径过滤搜索多对一模式，以找到可疑的信用欺诈用户和行为。针对网络赌博，可以通过识别短时间内的多笔资金转移，来发现涉赌的资金账号。股权穿透场景对实体间的股权关系进行递归计算。这些场景具有多跳实体和关系访问、时间窗口约束和读写事务等常见模式。\n更进一步，从介绍中的讨论和图负载的分析中，归纳出以下特征:\n\n**规律一** KHop是图中最典型的操作，它基于点和边的图拓扑的数据访问模式，和关系型数据库有着本质的区别。KHop 的典型性除了表现在数据访问模式不同，它同时也是图数据库最需要关注的性能点。\n\n**规律二** 图负载的数据访问在拓扑上有一定的局部性，同一个点的边通常会被同时访问。当这些边的标签相同时，有更大的概率会被同时访问。\n\n**规律三** 图负载在访问点边时，通常会访问其对应的属性，来作为遍历过滤的条件。\n\n**规律四** 在基于时序的图负载，对点边的过滤通常是在某个时间范围，比如最近的一周。\n\n**规律五** 写操作可能伴随着大量的读操作，需要在单个事务周期里处理。\n\n通过对实际线上图应用的分析，图负载的读写比率大约为 20:1，虽然场景局限在金融场景，集群数也有限，但涉及的数据规模和用户量非常庞大，具有一定代表性。20:1 的图负载读写比率，说明读工作负载对整体性能的影响更大， 而写工作负载的性能也不能忽视。\n\n## 3.存储数据结构\n\nTuGraph底层采用B+树来支持实时的增删查改事务。"
            },
            {
                "content": "**规律一** KHop是图中最典型的操作，它基于点和边的图拓扑的数据访问模式，和关系型数据库有着本质的区别。KHop 的典型性除了表现在数据访问模式不同，它同时也是图数据库最需要关注的性能点。\n\n**规律二** 图负载的数据访问在拓扑上有一定的局部性，同一个点的边通常会被同时访问。当这些边的标签相同时，有更大的概率会被同时访问。\n\n**规律三** 图负载在访问点边时，通常会访问其对应的属性，来作为遍历过滤的条件。\n\n**规律四** 在基于时序的图负载，对点边的过滤通常是在某个时间范围，比如最近的一周。\n\n**规律五** 写操作可能伴随着大量的读操作，需要在单个事务周期里处理。\n\n通过对实际线上图应用的分析，图负载的读写比率大约为 20:1，虽然场景局限在金融场景，集群数也有限，但涉及的数据规模和用户量非常庞大，具有一定代表性。20:1 的图负载读写比率，说明读工作负载对整体性能的影响更大， 而写工作负载的性能也不能忽视。\n\n## 3.存储数据结构\n\nTuGraph底层采用B+树来支持实时的增删查改事务。\n\n在排序树的数据结构中，B+树和LSM树为主要代表。B+树在树节点中使用拆分和合并式来更新排序数据，而 LSM 树在日志中追加更新，以进行延迟数据合并。B+ 早期用在文件系统的实现中，通过将数据保存 在自适应长度的叶子节点中，解决硬盘顺序操作和随机操作性能存在数据量级差别的问题，有较均衡的读写性能。LSM 树的主要优势使用 WAL(Write Ahead Log) 进行更新，将更新操作变成顺序操作，在键值较小时性能优势尤为突出。WAL 意味着将数据的更新合并推迟，批量更新能提升综合效率，也使得系统的调度变得复杂。如果更新合并完成前，恰好对其中的数据继续读取，LSM 树就需要读取几个层级局部合并的日志，会导致读取放大和空间放大，从而影响读效率。\n\n总结来说，B+ 树有较好的顺序读写性能，而 LSM 树在数据随机写方面占优。此外 LSM 树采用后台合并的方式，使得性能的波动难以预期，性能波动和上层存储和计算的关联性较弱，增加了整体设计的成本。综上考虑，TuGraph 选用 B+ 树作为读性能优先的实现。\n\n## 4.数据编码"
            },
            {
                "content": "## 3.存储数据结构\n\nTuGraph底层采用B+树来支持实时的增删查改事务。\n\n在排序树的数据结构中，B+树和LSM树为主要代表。B+树在树节点中使用拆分和合并式来更新排序数据，而 LSM 树在日志中追加更新，以进行延迟数据合并。B+ 早期用在文件系统的实现中，通过将数据保存 在自适应长度的叶子节点中，解决硬盘顺序操作和随机操作性能存在数据量级差别的问题，有较均衡的读写性能。LSM 树的主要优势使用 WAL(Write Ahead Log) 进行更新，将更新操作变成顺序操作，在键值较小时性能优势尤为突出。WAL 意味着将数据的更新合并推迟，批量更新能提升综合效率，也使得系统的调度变得复杂。如果更新合并完成前，恰好对其中的数据继续读取，LSM 树就需要读取几个层级局部合并的日志，会导致读取放大和空间放大，从而影响读效率。\n\n总结来说，B+ 树有较好的顺序读写性能，而 LSM 树在数据随机写方面占优。此外 LSM 树采用后台合并的方式，使得性能的波动难以预期，性能波动和上层存储和计算的关联性较弱，增加了整体设计的成本。综上考虑，TuGraph 选用 B+ 树作为读性能优先的实现。\n\n## 4.数据编码\n\n对于属性图模型而言，除了图拓扑编码外，属性数据也会很大程度影响功能和性能，我们先讨论属性数据如何与拓扑数据共存的编码格式。从目前的调研来看，属性编码有两种方式，我们称之为基于指针索引将属性数据单独存储的离散编码，和将属性数据和拓扑数据打包在一起的紧凑编码。离散编码根据程度的不同，可以每个属性都单独存储，或者每条边的属性打包后各自存储，下面的讨论对两种情况都适用。\n\n点查询。属性编码主要针对边，不涉及点查询。\n\n单边查询。离散编码通过指针定位边，紧凑编码则需要二分查找定位边的位置，离散编码有略微的优势。\n\n边遍历。离散编码在边遍历过程需要不断地进行指针跳转进行随机数据访问，而紧凑编码提前把数据排列在一起，顺序访问的特性使得效率大大提升。 由规律三知对边的遍历操作很普遍，紧凑编码在边遍历的优势明显。\n\n单边更新。离散编码对边的更新仅需找到对应的指针位置，插入数据后修改前后指针指向。紧凑编码则需要对紧凑排列的数据进行重编码，对整个边值进行重新写入，开销显著大于离散编码的情形。"
            },
            {
                "content": "## 4.数据编码\n\n对于属性图模型而言，除了图拓扑编码外，属性数据也会很大程度影响功能和性能，我们先讨论属性数据如何与拓扑数据共存的编码格式。从目前的调研来看，属性编码有两种方式，我们称之为基于指针索引将属性数据单独存储的离散编码，和将属性数据和拓扑数据打包在一起的紧凑编码。离散编码根据程度的不同，可以每个属性都单独存储，或者每条边的属性打包后各自存储，下面的讨论对两种情况都适用。\n\n点查询。属性编码主要针对边，不涉及点查询。\n\n单边查询。离散编码通过指针定位边，紧凑编码则需要二分查找定位边的位置，离散编码有略微的优势。\n\n边遍历。离散编码在边遍历过程需要不断地进行指针跳转进行随机数据访问，而紧凑编码提前把数据排列在一起，顺序访问的特性使得效率大大提升。 由规律三知对边的遍历操作很普遍，紧凑编码在边遍历的优势明显。\n\n单边更新。离散编码对边的更新仅需找到对应的指针位置，插入数据后修改前后指针指向。紧凑编码则需要对紧凑排列的数据进行重编码，对整个边值进行重新写入，开销显著大于离散编码的情形。\n\n批量边更新。批量更新可以在内存中预先构建点的所有边属性，一次性编码写入，离散编码和紧凑编码相当。但紧凑编码不需要存储指针变量，更少的存储空间效率也会更高。\n\n以上离散编码和紧凑编码在某一类的查询的性能问题，可以通过优化的来缓解。整体上说，由于图负载读写 20:1 的特性，读性能在整体性能中占比更高。以及规律三所揭示的对属性访问的特征，TuGraph 更倾向于采用紧凑编码来保证读性能。其主要弱势为单边更新时重编码的开销，可以用自适应映射的技术来解决。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/5.characteristics/2.multi-level-Interfaces.md",
        "chunks": [
            {
                "content": "# 多层级接口\n\n\n> 此文档主要介绍 TuGraph 的多层级接口的设计理念。\n\n## 1.简介\n\n多层级接口是 TuGraph 针对多丰富的使用场景，在易用性和高性中作出的平衡。比如描述式图查询语言 Cypher 能够抹去图数据库实现的细节，基于图模型的抽象来进行表达。Cypher 过于高层的表述，无法高效转化成底层的执行，因此提供了 Procedure API 的过程式语言，来发挥图数据库的最佳性能。\n\n接口可以大致分为客户端接口和服务端接口，大部分操作都在服务端完成，客户端只做数据的封装和解析。客户端和服务端通过网络连接，TuGraph 支持更加灵活的短连接 REST 协议，以及更加高效的长链接 RPC 协议，可根据不同的业务场景来选择。\n\n服务端接口均处在计算层，和图数据存储间用一层 Core API 在逻辑上隔开。\n\n![多层级接口架构](../../../../images/multi-level-Interfaces.png)\n\n## 2.客户端接口\n\n客户端接口指在客户端执行的接口，通常用于集成到软件应用中。TuGraph 的客户端的接口比较简单，包括登录登出、数据导入导出、存储过程加载调用、Cypher操作等。其中 Cypher 中集成了大部分的功能，包括数据操作、图模型操作、运维管理、账户管理等。\n\n由于 Cypher 的参数和返回值都是字符串，JAVA OGM 是对 Cypher 的结构化封装，即查询结果能够被封装为一个有类型的对象，方便使用。\n\n## 3.服务端接口\n\n服务端接口包括描述式图查询语言 Cypher、过程式图查询语言 Procedure API、图分析编程框架 OLAP API 和图神经网络编程框架 GNN PI，为图事务引擎、图分析引擎、图神经网络引擎提供服务，下面先展开介绍各个接口的特点。\n\n> __描述式图查询语言__ 是对查询逻辑的抽象描述，而与执行逻辑无关，对图数据库应用者比较友好，类比关系型数据库的 SQL 语言。TuGraph 的 Cypher 语言主要依照 Neo4j 开源的 OpenCypher 查询标准，同时对运维管理等辅助功能进行了扩展，在功能上囊括了 TuGraph 的大部分操作。描述式图查询语言会成为图数据库的主要数据操作方式，但由于描述到执行之间需要生成执行计划（Execution Plan），生成最优执行计划在学术界和工业界均有很长的路要走。"
            },
            {
                "content": "由于 Cypher 的参数和返回值都是字符串，JAVA OGM 是对 Cypher 的结构化封装，即查询结果能够被封装为一个有类型的对象，方便使用。\n\n## 3.服务端接口\n\n服务端接口包括描述式图查询语言 Cypher、过程式图查询语言 Procedure API、图分析编程框架 OLAP API 和图神经网络编程框架 GNN PI，为图事务引擎、图分析引擎、图神经网络引擎提供服务，下面先展开介绍各个接口的特点。\n\n> __描述式图查询语言__ 是对查询逻辑的抽象描述，而与执行逻辑无关，对图数据库应用者比较友好，类比关系型数据库的 SQL 语言。TuGraph 的 Cypher 语言主要依照 Neo4j 开源的 OpenCypher 查询标准，同时对运维管理等辅助功能进行了扩展，在功能上囊括了 TuGraph 的大部分操作。描述式图查询语言会成为图数据库的主要数据操作方式，但由于描述到执行之间需要生成执行计划（Execution Plan），生成最优执行计划在学术界和工业界均有很长的路要走。\n\n> __过程式图查询语言__ 是为了解决描述式图查询语言与最优性能间的鸿沟。TuGraph的 Procedure API 是在 Core API 上做了一层简单的封装，C++ Procedure API的灵活性和高效性能够充分发挥存储的极致性能，也是 Cypher 优化的上限性能。Python Procedure API 是 C++ Procedure API 上的一层跨语言封装，翻译过程中值的拷贝会带来一定的性能损失，优势则主要是 python 语言本身的易用性。raversal API 是并行执行的 Procedure 接口，描述上更接近于集合的操作，比如扩展点集合所有出度邻居，获得一个新的点集。\n\n> __图分析编程框架__ 属于 ‘图计算系统’ 的范畴，会将图数据从支持增删改查的存储中导出快照，以更紧凑的数据存储格式来支持只读的复杂图分析，这里叫做OLAP API。OLAP API 封装了高并发执行的数据结构，包括 Vector、Bitmap等，以及基于 CSR 格式的图快照数据结构，然后提供一套并发的快速点边操作框架。在图分析任务完成后，数据可以通过接口写回图数据库。"
            },
            {
                "content": "> __过程式图查询语言__ 是为了解决描述式图查询语言与最优性能间的鸿沟。TuGraph的 Procedure API 是在 Core API 上做了一层简单的封装，C++ Procedure API的灵活性和高效性能够充分发挥存储的极致性能，也是 Cypher 优化的上限性能。Python Procedure API 是 C++ Procedure API 上的一层跨语言封装，翻译过程中值的拷贝会带来一定的性能损失，优势则主要是 python 语言本身的易用性。raversal API 是并行执行的 Procedure 接口，描述上更接近于集合的操作，比如扩展点集合所有出度邻居，获得一个新的点集。\n\n> __图分析编程框架__ 属于 ‘图计算系统’ 的范畴，会将图数据从支持增删改查的存储中导出快照，以更紧凑的数据存储格式来支持只读的复杂图分析，这里叫做OLAP API。OLAP API 封装了高并发执行的数据结构，包括 Vector、Bitmap等，以及基于 CSR 格式的图快照数据结构，然后提供一套并发的快速点边操作框架。在图分析任务完成后，数据可以通过接口写回图数据库。\n\n> __图神经网络编程框架__ 主要提供了图神经网络应用编程所需要的接口，能够对接PyTorch 等机器学习框架。TuGraph 的图神经网络编程框架主要集成了 DGL，在 Python 的语言环境中完成从图存储到图神经网络应用的完整流程。\n\n除了 Cypher 是解释执行外，其余服务端接口都是编译执行，即需要将对应代码传到服务端后，进行编译（可能会有时间开销），再在服务端执行。所以通常需要先加载，然后再已加载的应用列表中找到程序，传输入参数后执行。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/5.characteristics/3.htap.md",
        "chunks": [
            {
                "content": "# HTAP\n\n> 此文档主要介绍 TuGraph 的HTAP的设计理念。\n\n## 1.简介\n\n![htap架构](../../../../images/htap.png)\n\nHTAP 的实现在架构上有多种不同的方式：一是用两个不同的副本来分别处理 OLTP 和 OLAP 的任务，核心是数据的一致性同步和额外的资源开销；二是在任何时候都使用同一份数据存储，该实现的数据结构存在内存膨胀，在工业化落地还需要进一步工作。在 TuGraph 的设计中，简单的 OLAP 操作和 OLTP 操作共用一份数据，而复杂的 OLAP 操作则单独导出快照处理。\n\n## 2.设计\n\n在 TuGraph 中，OLTP 为图事务引擎，在图 4.4对应事务操作；OLAP 为图分析引擎，对应简单图分析操作（比如 SPSP）和复杂图分析操作（比如 PageRank），前者可以直接在图存储上执行，而后者需要额外导出快照执行。\n\n- 事务操作，即图事务引擎测的操作，为局部图的增删查改操作，典型的应用为 K 跳访问 K-Hop。\n- 简单分析操作，是图分析引擎中较为简单的部分，通常也是局部的图分析操作，比如两点间最短路算法 SPSP、Jaccard 算法。\n- 复杂分析操作，是图分析引擎中较为复杂的部分，通常涉及全图的多轮数据迭代操作，比如网页排序算法 PageRank、社区发现算法 Louvain。\n\n如架构图所示，我们在图中增加了外部存储，使得图分析的数据源不局限在图数据库中，可以直接从文本文件读取。\n\n- 图存储，即图数据库中的存储，有精心设计的数据结构，能够完成实时增删查改。\n- 外部存储，可以是 RDBMS 或文本文件，以边表的简单方式存储，仅供一次性批量读取，和批量结果写入。在计算层，和整体架构图中的接口对应。\n- Cypher，描述式图查询语言，可以并发执行。\n- Procedure API，过程式图查询语言，其灵活性能够同时支持事务操作和图分析操作，但效率上不足以完成复杂图分析操作，可以并发执行。\n- OLAP API，针对多轮迭代的复杂图分析。应用需要先将存储中的图数据导出成内存中的一个快照，该快照仅用来快速访问，而不需要考虑 ACID 的写支持，因此可以排布地更加紧凑，CSR 排布的读效率要远高于图存储的数据排布。OLAP API 只能串行执行，每个操作都用满 CPU 资源。"
            },
            {
                "content": "如架构图所示，我们在图中增加了外部存储，使得图分析的数据源不局限在图数据库中，可以直接从文本文件读取。\n\n- 图存储，即图数据库中的存储，有精心设计的数据结构，能够完成实时增删查改。\n- 外部存储，可以是 RDBMS 或文本文件，以边表的简单方式存储，仅供一次性批量读取，和批量结果写入。在计算层，和整体架构图中的接口对应。\n- Cypher，描述式图查询语言，可以并发执行。\n- Procedure API，过程式图查询语言，其灵活性能够同时支持事务操作和图分析操作，但效率上不足以完成复杂图分析操作，可以并发执行。\n- OLAP API，针对多轮迭代的复杂图分析。应用需要先将存储中的图数据导出成内存中的一个快照，该快照仅用来快速访问，而不需要考虑 ACID 的写支持，因此可以排布地更加紧凑，CSR 排布的读效率要远高于图存储的数据排布。OLAP API 只能串行执行，每个操作都用满 CPU 资源。\n\nOLAP API 的快照可以从外部存储创建，即将边表数据构成件 CSR 的格式；或者从图存储中创建。需要注意的是，OLAP API 要求点的 ID 是连续的自然数，可能需要额外的 ID 映射，该步骤在创建快照时可以在指定一个属性进行映射，或直接取属性值作为 ID。\n\n与计算接口和存储相对应，有四种运行模式。\n\n- 事务模式，每个操作对应一条 Cypher 语句，默认是一个事务。\n- Plugin 模式，通过插件的方式，在计算逻辑加载到服务端后调用，也叫存储过程。\n- Embed 模式，和 Plugin 模式的使用接口一致，区别是图数据库服务不需要起来，就可以直接用接口调用数据库中的数据，通常用于调试 Procedure API 和OLAP API 的代码，调试信息和操作步骤比 Plugin 模式更加友好。\n- Standalone 模式，最大程度剥离与图数据库的关系，仅想用图分析引擎做数据分析时，该模式会比较直接。Standalone 模式会直接使用外部存储的数据。\n\n图神经网络引擎的使用方式和 ‘复杂图分析操作’ 类似，会同时调用部分 OLAP API 和 GNN API，不在这里展开。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/6.architecture.md",
        "chunks": [
            {
                "content": "# TuGraph产品架构\n\n> 此文档主要介绍 TuGraph 的产品架构。\n\n## 1.简介\n\n![产品架构](../../../images/architecture.png)\n\n上图从功能模块的角度，以 TuGraph 为例，给出了企业级图数据库的整体架构，自下而上包括：\n\n- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。\n- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。\n- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。\n- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。\n- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/7.functionality.md",
        "chunks": [
            {
                "content": "# 功能概览\n\n> 此文档主要介绍 TuGraph 的主要功能和特性。\n\n## 1.安装部署\n\n## 1.1.部署方式\n\nTuGraph目前提供云部署、Docker部署以及安装包部署三种部署方式，用户可根据实际情况选择适合的部署方式。\n\n## 1.2.软硬件环境\n\nTuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。\n\nTuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。\n\n软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。\n\n## 2.存储层\n\n在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。\n\n在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。\n\n存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。\n\n## 3.计算层\n\n计算层在功能上分成三个部分，包括TP类的图事务引擎，AP类的图分析引擎和图神经网络引擎。"
            },
            {
                "content": "## 2.存储层\n\n在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。\n\n在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。\n\n存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。\n\n## 3.计算层\n\n计算层在功能上分成三个部分，包括TP类的图事务引擎，AP类的图分析引擎和图神经网络引擎。\n\n- __图事务引擎__，主要用来处理并发的图操作，包括单点查询、邻居查询、路径遍历。图事务引擎侧重并发操作的ACID事务，确保操作逻辑不会互相干扰，主要性能指标为 QPS，即每秒完成的查询数量。\n\n- __图分析引擎__，操作类型通常为全图迭代。部分简单的分析任务（比如SPSP）可以由图事务引擎完成，复杂的分析任务均由图分析引擎完成，单个任务通常需要数秒至数小时。因此单个图分析任务要并发利用所有的硬件资源，性能指标为任务完成的总时长。\n\n- __图神经网络引擎__，通常也为全图迭代。图神经网络引擎除了基于图拓扑的操作，也需要集成一个机器学习的框架来处理向量操作，比如 PyTorch、MXNet、TenserFlow。"
            },
            {
                "content": "存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。\n\n## 3.计算层\n\n计算层在功能上分成三个部分，包括TP类的图事务引擎，AP类的图分析引擎和图神经网络引擎。\n\n- __图事务引擎__，主要用来处理并发的图操作，包括单点查询、邻居查询、路径遍历。图事务引擎侧重并发操作的ACID事务，确保操作逻辑不会互相干扰，主要性能指标为 QPS，即每秒完成的查询数量。\n\n- __图分析引擎__，操作类型通常为全图迭代。部分简单的分析任务（比如SPSP）可以由图事务引擎完成，复杂的分析任务均由图分析引擎完成，单个任务通常需要数秒至数小时。因此单个图分析任务要并发利用所有的硬件资源，性能指标为任务完成的总时长。\n\n- __图神经网络引擎__，通常也为全图迭代。图神经网络引擎除了基于图拓扑的操作，也需要集成一个机器学习的框架来处理向量操作，比如 PyTorch、MXNet、TenserFlow。\n\n三个引擎的操作逻辑不尽相同，独立配置资源池。事图事务引擎基于RPC操作设置了一个线程池，每接受客户端的一个操作，从线程中取一个线程来处理，并发执行的数量等于RPC线程池的容量，通常配置为服务器的核数。图分析引擎有一个分析线程池，每个图分析任务会并发执行，即用所有的线程来执行一个任务，来加速操作的性能。TuGraph图分析操作串行执行的特性会一定程度限制用户的使用体验，并发的图分析的需求可以通过高可用部署的方式，增加机器资源来处理，或者接入外部的任务调度器，将数据传到实时调度的容器来计算。图神经网络操作在图上的操作会复用图事务引擎或图分析引擎的资源，向量的操作会起单独的资源，在机器学习框架中可以使用GPU等单独的加速硬件。\n\n## 4.核心功能\n\n### 4.1.查询语言\n\nTuGraph 提供 Cypher 图查询语言，遵循OpenCypher标准。\n- __支持Procedure嵌入__\n\n- __可插拔优化框架__ 各类优化功能\n\n- __可扩展安全性检查框架__ 对于cypher进行\n\n### 4.2.存储过程\n\n当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个 REST 请求并在客户端完成整个\n处理流程的方式，TuGraph 提供的存储过程（Procedure）是更简洁和高效的选择。"
            },
            {
                "content": "## 4.核心功能\n\n### 4.1.查询语言\n\nTuGraph 提供 Cypher 图查询语言，遵循OpenCypher标准。\n- __支持Procedure嵌入__\n\n- __可插拔优化框架__ 各类优化功能\n\n- __可扩展安全性检查框架__ 对于cypher进行\n\n### 4.2.存储过程\n\n当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个 REST 请求并在客户端完成整个\n处理流程的方式，TuGraph 提供的存储过程（Procedure）是更简洁和高效的选择。\n\n从 3.5 版本开始，TuGraph 重新设计了新的存储过程编程范式，支持定义标准的签名和结果，支持POG编程。\n\nTuGraph 支持 POG (Procedres on Graph Query Languages) 编程和 POG 库，其中“Graph Query Languages”包含 Cypher 以及\n制定中的 ISO GQL 等图查询语言。POG 库提供在查询语言中对用户定义的存储过程的访问，打破了查询语言和存储过程之间的界限，扩展了查询\n语言的使用范围。\n\n> 这个文档描述了 [新的 Procedure 编程范式以及 POG](../9.olap&procedure/1.procedure/1.procedure.md)。\n\n### 4.3.数据导入导出\n\n尽管TuGraph本身支持数据的插入，但批量导入能够大幅提升的效率。导入的功能可以分为空库导入（离线导入）和增量导入，前者指子图是空的时候进行导入，额外的假设能够大幅提升导入的性能，在 TuGraph 中，空库导入和增量导入的吞吐率差了10 倍。在数据导出中，需要考虑导出数据的一致性，即是基于一个快照数据导出的。\n\nTuGraph 可以通过 命令行工具`lgraph_export` 来对已经存放在TuGraph的图数据进行数据导出，导出格式支持CSV和JSON。\n\n### 4.4.备份恢复\n\nTUGraph的备份在功能上可分为主动/定时、离线/在线、全量/增量备份，用尽量小的存储和计算代价来完成备份。恢复功能可以恢复到最新的状态，或者历史标注的时间点，需要保证数据库是一致的状态。\n\n### 4.5 数据预热"
            },
            {
                "content": "> 这个文档描述了 [新的 Procedure 编程范式以及 POG](../9.olap&procedure/1.procedure/1.procedure.md)。\n\n### 4.3.数据导入导出\n\n尽管TuGraph本身支持数据的插入，但批量导入能够大幅提升的效率。导入的功能可以分为空库导入（离线导入）和增量导入，前者指子图是空的时候进行导入，额外的假设能够大幅提升导入的性能，在 TuGraph 中，空库导入和增量导入的吞吐率差了10 倍。在数据导出中，需要考虑导出数据的一致性，即是基于一个快照数据导出的。\n\nTuGraph 可以通过 命令行工具`lgraph_export` 来对已经存放在TuGraph的图数据进行数据导出，导出格式支持CSV和JSON。\n\n### 4.4.备份恢复\n\nTUGraph的备份在功能上可分为主动/定时、离线/在线、全量/增量备份，用尽量小的存储和计算代价来完成备份。恢复功能可以恢复到最新的状态，或者历史标注的时间点，需要保证数据库是一致的状态。\n\n### 4.5 数据预热\n\nTuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。\n\n### 4.6 高可用\n\n高可用是指通过通过集群配置，做到实时多副本数据热备，在部分副本不用时，集群仍然能正常提供服务，TuGraph采用 RAFT 协议的多机热备机制，能够将 RPO 降低到接近 0 的程度。TuGraph 选择在计算层进行数据同步，同步的对象是写操作，通过 RPC 接口快速同步。TuGraph 的高可用集群采用主从模式，只有主节点处理写请求，主从节点均能处理读请求。主节点的写请求处理需要同步到多于二分之一的总节点上，多数节点写成功，该写请求才算完成。\n\n## 5.客户端工具\n\n客户端主要分为各种编程语言的SDK，OGM以及命令行工具。"
            },
            {
                "content": "### 4.4.备份恢复\n\nTUGraph的备份在功能上可分为主动/定时、离线/在线、全量/增量备份，用尽量小的存储和计算代价来完成备份。恢复功能可以恢复到最新的状态，或者历史标注的时间点，需要保证数据库是一致的状态。\n\n### 4.5 数据预热\n\nTuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。\n\n### 4.6 高可用\n\n高可用是指通过通过集群配置，做到实时多副本数据热备，在部分副本不用时，集群仍然能正常提供服务，TuGraph采用 RAFT 协议的多机热备机制，能够将 RPO 降低到接近 0 的程度。TuGraph 选择在计算层进行数据同步，同步的对象是写操作，通过 RPC 接口快速同步。TuGraph 的高可用集群采用主从模式，只有主节点处理写请求，主从节点均能处理读请求。主节点的写请求处理需要同步到多于二分之一的总节点上，多数节点写成功，该写请求才算完成。\n\n## 5.客户端工具\n\n客户端主要分为各种编程语言的SDK，OGM以及命令行工具。\n\n客户端 SDK 主要用于二次开发，可以通过 RPC 或 REST 协议链接服务端。RPC 基于长链接有较好的性能，数据需要通过 protobuf 统一序列化。TuGraph 使用brpc，支持 Java、Python、C++ 的 rpc 客户端。REST 的协议比较宽泛，能够简单适配更加多样的环境，不同的编程语言能够简单对接。TuGraph 给出了 Python 的REST 客户端实例，命令行的交互也是用 REST 实现。\n\nOGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。\n\n命令行工具`lgraph_cypher`是查询客户端，可用于向 TuGraph 服务器提交 OpenCypher 请求。`lgraph_cypher`客户端有两种执行模式：单命令模式和交互式模式。\n\n\n## 6.生态工具"
            },
            {
                "content": "客户端 SDK 主要用于二次开发，可以通过 RPC 或 REST 协议链接服务端。RPC 基于长链接有较好的性能，数据需要通过 protobuf 统一序列化。TuGraph 使用brpc，支持 Java、Python、C++ 的 rpc 客户端。REST 的协议比较宽泛，能够简单适配更加多样的环境，不同的编程语言能够简单对接。TuGraph 给出了 Python 的REST 客户端实例，命令行的交互也是用 REST 实现。\n\nOGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。\n\n命令行工具`lgraph_cypher`是查询客户端，可用于向 TuGraph 服务器提交 OpenCypher 请求。`lgraph_cypher`客户端有两种执行模式：单命令模式和交互式模式。\n\n\n## 6.生态工具\n\n生态工具是企业级数据库一个非常重要的组成部分，丰富的生态工具能够大大提升图数据库的可用性，稳定性。\n\n### 6.1.TuGraph DataX\n\n![导入导出](../../../images/tugraph-datax.png)\n\nTuGraph 核心支持 CSV 和 JSON 合适的导入导出，提供空库导入和增量导入的模式。实际中会存在 MySQL、Kafka、Hive 等多数据源导入的需求，TuGraph 通过 DataX 做多数据源的对接。由于关系模型和图模型存在的差异，数据清洗的流程可以使用 SparkSQL 快速处理，TuGraph 本身仅关注 CSV 和 JSON 的简单场景导入可靠性和性能。\n\n### 6.2.可视化交互\n\nTuGraph Browser 是面向图数据库直接使用者的可视化交互界面，功能上覆盖了 TuGraph 的绝大部分能力，包括数据导入、图模型建立、数据增删查改、监控运维等操作链路。\n\n### 6.3.运维监控"
            },
            {
                "content": "## 6.生态工具\n\n生态工具是企业级数据库一个非常重要的组成部分，丰富的生态工具能够大大提升图数据库的可用性，稳定性。\n\n### 6.1.TuGraph DataX\n\n![导入导出](../../../images/tugraph-datax.png)\n\nTuGraph 核心支持 CSV 和 JSON 合适的导入导出，提供空库导入和增量导入的模式。实际中会存在 MySQL、Kafka、Hive 等多数据源导入的需求，TuGraph 通过 DataX 做多数据源的对接。由于关系模型和图模型存在的差异，数据清洗的流程可以使用 SparkSQL 快速处理，TuGraph 本身仅关注 CSV 和 JSON 的简单场景导入可靠性和性能。\n\n### 6.2.可视化交互\n\nTuGraph Browser 是面向图数据库直接使用者的可视化交互界面，功能上覆盖了 TuGraph 的绝大部分能力，包括数据导入、图模型建立、数据增删查改、监控运维等操作链路。\n\n### 6.3.运维监控\n\nTuGraph 使用 Prometheus 加 Grafana 的监控框架，采用松耦合的方式。Prometheus 从 TuGraph 的监控接口获取监控信息，存储在本地时序数据库中，然后通过 Grafana 在网页端交互展示。\n\nTuGraph 提供的监控的状态包括图数据库的状态和服务器的状态，前者包括读写负载、点边数量等数据库端的状态，后者包括内存、CPU、硬盘等服务器的实时状态。如果某些监控状态超过了预期的阈值，就需要主动告警，通常需要对接其他运维管控系统，比如群消息、邮件告警等。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/8.scenarios.md",
        "chunks": [
            {
                "content": "# 应用场景\n\n> 此文档主要介绍图数据库适用的应用场景。\n\n## 1. 金融领域\n\n金融领域的实体主要涉及人、公司、账户、产品等，它们之间的关系包括交易关系、登录关系、股权关系、雇佣关系等。这些实体构成了一张金融图数据网络。应用图数据库，我们可以从金融图数据网络里发掘出大量有用信息，帮助我们做出更准确的金融决策。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|贷款审核|通过分析申请人的关联关系、交易情况等辅助判断申请人的偿还能力和偿还意愿，可应用于零售贷款审核、小微贷款审核、供应链金融等。此方法可与传统的基于申请人自身信息的审核机制互补，在个体信息录覆盖较低的小微贷款审核中尤其有用。|\n|贷后管理|通过分析借款人交易情况，辅助分析借款人是否有逾期风险。相比于传统只在贷款资金流向特定用户的情况下发出警报的方式不同，该方法可以给每个账户赋予一个风险值，并在贷款流向高风险账户时给出预警。|\n|失联修复|通过分析失联贷款人的社交和购物数据，找出其它联系方式。该方法可以大幅改进失联修复率。|\n|担保环检测|可在担保关系图中找出环状、链式、家族式、交叉等特殊担保结构，揭露潜在风险。相比于关系型数据库的JOIN方法，基于图算法的方案更高效，可以检测出任意长的担保环，且可以实现更复杂限定条件的检测。|\n|信用卡团伙欺诈检测|构建信用卡申请信息中的地址、联系方式等关系网络，在申请关系网络中运行社区发现算法，可以检测出疑似欺诈的团伙，从而拒绝涉嫌欺诈的申请件，减少经济损失。|\n|反洗钱|通过交易网络和介质网络，找出疑似洗钱的行为和链路。洗钱是一个复杂的多方参与的过程，通过在交易和社交网络中进行图分析，我们可以更精准的检测出洗钱行为。|\n|车险反欺诈|针对有修理厂参与的骗保行为，通过分析被保人、案件地点和修理厂之间的关系，可以更精准的识别出骗保行为，减少经济损失。|\n\n## 2. 工业领域"
            },
            {
                "content": "## 2. 工业领域\n\n在生产和制造过程中会产生大量异构数据，如何有效的组织和管理这些数据是工业大数据中最重要的问题之一。这些数据包括设计文档、设备数据、仿真方案和结果、实验结果、经验文档等，关系错综复杂。传统的数据管理系统只能累积数据，而查找相关材料则往往力不从心。使用图模型，将这些不同类型的数据组织成一张网络，就可以方便地浏览和查找数据。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|供应链管理|供应链数据主要关心产品—部件—零件的对应关系、零件与供应商的对应关系、零件中的敏感成分等。相比于传统的物料管理（BOM）系统，使用图数据库的方案可以更方便地维护多个部件层次、多个供应商级别的复杂网络，从而为穿透式供应链提供基础支持。|\n|文档管理|使用图数据库可以将不同类型的文档按不同关系有机地组织在一起。例如将部件设计文档、部件—零件关系、部件测试文档、相关经验文档等组织起来，在需要查找时就可以方便获取该部件的所有相关信息。|\n|研发过程管理|产品研发和验证过程中需要进行大量仿真、试验和测试，每一个测试流程都会涉及大量不同的步骤。步骤之间的连接关系、每个步骤中使用的数据版本、算法版本等就构成了一张复杂的关系网络。使用图数据库可以更好管理这个关系网络，从而为研发过程中的数据复用、流程改进提供良好基础。|\n|设备信息管理|制造业需要管理大量设备，设备之间又互相关联（供电关系、供料关系、空间关系），从而形成了一张复杂的网络。传统的数据库很难体现这种复杂关系。而使用图数据库则可以便捷表示这些关系，从而更好的管理设备信息。|\n\n## 3. 智慧城市"
            },
            {
                "content": "## 3. 智慧城市\n\n随着科技的发展，城市的智能化管理已成为一个大趋势。智能化管理需要建立在良好的信息管理平台之上，因此需要强大的系统软件做支撑。在智能化城市管理系统中，智能化决策系统需要基于大量不同信息做出决策，这些信息包括各种拓扑信息（道路、管线），供求信息（电力输送、饮用水供应、污水排放），环境信息（温度、湿度、雨量）等。要将这些复杂的异构数据有机管理起来，并基于它们做出决策，就需要一个成熟的系统。传统的数据管理系统基于关系数据模型，并不适合管理这种复杂异构数据。而使用图模型就可以很好的解决这一问题。如果我们将这些不同的数据利用图数据库进行管理，就可以实现很多复杂的智能管理场景。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|智能交通|基于道路拓扑、道路容量及当前流量，可以进行智能信号灯调度，从而提高通行效率。|\n|智能排水|基于排水系统信息及当前雨量，可以对排水系统进行调度，从而减少内涝的产生。|\n|管线管理|将管线的生产、安装、拓扑信息，以及历史状态信息有机组织起来，可以帮助我们对管线进行全周期管理，包括故障排查、寿命评估等。|\n|人群疏散|大量人群需要疏散时，需要考虑公交、地铁、出租车、共享单车等多种交通方式，同时还需要考虑道路承载量。使用图数据库将这些信息有机整合在一起，可以帮助我们更好的做出决策，以便为大型公共活动提供更好的支持。|\n\n## 4. 社会治理\n\n社会治理包括公共安全、法律事务、舆论、网络安全等多方面。社会治理是一个综合性的、多系统联动问题。它需要综合大量数据、全局考量才能做出更好的决策。在这种多维度复杂数据问题上，图数据模型可以提供更好的适应性，从而为智能化的社会治理决策平台提供坚实的基础。"
            },
            {
                "content": "## 4. 社会治理\n\n社会治理包括公共安全、法律事务、舆论、网络安全等多方面。社会治理是一个综合性的、多系统联动问题。它需要综合大量数据、全局考量才能做出更好的决策。在这种多维度复杂数据问题上，图数据模型可以提供更好的适应性，从而为智能化的社会治理决策平台提供坚实的基础。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|犯罪团伙发现|合谋团伙必然会通过某些方式产生联系，这种联系包括面谈（出现在同一地点）、电话联系、或者互联网联系，他们还可能有经济往来。如果我们将这些数据统一存放在一张图中，我们就可以通过图分析算法查找出联系紧密的群体，从而发现和识别整个犯罪团伙。|\n|涉众案件调查|涉众案件，特别是涉众经济案件往往涉及大量的人员和要素（货币、地点、事件等）。如何有效的组织这些资料，从而为办案提供证据支持是涉众案件调查的一个难点。使用图数据库来存储和分析这些资料，可以让我们快速定位资料、分析人员构成、为案件调查提供更好的技术支持。|\n|违法网站甄别|违法网站、钓鱼网站、黄色网站等往往通过使用不同的域名和IP来避免被封杀。基于黑名单的过滤方法只能封禁已知的违法网站，无法对新出现的域名和IP进行有效甄别。基于IP—域名网络的映射关系，我们可以建立一张图，然后通过图计算建立起域名和IP的“可信度”模型，利用该模型来判断网站是否属于违法网站。|\n|法院卷宗管理|卷宗往往错综复杂，不同的案件之间可能通过当事人产生联系，也可能通过案发地、案件性质、审判人员等产生联系。这些联系构成了一张复杂的网络。使用图数据库我们可以更方便的管理这些复杂关系，提高办案和查询效率。|\n\n## 5. 互联网\n\n人—人关系的社交网络、人—商品的购买关系都能构成图。通过分析这些网络数据，我们可以为用户提供更优质的服务，包括相关推荐、用户信息归集、重要用户识别、垃圾用户识别等。"
            },
            {
                "content": "## 5. 互联网\n\n人—人关系的社交网络、人—商品的购买关系都能构成图。通过分析这些网络数据，我们可以为用户提供更优质的服务，包括相关推荐、用户信息归集、重要用户识别、垃圾用户识别等。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|ID映射|图数据库可以将用户相关的所有信息，包括用户之间的关系统一存储在一个数据库中，同时还能通过这些关系来找出疑似单人多号和多人一号的情况，从而为后期的风控、推荐等业务提供决策支持。|\n|好友推荐|基于分析社交网络，我们可以提供“好友的好友”，“共同好友”等好友推荐。|\n|商品推荐|基于用户—商品关系图，我们可以找出兴趣爱好类似的用户，向他们推荐类似用户选择的其他商品。|\n|垃圾用户识别|传统的垃圾用户识别主要基于用户账号本身的信息，如注册信息、发帖信息等，但是这些信息都比较容易伪造。而基于网络的信息则不存在这个问题：它们很难被伪造。因此基于网络信息的垃圾用户识别可以更加精准和高效。|"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/2.introduction/9.glossary.md",
        "chunks": [
            {
                "content": "# 名词解释\n\n## 1.图技术\n\n> __图计算__：广义图计算，技术上包括图查询、图分析、图学习；狭义图计算，包括图计算任务和图分析。\n\n> __图查询__：指图数据库的查询能力，通常通过Cypher/ISO GQL等查询语言实现。\n\n> __图分析__：侧重于对全图数据的算法分析、模式分析等。\n\n> __图学习__：与图神经网络、图机器学习含义相同。\n\n> __图智能__：等于广义图计算，包括图数据库、图分析、图学习，通常用于概念推广，不用于产品。\n\n## 2.图产品\n\n> __图计算系统__：一般包括图数据库、图分析系统、图学习系统，有时也特指图分析系统。\n\n> __图数据库__：侧重于对图数据的增删改查、事务性操作等，如TuGraph DB、Neo4j、JanusGraph等。\n\n> __图分析系统__：解决图分析问题，可以细分为流水图分析、离线图分析，如TuGraph Analytics、GraphX等。\n\n> __图学习系统__：解决图学习问题，比如TuGraph Learn、DGL等。\n\n## 3.具体概念\n\n\n> __Vertex__：点，也叫顶点，也指 Vertex Value。尽量避免Node（结点、节点）的叫法，一般用Node表示服务器个数，容易叫混。结点指结合、交结、交叉的意思；节点可以指一个时间线上的里程碑（关键节点）或计算机系统里的一个处理实体（如计算机网络里的一台服务器）。\n\n> __Edge__：边，也指 Edge Value。\n\n> __Vertex Label__：点类型，也叫 Vertex Type。\n\n> __Edge Label__：边类型，也叫 Edge Type。\n\n> __Degree__：度，入度/出度，表示一个点的入边、出边的条数。注意，在非图论的场景中，往往把“跳”也称作“度”。\n\n> __Hop__：跳，表示一个点到另一个点之间的路径经过的点数（不含起点、含终点）。算法性能测试里K-Hop即为此义。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/3.quick-start/1.preparation.md",
        "chunks": [
            {
                "content": "# 快速上手\n\n> 此文档主要用于新用户快速上手，其中包含了 TuGraph 的简介、特征、安装和使用。\n\n## 1.简介\n\nTuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。\n\n主要功能特征包括：\n\n- 标签属性图模型\n- 支持多图\n- 完善的 ACID 事务处理\n- 内置 34 图分析算法\n- 基于 web 客户端的图可视化工具\n- 支持 RESTful API 和 RPC\n- OpenCypher 图查询语言\n- 基于 C++/Python 的存储过程\n- 适用于高效图算法开发的 Traversal API\n\n性能及可扩展性特征包括：\n\n- TB 级大容量\n- 千万点/秒的高吞吐率\n- 高可用性支持\n- 高性能批量导入\n- 在线/离线备份\n\n\n### 1.1.支持的平台\n\nTuGraph 无论是物理、虚拟还是容器化环境，均支持 X86_64 和 ARM64 架构的的平台。\n\n### 1.2.硬件要求\n\n_目前我们建议用户使用 NVMe SSD 配合较大的内存配置以获取最佳性能。_\n\n| 硬件   | 最低配置      | 建议配置                     |\n|------|-----------|--------------------------|\n| CPU  | X86_64    | Xeon E5 2670 v4          |\n| 内存   | 4GB       | 256GB                    |\n| 硬盘   | 100GB     | 1TB NVMe SSD             |\n| 操作系统 | Linux 2.6 | Ubuntu 18.04, CentOS 7.3 |\n\n## 2.安装\n\nTuGraph 可以通过 Docker Image 快速安装，或者通过 rpm/deb 包本地安装。另外TuGraph在阿里云计算巢上提供了社区版服务，您无需自行购置云主机，即可在计算巢上快速部署TuGraph服务、实现运维监控，从而搭建您自己的图应用。"
            },
            {
                "content": "### 1.2.硬件要求\n\n_目前我们建议用户使用 NVMe SSD 配合较大的内存配置以获取最佳性能。_\n\n| 硬件   | 最低配置      | 建议配置                     |\n|------|-----------|--------------------------|\n| CPU  | X86_64    | Xeon E5 2670 v4          |\n| 内存   | 4GB       | 256GB                    |\n| 硬盘   | 100GB     | 1TB NVMe SSD             |\n| 操作系统 | Linux 2.6 | Ubuntu 18.04, CentOS 7.3 |\n\n## 2.安装\n\nTuGraph 可以通过 Docker Image 快速安装，或者通过 rpm/deb 包本地安装。另外TuGraph在阿里云计算巢上提供了社区版服务，您无需自行购置云主机，即可在计算巢上快速部署TuGraph服务、实现运维监控，从而搭建您自己的图应用。\n\n> 安装包/镜像下载：参考[下载地址](../1.guide.md)中的“TuGraph最新版本”章节。\n\n> 计算巢部署：可以在阿里云计算巢自行搜索，也可以通过[部署链接]( ../5.installation&running/5.cloud-deployment.md )快速访问。\n\n### 2.1.通过docker快速体验\n\n1. 本地安装 docker 环境\n\n   参考 docker 官方文档：https://docs.docker.com/get-started/\n\n2. 拉取镜像\n   ```shell\n   docker pull tugraph/tugraph-runtime-centos7\n   ```\n\n3. 启动docker\n\n启动 TuGraph 服务可以通过两种方式来实现。第一种方式将镜像拉取与服务启动整合在一起，用户只需执行运行容器的操作，即可同时启动 TuGraph 服务。第二种方式则是在创建 TuGraph 容器后，手动进入容器内部以触发服务启动。尽管这种方法初期步骤稍显繁琐，但在如忘记密码的情况下，它提供了更灵活的密码重置选项。\n\n**方式一**"
            },
            {
                "content": "> 安装包/镜像下载：参考[下载地址](../1.guide.md)中的“TuGraph最新版本”章节。\n\n> 计算巢部署：可以在阿里云计算巢自行搜索，也可以通过[部署链接]( ../5.installation&running/5.cloud-deployment.md )快速访问。\n\n### 2.1.通过docker快速体验\n\n1. 本地安装 docker 环境\n\n   参考 docker 官方文档：https://docs.docker.com/get-started/\n\n2. 拉取镜像\n   ```shell\n   docker pull tugraph/tugraph-runtime-centos7\n   ```\n\n3. 启动docker\n\n启动 TuGraph 服务可以通过两种方式来实现。第一种方式将镜像拉取与服务启动整合在一起，用户只需执行运行容器的操作，即可同时启动 TuGraph 服务。第二种方式则是在创建 TuGraph 容器后，手动进入容器内部以触发服务启动。尽管这种方法初期步骤稍显繁琐，但在如忘记密码的情况下，它提供了更灵活的密码重置选项。\n\n**方式一**\n\n   ```shell\n    docker run -d -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \\\n    --name tugraph_demo ${REPOSITORY}:${VERSION}\n   \n   # ${REPOSITORY}是镜像地址，${VERSION}是版本号。\n   # 7070是默认的http端口，访问tugraph-db-browser使用。   \n   # 7687是bolt端口，bolt client访问使用。\n   # 9090是默认的rpc端口，rpc client访问使用。\n   # /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录\n   # 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。\n   ```\n\n**方式二**"
            },
            {
                "content": "**方式二**\n\n   ```shell\n    docker run -dt -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \\\n    --name tugraph_demo ${REPOSITORY}:${VERSION} /bin/bash\n    \n    docker exec -it tugraph_demo bash\n    lgraph_server -c /usr/local/etc/lgraph.json -d start\n    \n   # ${REPOSITORY}是镜像地址，${VERSION}是版本号。\n   # 7070是默认的http端口，访问tugraph-db-browser使用。   \n   # 7687是bolt端口，bolt client访问使用。\n   # 9090是默认的rpc端口，rpc client访问使用。\n   # /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录\n   # 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。\n   ```\n\n5. 前端访问\n\n访问tugraph-db-browser: `http://x.x.x.x:7070`，数据库地址格式为 `bolt://ip:bolt_port`（老版本不用填），默认用户名为 `admin`，密码为 `73@TuGraph`。\n首次登录会默认跳转修改密码页面，请尽快修改默认密码避免安全风险。"
            },
            {
                "content": "5. 前端访问\n\n访问tugraph-db-browser: `http://x.x.x.x:7070`，数据库地址格式为 `bolt://ip:bolt_port`（老版本不用填），默认用户名为 `admin`，密码为 `73@TuGraph`。\n首次登录会默认跳转修改密码页面，请尽快修改默认密码避免安全风险。   \n\n### 2.2.新旧前端说明\n进入容器，可以通过修改配置文件\"/usr/local/etc/lgraph.json\"中的\"web\"参数来选择使用老版本或新版本的前端。对于老版本，可以将\"web\"的值设为\"/usr/local/share/lgraph/resource\"；对于新版本，可以将\"web\"的值设为\"/usr/local/share/lgraph/browser-resource\"。完成配置文件的修改后，请执行命令 `docker restart tugraph` 以使更改生效。需要注意的是，新版本是默认选项。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/3.quick-start/2.demo/1.movie.md",
        "chunks": [
            {
                "content": "# 场景：影视\n\n> 此文档主要介绍 影视场景Demo 的使用方法。\n\n## 1.建模和数据导入\n\n完成登录后，点击`新建图项目`，选择movie数据，填写图项目配置，系统会自动完成Movie场景图项目创建。其余场景也可用相同方式创建。\n\nMovie 场景图：\n\n\n\n| 标签          | 类型  | 说明                                  |\n|-------------|-----|-------------------------------------|\n| movie       | 实体  | 表示某一部具体的影片，比如\"阿甘正传\"。                |\n| person      | 实体  | 表示个人，对影片来说可能是演员、导演，或编剧。             |\n| genre       | 实体  | 表示影片的类型，比如剧情片、恐怖片。                  |\n| keyword     | 实体  | 表示与影片相关的一些关键字，比如\"拯救世界\"、\"虚拟现实\"、\"地铁\"。 |\n| user        | 实体  | 表示观影的用户。                            |\n| produce     | 关系  | 表示影片的出品人关系。                         |\n| acted_in    | 关系  | 表示演员出演了哪些影片。                        |\n| direct      | 关系  | 表示影片的导演是谁。                          |\n| write       | 关系  | 表示影片的编剧关系。                          |\n| has_genre   | 关系  | 表示影片的类型分类。                          |\n| has_keyword | 关系  | 表示影片的一些关键字，即更细分类的标签。                |\n| rate        | 关系  | 表示用户对影片的打分。                         |\n\n## 2.查询示例\n\n### 2.1.示例一"
            },
            {
                "content": "## 2.查询示例\n\n### 2.1.示例一\n\n查询影片 'Forrest Gump' 的所有演员，返回影片和演员构成的子图。\n\n```\nMATCH (m:movie {title: 'Forrest Gump'})<-[:acted_in]-(a:person) RETURN a, m\n```\n\n### 2.2.示例二\n\n查询影片 'Forrest Gump' 的所有演员，列出演员在影片中扮演的角色。\n\n```\nMATCH (m:movie {title: 'Forrest Gump'})<-[r:acted_in]-(a:person) RETURN a.name,r.role\n```\n\n### 2.3.示例三\n\n查询 Michael 所有评分低于 3 分的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie) WHERE r.stars < 3 RETURN m.title, r.stars\n```\n\n### 2.4.示例四\n\n查询和 Michael 有相同讨厌的影片的用户，讨厌标准为评分小于三分。\n\n```\nMATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie)<-[s:rate]-(v) WHERE r.stars < 3 AND s.stars < 3 RETURN u, m, v\n```\n\n### 2.5.示例五\n\n给 Michael 推荐影片，方法为先找出和 Michael 讨厌同样影片的用户，再筛选出这部分用户喜欢的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie)<-[s:rate]-(v)-[r2:rate]->(m2:movie) WHERE r.stars < 3 AND s.stars < 3 AND r2.stars > 3 RETURN u, m, v, m2\n```\n\n### 2.6.示例六\n\n查询 Michael 的好友们喜欢的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[:is_friend]->(v:user)-[r:rate]->(m:movie) WHERE r.stars > 3 RETURN u, v, m\n```"
            },
            {
                "content": "### 2.5.示例五\n\n给 Michael 推荐影片，方法为先找出和 Michael 讨厌同样影片的用户，再筛选出这部分用户喜欢的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie)<-[s:rate]-(v)-[r2:rate]->(m2:movie) WHERE r.stars < 3 AND s.stars < 3 AND r2.stars > 3 RETURN u, m, v, m2\n```\n\n### 2.6.示例六\n\n查询 Michael 的好友们喜欢的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[:is_friend]->(v:user)-[r:rate]->(m:movie) WHERE r.stars > 3 RETURN u, v, m\n```\n\n### 2.7.示例七\n\n通过查询给'Forrest Gump'打高分的人也喜欢哪些影片，给喜欢'Forrest Gump'的用户推荐类似的影片。\n\n```\nMATCH (m:movie {title:'Forrest Gump'})<-[r:rate]-(u:user)-[r2:rate]->(m2:movie) WHERE r.stars>3 AND r2.stars>3 RETURN m, u,m2\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/3.quick-start/2.demo/2.wandering-earth.md",
        "chunks": [
            {
                "content": "# 场景：流浪地球\n\n> 此文档主要介绍 流浪地球 demo的使用方法。\n\n## 1.Demo场景设计\n\nDemo背景基于流浪地球1、流浪地球2的故事背景进行设计\n\n- 基于剧情，设计了图结构，包含组织、角色、天体与设施3类点，事件、关系两类边\n- 根据剧情准备了对应Schema的数据\n- 准备了一些query，提出一些关于剧情的问题\n\n## 2.使用说明\n\n前置条件：TuGraph已安装\n\n## 3.数据导入\n\n- 手动导入\n  - 数据存放目录：https://github.com/TuGraph-family/tugraph-db-demo\n  - 根据数据存放目录对应修改import.json里面的DATA_PATH。具体可以参考[数据导入](../../6.utility-tools/1.data-import.md)\n  - 启动TuGraph服务后，访问${HOST_IP}:7070，打开web页面，确认数据是否导入成功。\n- 自动创建\n    - 点击`新建图项目`，选择流浪地球数据，填写图项目配置，系统会自动完成流浪地球场景图项目创建。\n\n## 4.Cypher查询\n\n参考cypher文档，在TuGraph的Web页面前端输入Cypher进行查询\n\n## 5.使用展示\n\n### 5.1.数据导入的展示\n\n![数据导入展示](../../../../images/wandering-earth-1.png)\n\n### 5.2.查询展示\n查询木星危机的所有事件经过\n\n```\nMATCH (n)-[e:事件关系]-(m) where e.title='木星危机' RETURN n,e\n```\n\n![数据导入展示](../../../../images/wandering-earth-2.png)\n\n查询所以危机的相关事件经过\n\n```cypher\nMATCH (n)-[e1]-(m)-[e2]-(p)\nwhere e1.title REGEXP \".*危机\" and e2.title REGEXP \".*危机\" and e1.title <> e2.title\nRETURN n,e1,e2,p\n```\n\n![数据导入展示](../../../../images/wandering-earth-3.png)"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/3.quick-start/2.demo/3.the-three-body.md",
        "chunks": [
            {
                "content": "# 场景：三体\n\n> 此文档主要介绍 三体 demo的使用方法。\n\n## 1.Demo场景设计\nDemo背景基于三体1、三体2、三体3的故事背景进行设计。\n\n根据三体故事的设定，我们设计了4类点和6类边，点包括“人物”、“组织”、“计划”、“时间线”，边包括“人物-人物关系”、“人物-计划关系”、“人物-组织关系”、“组织-计划关系”、“组织-组织关系”。\n根据剧情准备了对应Schema的数据，准备了一些query，提出一些关于剧情的问题。\n\n## 2.使用说明\n\n前置条件：TuGraph已安装。\n\n## 3.数据导入\n\n- 手动导入\n    - 数据存放目录：https://github.com/TuGraph-family/tugraph-db-demo\n    - 根据数据存放目录对应修改import.json里面的DATA_PATH。具体可以参考[数据导入](../../6.utility-tools/1.data-import.md)\n    - 启动TuGraph服务后，访问${HOST_IP}:7070，打开web页面，确认数据是否导入成功。\n- 自动创建\n    - 点击`新建图项目`，选择三体数据，填写图项目配置，系统会自动完成三体场景图项目创建。\n\n## 4.Cypher查询\n\n参考TuGraph文档，在TuGraph的Web页面前端输入Cypher进行查询。\n\n## 5.使用展示\n\n### 5.1.数据导入的展示\n\n![data](../../../../images/three-body-data.png)\n\n## 6.查询展示\n\n### 6.1.人物关系查询\n三体一剧情中，一开始全世界各地发生了大量科学家自杀事件，引起了警方重视，查案过程根据人物关系线索一步步排查，就如上面的图所示，随着线索越来越多，背后的真相逐步浮出水面。史强和汪淼发现大多数人都和叶文洁有着直接或者间接的联系，并派汪淼卧底，最终发现叶文洁的最终统帅身份。在图中也可以看出，叶文洁顶点周围有很多边关系（一度或二度邻居很多）。\n\n```cypher\nMATCH (n)-[e:person_person]-(m) RETURN n,e,m\n```\n\n![data](../../../../images/three-body-cypher1.png)"
            },
            {
                "content": "## 4.Cypher查询\n\n参考TuGraph文档，在TuGraph的Web页面前端输入Cypher进行查询。\n\n## 5.使用展示\n\n### 5.1.数据导入的展示\n\n![data](../../../../images/three-body-data.png)\n\n## 6.查询展示\n\n### 6.1.人物关系查询\n三体一剧情中，一开始全世界各地发生了大量科学家自杀事件，引起了警方重视，查案过程根据人物关系线索一步步排查，就如上面的图所示，随着线索越来越多，背后的真相逐步浮出水面。史强和汪淼发现大多数人都和叶文洁有着直接或者间接的联系，并派汪淼卧底，最终发现叶文洁的最终统帅身份。在图中也可以看出，叶文洁顶点周围有很多边关系（一度或二度邻居很多）。\n\n```cypher\nMATCH (n)-[e:person_person]-(m) RETURN n,e,m\n```\n\n![data](../../../../images/three-body-cypher1.png)\n\n### 6.2.邻域顶点分析\n三体中的各种计划比较多，有的时候可能会被绕晕，这时候我们可以通过图的邻居顶点查询来查看该计划的相关人物和组织等。如\"面壁计划\"中,我们可以看到有四位人物与之相关，这四位也是被世人所寄予厚望的“面壁者”。\n\n```cypher\nMATCH (p:plan {name: \"面壁计划\"})-[e]-(neighbor:person)\nRETURN neighbor,p,e\n```\n\n![data](../../../../images/three-body-cypher2.png)\n\n### 6.3.查询a节点和b节点的共同邻居\n我们往往希望知道两个人物之间的共同关联的人物都有谁，这样就能很快的掌握这两个人物之间的关系，在大数据量的情况下，使用cypher进行图关系分析就很方便！\n\n```cypher\nMATCH (a:person {name: \"叶文洁\"})-[e1:person_person]->(n)<-[e2:person_person]-(b:person {name: \"汪淼\"})\nRETURN a,b,n,e1,e2\n```\n\n![data](../../../../images/three-body-cypher3.png)"
            },
            {
                "content": "```cypher\nMATCH (p:plan {name: \"面壁计划\"})-[e]-(neighbor:person)\nRETURN neighbor,p,e\n```\n\n![data](../../../../images/three-body-cypher2.png)\n\n### 6.3.查询a节点和b节点的共同邻居\n我们往往希望知道两个人物之间的共同关联的人物都有谁，这样就能很快的掌握这两个人物之间的关系，在大数据量的情况下，使用cypher进行图关系分析就很方便！\n\n```cypher\nMATCH (a:person {name: \"叶文洁\"})-[e1:person_person]->(n)<-[e2:person_person]-(b:person {name: \"汪淼\"})\nRETURN a,b,n,e1,e2\n```\n\n![data](../../../../images/three-body-cypher3.png)\n\n### 6.4.设置/更改属性\n随着剧情推进，我们逐步了解了\"叶文洁\"身上的多个标签，那么我们也可以将这些标签更新至“叶文洁”节点上：\n\n```cypher\nMATCH (p:person {name: \"叶文洁\"})\nSET p.introduce = \"清华大学教授、ETO精神领袖、首位和三体人交流的人\"\nRETURN p\n```\n\n### 6.5.增加/删除节点\n后续我们了解到了罗辑、程心等等人物和PIA、星环集团等组织，希望把这些作为节点添加至图中：\n\n```cypher\nCREATE (a:person {introduce: \"物理学教授\", name: \"bbb\"})\nRETURN a\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/3.quick-start/2.demo/4.three-kingdoms.md",
        "chunks": [
            {
                "content": "# 场景：三国\n\n> 此文档主要介绍 三国 demo的使用方法。\n\n## 1. 简介\n由于史料的缺失，一些即使为人们熟知的历史事件也往往存在着很多未解之谜。以三国历史为例，诸葛亮为什么出山帮助当时势力弱小的刘备，同为天下英雄的曹操和刘备为什么成就差距巨大等等。以往学者往往采用二维关系分析历史，这样得出的结论往往比较片面。使用TuGraph将三国的历史人物和事件导入图模型中，使用图计算方式进行分析，能够帮助我们从有限的信息中获得更有价值的知识，是一种非常有意义的跨学科尝试。\n## 2. 数据建模\n我们设计了5类顶点和5类边，点包括“主公”，“州”，“文臣”，“武将”，“战役”，边包括“父亲”，“兄长”，“隶属”，“籍贯”，“参战”。其具体建模信息如下所示：\n![image.png](../../../../images/three-kingdoms-schema.png)\n\n## 3. 数据导入\n- 手动导入\n  - 数据存放目录：https://github.com/TuGraph-family/tugraph-db-demo\n  - 根据数据存放目录对应修改import.json里面的DATA_PATH。具体可以参考[数据导入](../../6.utility-tools/1.data-import.md)\n  - 启动TuGraph服务后，访问${HOST_IP}:7070，打开web页面，确认数据是否导入成功。\n- 自动创建\n    - 点击`新建图项目`，选择三国数据，填写图项目配置，系统会自动完成三国场景图项目创建。"
            },
            {
                "content": "## 3. 数据导入\n- 手动导入\n  - 数据存放目录：https://github.com/TuGraph-family/tugraph-db-demo\n  - 根据数据存放目录对应修改import.json里面的DATA_PATH。具体可以参考[数据导入](../../6.utility-tools/1.data-import.md)\n  - 启动TuGraph服务后，访问${HOST_IP}:7070，打开web页面，确认数据是否导入成功。\n- 自动创建\n    - 点击`新建图项目`，选择三国数据，填写图项目配置，系统会自动完成三国场景图项目创建。\n\n## 4. Cypher分析\n### 4.1. 诸葛亮为什么选择刘备\n通过如下cypher命令可以查看诸葛亮和曹操、刘备之间的关系\n```\nMATCH p = (cc:主公 {name: '曹操'})-[*1..3]-(zgl:文臣 {name: '诸葛亮'}) RETURN p\n```\n得到的查询结果如下图所示\n![image.png](../../../../images/three-kingdoms-cypher1.png)\n从图中可以很直观的看出，曹操和诸葛亮之间的最短路径之一包含徐州之战，曹操曾经因父亲被杀对徐州进行过屠城，而诸葛亮是徐州琅琊郡人，任何人都断然不会选择一个屠杀过自己家乡的军阀作为主公。而相反，刘备曾经在徐州之战中阻止过曹操的暴行，这应当是诸葛亮对刘备好感的原因之一。\n\n### 4.2. 曹操为什么成就比刘备高\n通过如下cypher命令可以查看家族对曹操创业的助力\n```\nMATCH (cc:主公{name:\"曹操\"})<-[r:隶属]-(wj:武将) WHERE wj.name REGEXP \"曹.*\" OR wj.name REGEXP \"夏侯.*\" return cc,wj,r\n```\n得到的查询结果如下图所示\n![image.png](../../../../images/three-kingdoms-cypher2.png)\n平定天下最重要的就是军事人才，曹操其父本姓夏侯，过继于曹氏，曹氏和夏侯氏在谯县都属于地方大族，在曹操创业初期提供了夏侯惇，夏侯渊，曹仁，曹洪在内大量的军事人才。而刘备其父早丧，没有家族助力，年过50才凑齐了自己的五虎上将，而这时已经过了天下大乱争夺地盘的最佳时机，曹操已经天下九州居其六了。"
            },
            {
                "content": "### 4.2. 曹操为什么成就比刘备高\n通过如下cypher命令可以查看家族对曹操创业的助力\n```\nMATCH (cc:主公{name:\"曹操\"})<-[r:隶属]-(wj:武将) WHERE wj.name REGEXP \"曹.*\" OR wj.name REGEXP \"夏侯.*\" return cc,wj,r\n```\n得到的查询结果如下图所示\n![image.png](../../../../images/three-kingdoms-cypher2.png)\n平定天下最重要的就是军事人才，曹操其父本姓夏侯，过继于曹氏，曹氏和夏侯氏在谯县都属于地方大族，在曹操创业初期提供了夏侯惇，夏侯渊，曹仁，曹洪在内大量的军事人才。而刘备其父早丧，没有家族助力，年过50才凑齐了自己的五虎上将，而这时已经过了天下大乱争夺地盘的最佳时机，曹操已经天下九州居其六了。\n\n### 4.3. 三国中最强大的魏国为何最先灭亡\n通过如下cypher命令可以查看曹操集团的重要文官组成\n```\nMATCH (cc:主公)<-[r:隶属]-(wc) WHERE cc.name REGEXP \"曹.*\" AND (label(wc) = \"文臣\" OR label(wc) = \"主公\") return cc,wc,r\n```\n得到的查询结果如下图所示\n![image.png](../../../../images/three-kingdoms-cypher3.png)\n曹魏事实上于249年灭亡于高平陵之变，立国29年，少于蜀汉（43年）和东吴（51年）。三国中实力最强大的魏国最先灭亡的原因就在于曹魏的文官制度（九品中正制）使得权力很容易集中在世家大族手中。从图中可以看出，曹操曹丕父子两代的重要文臣几乎都是世家大族，颍川荀氏，颍川钟氏，颍川陈氏，武威贾氏等，甚至还出现了地区化趋势，集中于颍川，最终政权也为和颍川荀氏关系密切的河内司马氏所篡夺。"
            },
            {
                "content": "### 4.4. 三国各自的实力究竟如何\n通过如下cypher命令可以查看三国各集团的人口实力\n```\nMATCH (p) WHERE (label(p)=\"主公\" OR label(p)=\"文臣\" OR label(p)=\"武将\") AND p.hometown IN [\"幽州\",\"冀州\",\"青州\",\"并州\",\"凉州\",\"司州\",\"豫州\",\"兖州\",\"徐州\"] WITH COUNT(p) AS w\nMATCH (p) WHERE (label(p)=\"主公\" OR label(p)=\"文臣\" OR label(p)=\"武将\") AND p.hometown IN [\"益州\"] WITH COUNT(p) AS s,w\nMATCH (p) WHERE (label(p)=\"主公\" OR label(p)=\"文臣\" OR label(p)=\"武将\") AND p.hometown IN [\"扬州\",\"荆州\",\"交州\"]\nRETURN w as 魏人口,s as 蜀人口,count(p) as 吴人口\n```\n得到的查询结果如下表所示\n![image.png](../../../../images/three-kingdoms-cypher4.png)\n古代社会衡量一个国家实力的重要指标是人口数量，由于人口数据缺失，我们使用三国所有主公和文臣武将的籍贯数据估计每个州的人口数量。发现三国主要人物中，按籍贯有60个属于魏国，有23个属于吴国，仅有2个属于蜀国，证明魏国确实是三国中最强大的国家。\n\n### 4.5. 曹操的军事能力如何评价\n通过如下cypher命令可以查看曹操参与的主要战役\n```\nMATCH (cc:主公{name:\"曹操\"})-[e]-(zy:战役) RETURN cc,zy,e\n```\n得到的查询结果如下图所示\n![image.png](../../../../images/three-kingdoms-cypher5.png)\n从图中可以看出，曹操在三国主要的15场战役中参加了8场，出场率比较高。但是曹操只获胜了徐州之战、兖州之战、官渡之战和襄樊之战，汉中之战、宛城之战、群雄讨董和赤壁之战都失败了，综合胜率50%，证明曹操并不算一个非常优秀的军事家。\n\n## 5. 备注\n更多的分析有待大家积极补充和尝试！"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/3.quick-start/2.demo/5.round-the-world.md",
        "chunks": [
            {
                "content": "# Round The World Demo\n\n> 此文档主要介绍了基于tugraph-db开发的环球旅行（Round The World）demo\n\n## 简介\n\n基于\"80天环游世界\"的虚拟背景，基于部分公开历史航班数据，帮助用户设计多个城市的最优航班规划。\n- demo设计了自定义网站服务\n- 数据来源为国外某开源网站，不包含大陆城市航班数据\n- 数据中航班价格为模拟数据，不代表真实价格\n\n## 示例\n\n### 登录页面\n\n![data](../../../../images/round-the-world/main_page.jpg)\n\n### 查询页面\n\n在登录页面点击后进入查询页面\n\n![data](../../../../images/round-the-world/flight_page.jpg)\n\n### 查询示例\n\n在左下角的城市列表中选择不超过8个城市，点击查询可返回推荐的航班规划，在满足前后航班间隔在2-6小时的要求下，返回费用最低和飞行时间最短的10条路径规划。\n\n![data](../../../../images/round-the-world/search_example.jpg)\n\n详细使用说明见 [Round The World Demo](https://github.com/TuGraph-family/tugraph-db-demo/tree/main/round_the_world) 文档。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/4.user-guide/1.tugraph-browser.md",
        "chunks": [
            {
                "content": "# 可视化操作手册\n\n> 此文档主要介绍 TuGraph Browser 的使用和操作方法。\n\n## 1.简介\n\nTuGraph Browser（以下简称Browser）是一款功能强大的产品可视化开发工具，它以直观的可视化方式呈现图数据，使用户可以轻松地管理、维护和查看数据库运行状态。此工具不仅支持图数据的管理和可视化，还支持对系统账户的管理，为用户提供了全面的操作和管理体验，让用户能够更加高效地管理和利用图数据库。\n\n## 2.操作指南\n\n### 2.1.访问\n\n当用户完成图数据库的安装后，可以通过浏览器访问Browser。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7070。\n\n- 例如：127.0.0.1:7070。\n- 推荐使用Chrome。\n\n### 2.2.登录\n\n![login](../../../images/browser/login.png)\n\n- 浏览器成功访问Browser后，首先进入的是登录页面（如上图所示），用户需要填写账号和密码进行登录。\n- 数据库地址格式为：ip:bolt_port。\n- 默认账号：admin。\n- 默认密码：73@TuGraph。\n- 用户首次登录后，会跳转至修改密码页面，密码修改成功后，使用新密码重新登录即可使用。\n\n### 2.3.快速上手\n\n对于首次使用TuGraph的用户，可以通过产品内置的demo数据快速构建一个图项目，快速上手图数据项目。\n\n#### 2.3.1.创建图项目\n\n在`图项目`首页的选项卡中，点击`新建图项目`创建新的图项目。\n\n![快速上手-新建图项目](../../../images/browser/quickstart-creategraph.png)\n\n选择一个产品内置的demo数据，点击`下一步`按钮。\n\n![快速上手-选择一个demo](../../../images/browser/quickstart-selectdemo.png)\n\n在`填写配置`界面输入图项目信息，demo数据量都相对较小，`最大存储空间`设置为1G即可。输入完图项目信息后，点击`创建`按钮后，系统会自动创建demo数据的图模型、导入图数据。\n\n![快速上手-填写配置](../../../images/browser/quickstart-configure.png)"
            },
            {
                "content": "### 2.3.快速上手\n\n对于首次使用TuGraph的用户，可以通过产品内置的demo数据快速构建一个图项目，快速上手图数据项目。\n\n#### 2.3.1.创建图项目\n\n在`图项目`首页的选项卡中，点击`新建图项目`创建新的图项目。\n\n![快速上手-新建图项目](../../../images/browser/quickstart-creategraph.png)\n\n选择一个产品内置的demo数据，点击`下一步`按钮。\n\n![快速上手-选择一个demo](../../../images/browser/quickstart-selectdemo.png)\n\n在`填写配置`界面输入图项目信息，demo数据量都相对较小，`最大存储空间`设置为1G即可。输入完图项目信息后，点击`创建`按钮后，系统会自动创建demo数据的图模型、导入图数据。\n\n![快速上手-填写配置](../../../images/browser/quickstart-configure.png)\n\n#### 2.3.2.开始图项目\n\ndemo数据的图项目创建完成后，可以在`图项目`的选项卡中找到相应的图项目，可以点击`图查询`查询图数据。\n\n![快速上手-图项目选项卡](../../../images/browser/quickstart-graphtab.png)\n\n执行默认的查询语句，浏览demo里的图数据。\n\n![快速上手-验证结果](../../../images/browser/quickstart-result.png)\n\n更多MovieDemo的操作请浏览[影视场景](../3.quick-start/2.demo/1.movie.md)\n\n### 2.4.图项目\n\n`图项目`提供可视化的图项目管理和图数据研发功能，它为用户提供了一系列便捷的图数据可视化操作，包括图项目的创建、修改、删除等管理操作，以及图数据的查询、点边统计等操作。此外，它也支持图模型的管理，使用户可以更加方便地进行图数据的管理和维护。\n\n#### 2.4.1.图项目管理\n\n在`图项目`界面，可以看到当前图数据库中的图项目。\n\n![图项目-首页](../../../images/browser/graphmanagement-homepage.png)\n\n##### 2.4.1.1.新建图项目\n\n在`图项目`界面，点击`新建图项目`按钮创建一个新的图项目。"
            },
            {
                "content": "![快速上手-图项目选项卡](../../../images/browser/quickstart-graphtab.png)\n\n执行默认的查询语句，浏览demo里的图数据。\n\n![快速上手-验证结果](../../../images/browser/quickstart-result.png)\n\n更多MovieDemo的操作请浏览[影视场景](../3.quick-start/2.demo/1.movie.md)\n\n### 2.4.图项目\n\n`图项目`提供可视化的图项目管理和图数据研发功能，它为用户提供了一系列便捷的图数据可视化操作，包括图项目的创建、修改、删除等管理操作，以及图数据的查询、点边统计等操作。此外，它也支持图模型的管理，使用户可以更加方便地进行图数据的管理和维护。\n\n#### 2.4.1.图项目管理\n\n在`图项目`界面，可以看到当前图数据库中的图项目。\n\n![图项目-首页](../../../images/browser/graphmanagement-homepage.png)\n\n##### 2.4.1.1.新建图项目\n\n在`图项目`界面，点击`新建图项目`按钮创建一个新的图项目。\n\n![图项目-新建图项目按钮](../../../images/browser/graphmanagement-creategraph.png)\n\n新建图项目需要通过`选择模板`和`填写配置`两个页面完成图项目的创建。\n\n- __选择模板__：产品提供空模板和demo模板两类模板。\n    - 空模板：全新的图项目，用户需要自己创建图模型和导入图数据，一般用于正式项目开发。\n    - demo模板：产品内置的demo数据，图项目创建成功后，系统会自动创建demo图模型并导入demo图数据，一般用于试用和学习。\n\n![图项目-选择模板](../../../images/browser/graphmanagement-selecttemplate.png)"
            },
            {
                "content": "#### 2.4.1.图项目管理\n\n在`图项目`界面，可以看到当前图数据库中的图项目。\n\n![图项目-首页](../../../images/browser/graphmanagement-homepage.png)\n\n##### 2.4.1.1.新建图项目\n\n在`图项目`界面，点击`新建图项目`按钮创建一个新的图项目。\n\n![图项目-新建图项目按钮](../../../images/browser/graphmanagement-creategraph.png)\n\n新建图项目需要通过`选择模板`和`填写配置`两个页面完成图项目的创建。\n\n- __选择模板__：产品提供空模板和demo模板两类模板。\n    - 空模板：全新的图项目，用户需要自己创建图模型和导入图数据，一般用于正式项目开发。\n    - demo模板：产品内置的demo数据，图项目创建成功后，系统会自动创建demo图模型并导入demo图数据，一般用于试用和学习。\n\n![图项目-选择模板](../../../images/browser/graphmanagement-selecttemplate.png)\n\n- __填写配置__：用户需要填写图项目基本信息，并点击`创建`按钮创建图项目。\n    - 图名称：新建图项目的名称，同时作为该图项目的唯一主键。支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n    - 图描述：新建图项目的描述，可用于详细说明该项目的背景和目标。\n    - 高级配置-最大存储空间：设置图项目最大可占用的存储空间，实际并不会提前占用物理存储空间，实际数据量达到最大存储空间阈值后不可再写入数据。\n\n![图项目-填写配置](../../../images/browser/graphmanagement-configure.png)\n\n创建成功后，可在`图项目`页面的图项目选项卡中查看。\n\n##### 2.4.1.2.编辑图项目\n\n在`图项目`界面，点击图项目选项卡中的`编辑`按钮（笔形图标），编辑对应图项目的基础信息。\n\n![图项目-编辑图项目按钮](../../../images/browser/graphmanagement-editgraph-button.png)\n\n编辑图项目功能可以修改`图描述`和`最大存储空间`。"
            },
            {
                "content": "- __填写配置__：用户需要填写图项目基本信息，并点击`创建`按钮创建图项目。\n    - 图名称：新建图项目的名称，同时作为该图项目的唯一主键。支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n    - 图描述：新建图项目的描述，可用于详细说明该项目的背景和目标。\n    - 高级配置-最大存储空间：设置图项目最大可占用的存储空间，实际并不会提前占用物理存储空间，实际数据量达到最大存储空间阈值后不可再写入数据。\n\n![图项目-填写配置](../../../images/browser/graphmanagement-configure.png)\n\n创建成功后，可在`图项目`页面的图项目选项卡中查看。\n\n##### 2.4.1.2.编辑图项目\n\n在`图项目`界面，点击图项目选项卡中的`编辑`按钮（笔形图标），编辑对应图项目的基础信息。\n\n![图项目-编辑图项目按钮](../../../images/browser/graphmanagement-editgraph-button.png)\n\n编辑图项目功能可以修改`图描述`和`最大存储空间`。\n\n![图项目-编辑图项目](../../../images/browser/graphmanagement-editgraph.png)\n\n##### 2.4.1.3.删除图项目\n\n在`图项目`界面，点击图项目选项卡中的`删除`按钮（垃圾桶图标），删除对应的图项目。\n\n![图项目-删除图项目按钮](../../../images/browser/graphmanagement-deletegraph-button.png)\n\n_需要注意：图项目删除后无法恢复_。\n\n##### 2.4.1.4.点边统计\n\n在`图项目`界面，点击图项目选项卡中的`点边统计`按钮（刷新图标），统计对应图项目当前时间节点的点边数量。\n\n![图项目-点边统计按钮](../../../images/browser/graphmanagement-statistics-button.png)\n\n统计结果将展示在图项目选项卡上，已经统计过点边数据的图项目再次统计需要点击`刷新`按钮。\n\n![图项目-点边统计](../../../images/browser/graphmanagement-statistics.png)"
            },
            {
                "content": "![图项目-编辑图项目](../../../images/browser/graphmanagement-editgraph.png)\n\n##### 2.4.1.3.删除图项目\n\n在`图项目`界面，点击图项目选项卡中的`删除`按钮（垃圾桶图标），删除对应的图项目。\n\n![图项目-删除图项目按钮](../../../images/browser/graphmanagement-deletegraph-button.png)\n\n_需要注意：图项目删除后无法恢复_。\n\n##### 2.4.1.4.点边统计\n\n在`图项目`界面，点击图项目选项卡中的`点边统计`按钮（刷新图标），统计对应图项目当前时间节点的点边数量。\n\n![图项目-点边统计按钮](../../../images/browser/graphmanagement-statistics-button.png)\n\n统计结果将展示在图项目选项卡上，已经统计过点边数据的图项目再次统计需要点击`刷新`按钮。\n\n![图项目-点边统计](../../../images/browser/graphmanagement-statistics.png)\n\n![图项目-刷新点边统计按钮](../../../images/browser/graphmanagement-statistics-refresh-button.png)\n\n##### 2.4.1.5.存储过程\n\n在`图项目`界面，点击图项目选项卡中的`存储过程`按钮（卡片最右侧图标），跳转到操作存储过程的图页面。\n\n![图项目-存储过程按钮](../../../images/browser/graphmanagement-procedure-button.png)\n\n在`存储过程`页面，可以新建存储过程，新建时需要填写\"存储过程名称\"、\"存储过程类型\"、\"存储过程描述\"，然后选择\"版本\"和\"执行时是否修改数据库\"\n\n![图项目-存储过程](../../../images/browser/graphmanagement-procedure.png)\n\n更多存储过程的相关操作可见 [存储过程](../9.olap&procedure/1.procedure/1.procedure.md)\n\n#### 2.4.2.图构建"
            },
            {
                "content": "![图项目-刷新点边统计按钮](../../../images/browser/graphmanagement-statistics-refresh-button.png)\n\n##### 2.4.1.5.存储过程\n\n在`图项目`界面，点击图项目选项卡中的`存储过程`按钮（卡片最右侧图标），跳转到操作存储过程的图页面。\n\n![图项目-存储过程按钮](../../../images/browser/graphmanagement-procedure-button.png)\n\n在`存储过程`页面，可以新建存储过程，新建时需要填写\"存储过程名称\"、\"存储过程类型\"、\"存储过程描述\"，然后选择\"版本\"和\"执行时是否修改数据库\"\n\n![图项目-存储过程](../../../images/browser/graphmanagement-procedure.png)\n\n更多存储过程的相关操作可见 [存储过程](../9.olap&procedure/1.procedure/1.procedure.md)\n\n#### 2.4.2.图构建\n\nBrowser的`图构建`功能主要用于图项目的模型定义和数据导入。在`图项目`页面中，点击图项目选项卡中的`图构建`按钮。\n\n![图构建-按钮](../../../images/browser/graphbuild-button.png)\n\n##### 2.4.2.1.模型定义\n\nBrowser提供可视化的方式创建和维护图模型。\n\n- 也可用通过`cypher`工具和`lgraph_import`工具创建和维护图模型，详见[Cypher API](../8.query/1.cypher.md)和[数据导入](../6.utility-tools/1.data-import.md)文档。\n\n###### a.浏览图模型\n\n在`模型定义`界面可以查看详细的图模型设置，支持列表和画布方式查看图模型，支持列表展示点类型的属性和索引、边类型的属性和起点/终点类型。\n\n![图构建-浏览图模型](../../../images/browser/graphbuild.png)\n\n- 支持列表查看点类型和边类型。\n    - 支持点类型和边类型的个数展示，在点类型或边类型页签中展示对应的点或边数量。\n    - 支持点类型和边类型的名称关键字搜索，在`搜索框`输入关键字可展示对应的点或边。"
            },
            {
                "content": "![图构建-按钮](../../../images/browser/graphbuild-button.png)\n\n##### 2.4.2.1.模型定义\n\nBrowser提供可视化的方式创建和维护图模型。\n\n- 也可用通过`cypher`工具和`lgraph_import`工具创建和维护图模型，详见[Cypher API](../8.query/1.cypher.md)和[数据导入](../6.utility-tools/1.data-import.md)文档。\n\n###### a.浏览图模型\n\n在`模型定义`界面可以查看详细的图模型设置，支持列表和画布方式查看图模型，支持列表展示点类型的属性和索引、边类型的属性和起点/终点类型。\n\n![图构建-浏览图模型](../../../images/browser/graphbuild.png)\n\n- 支持列表查看点类型和边类型。\n    - 支持点类型和边类型的个数展示，在点类型或边类型页签中展示对应的点或边数量。\n    - 支持点类型和边类型的名称关键字搜索，在`搜索框`输入关键字可展示对应的点或边。\n\n        ![图构建-浏览图模型-搜索](../../../images/browser/graphbuild-list-search.png)\n    - 支持点类型和边类型的名称复制，点击`复制`按钮可以复制点或边的名称至粘贴板。\n\n        ![图构建-浏览图模型-复制](../../../images/browser/graphbuild-list-copy.png)\n    - 支持点类型和边类型的删除，点击`删除`按钮可以删除对应的点或边。\n\n        ![图构建-浏览图模型-删除](../../../images/browser/graphbuild-list-delete.png)\n- 支持画布方式查看点类型和边类型。\n- 在列表或画布中点击相应的点类型或边类型，可以展示模型详情。\n        ![图构建-浏览图模型-删除](../../../images/browser/graphbuild-select.png)\n\n###### b.添加点\n\n在`模型定义`界面点击`添加点`按钮，在右侧滑动窗口中添加点类型。"
            },
            {
                "content": "![图构建-浏览图模型-搜索](../../../images/browser/graphbuild-list-search.png)\n    - 支持点类型和边类型的名称复制，点击`复制`按钮可以复制点或边的名称至粘贴板。\n\n        ![图构建-浏览图模型-复制](../../../images/browser/graphbuild-list-copy.png)\n    - 支持点类型和边类型的删除，点击`删除`按钮可以删除对应的点或边。\n\n        ![图构建-浏览图模型-删除](../../../images/browser/graphbuild-list-delete.png)\n- 支持画布方式查看点类型和边类型。\n- 在列表或画布中点击相应的点类型或边类型，可以展示模型详情。\n        ![图构建-浏览图模型-删除](../../../images/browser/graphbuild-select.png)\n\n###### b.添加点\n\n在`模型定义`界面点击`添加点`按钮，在右侧滑动窗口中添加点类型。\n\n![图构建-添加点按钮](../../../images/browser/graphbuild-addvertex-button.png)\n\n用户需要输入点类型名称、属性和索引，点击`完成`按钮完成点类型的创建。\n- 点类型名称：点的名称，也是该点的唯一标识。\n- 属性：点的属性，需要一个属性作为主键。\n    - 数据类型：属性字段的数据类型，支持INT、STRING、DOUBLE、DATE、DATETIME、BLOB、BOOL等类型。\n    - 选填：该属性是否可以为空值。\n    - 删除：在创建点时可以任意删除属性。\n- 索引：点的索引属性，需要先创建属性再设置该属性为索引，索引创建成功后无法修改。\n    - 属性：需要配置索引的属性。\n    - 唯一：设置该属性字段为唯一值。\n    - 主键：对应属性是否为主键，选择`是`后`唯一`选项必须为`是`。\n    - 删除：在创建点时可以任意删除索引。\n\n![图构建-添加点按钮](../../../images/browser/graphbuild-addvertex.png)"
            },
            {
                "content": "![图构建-添加点按钮](../../../images/browser/graphbuild-addvertex-button.png)\n\n用户需要输入点类型名称、属性和索引，点击`完成`按钮完成点类型的创建。\n- 点类型名称：点的名称，也是该点的唯一标识。\n- 属性：点的属性，需要一个属性作为主键。\n    - 数据类型：属性字段的数据类型，支持INT、STRING、DOUBLE、DATE、DATETIME、BLOB、BOOL等类型。\n    - 选填：该属性是否可以为空值。\n    - 删除：在创建点时可以任意删除属性。\n- 索引：点的索引属性，需要先创建属性再设置该属性为索引，索引创建成功后无法修改。\n    - 属性：需要配置索引的属性。\n    - 唯一：设置该属性字段为唯一值。\n    - 主键：对应属性是否为主键，选择`是`后`唯一`选项必须为`是`。\n    - 删除：在创建点时可以任意删除索引。\n\n![图构建-添加点按钮](../../../images/browser/graphbuild-addvertex.png)\n\n- 编辑点：可以增加点的属性和修改已有属性的数据类型，新增或删除索引。需要对每个新增或修改的属性点击`保存`按钮才可以生效。\n_注：主键字段的属性创建后无修改_\n\n![图构建-编辑点](../../../images/browser/graphbuild-editvertex.png)\n\n###### c.添加边\n\n在`模型定义`界面点击`添加边`按钮，在右侧滑动窗口中添加边类型。\n\n![图构建-添加边按钮](../../../images/browser/graphbuild-addedge-button.png)"
            },
            {
                "content": "![图构建-添加点按钮](../../../images/browser/graphbuild-addvertex.png)\n\n- 编辑点：可以增加点的属性和修改已有属性的数据类型，新增或删除索引。需要对每个新增或修改的属性点击`保存`按钮才可以生效。\n_注：主键字段的属性创建后无修改_\n\n![图构建-编辑点](../../../images/browser/graphbuild-editvertex.png)\n\n###### c.添加边\n\n在`模型定义`界面点击`添加边`按钮，在右侧滑动窗口中添加边类型。\n\n![图构建-添加边按钮](../../../images/browser/graphbuild-addedge-button.png)\n\n用户需要输入边类型名称、属性、选择起点类型和终点类型，点击`完成`按钮完成边类型的创建。\n- 边类型名称：边的名称，也是该边的唯一标识。\n- 属性：边的属性，边上可以没有属性。\n    - 数据类型：属性字段的数据类型，支持INT、STRING、DOUBLE、DATE、DATETIME、BLOB、BOOL等类型。\n    - 选填：该属性是否可以为空值。\n    - 删除：在创建边时可以任意删除属性。\n- 选择起点类型和终点类型：设置边的起点点类型和终点点类型，支持多个起点类型和终点类型。\n    - 起点：选择起点的点类型。\n    - 终点：选择终点的点类型。\n    - 需要提前创建至少一个点类型才能设置边的起点类型和终点。\n    - 如果不选择则表示起点和终点可以为任意点类型，同时画布上不展示对应的边，需要在左侧列表查看边类型。\n\n![图构建-添加边](../../../images/browser/graphbuild-addedge.png)\n\n- 编辑边：可以增加边的属性和修改已有属性的数据类型。需要对每个新增或修改的属性点击`保存`按钮才可以生效。\n\n![图构建-编辑边](../../../images/browser/graphbuild-editedge.png)\n\n###### d.导入模型\n\n在`模型定义`界面点击`导入模型`按钮，可以上传模型文件快速创建模型。\n\n![图构建-导入模型按钮](../../../images/browser/graphbuild-importmodel-button.png)"
            },
            {
                "content": "![图构建-添加边](../../../images/browser/graphbuild-addedge.png)\n\n- 编辑边：可以增加边的属性和修改已有属性的数据类型。需要对每个新增或修改的属性点击`保存`按钮才可以生效。\n\n![图构建-编辑边](../../../images/browser/graphbuild-editedge.png)\n\n###### d.导入模型\n\n在`模型定义`界面点击`导入模型`按钮，可以上传模型文件快速创建模型。\n\n![图构建-导入模型按钮](../../../images/browser/graphbuild-importmodel-button.png)\n\n在`导入模型`界面点击`上传文件`按钮，上传模型文件成功后，点击确定可以导入图模型。\n\n- 覆盖当前画布中的模型：选中该选项，导入时会先清空已有图模型再导入模型文件中的图模型；不选择，会导入模型文件中新增的点类型和边类型，但不会修改已有的点类型和边类型。\n\n![图构建-导入模型](../../../images/browser/graphbuild-importmodel.png)\n\n###### e.导出模型\n\n在`模型定义`界面点击`导出模型`按钮，可以将当前图项目中的图模型导出成json文件。\n\n![图构建-导出模型按钮](../../../images/browser/graphbuild-exportmodel-button.png)\n\n模型文件为json格式，不建议手动修改。\n\n![图构建-导出模型按钮](../../../images/browser/graphbuild-exportmodel.png)\n\n##### 2.4.2.2.数据导入\n\n完成`模型定义`之后，点击`数据导入`按钮进入数据导入页面。\n\n![图构建-数据导入](../../../images/browser/graphbuild-dataimport.png)\n\n###### a.数据准备\n\n在数据导入前需要提前准备数据，当前Browser支持CSV文件的上传，需要保证数据文件后缀为csv。\n- 不强制要求包含表头。\n- 支持文本限定符，文本限定符为双引号。\n\n![数据导入-csv](../../../images/browser/graphbuild-import-csv.png)\n\n###### b.上传文件"
            },
            {
                "content": "在`模型定义`界面点击`导出模型`按钮，可以将当前图项目中的图模型导出成json文件。\n\n![图构建-导出模型按钮](../../../images/browser/graphbuild-exportmodel-button.png)\n\n模型文件为json格式，不建议手动修改。\n\n![图构建-导出模型按钮](../../../images/browser/graphbuild-exportmodel.png)\n\n##### 2.4.2.2.数据导入\n\n完成`模型定义`之后，点击`数据导入`按钮进入数据导入页面。\n\n![图构建-数据导入](../../../images/browser/graphbuild-dataimport.png)\n\n###### a.数据准备\n\n在数据导入前需要提前准备数据，当前Browser支持CSV文件的上传，需要保证数据文件后缀为csv。\n- 不强制要求包含表头。\n- 支持文本限定符，文本限定符为双引号。\n\n![数据导入-csv](../../../images/browser/graphbuild-import-csv.png)\n\n###### b.上传文件\n\n在`数据导入`页面上传需要导入的数据文件，将数据导入到图项目中。\n\n![数据导入-上传文件](../../../images/browser/graphbuild-import.png)\n\n- 分隔符：数据文件的列分隔符。\n- 文件上传：支持上传多个文件。\n    - 支持弹窗中选择多个上传文件。\n    - 支持将文件拖拽至页面中上传。\n    - 支持同时上传点文件和边文件。\n\n###### c.数据映射\n\n文件上传成功后，需要在`数据导入`页面设置`数据对应表`，将数据文件中的数据列和目标点/边、对应属性建立映射关系。"
            },
            {
                "content": "![图构建-数据导入](../../../images/browser/graphbuild-dataimport.png)\n\n###### a.数据准备\n\n在数据导入前需要提前准备数据，当前Browser支持CSV文件的上传，需要保证数据文件后缀为csv。\n- 不强制要求包含表头。\n- 支持文本限定符，文本限定符为双引号。\n\n![数据导入-csv](../../../images/browser/graphbuild-import-csv.png)\n\n###### b.上传文件\n\n在`数据导入`页面上传需要导入的数据文件，将数据导入到图项目中。\n\n![数据导入-上传文件](../../../images/browser/graphbuild-import.png)\n\n- 分隔符：数据文件的列分隔符。\n- 文件上传：支持上传多个文件。\n    - 支持弹窗中选择多个上传文件。\n    - 支持将文件拖拽至页面中上传。\n    - 支持同时上传点文件和边文件。\n\n###### c.数据映射\n\n文件上传成功后，需要在`数据导入`页面设置`数据对应表`，将数据文件中的数据列和目标点/边、对应属性建立映射关系。\n\n- 数据对应表：展示已经上传的数据问题。\n    - 文件名称：上传的数据文件名称。\n    - 文件大小：上传的数据文件大小。\n    - 读取结果：数据文件上传结果，success为读取成功。\n    - 删除：在页面中删除，不会删除本地文件。\n- 数据文件映射：每个已上传的数据文件都需要配置映射关系。\n    - 标签：选择该文件对应的点或边类型，只能选择一类点或一类边。\n    - 从第N行，开始：从第N行开始读取数据，系统默认从第0行开始读取数据，如需跳过表头可输入1。\n    - 属性映射：下拉选择数据列对应的属性字段。\n    - 数据预览：系统会预读数据文件的前5行。\n\n![数据导入-数据映射](../../../images/browser/graphbuild-import-datamapping.png)\n\n文件上传成功后，可以点击`继续导入`按钮继续导入其他数据，或者点击`前往图查询`按钮在`图查询`页面查询已导入的数据。\n\n![数据导入-导入成功](../../../images/browser/graphbuild-import-success.png)"
            },
            {
                "content": "- 数据对应表：展示已经上传的数据问题。\n    - 文件名称：上传的数据文件名称。\n    - 文件大小：上传的数据文件大小。\n    - 读取结果：数据文件上传结果，success为读取成功。\n    - 删除：在页面中删除，不会删除本地文件。\n- 数据文件映射：每个已上传的数据文件都需要配置映射关系。\n    - 标签：选择该文件对应的点或边类型，只能选择一类点或一类边。\n    - 从第N行，开始：从第N行开始读取数据，系统默认从第0行开始读取数据，如需跳过表头可输入1。\n    - 属性映射：下拉选择数据列对应的属性字段。\n    - 数据预览：系统会预读数据文件的前5行。\n\n![数据导入-数据映射](../../../images/browser/graphbuild-import-datamapping.png)\n\n文件上传成功后，可以点击`继续导入`按钮继续导入其他数据，或者点击`前往图查询`按钮在`图查询`页面查询已导入的数据。\n\n![数据导入-导入成功](../../../images/browser/graphbuild-import-success.png)\n\n#### 2.4.3.图查询\n\n在`图项目`界面点击图项目选项卡中的`图查询`按钮，可以查询和访问图项目中的图数据，产品提供`语句查询`、`路径查询`、`点查询`等多种模式查询图数据，支持切换图项目和查询结果展示。\n\n![图查询-按钮](../../../images/browser/query-button.png)\n\n##### 2.4.3.1.切换图项目\n\n`图查询`功能只能访问一个图项目数据，用户可以在`切换图项目`下拉框中选择并切换至其他图数据。\n\n![图查询-切换图项目](../../../images/browser/query-selectgraph.png)\n\n##### 2.4.3.2.语句查询\n\nBrowser提供可视化方式开发和调试图查询语句，用户可以输入图查询语句、执行并返回结果，支持收藏语句和查看图模型。\n\n![图查询-语句查询](../../../images/browser/query-view.png)\n\n###### a.语句查询窗口\n\n用户在`语句查询窗口`输入图查询语句，点击`执行`按钮可以运行对应语句，并在`执行结果页签`展示结果。"
            },
            {
                "content": "#### 2.4.3.图查询\n\n在`图项目`界面点击图项目选项卡中的`图查询`按钮，可以查询和访问图项目中的图数据，产品提供`语句查询`、`路径查询`、`点查询`等多种模式查询图数据，支持切换图项目和查询结果展示。\n\n![图查询-按钮](../../../images/browser/query-button.png)\n\n##### 2.4.3.1.切换图项目\n\n`图查询`功能只能访问一个图项目数据，用户可以在`切换图项目`下拉框中选择并切换至其他图数据。\n\n![图查询-切换图项目](../../../images/browser/query-selectgraph.png)\n\n##### 2.4.3.2.语句查询\n\nBrowser提供可视化方式开发和调试图查询语句，用户可以输入图查询语句、执行并返回结果，支持收藏语句和查看图模型。\n\n![图查询-语句查询](../../../images/browser/query-view.png)\n\n###### a.语句查询窗口\n\n用户在`语句查询窗口`输入图查询语句，点击`执行`按钮可以运行对应语句，并在`执行结果页签`展示结果。\n\n- 切换查询语言：提供不同图查询语言模式的切换。_当前只支持Cypher语法_\n\n![图查询-切换语言](../../../images/browser/query-selectgql.png)\n\n- 语句查询窗口：提供当前查询语言的语法提示。\n\n![图查询-语法提示](../../../images/browser/query-gqltips.png)\n\n- 执行：点击`执行`按钮，发送输入的查询语句至后台运行。\n\n![图查询-执行按钮](../../../images/browser/query-execute-button.png)\n\n- 收藏：点击`收藏`按钮，将当前语句查询窗口的内容保存成模板，以便下次使用。\n\n![图查询-收藏按钮](../../../images/browser/query-bookmark-button.png)\n\n- 下载：点击`下载`按钮，将当前语句查询窗口的内容保存成文本文件并下载至本地，以便下次使用。\n\n![图查询-下载按钮](../../../images/browser/query-download-button.png)"
            },
            {
                "content": "- 切换查询语言：提供不同图查询语言模式的切换。_当前只支持Cypher语法_\n\n![图查询-切换语言](../../../images/browser/query-selectgql.png)\n\n- 语句查询窗口：提供当前查询语言的语法提示。\n\n![图查询-语法提示](../../../images/browser/query-gqltips.png)\n\n- 执行：点击`执行`按钮，发送输入的查询语句至后台运行。\n\n![图查询-执行按钮](../../../images/browser/query-execute-button.png)\n\n- 收藏：点击`收藏`按钮，将当前语句查询窗口的内容保存成模板，以便下次使用。\n\n![图查询-收藏按钮](../../../images/browser/query-bookmark-button.png)\n\n- 下载：点击`下载`按钮，将当前语句查询窗口的内容保存成文本文件并下载至本地，以便下次使用。\n\n![图查询-下载按钮](../../../images/browser/query-download-button.png)\n\n详细Cypher使用指南请参考文档：[Cypher API](../8.query/1.cypher.md)\n\n###### b.收藏列表\n\n以列表方式展示已经收藏的查询语句，点击列表中的收藏模板可以使用其中的语句。支持关键字搜索、名称修改以及删除。\n\n![图查询-语句收藏](../../../images/browser/query-bookmark.png)\n\n###### c.查看图模型\n\nBrowser提供当前图项目中的图模型查询，方便用户清晰点边类型模型，支持列表展示和画布图谱展示方式，支持隐藏查看图模型窗口。\n\n![图查询-图模型列表](../../../images/browser/query-schema-list.png)\n![图查询-图模型图谱](../../../images/browser/query-schema-graph.png)\n\n##### 2.4.3.3.路径查询\n\nBrowser提供`路径查询`模板，用户可以通过选择路径的方式，查找图项目中的图数据是否存在相应的路径。\n\n![路径查询](../../../images/browser/pathquery-result.png)"
            },
            {
                "content": "###### b.收藏列表\n\n以列表方式展示已经收藏的查询语句，点击列表中的收藏模板可以使用其中的语句。支持关键字搜索、名称修改以及删除。\n\n![图查询-语句收藏](../../../images/browser/query-bookmark.png)\n\n###### c.查看图模型\n\nBrowser提供当前图项目中的图模型查询，方便用户清晰点边类型模型，支持列表展示和画布图谱展示方式，支持隐藏查看图模型窗口。\n\n![图查询-图模型列表](../../../images/browser/query-schema-list.png)\n![图查询-图模型图谱](../../../images/browser/query-schema-graph.png)\n\n##### 2.4.3.3.路径查询\n\nBrowser提供`路径查询`模板，用户可以通过选择路径的方式，查找图项目中的图数据是否存在相应的路径。\n\n![路径查询](../../../images/browser/pathquery-result.png)\n\n- 路径：在路径选择下拉框内选择需要查找的路径。\n    - 选择路径：根据图模型的定义，系统会自动匹配出对应的一度关系路径；再次点击路径下拉框会，系统会根据路径终点的点类型自动匹配下一度关系路径。\n![路径查询-选择路径](../../../images/browser/pathquery-select.png)\n    - 执行：点击`执行`按钮返回图项目中匹配的路径。\n    - 高级配置：设置扫描的路径数目，默认为100条路径。\n![路径查询-高级配置](../../../images/browser/pathquery-configuration.png)\n\n_注：需要图模型中的边设置起点和终点，如果图项目中的边均未设置起点和终点，下拉选项无结果_\n\n##### 2.4.3.4.点查询\n\nBrowser提供`点查询`模板，用户可以通过选择点属性进行查询，查找图项目中的点数据。\n\n![点查询](../../../images/browser/vertexquery.png)\n\n##### 2.4.3.5.执行结果页签\n\nBrowser提供表格文本、点边视图等多种方式展示图查询结果，支持结果下载、插入数据、全屏展示。\n\n###### a.表格文本\n\nBrowser提供以表格文本方式展示查询结果。"
            },
            {
                "content": "_注：需要图模型中的边设置起点和终点，如果图项目中的边均未设置起点和终点，下拉选项无结果_\n\n##### 2.4.3.4.点查询\n\nBrowser提供`点查询`模板，用户可以通过选择点属性进行查询，查找图项目中的点数据。\n\n![点查询](../../../images/browser/vertexquery.png)\n\n##### 2.4.3.5.执行结果页签\n\nBrowser提供表格文本、点边视图等多种方式展示图查询结果，支持结果下载、插入数据、全屏展示。\n\n###### a.表格文本\n\nBrowser提供以表格文本方式展示查询结果。\n\n![JSON视图](../../../images/browser/query-result-txt.png)\n\n###### b.点边视图\n\nBrowser提供以画布方式展示查询结果。\n\n![点边视图](../../../images/browser/query-result-graph.png)\n\n###### c.插入数据\n\nBrowser提供可视化方式在对应图项目中插入点或边数据。点击`插入数据`按钮，在`插入数据`页签选择点类型或边类型，输入属性值，点击确定完成数据插入。\n\n![插入数据-按钮](../../../images/browser/query-result-insert-button.png)\n\n![插入数据](../../../images/browser/query-result-insert.png)\n\n###### d.下载执行结果\n\nBrowser提供图查询结果导出成文本文件功能。点击`下载执行结果`按钮，系统会自动将结果保存成文本文件并下载至本地。\n\n![下载执行结果-按钮](../../../images/browser/query-result-download.png)\n![下载执行结果-按钮](../../../images/browser/query-result-downloadtxt.png)\n\n###### e.全屏展示\n\nBrowser提供全屏方式展示图查询结果，点击`全屏显示`按钮全屏展示结果，点击`退出全屏`按钮退出全屏展示。"
            },
            {
                "content": "###### c.插入数据\n\nBrowser提供可视化方式在对应图项目中插入点或边数据。点击`插入数据`按钮，在`插入数据`页签选择点类型或边类型，输入属性值，点击确定完成数据插入。\n\n![插入数据-按钮](../../../images/browser/query-result-insert-button.png)\n\n![插入数据](../../../images/browser/query-result-insert.png)\n\n###### d.下载执行结果\n\nBrowser提供图查询结果导出成文本文件功能。点击`下载执行结果`按钮，系统会自动将结果保存成文本文件并下载至本地。\n\n![下载执行结果-按钮](../../../images/browser/query-result-download.png)\n![下载执行结果-按钮](../../../images/browser/query-result-downloadtxt.png)\n\n###### e.全屏展示\n\nBrowser提供全屏方式展示图查询结果，点击`全屏显示`按钮全屏展示结果，点击`退出全屏`按钮退出全屏展示。\n\n![全屏展示-按钮](../../../images/browser/query-result-fullscreen-button.png)\n![全屏展示](../../../images/browser/query-result-fullscreen.png)\n![全屏展示-按钮](../../../images/browser/query-result-fullscreen-close.png)\n\n#### 2.4.4.图分析\n\n在`图项目`界面点击图项目选项卡中的`图分析`按钮，可以在画布中展示和分析图数据，产品提供`语句查询`和`配置查询`将图项目中的数据查询并加载至画布，支持画布数据的筛选、布局样式调整以及画布操作。\n\n![图分析-按钮](../../../images/browser/graphanalysis-button.png)\n\n如下图所示，图分析功能主要包括："
            },
            {
                "content": "###### e.全屏展示\n\nBrowser提供全屏方式展示图查询结果，点击`全屏显示`按钮全屏展示结果，点击`退出全屏`按钮退出全屏展示。\n\n![全屏展示-按钮](../../../images/browser/query-result-fullscreen-button.png)\n![全屏展示](../../../images/browser/query-result-fullscreen.png)\n![全屏展示-按钮](../../../images/browser/query-result-fullscreen-close.png)\n\n#### 2.4.4.图分析\n\n在`图项目`界面点击图项目选项卡中的`图分析`按钮，可以在画布中展示和分析图数据，产品提供`语句查询`和`配置查询`将图项目中的数据查询并加载至画布，支持画布数据的筛选、布局样式调整以及画布操作。\n\n![图分析-按钮](../../../images/browser/graphanalysis-button.png)\n\n如下图所示，图分析功能主要包括：\n\n  1、操作栏：图分析主要操作功能，包括布局切换、查询过滤、布局、样式以及画布操作；\n  2、左边栏：查询、筛选、外观功能操作区域；\n  3、画布区域：展示图数据的区域，展示点和边数据，支持点扩展查询、收起节点、固定节点、删除节点、画布图数据统计、缩放、居中等功能；\n  4、右边栏：选中一个点数据或边数据后，会展示对应的属性信息；\n  5、布局切换：标签布局和卡片布局的切换。\n\n![图分析-操作区域](../../../images/browser/graphanalysis-operation-area.png)\n\n##### 2.4.4.1.语句查询\n\n在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。\n- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。\n- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。\n\n![图分析-语句查询](../../../images/browser/graphanalysis-queryfilter-query.png)\n\n##### 2.4.4.2.配置查询"
            },
            {
                "content": "![图分析-操作区域](../../../images/browser/graphanalysis-operation-area.png)\n\n##### 2.4.4.1.语句查询\n\n在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。\n- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。\n- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。\n\n![图分析-语句查询](../../../images/browser/graphanalysis-queryfilter-query.png)\n\n##### 2.4.4.2.配置查询\n\n在`配置查询`功能中，用户可以选择节点类型和输入属性条件来查询图数据，并加载数据至画布区域进行展示。\n- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。\n\n![图分析-模板查询](../../../images/browser/graphanalysis-queryfilter-configurequery.png)\n\n##### 2.4.4.3.画布分析\n\n在`画布分析`功能中，用户可以对画布中的节点或边数据进行操作和分析，主要包括：选中节点进行扩展查询、收起/展开节点、固定节点，清空画布，套索，点/边检索，画布图例等。画布上的最基础操作是拖拽点数据，鼠标左键选住一个节点并移动鼠标，可以完成点数据位置的移动。\n\n###### a.扩展查询\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，鼠标移至`扩展查询`处弹出二级悬窗，点击对应的扩展度数进行查询。\n- 一度查询：双向扩展一度关系。\n- 二度查询：双向扩展二度关系。\n- 三度查询：双向扩展三度关系。\n\n![图分析-画布分析-扩展查询-按钮](../../../images/browser/graphanalysis-canvas-expand-before.png)\n\n![图分析-画布分析-扩展查询-查询后](../../../images/browser/graphanalysis-canvas-expand-after.png)\n\n###### b.收起/展开节点"
            },
            {
                "content": "##### 2.4.4.3.画布分析\n\n在`画布分析`功能中，用户可以对画布中的节点或边数据进行操作和分析，主要包括：选中节点进行扩展查询、收起/展开节点、固定节点，清空画布，套索，点/边检索，画布图例等。画布上的最基础操作是拖拽点数据，鼠标左键选住一个节点并移动鼠标，可以完成点数据位置的移动。\n\n###### a.扩展查询\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，鼠标移至`扩展查询`处弹出二级悬窗，点击对应的扩展度数进行查询。\n- 一度查询：双向扩展一度关系。\n- 二度查询：双向扩展二度关系。\n- 三度查询：双向扩展三度关系。\n\n![图分析-画布分析-扩展查询-按钮](../../../images/browser/graphanalysis-canvas-expand-before.png)\n\n![图分析-画布分析-扩展查询-查询后](../../../images/browser/graphanalysis-canvas-expand-after.png)\n\n###### b.收起/展开节点\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`收起节点`会隐藏所选节点的一度关系节点；再次右键已`收起节点`的点数据可以进行`展开节点`操作，展示已隐藏的一度关系节点。\n\n![图分析-画布分析-收起节点](../../../images/browser/graphanalysis-canvas-collapse.png)\n\n![图分析-画布分析-展开节点](../../../images/browser/graphanalysis-canvas-expand.png)\n\n###### c.删除节点\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`删除节点`会将所选节点移出画布。\n\n![图分析-画布分析-删除节点](../../../images/browser/graphanalysis-canvas-delete.png)\n\n###### d.清空画布\n\n在`操作栏`区域点击`清空画布`按钮，会清除所有画布中的数据。\n\n![图分析-画布分析-清空画布](../../../images/browser/graphanalysis-canvas-clear.png)\n\n###### e.点/边检索"
            },
            {
                "content": "![图分析-画布分析-收起节点](../../../images/browser/graphanalysis-canvas-collapse.png)\n\n![图分析-画布分析-展开节点](../../../images/browser/graphanalysis-canvas-expand.png)\n\n###### c.删除节点\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`删除节点`会将所选节点移出画布。\n\n![图分析-画布分析-删除节点](../../../images/browser/graphanalysis-canvas-delete.png)\n\n###### d.清空画布\n\n在`操作栏`区域点击`清空画布`按钮，会清除所有画布中的数据。\n\n![图分析-画布分析-清空画布](../../../images/browser/graphanalysis-canvas-clear.png)\n\n###### e.点/边检索\n\n在`点/边检索`窗口选择点或边，并输入关键字，会模糊检索画布中的属性数据，检索后可定位至数据位置。\n\n![图分析-画布分析-检索](../../../images/browser/graphanalysis-canvas-retrieval.png)\n\n###### f.画布图例\n\n在`画布`区域的图例位置，会展示画布中的点类型，点击点类型可以选中对应的点数据，点击更多按钮可以展示统计情况，支持列表或图表方式展示点或边的数量。\n\n![图分析-画布分析-列表](../../../images/browser/graphanalysis-canvas-legend-list.png)\n![图分析-画布分析-图表](../../../images/browser/graphanalysis-canvas-legend-chart.png)\n\n###### g.缩放/居中\n\n可以使用鼠标滚轮和缩放按钮进行缩放。\n![图分析-画布分析-缩放](../../../images/browser/graphanalysis-canvas-zoom.png)\n![图分析-画布分析-缩放](../../../images/browser/graphanalysis-canvas-center.png)\n\n\n##### 2.4.4.4.属性筛选"
            },
            {
                "content": "###### f.画布图例\n\n在`画布`区域的图例位置，会展示画布中的点类型，点击点类型可以选中对应的点数据，点击更多按钮可以展示统计情况，支持列表或图表方式展示点或边的数量。\n\n![图分析-画布分析-列表](../../../images/browser/graphanalysis-canvas-legend-list.png)\n![图分析-画布分析-图表](../../../images/browser/graphanalysis-canvas-legend-chart.png)\n\n###### g.缩放/居中\n\n可以使用鼠标滚轮和缩放按钮进行缩放。\n![图分析-画布分析-缩放](../../../images/browser/graphanalysis-canvas-zoom.png)\n![图分析-画布分析-缩放](../../../images/browser/graphanalysis-canvas-center.png)\n\n\n##### 2.4.4.4.属性筛选\n\n在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`属性筛选`进行筛选过滤。用户可以选择要筛选的点或边类型，以及对应的属性值进行设置，检索到筛选组条件的数据后会在画布上高亮选中对应的点或边数据。\n- 请选择点/边类型：选择需要检索的点类型或边类型。\n- 属性条件：设置需要检索的属性条件，可以设置多组，取并集筛选结果。\n- 添加筛选组：可以多组筛选条件，取并集筛选结果。\n- 重置：可以清空筛选条件。\n\n![图分析-筛选-属性筛选](../../../images/browser/graphanalysis-queryfilter-attributefilter.png)\n\n##### 2.4.4.5.统计筛选\n\n在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`统计筛选`进行画布数据统计。用户可以选择要统计的点或边类型，以及对应的属性值进行设置，系统会自动根据用户选择的点/边类型和属性进行分组统计，支持按照图表和列表两种方式展示结果，同时点击图表或列表区域的数值可以高亮选中画布中的数据。"
            },
            {
                "content": "##### 2.4.4.4.属性筛选\n\n在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`属性筛选`进行筛选过滤。用户可以选择要筛选的点或边类型，以及对应的属性值进行设置，检索到筛选组条件的数据后会在画布上高亮选中对应的点或边数据。\n- 请选择点/边类型：选择需要检索的点类型或边类型。\n- 属性条件：设置需要检索的属性条件，可以设置多组，取并集筛选结果。\n- 添加筛选组：可以多组筛选条件，取并集筛选结果。\n- 重置：可以清空筛选条件。\n\n![图分析-筛选-属性筛选](../../../images/browser/graphanalysis-queryfilter-attributefilter.png)\n\n##### 2.4.4.5.统计筛选\n\n在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`统计筛选`进行画布数据统计。用户可以选择要统计的点或边类型，以及对应的属性值进行设置，系统会自动根据用户选择的点/边类型和属性进行分组统计，支持按照图表和列表两种方式展示结果，同时点击图表或列表区域的数值可以高亮选中画布中的数据。\n\n![图分析-筛选-统计筛选](../../../images/browser/graphanalysis-queryfilter-statisticalfilter.png)\n![图分析-统计筛选-图表切换](../../../images/browser/graphanalysis-queryfilter-statisticalfilter-chartswitch.png)\n\n##### 2.4.4.6.点边布局\n\n在`操作栏`区域点击`布局`按钮，选择对应的布局方式会将画布中的数据进行重新排布，支持力导向布局、同心圆布局、圆形布局、辐射布局、Dagre布局以及网格布局，每种布局方式均有不同布局参数，调整参数后画布中的数据会进行重新排布。\n\n![图分析-布局样式-按钮](../../../images/browser/graphanalysis-style-layout-button.png)\n![图分析-布局样式-布局参数](../../../images/browser/graphanalysis-style-layout-parameters.png)"
            },
            {
                "content": "![图分析-筛选-统计筛选](../../../images/browser/graphanalysis-queryfilter-statisticalfilter.png)\n![图分析-统计筛选-图表切换](../../../images/browser/graphanalysis-queryfilter-statisticalfilter-chartswitch.png)\n\n##### 2.4.4.6.点边布局\n\n在`操作栏`区域点击`布局`按钮，选择对应的布局方式会将画布中的数据进行重新排布，支持力导向布局、同心圆布局、圆形布局、辐射布局、Dagre布局以及网格布局，每种布局方式均有不同布局参数，调整参数后画布中的数据会进行重新排布。\n\n![图分析-布局样式-按钮](../../../images/browser/graphanalysis-style-layout-button.png)\n![图分析-布局样式-布局参数](../../../images/browser/graphanalysis-style-layout-parameters.png)\n\n详细布局参数可参考[AntV-G6](https://g6.antv.antgroup.com/api/graph-layout/guide)。\n\n##### 2.4.4.7.外观样式\n\n在`操作栏`区域点击`外观`按钮，在`左边栏`点击`点样式`或`边样式`进行外观样式配置。\n- 点样式\n    - 应用点类型：设置对应点类型的展示样式，支持同时配置多个点类型外观。\n    - 大小：对应点类型的展示大小。\n    - 颜色：对应点类型的展示颜色。\n    - 图标：对应点类型的图标样式。\n    - 显示文本：对应点类型显示的文本内容，默认为id。\n    - 高级配置：根据设置的条件标记对应的点数据。\n- 边样式\n    - 应用边类型：设置对应边类型的展示样式。\n    - 颜色：对应点类型的展示颜色。\n    - 边宽：对应边类型的展示宽度。\n    - 显示文本：对应边类型显示的文本内容，默认不显示。\n    - 高级配置：根据设置的条件按颜色展示对应的边数据，支持同时配置多个边类型外观。\n\n![图分析-外观](../../../images/browser/graphanalysis-style-appearance.png)"
            },
            {
                "content": "##### 2.4.4.7.外观样式\n\n在`操作栏`区域点击`外观`按钮，在`左边栏`点击`点样式`或`边样式`进行外观样式配置。\n- 点样式\n    - 应用点类型：设置对应点类型的展示样式，支持同时配置多个点类型外观。\n    - 大小：对应点类型的展示大小。\n    - 颜色：对应点类型的展示颜色。\n    - 图标：对应点类型的图标样式。\n    - 显示文本：对应点类型显示的文本内容，默认为id。\n    - 高级配置：根据设置的条件标记对应的点数据。\n- 边样式\n    - 应用边类型：设置对应边类型的展示样式。\n    - 颜色：对应点类型的展示颜色。\n    - 边宽：对应边类型的展示宽度。\n    - 显示文本：对应边类型显示的文本内容，默认不显示。\n    - 高级配置：根据设置的条件按颜色展示对应的边数据，支持同时配置多个边类型外观。\n\n![图分析-外观](../../../images/browser/graphanalysis-style-appearance.png)\n\n##### 2.4.4.8.视图切换\n\n图分析中支持2D图谱视图、列表视图以及JSON视图。\n![图分析-视图-2D](../../../images/browser/graphanalysis-view-2D.png)\n![图分析-视图-list](../../../images/browser/graphanalysis-view-list.png)\n![图分析-视图-json](../../../images/browser/graphanalysis-view-json.png)\n\n##### 2.4.4.9.标签/卡片布局切换\n\n图分析支持标签布局和卡片布局。\n![图分析-标签](../../../images/browser/graphanalysis-tag.png)\n![图分析-卡片](../../../images/browser/graphanalysis-card.png)\n\n### 2.5.控制台"
            },
            {
                "content": "![图分析-外观](../../../images/browser/graphanalysis-style-appearance.png)\n\n##### 2.4.4.8.视图切换\n\n图分析中支持2D图谱视图、列表视图以及JSON视图。\n![图分析-视图-2D](../../../images/browser/graphanalysis-view-2D.png)\n![图分析-视图-list](../../../images/browser/graphanalysis-view-list.png)\n![图分析-视图-json](../../../images/browser/graphanalysis-view-json.png)\n\n##### 2.4.4.9.标签/卡片布局切换\n\n图分析支持标签布局和卡片布局。\n![图分析-标签](../../../images/browser/graphanalysis-tag.png)\n![图分析-卡片](../../../images/browser/graphanalysis-card.png)\n\n### 2.5.控制台\n\n`控制台`提供可视化的的账户管理和数据库信息查看功能，它为用户提供了全面的账户和角色管理功能，包括账户的增删改查以及禁用，角色的增删改查以及禁用。此外，它也为用户提供了便捷的数据库信息查看功能，让用户可以轻松地查看图数据库的基础信息和配置信息。其中，基础信息主要包括版本号、运行时间、CPP编译版本号等，而数据库配置信息则包括端口号、系统功能参数配置等。\n\n#### 2.5.1.账户管理\n\n##### 2.5.1.1.账户管理\n\n###### a.添加账户\n\n在`账户管理`界面点击`添加`按钮创建新的账户，用户需要输入账户名称、账户描述、账户密码以及相关角色。\n\n![账户管理-添加账户按钮](../../../images/browser/account-add-button.png)\n\n- 账户名称：支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n- 相关角色：新建账户时必须要选择一个角色，在账户添加成功后，系统会自动生成一个与账户名称一样的角色。\n\n![账户管理-添加账户](../../../images/browser/account-add.png)\n\n###### b.编辑账户"
            },
            {
                "content": "`控制台`提供可视化的的账户管理和数据库信息查看功能，它为用户提供了全面的账户和角色管理功能，包括账户的增删改查以及禁用，角色的增删改查以及禁用。此外，它也为用户提供了便捷的数据库信息查看功能，让用户可以轻松地查看图数据库的基础信息和配置信息。其中，基础信息主要包括版本号、运行时间、CPP编译版本号等，而数据库配置信息则包括端口号、系统功能参数配置等。\n\n#### 2.5.1.账户管理\n\n##### 2.5.1.1.账户管理\n\n###### a.添加账户\n\n在`账户管理`界面点击`添加`按钮创建新的账户，用户需要输入账户名称、账户描述、账户密码以及相关角色。\n\n![账户管理-添加账户按钮](../../../images/browser/account-add-button.png)\n\n- 账户名称：支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n- 相关角色：新建账户时必须要选择一个角色，在账户添加成功后，系统会自动生成一个与账户名称一样的角色。\n\n![账户管理-添加账户](../../../images/browser/account-add.png)\n\n###### b.编辑账户\n\n在`账户管理`界面点击`添加`按钮创建新的账户，用户可以编辑账户描述、账户密码以及相关角色。\n\n![账户管理-编辑账户](../../../images/browser/account-edit.png)\n\n###### c.禁用账户\n\n在`账户管理`界面点击`禁用`按钮禁止对应的账户登录和访问，点击`启用`按钮开启对应的账户登录和访问权限。\n\n![账户管理-禁用](../../../images/browser/account-disable.png)\n![账户管理-启用](../../../images/browser/account-enable.png)\n\n###### d.删除账户\n\n在`账户管理`界面点击`删除`按钮删除对应的账户。\n\n![账户管理-删除](../../../images/browser/account-delete.png)\n\n##### 2.5.1.2.角色管理\n\n###### a.添加角色\n\n在`角色管理`界面点击`添加`按钮创建新的角色，用户需要输入角色名称、角色描述以及图权限。"
            },
            {
                "content": "###### b.编辑账户\n\n在`账户管理`界面点击`添加`按钮创建新的账户，用户可以编辑账户描述、账户密码以及相关角色。\n\n![账户管理-编辑账户](../../../images/browser/account-edit.png)\n\n###### c.禁用账户\n\n在`账户管理`界面点击`禁用`按钮禁止对应的账户登录和访问，点击`启用`按钮开启对应的账户登录和访问权限。\n\n![账户管理-禁用](../../../images/browser/account-disable.png)\n![账户管理-启用](../../../images/browser/account-enable.png)\n\n###### d.删除账户\n\n在`账户管理`界面点击`删除`按钮删除对应的账户。\n\n![账户管理-删除](../../../images/browser/account-delete.png)\n\n##### 2.5.1.2.角色管理\n\n###### a.添加角色\n\n在`角色管理`界面点击`添加`按钮创建新的角色，用户需要输入角色名称、角色描述以及图权限。\n\n![角色管理-添加角色按钮](../../../images/browser/role-add-button.png)\n\n- 角色名称：支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n- 图权限：browser支持全部、读、写和无共四类图权限配置。\n    - 全部：对应图的读和写权限，包含编辑图模型权限（schema）。\n    - 读写：对应图的写权限，不包含编辑图模型权限（schema）。\n    - 只读：对应图的读权限。\n    - 无：无法访问和操作对应图。\n- 角色冲突：当两个角色对同一个图有不同图权限，同时对一个账户授权了这两个角色，该账户对该图的图权限为两个角色的并集。\n\n![角色管理-添加角色](../../../images/browser/role-add.png)\n\n###### b.编辑角色\n\n在`角色管理`界面点击`编辑`按钮编辑已有角色，用户可以编辑角色描述以及图权限。\n\n![角色管理-编辑角色](../../../images/browser/role-edit.png)\n\n###### c.禁用角色"
            },
            {
                "content": "![角色管理-添加角色按钮](../../../images/browser/role-add-button.png)\n\n- 角色名称：支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n- 图权限：browser支持全部、读、写和无共四类图权限配置。\n    - 全部：对应图的读和写权限，包含编辑图模型权限（schema）。\n    - 读写：对应图的写权限，不包含编辑图模型权限（schema）。\n    - 只读：对应图的读权限。\n    - 无：无法访问和操作对应图。\n- 角色冲突：当两个角色对同一个图有不同图权限，同时对一个账户授权了这两个角色，该账户对该图的图权限为两个角色的并集。\n\n![角色管理-添加角色](../../../images/browser/role-add.png)\n\n###### b.编辑角色\n\n在`角色管理`界面点击`编辑`按钮编辑已有角色，用户可以编辑角色描述以及图权限。\n\n![角色管理-编辑角色](../../../images/browser/role-edit.png)\n\n###### c.禁用角色\n\n在`角色管理`界面点击`禁用`按钮禁止对应的角色，点击`启用`按钮开启对应的角色。禁用角色后，对应角色图访问权限失效。\n\n- 禁用角色：禁用之后，对应角色图访问权限失效。\n    - 当一个用户拥有两个角色对同一个图有操作权限时，当禁用其中一个角色时，另一个角色权限同样有效。\n\n![角色管理-禁用](../../../images/browser/role-disable.png)\n![角色管理-启用](../../../images/browser/role-enable.png)\n\n###### d.删除角色\n\n在`角色管理`界面点击`删除`按钮删除对应的角色。\n\n![角色管理-删除](../../../images/browser/role-delete.png)\n\n#### 2.5.2.数据库信息\n\n##### 2.5.2.1.基础信息\n\n`基础信息`获取当前系统运行的状态，并展示关键信息。\n\n![数据库信息-基础信息](../../../images/browser/db_basic.png)"
            },
            {
                "content": "###### c.禁用角色\n\n在`角色管理`界面点击`禁用`按钮禁止对应的角色，点击`启用`按钮开启对应的角色。禁用角色后，对应角色图访问权限失效。\n\n- 禁用角色：禁用之后，对应角色图访问权限失效。\n    - 当一个用户拥有两个角色对同一个图有操作权限时，当禁用其中一个角色时，另一个角色权限同样有效。\n\n![角色管理-禁用](../../../images/browser/role-disable.png)\n![角色管理-启用](../../../images/browser/role-enable.png)\n\n###### d.删除角色\n\n在`角色管理`界面点击`删除`按钮删除对应的角色。\n\n![角色管理-删除](../../../images/browser/role-delete.png)\n\n#### 2.5.2.数据库信息\n\n##### 2.5.2.1.基础信息\n\n`基础信息`获取当前系统运行的状态，并展示关键信息。\n\n![数据库信息-基础信息](../../../images/browser/db_basic.png)\n\n|参数    |含义    |\n|-------|--------|\n|TuGraph版本号|当前TuGraph的版本号，x.x.x|\n|运行时间|TuGraph服务启动到现在的时间|\n|服务器代码版本|tugraph-db仓库的当前commit|\n|前端代码版本|tugraph-web仓库的当前commit|\n|CPP编译器版本号|编译TuGraph时的CPP版本号|\n|Python版本号|编译TuGraph时的Python版本号|\n|CPP编译器ID|编译TuGraph时的CPP类型|\n\n也可以通过命令获取当前系统运行状态。\n\n```\nCALL dbms.system.info()\n```\n\n##### 2.5.2.2.数据库配置信息\n\n`数据库配置信息`获取当前系统运行的配置参数，并展示关键信息。调整配置参数或了解详细配置参数请参考[数据库运行-服务配置](../5.installation&running/7.tugraph-running.md)。\n\n![数据库信息-数据库配置信息](../../../images/browser/db_configuration.png)"
            },
            {
                "content": "| 参数                          | 含义                                 |\n|-----------------------------|------------------------------------|\n| bind_host                   | 系统启动时设置的host，一般为0.0.0.0            |\n| browser.credential_timeout                   | 浏览器缓存的用户名和密码过期时间                   |\n| browser.retain_connection_credentials                   | 浏览器是否缓存用户名和密码                      |\n| disable_auth                | 是否关闭token认证的定期更新，如为true则token可以永久使用 |\n| durable                     | 是否开启存储底层持久化，如为false，数据异步更新到磁盘      |\n| enable_audit_log            | 是否开启审计日志                           |\n| enable_backup_log           | 是否开启实时增量备份                         |\n| enable_fulltext_index       | 是否开启全文索引                           |\n| enable_ha       | 是否开启高可用                            |\n| enable_ip_check             | 是否开启IP白名单                          |\n| enable_rpc                  | 是否开启RPC端口                          |\n| enable_ssl                  | 是否开启ssl加密传输                        |"
            },
            {
                "content": "| enable_audit_log            | 是否开启审计日志                           |\n| enable_backup_log           | 是否开启实时增量备份                         |\n| enable_fulltext_index       | 是否开启全文索引                           |\n| enable_ha       | 是否开启高可用                            |\n| enable_ip_check             | 是否开启IP白名单                          |\n| enable_rpc                  | 是否开启RPC端口                          |\n| enable_ssl                  | 是否开启ssl加密传输                        |\n| optimistic_txn              | 是否开启乐观多线程写入事务                      |\n| port                        | 当前系统的REST访问端口                      |\n| rpc_port                    | RPC 及 HA 服务所用端口                    |\n| subprocess_max_idle_seconds | 自进程最大空闲时间，线程池参数                    |\n| thread_limit                | 服务端同时使用的最大线程数                      |\n| verbose                     | 日志输出信息的详细程度。可设为 0，1，2，值越大则输出信息越详细  |"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/4.user-guide/2.tugraph-browser-legacy.md",
        "chunks": [
            {
                "content": "# 可视化操作手册（旧版）\n\n> 此文档主要介绍 TuGraph Browser 的使用\n\n## 定义\n\nTuGraph Browser 是 TuGraph 提供的可视化开发工具。\n\n## 作用\n\nTuGraph Browser 的主要功能是为使用图数据库的开发人员，提供可视化的图数据开发，图数据管理和维护等功能。\n\n## 操作详情\n\n### 1.连接数据库\n\n当用户完成图数据库的安装后，可以通过浏览器进行访问，TuGraph Browser 工具。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7090。\n\n### 2.登录数据库\n\n![alt 登录](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/1.tugraph-browser-lpgin.png)\n\n- 页面打开成功会，首先进图的是登录页面，用户需要填写账号和密码进行登录。\n- 默认账号：admin\n- 默认密码：73@TuGraph\n- 建议用户登录后，及时修改初始化的密码\n\n### 3.工作台\n\n#### 3.1 快速上手\n\n- 首次登录，系统会默认创建 default 空图\n\n  ![alt 快速上手](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/2.tugraph-browser-quickstart-01.png)\n\n- 用户点击帮助选项，并选择快速上手\n\n  ![alt 帮助](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/3.tugraph-browser-quickstart-02.png)\n\n- 然后点击“一键创建模型”——>\"一键创建数据\"，就可以完成内置的 Movie 数据图谱的构建\n\n#### 3.2 创建子图和示例\n\n##### 3.2.1 创建子图"
            },
            {
                "content": "### 3.工作台\n\n#### 3.1 快速上手\n\n- 首次登录，系统会默认创建 default 空图\n\n  ![alt 快速上手](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/2.tugraph-browser-quickstart-01.png)\n\n- 用户点击帮助选项，并选择快速上手\n\n  ![alt 帮助](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/3.tugraph-browser-quickstart-02.png)\n\n- 然后点击“一键创建模型”——>\"一键创建数据\"，就可以完成内置的 Movie 数据图谱的构建\n\n#### 3.2 创建子图和示例\n\n##### 3.2.1 创建子图\n\n- 点击新建子图\n  ![alt 创建子图](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/4.tugraph-browser-create-subgraph-01.png)\n- 填写表单信息\n  ![alt 填写表单](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/5.tugraph-browser-create-subgraph-02.png)\n  - 子图名称\n  - 子图描述\n  - 配置信息\n  - 点击确认，提示创建成功\n- 切换子图\n  ![alt 切换子图](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/6.tugraph-browser-use-graph-01.png)"
            },
            {
                "content": "##### 3.2.1 创建子图\n\n- 点击新建子图\n  ![alt 创建子图](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/4.tugraph-browser-create-subgraph-01.png)\n- 填写表单信息\n  ![alt 填写表单](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/5.tugraph-browser-create-subgraph-02.png)\n  - 子图名称\n  - 子图描述\n  - 配置信息\n  - 点击确认，提示创建成功\n- 切换子图\n  ![alt 切换子图](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/6.tugraph-browser-use-graph-01.png)\n\n- 点击新建示例\n  ![alt 创建子图](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/3.3.0-image/create-scene-01.png)\n- 选择示例并点击创建\n  ![alt 创建子图](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/3.3.0-image/select-scene.png)\n\n#### 3.3 查询\n\n![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/7.tugraph-browser-query-01.png)\n\n##### 3.3.1 页面组成\n\n- cypher 输入框\n- 结果集展示区域\n\n##### 3.3.2 结果集展示区域功能详情"
            },
            {
                "content": "#### 3.3 查询\n\n![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/7.tugraph-browser-query-01.png)\n\n##### 3.3.1 页面组成\n\n- cypher 输入框\n- 结果集展示区域\n\n##### 3.3.2 结果集展示区域功能详情\n\n- 结果集标签展示及功能\n  ![alt 结果集标签](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/3.3.0-image/tugraph-browser-result.png)\n  - 这里展示了结果集的所有类型统计\n  - 点击不同的“label（标签）”，可以进行以下修改操作\n    - 修改展示颜色\n    - 修改节点大小或边的粗细\n    - 修改默认展示属性或系统属性\n    - 布局修改\n      - 力导布局\n      - 网格布局\n      - 树形布局\n      - 环境布局\n    - 边聚合\n      - 相同类型，方向的边可以进行合并\n    - 创建节点\n      - 点击创建节点按钮\n      - 选择节点类型\n      - 添写节点内容\n    - 创建关系\n      - 在画布中选择起点和终点\n      - 选择可以匹配的类型\n      - 填写节点信息\n    - 停止布局\n      - 当数据量过大，导致浏览器页面卡顿时候，可以点击这个停止布局的按钮，能够提高体验的流畅度\n    - 鼠标悬停\n      - 开启此功能，可以高亮显示鼠标悬停节点的一度邻居节点\n    - 结果集导出\n      - 可以将结果集导出为 png，json，csv 三种不同的文件形式\n    - 刷新\n      - 点击刷新按钮，会重新执行当前页面的初始 cypher 语句，并刷新结果集\n    - 最大化\n      - 点击最大化，结果集展示区域将全屏展示\n    - 结果集展示形式切换\n      - 支持图谱、表格、文本三种形式\n\n##### 3.3.3 建模"
            },
            {
                "content": "##### 3.3.3 建模\n\n- 点边模型\n  ![alt 建模](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/3.3.0-image/create-schema.png)\n- 点边模型支持实时的、增、删、改、查\n\n- 点边模型支持导入和导出\n\n##### 3.3.4 数据导入\n\n- 本地数据导入\n\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/14.tugraph-browser-import-data-01.png)\n\n  - 选择文件编码格式\n  - 选择本地 CSV 文件\n  - 选择对应的节点或边的模型\n  - 进行数据映射\n  - 完成数据导入\n  - 单个文件最大支持2GB\n\n##### 3.3.5 插件\n\n- 存储过程的使用\n\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/15.tugraph-browser-plugin.png)\n\n  - 用户可以上传本地编写的 Plugin 程序，并在可视化页面进行执行，并查看执行结果\n  - 用户可以在可视化对插件进行、卸载、执行、下载等操作\n\n##### 3.3.6 帮助\n\n- 其中记录了 TuGraph-browser 的使用方式\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/16.TuGraph-browser-help.png)\n\n#### 3.4 控制台\n\n##### 3.4.1 数据库基础信息\n\n- 展示数据库相关的基础配置信息\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/17.tugraph-browser-config.png)"
            },
            {
                "content": "- 用户可以上传本地编写的 Plugin 程序，并在可视化页面进行执行，并查看执行结果\n  - 用户可以在可视化对插件进行、卸载、执行、下载等操作\n\n##### 3.3.6 帮助\n\n- 其中记录了 TuGraph-browser 的使用方式\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/16.TuGraph-browser-help.png)\n\n#### 3.4 控制台\n\n##### 3.4.1 数据库基础信息\n\n- 展示数据库相关的基础配置信息\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/17.tugraph-browser-config.png)\n\n##### 3.4.2 权限管理\n\n- 用来创建用户和角色的功能模块，用户可以在这里进行权限的管理操作\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/18.tugraph-browser-auth.png)\n\n##### 3.4.3 实时状态\n\n- 这里展示了数据库实时状态，包括：CPU 使用率、内存用率、磁盘使用率、数据请求次数、磁盘 IO\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/19.tugraph-browser-status.png)\n\n##### 3.4.4 任务管理\n\n- 在这里用户可以看到在正在执行中的任务，可以在此进行停止任务的操作\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/20.tugraph-browser-task.png)\n\n##### 3.4.5 审计日志"
            },
            {
                "content": "##### 3.4.3 实时状态\n\n- 这里展示了数据库实时状态，包括：CPU 使用率、内存用率、磁盘使用率、数据请求次数、磁盘 IO\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/19.tugraph-browser-status.png)\n\n##### 3.4.4 任务管理\n\n- 在这里用户可以看到在正在执行中的任务，可以在此进行停止任务的操作\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/20.tugraph-browser-task.png)\n\n##### 3.4.5 审计日志\n\n- 这里记录的数据库相关的审计日志，用来排查使用遇到的问题\n  ![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/21.tugraph-browser-log.png)"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/5.installation%26running/1.environment.md",
        "chunks": [
            {
                "content": "# 环境准备\n\n> 此文档主要介绍 TuGraph 部署时所需的软硬件环境。\n\n## 1.硬件环境\n\n### 1.1. CPU\nTuGraph 无论是物理、虚拟还是容器化环境，均支持 X86_64 和 ARM64 架构的硬件平台，测试认证过的硬件平台包括 Intel、AMD、Kunpeng、Hygon、飞腾等。\n\n### 1.2. 内存\n\n我们建议内存容量不小于实际的数据大小。如果最求极致的性能，把所有的数据缓存到内存里是最理想的。在数据访问的局部性上，图数据库的局部性要比关系型数据库差，因此如果数据在内存中放不下，通常会频繁地换入换出。\n\n### 1.3. 外存\n我们强烈建议用户使用 NVMe SSD 作为外存，数据库有大量的写操作需要同步的外存，通常为随机写，外存的读写性能很容易成为整体数据库运行的性能瓶颈。因此，高IOPS、低延迟的 NVMe SSD 是最优的选择。\n\n如果现实条件只能使用 SATA接口的SSD，或者云上的网盘，性能虽然会受到影响，但 TuGraph 依然能正确的运行。\n\n外存大小建议为实际数据大小的4倍，比如数据为1TB，则准备4TB的硬盘会比较稳妥。\n\n## 2.软件环境\n\n### 2.1. 操作系统\n\nTuGraph 能够兼容主流操作系统，包括Ubuntu、CentOS、SUSE、银河麒麟、 中标麒麟、UOS等，均通过测试认证。\n\n其中最稳定使用的系统版本是 Ubuntu 18.04、CentOS 7、CentOS 8。\n\n### 2.2. 系统库\n\n编译环境和运行环境对系统库的要求不一样，具体请参考[环境分类](2.environment-mode.md)。\n\n## 3.典型配置推荐\n\n| 硬件      | 最低配置   | 建议配置                   |\n| -------- | --------- | ------------------------ |\n| CPU      | 4 Cores   | 64 Cores                 |\n| 内存      | 4GB       | 512GB                    |\n| 外存      | 100GB     | 2TB NVMe SSD             |\n| OS       | Linux 4.9 | CentOS 7.3               |"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/5.installation%26running/2.environment-mode.md",
        "chunks": [
            {
                "content": "# 环境分类\n\n> 此文档主要介绍 TuGraph 涉及的三种环境。\n\n## 1.分类\n\n根据环境所承载功能的不同，区分为编译环境，运行环境，以及精简运行环境。\n* 编译环境，具备TuGraph编译的所有依赖库，包含运行环境的所有依赖，并且能够编译TuGraph源码，但不包含预编译好的TuGraph可执行文件和库文件，供开发者编译源码使用。\n* 运行环境，具备GCC/Java/Python环境，能够运行TuGraph的所有功能，并且能承载全文索引，java client，c++源码上传为plugin，以及python plugin的完整功能，内置TuGraph预编译好的可执行文件和库文件，供客户直接安装使用，无需编译源码。\n* 精简运行环境，约等于裸系统加预编译TuGraph，仅能运行TuGraph的基本功能，无C++ plugin编译运行，仅so上传，无全文索引，无python plugin，供快速搭建试用。\n\nTuGraph编译后，会把所有的依赖库以.a的形式打包在一起，因此原则上运行不需要的其他的依赖库。但TuGraph支持存储过程，即在服务端编译C++代码，因此在环境中依然需要涉及的编译器。\n\n## 2.依赖系统库\n\n针对三种环境，除去TuGraph的运行包，所需要的系统库如下：\n* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。\n* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。\n* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/5.installation%26running/3.docker-deployment.md",
        "chunks": [
            {
                "content": "# Docker部署\n\n>本文档介绍TuGraph Compile及TuGraph Runtime的Docker镜像的创建、下载。\n\n## 1.简介\n\n- TuGraph Compile Image：提供编译环境，可以用于TuGraph的编译，测试；\n- TuGraph Runtime Image：提供二进制可运行环境，附带TuGraph库和可执行文件；\n- TuGraph Mini Runtime Image: 提供二进制可运行环境，不包含TuGraph中Java、Python相关的功能，无C++ plugin编译运行，仅so上传。\n\n## 2.现有Docker Image\n\n### 2.1.镜像下载方式\n\n镜像托管在[DockerHub]( https://hub.docker.com/u/tugraph )，可直接下载使用。\n\n最新版本的Docker地址参见 [文档地图](../../1.guide.md)的\"TuGraph最新版本\"章节。\n\n### 2.2.命名规范\n\n#### 2.2.1.TuGraph Compile Image\n\n提供编译环境，可以用于TuGraph的编译。\n\n`tugraph/tugraph-compile-[os name & version]:[tugraph compile version]`\n\n例如： `tugraph/tugraph-compile-centos7:1.2.0`\n\n#### 2.2.2.TuGraph Runtime Image\n\n提供二进制可运行环境，附带TuGraph库和可执行文件。\n\n`tugraph/tugraph-runtime-[os name & version]:[tugraph-runtime version]`\n\n例如：`tugraph/tugraph-runtime-centos7:3.4.0`\n\n#### 2.2.3.TuGraph Mini Runtime Image\n\n提供二进制可运行环境，不包含TuGraph种Java、Python相关的功能，无C++ plugin编译运行，仅so上传。\n\n`tugraph/tugraph-mini-runtime-[os name & version]:[tugraph-runtime version]`"
            },
            {
                "content": "提供编译环境，可以用于TuGraph的编译。\n\n`tugraph/tugraph-compile-[os name & version]:[tugraph compile version]`\n\n例如： `tugraph/tugraph-compile-centos7:1.2.0`\n\n#### 2.2.2.TuGraph Runtime Image\n\n提供二进制可运行环境，附带TuGraph库和可执行文件。\n\n`tugraph/tugraph-runtime-[os name & version]:[tugraph-runtime version]`\n\n例如：`tugraph/tugraph-runtime-centos7:3.4.0`\n\n#### 2.2.3.TuGraph Mini Runtime Image\n\n提供二进制可运行环境，不包含TuGraph种Java、Python相关的功能，无C++ plugin编译运行，仅so上传。\n\n`tugraph/tugraph-mini-runtime-[os name & version]:[tugraph-runtime version]`\n\n例如： `tugraph/tugraph-mini-runtime-centos7:3.4.0`\n\n### 2.3.常见Docker操作\n\nDocker由Dockerfile生成，注意创建镜像需要下载依赖，因此网络问题可能会导致创建较慢或者创建失败。注意不要覆盖镜像，除非tag为 `latest`。\n\n创建Compile镜像\n```bash\ndocker build -f tugraph-compile-centos7-Dockerfile -t tugraph/tugraph-compile-centos7:1.2.0 .\n```\n\n创建Runtime / Mini Runtine镜像\n```bash\ndocker build --build-arg FILEPATH=\"${rpm_path_in_oss}\" --build-arg FILENAME=\"${rpm_name}\" -f tugraph-compile-centos7-Dockerfile -t tugraph/tugraph-runtime-centos7:1.2.0 .\n```"
            },
            {
                "content": "例如： `tugraph/tugraph-mini-runtime-centos7:3.4.0`\n\n### 2.3.常见Docker操作\n\nDocker由Dockerfile生成，注意创建镜像需要下载依赖，因此网络问题可能会导致创建较慢或者创建失败。注意不要覆盖镜像，除非tag为 `latest`。\n\n创建Compile镜像\n```bash\ndocker build -f tugraph-compile-centos7-Dockerfile -t tugraph/tugraph-compile-centos7:1.2.0 .\n```\n\n创建Runtime / Mini Runtine镜像\n```bash\ndocker build --build-arg FILEPATH=\"${rpm_path_in_oss}\" --build-arg FILENAME=\"${rpm_name}\" -f tugraph-compile-centos7-Dockerfile -t tugraph/tugraph-runtime-centos7:1.2.0 .\n```\n\n修改镜像名称\n```bash\ndocker tag ${image_name}:${image_tag} tugraph/tugraph-runtime-centos7:3.3.0\n```\n\n上传镜像\n```bash\ndocker push tugraph/tugraph-compile-centos7:1.2.0 .\n```\n\n获取镜像\n```bash\ndocker pull tugraph/tugraph-compile-centos7:1.2.0\n```\n\n导出镜像\n```bash\ndocker save ${image_name}:${image_tag} | gzip > lgraph_latest.tar.gz\n```\n\n导入镜像\n```bash\ndocker load --input lgraph_latest.tar.gz\n```\n\n其他Docker操作请参考[docker官方文档](https://docs.docker.com/engine/reference/commandline/cli )\n\n\n### 2.4. M1芯片支持"
            },
            {
                "content": "修改镜像名称\n```bash\ndocker tag ${image_name}:${image_tag} tugraph/tugraph-runtime-centos7:3.3.0\n```\n\n上传镜像\n```bash\ndocker push tugraph/tugraph-compile-centos7:1.2.0 .\n```\n\n获取镜像\n```bash\ndocker pull tugraph/tugraph-compile-centos7:1.2.0\n```\n\n导出镜像\n```bash\ndocker save ${image_name}:${image_tag} | gzip > lgraph_latest.tar.gz\n```\n\n导入镜像\n```bash\ndocker load --input lgraph_latest.tar.gz\n```\n\n其他Docker操作请参考[docker官方文档](https://docs.docker.com/engine/reference/commandline/cli )\n\n\n### 2.4. M1芯片支持\n\n在 M1 芯片的机器上运行 amd64 容器可能造成未知错误。TuGraph提供 arm64 的镜像供 M1 机器使用。\n包含compile和runtime两种镜像。\n\n在`tugraph-runtime-centos7:3.6.0`与`tugraph-compile-centos7:1.2.7`及之后，`tugraph-runtime-centos7`与`tugraph-compile-centos7`提供linux/amd64和linux/arm64/v8两种架构的镜像，可以在 M1 机器上通过docker pull获取arm64架构镜像。\n\n### 2.5. 运行服务\n\n1. 拉取镜像\n   ```shell\n   docker pull tugraph/tugraph-runtime-centos7:${VERSION}\n   ```\n\n2. 启动docker"
            },
            {
                "content": "其他Docker操作请参考[docker官方文档](https://docs.docker.com/engine/reference/commandline/cli )\n\n\n### 2.4. M1芯片支持\n\n在 M1 芯片的机器上运行 amd64 容器可能造成未知错误。TuGraph提供 arm64 的镜像供 M1 机器使用。\n包含compile和runtime两种镜像。\n\n在`tugraph-runtime-centos7:3.6.0`与`tugraph-compile-centos7:1.2.7`及之后，`tugraph-runtime-centos7`与`tugraph-compile-centos7`提供linux/amd64和linux/arm64/v8两种架构的镜像，可以在 M1 机器上通过docker pull获取arm64架构镜像。\n\n### 2.5. 运行服务\n\n1. 拉取镜像\n   ```shell\n   docker pull tugraph/tugraph-runtime-centos7:${VERSION}\n   ```\n\n2. 启动docker\n\n   ```shell\n    docker run -d -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \\\n    --name tugraph_demo ${REPOSITORY}:${VERSION}\n   \n   # ${REPOSITORY}是镜像地址，${VERSION}是版本号。\n   # 7070是默认的http端口，访问tugraph-db-browser使用。   \n   # 7687是bolt端口，bolt client访问使用。\n   # 9090是默认的rpc端口，rpc client访问使用。\n   # /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录\n   # 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。\n   ```"
            },
            {
                "content": "```shell\n    docker run -d -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \\\n    --name tugraph_demo ${REPOSITORY}:${VERSION}\n   \n   # ${REPOSITORY}是镜像地址，${VERSION}是版本号。\n   # 7070是默认的http端口，访问tugraph-db-browser使用。   \n   # 7687是bolt端口，bolt client访问使用。\n   # 9090是默认的rpc端口，rpc client访问使用。\n   # /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录\n   # 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。\n   ```\n\n## 3. 使用和开发TuGraph-DB Docker镜像时的最佳实践\n\n在您刚开始为TuGraph做出贡献时，请仔细阅读以下要点，并遵循它们。\n\n- 为了避免过多的Docker Layer，请尽量像现有的Dockerfile一样单行的写ENV和RUN将您的依赖项添加到Docker中。\n- 对于您需要构建依赖项的软件包/资源，请使用原始的软件包/资源，而不是在没有VCS跟踪的情况下修改这些资源。之后联系TuGraph团队将其上传到OSS以加速构建过程，如同您在Dockerfiles中看到的URL一样。\n- 为了使开发更加高效，最好从Base TuGraph编译镜像添加依赖项开始，完成开发确认依赖没问题后在Dockerfile中重新复制该过程。\n- CI使用了Docker镜像。如果您的CI失败，请检查依赖项问题。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/5.installation%26running/4.local-package-deployment.md",
        "chunks": [
            {
                "content": "# 本地包部署\n\n> 此文档主要介绍 TuGraph 的本地包部署。\n\n## 1. 环境准备\n\nTuGraph本地包部署需要对应的环境，快速验证可以使用精简安装包，几乎不需要任何第三方库。\n\n如果您需要使用完整的TuGraph功能，请参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile，该脚本包含完整的环境构建流程。\n\n## 2. 安装包下载\n\n最新版本的安装包地址参见 [文档地图](../../1.guide.md)的\"TuGraph最新版本\"章节。\n\n也可以访问Github进行下载：[TuGraph Release](https://github.com/TuGraph-family/tugraph-db/releases)\n\n## 3. CentOS 下的安装方法\n\n用于在 CentOS 上安装的 TuGraph 的.rpm 安装包，其中包含了 TuGraph 可执行文件以及编写嵌入式程序和存储过程所需的头文件和相关库文件。\n\n使用已经下载完成的`tugraph_x.y.z.rpm 安装包在终端下安装，只需要运行以下命令：\n\n```shell\n$ rpm -ivh tugraph-x.y.z.rpm\n```\n\n用户也可以通过指定`--prefix`选项指定安装目录。\n\n## 4. Ubuntu 下的安装方法\n\n用于在 Ubuntu 上安装的 TuGraph 的.deb 安装包，其中包含了 TuGraph 可执行文件以及编写嵌入式程序和存储过程所需的头文件和相关库文件。\n\n使用已经下载完成的`tugraph_x.y.z.deb`安装包在终端下安装，只需要运行以下命令：\n\n```shell\n$ sudo dpkg -i tugraph-x.y.z.deb\n```\n\n该命令默认将 TuGraph 安装于`/usr/local`目录下。用户也可以通过指定 `--instdir=` 选项更改安装目录。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/5.installation%26running/5.cloud-deployment.md",
        "chunks": [
            {
                "content": "# 云部署\n\n> 此文档主要介绍 TuGraph 的云部署，也可参见[阿里云计算巢部署文档]( https://aliyun-computenest.github.io/quickstart-tugraph/ )。\n\n## 1.简介\n\nTuGraph（tugraph.antgroup.com）是蚂蚁集团研发的高性能图数据库（Graph Database）。TuGraph在计算巢上提供了社区版服务，您无需自行购置云主机，即可在计算巢上快速部署TuGraph服务、实现运维监控，从而搭建您自己的图应用。本文向您介绍如何开通计算巢上的TuGraph社区版服务，以及部署流程和使用说明。\n\n## 2.实例说明\n\nTuGraph部署的为社区开源版本，源码参考Github Repo，目前可以选择的实例规格如下：\n\n| 规格族         | vCPU与内存                 | 系统盘              | 公网带宽      |\n|----------------|-------------------------|-------------------|-----------|\n| ecs.r7a.xlarge | AMD 内存型 r7a，4vCPU 32GiB | ESSD云盘 200GiB PL0 | 固定带宽1Mbps |\n| ecs.r6.xlarge  | 内存型r6，4vCPU 32GiB       | ESSD云盘 200GiB PL0 | 固定带宽1Mbps |\n\n预估费用在创建实例时可实时看到（目前为免费）。 如需更多规格、其他服务（如集群高可用性要求、企业级支持服务等），请联系我们 tugraph@service.alipay.com。\n\n## 3.部署流程\n\n### 3.1.准备工作\n\n在正式开始使用前，您需要一个阿里云账号，对ECS、VPC等资源进行访问和创建操作。\n\n- 若您使用个人账号，可以直接创建服务实例\n- 若您使用RAM用户创建服务实例，且是第一次使用阿里云计算巢\n    - 需要在创建服务实例前，对使用的RAM用户的账号添加相应资源的权限。添加RAM权限的详细操作，请参见为 __RAM用户授权__。所需权限如下表所示。\n    - 且需要授权创建关联角色，参考下图，选中 __同意授权并创建关联角色__"
            },
            {
                "content": "预估费用在创建实例时可实时看到（目前为免费）。 如需更多规格、其他服务（如集群高可用性要求、企业级支持服务等），请联系我们 tugraph@service.alipay.com。\n\n## 3.部署流程\n\n### 3.1.准备工作\n\n在正式开始使用前，您需要一个阿里云账号，对ECS、VPC等资源进行访问和创建操作。\n\n- 若您使用个人账号，可以直接创建服务实例\n- 若您使用RAM用户创建服务实例，且是第一次使用阿里云计算巢\n    - 需要在创建服务实例前，对使用的RAM用户的账号添加相应资源的权限。添加RAM权限的详细操作，请参见为 __RAM用户授权__。所需权限如下表所示。\n    - 且需要授权创建关联角色，参考下图，选中 __同意授权并创建关联角色__\n\n| 权限策略名称                    | 备注                                    |\n|---------------------------------|---------------------------------------|\n| AliyunECSFullAccess             | 管理云服务器服务（ECS）的权限             |\n| AliyunVPCFullAccess             | 管理专有网络（VPC）的权限                 |\n| AliyunROSFullAccess             | 管理资源编排服务（ROS）的权限             |\n| AliyunComputeNestUserFullAccess | 管理计算巢服务（ComputeNest）的用户侧权限 |\n| AliyunCloudMonitorFullAccess    | 管理云监控（CloudMonitor）的权限          |\n\n![同意授权并创建关联角色](../../../images/cloud-deployment-1.png)\n\n### 3.2.部署入口\n\n您可以在阿里云计算巢自行搜索，也可以通过下述部署链接快速到达。"
            },
            {
                "content": "![同意授权并创建关联角色](../../../images/cloud-deployment-1.png)\n\n### 3.2.部署入口\n\n您可以在阿里云计算巢自行搜索，也可以通过下述部署链接快速到达。\n\n[部署链接](https://computenest.console.aliyun.com/user/cn-hangzhou/serviceInstanceCreate?ServiceId=service-7b50ea3d20e643da95bf&&isTrial=true)\n\n### 3.3.申请试用\n\n在正式试用前，需要申请试用，按照提示填写信息，在审核通过后就可以创建TuGraph服务。\n\n![申请试用](../../../images/cloud-deployment-2.png)\n\n### 3.4.创建TuGraph服务\n\n#### 3.4.1.参数列表\n\n您在创建服务实例的过程中，需要配置服务实例信息的参数列表，具体如下。"
            },
            {
                "content": "#### 3.4.1.参数列表\n\n您在创建服务实例的过程中，需要配置服务实例信息的参数列表，具体如下。\n\n| 参数组               | 参数项   | 示例          | 说明                                                           |\n|--------------------|----------|---------------|--------------------------------------------------------------|\n| 服务实例名称         | N/A      | test          | 实例的名称                                                     |\n| 地域                 | N/A      | 华东1（杭州）   | 选中服务实例的地域，建议就近选中，以获取更好的网络延时。          |\n| 付费类型配置         | 付费类型 | 按量付费      | 免费使用请选用按量付费                                         |\n| 可用区配置           | 部署区域 | 可用区I       | 地域下的不同可用区域，确保实例非空                              |\n| 选择已有基础资源配置 | VPC ID   | vpc-xxx       | 按实际情况，选择专有网络的ID。                                   |\n| 选择已有基础资源配置 | 交换机ID | vsw-xxx       | 按实际情况，选择交换机ID。若找不到交换机, 可尝试切换地域和可用区 |\n| ECS实例配置          | 实例类型 | ecs.r6.xlarge | 当前支持ecs.r6.xlarge和ecs.r7a.xlarge规格                      |\n|ECS实例配置|\t实例密码|\t**|\t设置实例密码。长度8~30个字符，必须包含三项（大写字母、小写字母、数字、 ()`~!@#$%^&*_-+={}[]:;'<>,.?/ 中的特殊符号）。|"
            },
            {
                "content": "#### 3.4.2.具体步骤\n\n创建服务按如下步骤进行，参考下图：\n\n- 创建实例名称，如下图中“test”\n- 选择地域，如下图中“华东1（杭州）”\n\n![创建实例](../../../images/cloud-deployment-3.png)\n\n- 选择实例类型，当前支持ecs.r6.xlarge和ecs.r7a.xlarge规格。如果列表中无机型可选，请尝试选择其他的部署区域\n- 选中机型\n- 配置实例的密码\n- 选择部署区域，如下图中“可用区I”\n\n![选择区域](../../../images/cloud-deployment-4.png)\n\n- 点击下一步，进入订单确认页面\n- 勾选“权限确认”和“服务条款”中的复选框\n- 点击左下角绿色背景的开始免费试用，即可创建服务实例\n\n![确认](../../../images/cloud-deployment-5.png)\n\n### 3.5.启动TuGraph服务\n\n- 查看服务实例：服务实例创建成功后，部署时间大约需要2分钟。部署完成后，页面上可以看到对应的服务实例，如下图\n\n![查看实例](../../../images/cloud-deployment-6.png)\n\n- 点击该服务实例访问TuGraph。进入到对应的服务实例后，可以在页面上获取到web、rpc、ssh共3种使用方式，并且页面上展示了admin用户的密码\n\n![访问方式](../../../images/cloud-deployment-7.png)\n\n- 点击web的链接，即可跳转访问已经部署好的TuGraph Web。建议新手先通过TuGraph Web，快速使用demo上手。\n    - 首先在TuGraph Web的登录页面上，输入默认用户名admin和页面上展示的admin用户的密码进行登录，参考下图\n    - 登录完成后，选择任意一个带有官方图标的图项目，其中内置了demo数据，开启图数据的探索和发现！\n\n![登录](../../../images/cloud-deployment-8.png)\n![创建demo](../../../images/cloud-deployment-9.png)\n\n## 4.常见FAQ\n\n### 问题一：部署区域无可用资源\n\n有时，所选部署区域（如可用区G）没有所选套餐的可用资源，会报错如下图所示"
            },
            {
                "content": "- 点击该服务实例访问TuGraph。进入到对应的服务实例后，可以在页面上获取到web、rpc、ssh共3种使用方式，并且页面上展示了admin用户的密码\n\n![访问方式](../../../images/cloud-deployment-7.png)\n\n- 点击web的链接，即可跳转访问已经部署好的TuGraph Web。建议新手先通过TuGraph Web，快速使用demo上手。\n    - 首先在TuGraph Web的登录页面上，输入默认用户名admin和页面上展示的admin用户的密码进行登录，参考下图\n    - 登录完成后，选择任意一个带有官方图标的图项目，其中内置了demo数据，开启图数据的探索和发现！\n\n![登录](../../../images/cloud-deployment-8.png)\n![创建demo](../../../images/cloud-deployment-9.png)\n\n## 4.常见FAQ\n\n### 问题一：部署区域无可用资源\n\n有时，所选部署区域（如可用区G）没有所选套餐的可用资源，会报错如下图所示\n\n![部署区域错误](../../../images/cloud-deployment-10.png)\n\n__解决办法__：尝试选择其他区域，如可用区I等\n\n### 问题二: 启动后web访问不通\n\nweb的启动需要一点点时间，请稍后刷新页面即可。\n\n### 问题三: 登录时的用户名密码不正确\n\n请注意检查，登录时使用的密码应为详情页面展示的密码。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/5.installation%26running/6.compile.md",
        "chunks": [
            {
                "content": "# 从源码编译\n\n> 本文档主要描述 TuGraph 从源码进行编译。\n\n## 1.前置条件\n\n推荐在linux系统下搭建TuGraph。同时docker环境是个不错的选择,如果你想设置一个新的环境，请参考[Dockerfile](3.docker-deployment.md)。\n\n## 2.编译介绍\n\n以下是编译TuGraph的步骤：\n\n1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤\n2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`，如果在arm机器编译（如M1芯片的Mac中，需要加上` -DENABLE_BUILD_ON_AARCH64=ON`）\n3. `make`\n4. `make package` 或者 `cpack --config CPackConfig.cmake`\n\n示例：`tugraph/tugraph-compile-centos7`Docker环境\n\n```bash\n$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git\n$ cd tugraph-db\n$ deps/build_deps.sh\n$ mkdir build && cd build\n$ cmake .. -DOURSYSTEM=centos7\n$ make\n$ make package\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/5.installation%26running/7.tugraph-running.md",
        "chunks": [
            {
                "content": "# 数据库运行\n\n> 本文档主要描述 TuGraph 服务的运行模式、启动、停止和重启的操作,以及 TuGraph 的服务配置参数、配置文件格式和命令行配置参数。\n\n## 1.前置条件\n\nTuGraph 运行的前置条件为 TuGraph 正确安装，参考[安装流程](1.environment.md)。\n\nTuGraph 运行需要保证库文件 liblgraph.so 的文件位置在环境变量 LD_LIBRARY_PATH。\n\n运行 TuGraph 进程的用户不需要超级权限，但需要对配置文件（一般为lgraph.json）及文件中涉及的文件有读权限，并且对数据文件夹、日志文件夹等有写权限。\n\n## 2.运行模式\n\nTuGraph 可以作为前台普通进程启动，也可以作为后台守护进程启动。\n当作为普通进程运行时，TuGraph 可以直接将日志打印到终端，这在调试服务器配置时非常方便。但是，由于前台进程在终端退出后被终止，因此用户须确保在 TuGraph 服务器处于运行状态时，终端保持打开状态。另一方面，在守护进程模式下，即使启动它的终端退出，TuGraph 服务器也可以继续运行。因此，在长时间运行的服务器下推荐以守护进程模式启动 TuGraph 服务器。\n\n### 2.1.运行普通进程\n\n`lgraph_server -d run`命令可以将 TuGraph 作为普通进程运行。普通进程依赖命令行终端，因此终端结束时，TuGraph 进程也会自动终止。普通进程模式配合`--log_dir \"\"`可以将进程日志直接输出到终端，因此更方便调试。注：当不使用`-d run`命令时，将默认运行普通进程。\n\nlgraph_server的默认路径为：/usr/local/bin/lgraph_server 。\n\nlgraph.json的默认路径为：/usr/local/etc/lgraph.json 。\n\n启动命令：\n\n```shell\n$ ./lgraph_server -d run -c lgraph.json --log_dir \"\"\n```\n或者：\n```shell\n$ ./lgraph_server -c lgraph.json --log_dir \"\"\n```\n\n普通模式的运行输出示例："
            },
            {
                "content": "```shell\n**********************************************************************\n*                  TuGraph Graph Database v4.3.2                     *\n*                                                                    *\n*    Copyright(C) 2018-2023 Ant Group. All rights reserved.          *\n*                                                                    *\n**********************************************************************\nServer is configured with the following parameters:\n  Backup log enable:                   0\n  DB directory:                        /var/lib/lgraph/data\n  HA enable:                           0\n  HTTP port:                           7070\n  HTTP web dir:                        /usr/local/share/lgraph/browser-resource\n  RPC enable:                          1\n  RPC port:                            9090\n  SSL enable:                          0\n  Whether the token is unlimited:      0\n  audit log enable:                    0\n  bind host:                           0.0.0.0"
            },
            {
                "content": "DB directory:                        /var/lib/lgraph/data\n  HA enable:                           0\n  HTTP port:                           7070\n  HTTP web dir:                        /usr/local/share/lgraph/browser-resource\n  RPC enable:                          1\n  RPC port:                            9090\n  SSL enable:                          0\n  Whether the token is unlimited:      0\n  audit log enable:                    0\n  bind host:                           0.0.0.0\n  bolt port:                           7687\n  disable auth:                        0\n  durable:                             0\n  log dir:                             \"\"\n  log verbose:                         1\n  number of bolt io threads:           1\n  optimistic transaction:              0\n  reset admin password if you forget:  0\n  subprocess idle limit:               600\n  thread limit:                        0"
            },
            {
                "content": "audit log enable:                    0\n  bind host:                           0.0.0.0\n  bolt port:                           7687\n  disable auth:                        0\n  durable:                             0\n  log dir:                             \"\"\n  log verbose:                         1\n  number of bolt io threads:           1\n  optimistic transaction:              0\n  reset admin password if you forget:  0\n  subprocess idle limit:               600\n  thread limit:                        0\n[20240730 15:34:27.848783 0x00007f81bb3889c0 INFO  src/server/lgraph_server.h:78] [StateMachine] Builtin services are disabled according to ServerOptions.has_builtin_services\n[20240730 15:34:27.849116 0x00007f81bb3889c0 INFO  src/server/lgraph_server.cpp:268] Listening for RPC on port 9090\n[20240730 15:34:27.868819 0x00007f81bb3889c0 INFO  src/restful/server/rest_server.cpp:479] Listening for REST on port 7070\n[20240730 15:34:27.869970 0x00006e7d435ff700 INFO  src/server/bolt_server.cpp:36] bolt server run"
            },
            {
                "content": "[20240730 15:34:27.848783 0x00007f81bb3889c0 INFO  src/server/lgraph_server.h:78] [StateMachine] Builtin services are disabled according to ServerOptions.has_builtin_services\n[20240730 15:34:27.849116 0x00007f81bb3889c0 INFO  src/server/lgraph_server.cpp:268] Listening for RPC on port 9090\n[20240730 15:34:27.868819 0x00007f81bb3889c0 INFO  src/restful/server/rest_server.cpp:479] Listening for REST on port 7070\n[20240730 15:34:27.869970 0x00006e7d435ff700 INFO  src/server/bolt_server.cpp:36] bolt server run\n[20240730 15:34:27.870040 0x00007f81bb3889c0 INFO  src/server/lgraph_server.cpp:302] Server started.\n```"
            },
            {
                "content": "普通进程模式下，用户可以通过按 `CTRL+C` 来提前终止 TuGraph 进程。\n\n### 2.2.运行进程守护模式\n\n启动命令：\n\n```shell\n$ ./lgraph_server -d start -c lgraph.json\n```\n\n守护模式的运行输出示例：\n\n```shell\nStarting lgraph...\nThe service process is started at pid 12109.\n```\n\n此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。\n\n## 3.服务操作\n\n### 3.1.启动服务\n\nTuGraph 需要通过 `lgraph_server -d start` 命令行启动，启动命令示例如下：\n\n```bash\n$ ./lgraph_server -d start -c lgraph.json\nStarting lgraph...\nThe service process is started at pid 12109.\n```\n\n此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。\n\n### 3.2.停止服务\n\n用户可以使用`kill`命令以及`lgraph_server -d stop`命令停止 TuGraph 守护进程。由于可能在同一台计算机上运行多个 TuGraph 服务器进程，因此我们使用`.pid`文件区分不同的服务器进程，该文件写入启动该进程的工作目录。因此，需要在相同工作目录中运行`lgraph_server-d stop`命令，以停止正确的服务器进程。\n\n```shell\nuser@host:~/tugraph$ ./lgraph_server -d start -c lgraph.json\n20200508122306.378: Starting lgraph...\n20200508122306.379: The service process is started at pid 93.\n\nuser@host:~/tugraph$ cat ./lgraph.pid\n93"
            },
            {
                "content": "此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。\n\n### 3.2.停止服务\n\n用户可以使用`kill`命令以及`lgraph_server -d stop`命令停止 TuGraph 守护进程。由于可能在同一台计算机上运行多个 TuGraph 服务器进程，因此我们使用`.pid`文件区分不同的服务器进程，该文件写入启动该进程的工作目录。因此，需要在相同工作目录中运行`lgraph_server-d stop`命令，以停止正确的服务器进程。\n\n```shell\nuser@host:~/tugraph$ ./lgraph_server -d start -c lgraph.json\n20200508122306.378: Starting lgraph...\n20200508122306.379: The service process is started at pid 93.\n\nuser@host:~/tugraph$ cat ./lgraph.pid\n93\n\nuser@host:~/tugraph$ ./lgraph_server -d stop -c lgraph.json\n20200508122334.857: Stopping lgraph...\n20200508122334.857: Process stopped.\n```\n\n### 3.3.重启服务\n\n用户也可以通过`lgraph_server -d restart`来重启 TuGraph 服务：\n\n```bash\n$ ./lgraph_server -d restart\nStopping lgraph...\nProcess stopped.\nStarting lgraph...\nThe service process is started at pid 20899.\n```\n\n### 3.4.新旧前端切换"
            },
            {
                "content": "user@host:~/tugraph$ cat ./lgraph.pid\n93\n\nuser@host:~/tugraph$ ./lgraph_server -d stop -c lgraph.json\n20200508122334.857: Stopping lgraph...\n20200508122334.857: Process stopped.\n```\n\n### 3.3.重启服务\n\n用户也可以通过`lgraph_server -d restart`来重启 TuGraph 服务：\n\n```bash\n$ ./lgraph_server -d restart\nStopping lgraph...\nProcess stopped.\nStarting lgraph...\nThe service process is started at pid 20899.\n```\n\n### 3.4.新旧前端切换\n\n进入容器，可以通过修改配置文件\"/usr/local/etc/lgraph.json\"中的\"web\"参数来选择使用老版本或新版本的前端。对于老版本，可以将\"web\"的值设为\"/usr/local/share/lgraph/resource\"；对于新版本，可以将\"web\"的值设为\"/usr/local/share/lgraph/browser-resource\"。完成配置文件的修改后，请执行命令 `docker restart tugraph` 以使更改生效。需要注意的是，新版本是默认选项。\n\n## 4.服务配置\n\nTuGraph 服务器在启动时从配置文件和命令行选项加载配置，如果在配置文件和命令行中同一选项指定了不同的值，将优先使用命令行中指定的值。\n\n### 4.1.配置参数\n\n具体参数及其类型描述如下："
            },
            {
                "content": "| **参数名**                      | **参数类型** | **参数说明**                                                                                                                                                                          |\n|------------------------------|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| directory                    | 字符串                   | 数据文件所在目录。如果目录不存在 ，则自动创建。默认目录为 /var/lib/lgraph/data。                                                                                                                               |\n| durable                      | 布尔值                   | 是否开启实时持久化。关闭持久化可以减少写入时的磁盘 IO 开销，但是在机器断电等极端情况下可能丢失数据。默认值为 `true`。                                                                                                                  |"
            },
            {
                "content": "| directory                    | 字符串                   | 数据文件所在目录。如果目录不存在 ，则自动创建。默认目录为 /var/lib/lgraph/data。                                                                                                                               |\n| durable                      | 布尔值                   | 是否开启实时持久化。关闭持久化可以减少写入时的磁盘 IO 开销，但是在机器断电等极端情况下可能丢失数据。默认值为 `true`。                                                                                                                  |\n| host                         | 字符串                   | REST 服务器监听时使用的地址，一般为服务器的 IP 地址。默认地址为 0.0.0.0。注：在HA模式下，host需要设置为对应服务器的IP地址，不能设置为0.0.0.0。                                                                                           |\n| port                         | 整型                    | REST 服务器监听时使用的端口。默认端口为 7070。                                                                                                                                                      |"
            },
            {
                "content": "| host                         | 字符串                   | REST 服务器监听时使用的地址，一般为服务器的 IP 地址。默认地址为 0.0.0.0。注：在HA模式下，host需要设置为对应服务器的IP地址，不能设置为0.0.0.0。                                                                                           |\n| port                         | 整型                    | REST 服务器监听时使用的端口。默认端口为 7070。                                                                                                                                                      |\n| enable_rpc                   | 布尔值                   | 是否使用 RPC 服务。默认值为 false。                                                                                                                                                           |\n| rpc_port                     | 整型                    | RPC 及 HA 服务所用端口。默认端口为 9090。                                                                                                                                                       |"
            },
            {
                "content": "| enable_rpc                   | 布尔值                   | 是否使用 RPC 服务。默认值为 false。                                                                                                                                                           |\n| rpc_port                     | 整型                    | RPC 及 HA 服务所用端口。默认端口为 9090。                                                                                                                                                       |\n| bolt_port                    | 整型                    | Bolt 客户端端口。默认端口为 7687。                                                                                                                                                            |\n| enable_ha                    | 布尔值                   | 是否启动高可用模式。默认值为 false。                                                                                                                                                             |"
            },
            {
                "content": "| bolt_port                    | 整型                    | Bolt 客户端端口。默认端口为 7687。                                                                                                                                                            |\n| enable_ha                    | 布尔值                   | 是否启动高可用模式。默认值为 false。                                                                                                                                                             |\n| ha_log_dir                   | 字符串                   | HA 日志所在目录，需要启动 HA 模式。默认值为空。                                                                                                                                                       |\n| verbose                      | 整型                    | 日志输出信息的详细程度。可设为 0，1，2，值越大则输出信息越详细。默认值为 1。                                                                                                                                         |"
            },
            {
                "content": "| ha_log_dir                   | 字符串                   | HA 日志所在目录，需要启动 HA 模式。默认值为空。                                                                                                                                                       |\n| verbose                      | 整型                    | 日志输出信息的详细程度。可设为 0，1，2，值越大则输出信息越详细。默认值为 1。                                                                                                                                         |\n| log_dir                      | 字符串                   | 日志文件所在的目录。默认目录为 /var/log/lgraph/。                                                                                                                                                 |\n| ssl_auth                     | 布尔值                   | 是否使用 SSL 安全认证。当开启时，REST 服务器只开启 HTTPS 服务。默认值为 false。                                                                                                                               |"
            },
            {
                "content": "| log_dir                      | 字符串                   | 日志文件所在的目录。默认目录为 /var/log/lgraph/。                                                                                                                                                 |\n| ssl_auth                     | 布尔值                   | 是否使用 SSL 安全认证。当开启时，REST 服务器只开启 HTTPS 服务。默认值为 false。                                                                                                                               |\n| web                          | 字符串                   | Web 文件（包括可视化组件）的存储位置，默认设置在 /usr/local/share/lgraph/browser-resource 目录下。而对于之前的老版本，该目录则位于 /usr/local/share/lgraph/resource 。                                                       |\n| server_cert                  | 字符串                   | 在 SSL 认证开启时，服务器所使用的 certificate 文件路径。默认路径为 /usr/local/etc/lgraph/server-cert.pem。                                                                                                 |"
            },
            {
                "content": "| web                          | 字符串                   | Web 文件（包括可视化组件）的存储位置，默认设置在 /usr/local/share/lgraph/browser-resource 目录下。而对于之前的老版本，该目录则位于 /usr/local/share/lgraph/resource 。                                                       |\n| server_cert                  | 字符串                   | 在 SSL 认证开启时，服务器所使用的 certificate 文件路径。默认路径为 /usr/local/etc/lgraph/server-cert.pem。                                                                                                 |\n| server_key                   | 字符串                   | 在 SSL 认证开启时，服务器所使用的公钥文件。默认目录为 /usr/local/etc/lgraph/server-key.pem。                                                                                                               |\n| enable_audit_log             | 布尔值                   | 是否启用审计日志，默认值为 false。                                                                                                                                                              |"
            },
            {
                "content": "| server_key                   | 字符串                   | 在 SSL 认证开启时，服务器所使用的公钥文件。默认目录为 /usr/local/etc/lgraph/server-key.pem。                                                                                                               |\n| enable_audit_log             | 布尔值                   | 是否启用审计日志，默认值为 false。                                                                                                                                                              |\n| audit_log_expire             | 整型                    | 启用审计日志时，日志的有效时间（小时），超时自动清理，值为 0 时表示不清理。默认值为 0。                                                                                                                                    |\n| audit_log_dir                | 字符串                   | 启用审计日志时，日志文件的存放目录。默认目录为 $directory/_audit_log_。                                                                                                                                   |"
            },
            {
                "content": "| audit_log_expire             | 整型                    | 启用审计日志时，日志的有效时间（小时），超时自动清理，值为 0 时表示不清理。默认值为 0。                                                                                                                                    |\n| audit_log_dir                | 字符串                   | 启用审计日志时，日志文件的存放目录。默认目录为 $directory/_audit_log_。                                                                                                                                   |\n| load_plugins                 | 布尔值                   | 启动服务时导入所有存储过程。默认值为 true。                                                                                                                                                          |\n| optimistic_txn               | 布尔值                   | 为 Cypher 开启乐观多线程写入事务。默认为 false。                                                                                                                                                   |"
            },
            {
                "content": "| load_plugins                 | 布尔值                   | 启动服务时导入所有存储过程。默认值为 true。                                                                                                                                                          |\n| optimistic_txn               | 布尔值                   | 为 Cypher 开启乐观多线程写入事务。默认为 false。                                                                                                                                                   |\n| disable_auth                 | 布尔值                   | 关闭 REST 验证。默认为 false。                                                                                                                                                             |\n| ha_snapshot_interval_s       | 整型                    | 快照间隔（以秒为单位），默认值为 604800。-1表示不自动生成快照。                                                                                                                                              |"
            },
            {
                "content": "| disable_auth                 | 布尔值                   | 关闭 REST 验证。默认为 false。                                                                                                                                                             |\n| ha_snapshot_interval_s       | 整型                    | 快照间隔（以秒为单位），默认值为 604800。-1表示不自动生成快照。                                                                                                                                              |\n| ha_heartbeat_interval_ms     | 整型                    | 心跳间隔（以毫秒为单位）。 默认值为 1000。                                                                                                                                                          |\n| ha_node_offline_ms           | 整型                    | 心跳超时且节点下线间隔（以毫秒为单位）。默认为 60000。                                                                                                                                                    |"
            },
            {
                "content": "| ha_heartbeat_interval_ms     | 整型                    | 心跳间隔（以毫秒为单位）。 默认值为 1000。                                                                                                                                                          |\n| ha_node_offline_ms           | 整型                    | 心跳超时且节点下线间隔（以毫秒为单位）。默认为 60000。                                                                                                                                                    |\n| ha_node_remove_ms            | 整型                    | 节点被视为完全死亡并从列表中删除的间隔（以毫秒为单位）。默认值为 120000。                                                                                                                                          |\n| ha_first_snapshot_start_time | 字符串                   | 第一次打快照的时间，格式为\"HH:MM:SS\"，表示为在下一个HH:MM:SS时间点第一次打snapshot，以后每ha_snapshot_interval_s秒打一次。默认值为\"\"，表示在0-ha_snapshot_interval_s内的任一时刻随机打第一次snapshot，以后每ha_snapshot_interval_s秒打一次snapshot |"
            },
            {
                "content": "| ha_node_remove_ms            | 整型                    | 节点被视为完全死亡并从列表中删除的间隔（以毫秒为单位）。默认值为 120000。                                                                                                                                          |\n| ha_first_snapshot_start_time | 字符串                   | 第一次打快照的时间，格式为\"HH:MM:SS\"，表示为在下一个HH:MM:SS时间点第一次打snapshot，以后每ha_snapshot_interval_s秒打一次。默认值为\"\"，表示在0-ha_snapshot_interval_s内的任一时刻随机打第一次snapshot，以后每ha_snapshot_interval_s秒打一次snapshot |\n| enable_ip_check              | 布尔值                   | 允许 IP 白名单，默认值为 false。                                                                                                                                                             |\n| idle_seconds                 | 整型                    | 子进程可以处于空闲状态的最大秒数。 默认值为 600。                                                                                                                                                       |"
            },
            {
                "content": "| enable_ip_check              | 布尔值                   | 允许 IP 白名单，默认值为 false。                                                                                                                                                             |\n| idle_seconds                 | 整型                    | 子进程可以处于空闲状态的最大秒数。 默认值为 600。                                                                                                                                                       |\n| enable_backup_log            | 布尔值                   | 是否启用备份日志记录。 默认值为 false。                                                                                                                                                           |\n| backup_log_dir               | 字符串                   | 存储备份文件的目录。 默认值为空。                                                                                                                                                                 |"
            },
            {
                "content": "| enable_backup_log            | 布尔值                   | 是否启用备份日志记录。 默认值为 false。                                                                                                                                                           |\n| backup_log_dir               | 字符串                   | 存储备份文件的目录。 默认值为空。                                                                                                                                                                 |\n| snapshot_dir                 | 字符串                   | 存储快照文件的目录。 默认值为空。                                                                                                                                                                 |\n| thread_limit                 | 整型                    | 同时使用的最大线程数。 默认值为 0，即不做限制，以 license 为准。                                                                                                                                            |"
            },
            {
                "content": "| snapshot_dir                 | 字符串                   | 存储快照文件的目录。 默认值为空。                                                                                                                                                                 |\n| thread_limit                 | 整型                    | 同时使用的最大线程数。 默认值为 0，即不做限制，以 license 为准。                                                                                                                                            |\n| unlimited_token              | 布尔值                   | 是否将链接token设置为无期限。 默认值为 false，有效期为24小时。                                                                                                                                            |\n| reset_admin_password         | 布尔值                   | 是否重置管理者密码。 默认值为 false。 为 true 时，密码重置为`73@TuGraph`。                                                                                                                                |"
            },
            {
                "content": "| unlimited_token              | 布尔值                   | 是否将链接token设置为无期限。 默认值为 false，有效期为24小时。                                                                                                                                            |\n| reset_admin_password         | 布尔值                   | 是否重置管理者密码。 默认值为 false。 为 true 时，密码重置为`73@TuGraph`。                                                                                                                                |\n| enable_fulltext_index        | 布尔值                   | 是否启用全文索引功能，默认值为 false。                                                                                                                                                            |\n| fulltext_analyzer            | 字符串                   | 全文索引分词器类型。可设为`StandardAnalyzer`或者`SmartChineseAnalyzer`。默认是`StandardAnalyzer`                                                                                                     |"
            },
            {
                "content": "| enable_fulltext_index        | 布尔值                   | 是否启用全文索引功能，默认值为 false。                                                                                                                                                            |\n| fulltext_analyzer            | 字符串                   | 全文索引分词器类型。可设为`StandardAnalyzer`或者`SmartChineseAnalyzer`。默认是`StandardAnalyzer`                                                                                                     |\n| fulltext_commit_interval     | 整形                    | 全文索引数据提交周期,针对写操作，单位秒。默认是 0，立即提交。                                                                                                                                                  |\n| fulltext_refresh_interval    | 整形                    | 全文索引数据刷新周期，针对读操作，单位秒。默认是 0，立即可以读到最新写入的数据。                                                                                                                                         |"
            },
            {
                "content": "| fulltext_commit_interval     | 整形                    | 全文索引数据提交周期,针对写操作，单位秒。默认是 0，立即提交。                                                                                                                                                  |\n| fulltext_refresh_interval    | 整形                    | 全文索引数据刷新周期，针对读操作，单位秒。默认是 0，立即可以读到最新写入的数据。                                                                                                                                         |\n| ha_conf                      | 字符串                   | 根据 host1:port1,host2:port2,host3:port3 初始化HA集群，默认值为空。                                                                                                                             |\n| ha_node_join_group_s         | 整形                    | 节点尝试加入高可用集群的等待时长，单位秒，默认是 10。                                                                                                                                                      |"
            },
            {
                "content": "| ha_conf                      | 字符串                   | 根据 host1:port1,host2:port2,host3:port3 初始化HA集群，默认值为空。                                                                                                                             |\n| ha_node_join_group_s         | 整形                    | 节点尝试加入高可用集群的等待时长，单位秒，默认是 10。                                                                                                                                                      |\n| ha_bootstrap_role            | 整形                    | 是否使用bootstrap方式启动，以及使用该方式启动的服务器角色，0代表不使用bootstrap方式启动，1代表使用bootstrap方式启动且本节点为leader，2代表使用bootstrap方式启动且本节点为follower，只有这3种选项。 默认值为 0。                                              |\n| help                         | 布尔值                   | 打印此帮助消息。 默认值为 false。                                                                                                                                                              |"
            },
            {
                "content": "| ha_bootstrap_role            | 整形                    | 是否使用bootstrap方式启动，以及使用该方式启动的服务器角色，0代表不使用bootstrap方式启动，1代表使用bootstrap方式启动且本节点为leader，2代表使用bootstrap方式启动且本节点为follower，只有这3种选项。 默认值为 0。                                              |\n| help                         | 布尔值                   | 打印此帮助消息。 默认值为 false。                                                                                                                                                              |\n| browser.credential_timeout                         | 整形                    | 浏览器缓存的用户名和密码过期时间。                                                                                                                                                                 |\n| browser.retain_connection_credentials                         | 布尔值                   | 浏览器是否缓存用户名和密码。                                                                                                                                                              |"
            },
            {
                "content": "### 4.2.服务器配置文件\n\nTuGraph 的配置文件以 JSON 格式存储。建议将大多数配置存储在配置文件中，并且仅在需要时使用命令行选项临时修改某些配置参数。\n一个典型的配置文件如下：\n\n```json\n{\n  \"directory\" : \"/var/lib/lgraph/data\",\n  \"host\" : \"0.0.0.0\",\n  \"port\" : 7070,\n  \"rpc_port\" : 9090,\n  \"enable_rpc\" : true,\n  \"bolt_port\": 7687,\n  \"enable_ha\" : false,\n  \"verbose\" : 1,\n  \"log_dir\" : \"/var/log/lgraph_log\",\n  \"disable_auth\" : false,\n  \"ssl_auth\" : false,\n  \"server_key\" : \"/usr/local/etc/lgraph/server-key.pem\",\n  \"server_cert\" : \"/usr/local/etc/lgraph/server-cert.pem\",\n  \"web\" : \"/usr/local/share/lgraph/browser-resource\"\n}\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/5.installation%26running/8.high-availability-mode.md",
        "chunks": [
            {
                "content": "# 部署高可用模式\n\n> 此文档主要介绍了高可用模式的原理、准备工作、以及服务器的操作说明\n\n## 1.原理\n\nTuGraph 通过多机热备份来提供高可用（HA）模式。在高可用模式下，对数据库的写操作会被同步到所有服务器（非witness）上，这样即使有部分服务器宕机也不会影响服务的可用性。\n\n高可用模式启动时，多个 TuGraph 服务器组成一个备份组，即高可用集群。每个备份组由三个或更多 TuGraph 服务器组成，其中某台服务器会作为`leader`，而其他复制组服务器则作为`follower`。写入请求由`leader`\n提供服务，该`leader`将每个请求复制同步到`follower`，并在请求同步到服务器后才能响应客户端。这样，如果任何服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`\n服务器发生故障，其他服务器将自动选择出新的`leader`。\n\nTuGraph的高可用模式提供两种类型的节点：`replica`节点和`witness`节点。其中，`replica`节点是普通节点，有日志有数据，可对外提供服务。\n而`witness`节点是一种只接收心跳和日志但不保存数据的节点。根据部署需求，`leader`节点和`follower`节点可以灵活的部署为`replica`节点或`witness`节点。\n基于此，TuGraph高可用模式的部署方式有两种：一是普通部署模式，二是带witness的简约部署模式。\n\n对于普通部署模式，`leader`和所有`follower`均为`replica`类型的节点。写入请求由`leader`提供服务，该`leader`将每个请求复制同步到`follower`，\n并在请求同步到超过半数的服务器后才能响应客户端。这样，如果少于半数的服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`\n服务器发生故障，其他服务器将自动选举出新的`leader`，通过这种方式保证数据的一致性和服务的可用性。"
            },
            {
                "content": "TuGraph的高可用模式提供两种类型的节点：`replica`节点和`witness`节点。其中，`replica`节点是普通节点，有日志有数据，可对外提供服务。\n而`witness`节点是一种只接收心跳和日志但不保存数据的节点。根据部署需求，`leader`节点和`follower`节点可以灵活的部署为`replica`节点或`witness`节点。\n基于此，TuGraph高可用模式的部署方式有两种：一是普通部署模式，二是带witness的简约部署模式。\n\n对于普通部署模式，`leader`和所有`follower`均为`replica`类型的节点。写入请求由`leader`提供服务，该`leader`将每个请求复制同步到`follower`，\n并在请求同步到超过半数的服务器后才能响应客户端。这样，如果少于半数的服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`\n服务器发生故障，其他服务器将自动选举出新的`leader`，通过这种方式保证数据的一致性和服务的可用性。\n\n然而，在用户服务器资源不够或者发生网络分区时，不能建立正常的HA集群。此时，由于`witness`节点没有数据，对资源占用小，可以将`witness`节点和`replica`节点部署在一台机器上。\n例如，当只有2台机器的情况下，可以在一台机器上部署`replica`节点，在另一台机器上部署`replica`节点和`witness`节点，不仅节省资源，而且不需要把日志应用到状态机上，\n也不需要生成和安装快照，因此响应请求的速度很快，可以在集群崩溃或网络分区时协助快速选举出新的`leader`，这就是TuGraph HA集群的简约部署模式。\n尽管`witness`节点有诸多好处，但是由于没有数据，集群实际上增加了一个不能成为`leader`的节点，因此可用性会略有降低。为提高集群的可用性，\n可通过指定`ha_enable_witness_to_leader`参数为`true`，允许`witness`节点临时当主。`witness`节点在把新日志同步到其他节点之后，\n会将leader角色主动切换到有最新日志的节点。\n\nv3.6及以上版本支持此功能。\n\n## 2.准备工作\n\n要启用高可用模式，用户需要：\n\n- 三台及以上的 TuGraph 服务器实例。"
            },
            {
                "content": "v3.6及以上版本支持此功能。\n\n## 2.准备工作\n\n要启用高可用模式，用户需要：\n\n- 三台及以上的 TuGraph 服务器实例。\n\n- 在启动 lgraph_server 时打开高可用模式，可以使用配置文件或者命令行将`enable_ha`选项设置为`true`。\n\n- 设置正确的`rpc_port`，可通过配置文件或者命令行设置。\n\n## 3.启动初始备份组\n\n安装好TuGraph之后，可以使用`lgraph_server`命令在不同的机器上启动高可用集群。本节主要讲解高可用集群的启动方式，启动之后的集群状态管理参见[lgraph_peer工具](../6.utility-tools/5.ha-cluster-management.md)\n\n### 3.1.初始数据一致\n\n当启动时所有服务器中的数据相同或没有数据时，用户可以通过指定`--ha_conf host1:port1,host2:port2`启动服务器。\n这种方式可以将准备好的所有TuGraph实例一次性加入初始备份组，由备份组中的所有服务器根据raft协议选举出`leader`，并将其他服务器以`follower`的角色加入备份组。\n\n启动初始备份组的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n### 3.2.初始数据不一致\n\n如果第一台服务器中已有数据（以`lgraph_import`工具导入或从非高可用模式的服务器传输得到），\n并且之前并未在高可用模式下使用，则用户应使用boostrap方式启动。\n以`ha_bootstrap_role`参数为1在bootstrap模式下启动有数据的服务器，并通过`ha_conf`参数指定本机为`leader`。\n在bootstrap模式下，服务器在将新加入的服务器添加到备份组之前会将自己的\n数据复制到新服务器中，以使每个服务器中的数据保持一致。\n\n启动有数据服务器的命令示例如下所示："
            },
            {
                "content": "启动初始备份组的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n### 3.2.初始数据不一致\n\n如果第一台服务器中已有数据（以`lgraph_import`工具导入或从非高可用模式的服务器传输得到），\n并且之前并未在高可用模式下使用，则用户应使用boostrap方式启动。\n以`ha_bootstrap_role`参数为1在bootstrap模式下启动有数据的服务器，并通过`ha_conf`参数指定本机为`leader`。\n在bootstrap模式下，服务器在将新加入的服务器添加到备份组之前会将自己的\n数据复制到新服务器中，以使每个服务器中的数据保持一致。\n\n启动有数据服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_bootstrap_role 1\n```\n\n其他无数据的服务器需要指定`ha_bootstrap_role`参数为2，并通过`ha_conf`参数指定`leader`即可，命令示例如下所示\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_bootstrap_role 2\n```"
            },
            {
                "content": "启动有数据服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_bootstrap_role 1\n```\n\n其他无数据的服务器需要指定`ha_bootstrap_role`参数为2，并通过`ha_conf`参数指定`leader`即可，命令示例如下所示\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_bootstrap_role 2\n```\n\n**使用bootstrap启动HA集群时需要注意两点：**\n1. 需要等待`leader`节点生成snapshot并且成功启动之后再加入`follower`节点，否则`follower`节点可能加入失败。在启动`follower`节点时可以将`ha_node_join_group_s`参数配置的稍大，以在加入HA集群时多次等待和超时重试。\n2. HA集群只有在第一次启动时可以使用bootstrap模式，后续再启动时只能使用普通模式(见3.1节)启动，尤其不能让同一个集群的多个节点以bootstrap模式启动，否则可能产生数据不一致的情况\n\n## 4.启动witness节点\n\n### 4.1.不允许witness节点成为leader\n\n`witness`节点的启动方式和普通节点的启动方式一致，只需要设置`ha_is_witness`参数为`true`即可。需注意，witness节点的数量应少于集群节点总数量的一半。\n\n启动`witness`节点服务器的命令示例如下所示："
            },
            {
                "content": "**使用bootstrap启动HA集群时需要注意两点：**\n1. 需要等待`leader`节点生成snapshot并且成功启动之后再加入`follower`节点，否则`follower`节点可能加入失败。在启动`follower`节点时可以将`ha_node_join_group_s`参数配置的稍大，以在加入HA集群时多次等待和超时重试。\n2. HA集群只有在第一次启动时可以使用bootstrap模式，后续再启动时只能使用普通模式(见3.1节)启动，尤其不能让同一个集群的多个节点以bootstrap模式启动，否则可能产生数据不一致的情况\n\n## 4.启动witness节点\n\n### 4.1.不允许witness节点成为leader\n\n`witness`节点的启动方式和普通节点的启动方式一致，只需要设置`ha_is_witness`参数为`true`即可。需注意，witness节点的数量应少于集群节点总数量的一半。\n\n启动`witness`节点服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_is_witness 1\n```\n\n注：默认不允许`witness`节点成为`leader`节点，这可以提高集群的性能，但是在`leader`节点崩溃时会降低集群的可用性。\n\n### 4.2.允许witness节点成为leader\n\n可以通过指定`ha_enable_witness_to_leader`参数为`true`，使得`witness`节点可以临时成为`leader`节点，在将新日志同步完成之后再主动切主\n\n启动允许成为`leader`节点的`witness`节点服务器的命令示例如下所示："
            },
            {
                "content": "启动`witness`节点服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_is_witness 1\n```\n\n注：默认不允许`witness`节点成为`leader`节点，这可以提高集群的性能，但是在`leader`节点崩溃时会降低集群的可用性。\n\n### 4.2.允许witness节点成为leader\n\n可以通过指定`ha_enable_witness_to_leader`参数为`true`，使得`witness`节点可以临时成为`leader`节点，在将新日志同步完成之后再主动切主\n\n启动允许成为`leader`节点的`witness`节点服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_is_witness 1 --ha_enable_witness_to_leader 1\n```\n\n注：尽管允许`witness`节点成为`leader`节点可以提高集群的可用性，但是在极端情况下可能会影响数据的一致性。因此一般应保证`witness`节点数量+1少于集群节点总数量的一半。\n\n## 5.横向扩展其他服务器\n\n启动初始备份组后，如果想对备份组进行横向扩展，要将新服务器添加到备份组，\n应使用`--ha_conf HOST：PORT`选项，其中`HOST`可以是该备份组中已有的任何服务器的 IP 地址，\n而`PORT`是其 RPC 端口。例如：\n\n```bash\n./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090\n```"
            },
            {
                "content": "注：尽管允许`witness`节点成为`leader`节点可以提高集群的可用性，但是在极端情况下可能会影响数据的一致性。因此一般应保证`witness`节点数量+1少于集群节点总数量的一半。\n\n## 5.横向扩展其他服务器\n\n启动初始备份组后，如果想对备份组进行横向扩展，要将新服务器添加到备份组，\n应使用`--ha_conf HOST：PORT`选项，其中`HOST`可以是该备份组中已有的任何服务器的 IP 地址，\n而`PORT`是其 RPC 端口。例如：\n\n```bash\n./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090\n```\n\n此命令将启动一台高可用模式的 TuGraph 服务器，并尝试将其添加到包含服务器`172.22.224.15:9090`的备份组中。\n请注意，加入备份组需要服务器将其数据与备份组的`leader`服务器同步，此过程可能需要相当长的时间，具体取决于数据的大小。\n\n## 6.停止服务器\n\n当服务器通过`CTRL-C`下线时，它将通知当前的`leader`服务器，告知其从备份组中删除该下线的服务器。如果`leader`服务器下线，\n它将在下线前将`leader`身份权限传给另一台服务器。\n\n如果服务器被终止或者与备份组中的其他服务器失去连接，则该服务器将被视为失败节点，`leader`服务器将在特定时限后将其从备份组中删除。\n\n如果任何服务器离开备份组并希望重新加入，则必须从`--ha_conf HOST:PORT`选项开始，其中`HOST`是当前备份组中的某台服务器的 IP 地址。\n\n## 7.重启服务器\n\n不建议重新启动整个备份组，因为它会中断服务。如果需要，可以关闭所有服务器。但在重新启动时，\n必须保证关闭时的备份组中至少有N/2+1的服务器能正常启动，否则启动失败。 并且，\n无论初始启动复制组时是否指定`enable_bootstrap`为true，重启服务器时都只需通过\n指定`--ha_conf host1:port1,host2:port2`参数一次性重启所有服务器即可，命令示例如下所示："
            },
            {
                "content": "## 6.停止服务器\n\n当服务器通过`CTRL-C`下线时，它将通知当前的`leader`服务器，告知其从备份组中删除该下线的服务器。如果`leader`服务器下线，\n它将在下线前将`leader`身份权限传给另一台服务器。\n\n如果服务器被终止或者与备份组中的其他服务器失去连接，则该服务器将被视为失败节点，`leader`服务器将在特定时限后将其从备份组中删除。\n\n如果任何服务器离开备份组并希望重新加入，则必须从`--ha_conf HOST:PORT`选项开始，其中`HOST`是当前备份组中的某台服务器的 IP 地址。\n\n## 7.重启服务器\n\n不建议重新启动整个备份组，因为它会中断服务。如果需要，可以关闭所有服务器。但在重新启动时，\n必须保证关闭时的备份组中至少有N/2+1的服务器能正常启动，否则启动失败。 并且，\n无论初始启动复制组时是否指定`enable_bootstrap`为true，重启服务器时都只需通过\n指定`--ha_conf host1:port1,host2:port2`参数一次性重启所有服务器即可，命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n## 8.docker部署高可用集群\n\n在真实业务场景中，很可能遇到在多种操作系统或架构上部署高可用集群的需求。\n差异化的环境可能导致编译TuGraph时缺少某些依赖。因此，\n在docker中编译软件并部署高可用集群是非常有应用价值的。以centos7版本的docker为例，\n部署高可用集群的步骤如下所示。\n\n### 8.1.安装镜像\n使用如下命令下载TuGraph的编译docker镜像环境\n```shell\ndocker pull tugraph/tugraph-compile-centos7\n```\n然后拉取TuGraph源码并编译安装"
            },
            {
                "content": "```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n## 8.docker部署高可用集群\n\n在真实业务场景中，很可能遇到在多种操作系统或架构上部署高可用集群的需求。\n差异化的环境可能导致编译TuGraph时缺少某些依赖。因此，\n在docker中编译软件并部署高可用集群是非常有应用价值的。以centos7版本的docker为例，\n部署高可用集群的步骤如下所示。\n\n### 8.1.安装镜像\n使用如下命令下载TuGraph的编译docker镜像环境\n```shell\ndocker pull tugraph/tugraph-compile-centos7\n```\n然后拉取TuGraph源码并编译安装\n\n### 8.2.创建容器\n使用如下命令创建容器，使用`--net=host`使得容器运行在host模式，此模式下\ndocker和宿主机和共享网络namespace，即共用同一个IP。\n```shell\ndocker run --net=host -itd -p -v {src_dir}:{dst_dir} --name tugraph_ha tugraph/tugraph-compile-centos7 /bin/bash\n```\n\n### 8.3.启动服务\n在每台服务器上使用如下命令启动服务，因为docker和宿主机共享IP，所以可以直接指定在宿主机IP上启动服务\n```shell\n$ lgraph_server -c lgraph.json --host 172.22.224.15 --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n## 9.查看服务器状态\n\n备份组的当前状态可以在 TuGraph 可视化工具、REST API 以及 Cypher 查询中获取。\n\n在 TuGraph 可视化工具中，可以在 DBInfo 部分中找到备份组中的服务器及其角色列表。"
            },
            {
                "content": "### 8.3.启动服务\n在每台服务器上使用如下命令启动服务，因为docker和宿主机共享IP，所以可以直接指定在宿主机IP上启动服务\n```shell\n$ lgraph_server -c lgraph.json --host 172.22.224.15 --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n## 9.查看服务器状态\n\n备份组的当前状态可以在 TuGraph 可视化工具、REST API 以及 Cypher 查询中获取。\n\n在 TuGraph 可视化工具中，可以在 DBInfo 部分中找到备份组中的服务器及其角色列表。\n\n使用 REST API 时，可以使用`GET /info/peers` 请求获取信息。\n\n在 Cypher 中，使用`CALL dbms.listServers()`语句来查询当前备份组的状态信息。\n\n## 10.高可用模式下数据同步问题\n\n在高可用模式下，同一备份组中的不同服务器可能并不总是处于相同的状态。出于性能原因，如果请求已同步到超过一半的服务器，则`leader`服务器将认为该请求属于`committed`状态。尽管其余服务器最终将收到新请求，但服务器的状态不一致将持续一段时间。客户端也可能向刚刚重新启动的服务器发送请求，从而具有较旧的状态。\n\n为了确保客户端看到一致连续的数据，特别是为了摆脱`反向时间旅行`问题（其中客户端读取比以前看到的状态更旧的状态），每个 TuGraph 服务器都会保持一个单调增加的数据版本号。备份组中数据版本号到数据库状态的映射全局一致，这意味着如果两台服务器具有相同的数据版本号，则它们必须具有相同的数据。响应请求时，服务器在响应中包含了其数据版本号。因此，客户端可以知道它看到了哪个版本。客户端收到旧版本的数据之后可以重新向Leader发送请求，从而获取到最新的数据。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/1.data-import.md",
        "chunks": [
            {
                "content": "# 数据导入\n\n> 此文档主要介绍 TuGraph 的数据导入功能。其中包括 CSV 格式的分隔符，jsonline 的格式示例，以及导入在线和离线的两种模式。\n\n## 1.简介\n\n在图数据库服务安装成功后，您可以使用`lgraph_import`批量导入工具将现有数据导入 TuGraph。`lgraph_import`支持从 CSV 文件和 JSON 数据源导入数据。\n\n> CSV 格式\n\n```\n[movies.csv]\nid, name, year, rating\ntt0188766,King of Comedy,1999,7.3\ntt0286112,Shaolin Soccer,2001,7.3\ntt4701660,The Mermaid,2016,6.3\n```\n\n> jsonline 格式\n\n```json\n[\"tt0188766\",\"King of Comedy\",1999,7.3]\n[\"tt0286112\",\"Shaolin Soccer\",2001,7.3]\n[\"tt4701660\",\"The Mermaid\",2016,6.3]\n```\n\nTuGraph 支持两种导入模式：\n\n- _离线模式_：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。\n- _在线模式_：读取数据并将其发送到工作中的服务器，然后将数据导入其数据库。\n\n## 2.CSV文件格式分隔符\n\n    CSV格式的分隔符可以是单字符或多字符组成的字符串，其中不能包含`\\r`或`\\n`。注意不同的shell会对输入字符串做不同的处理，因此针对不同的shell输入参数可能需要不同的转义处理。\n\n此外，`lgraph_import`还支持以下转义字符，以便输入特殊符号："
            },
            {
                "content": "```json\n[\"tt0188766\",\"King of Comedy\",1999,7.3]\n[\"tt0286112\",\"Shaolin Soccer\",2001,7.3]\n[\"tt4701660\",\"The Mermaid\",2016,6.3]\n```\n\nTuGraph 支持两种导入模式：\n\n- _离线模式_：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。\n- _在线模式_：读取数据并将其发送到工作中的服务器，然后将数据导入其数据库。\n\n## 2.CSV文件格式分隔符\n\n    CSV格式的分隔符可以是单字符或多字符组成的字符串，其中不能包含`\\r`或`\\n`。注意不同的shell会对输入字符串做不同的处理，因此针对不同的shell输入参数可能需要不同的转义处理。\n\n此外，`lgraph_import`还支持以下转义字符，以便输入特殊符号：\n\n| 转义符 | 说明                                                             |\n| ------ | ---------------------------------------------------------------- |\n| \\\\     | 反斜杠`\\\\`                                                       |\n| \\\\a    | 响铃，即 ASCII 码 0x07                                           |\n| \\\\f    | form-feed，即 ASCII 码 0x0c                                      |\n| \\\\t    | 水平制表符，即 ASCII 码 0x09                                     |\n| \\\\v    | 垂直制表符，即 ASCII 码 0x0b                                     |\n| \\\\xnn  | 两位十六进制数，表示一个字节，如\\\\x9A                            |\n| \\\\nnn  | 三位八进制数，表示一个字节，如\\\\001, \\\\443，数值范围不能超过 255 |\n\n例："
            },
            {
                "content": "例：\n\n```bash\n$ ./lgraph_import -c ./import.config --delimiter \"\\001\\002\"\n```\n\n## 3.配置文件\n\n`lgraph_import`工具通过指定的配置文件进行环境配置。配置文件描述输入文件的路径、它们所代表的点/边以及点/边的格式。\n\n### 3.1.配置文件格式\n\n配置文件包含两部分：schema 和 files。`schema`部分定义 label，`files`部分描述要导入的数据文件。\n\n#### 3.1.1.关键字"
            },
            {
                "content": "- schema (数组形式）\n  - label（必选，字符串形式）\n  - type（必选，值只能是 VERTEX 或者 EDGE）\n  - properties（数组形式，对于点必选，对于边如果没有属性可以不配置）\n    - name（必选，字符串形式）\n    - type （必选，BOOL，INT8，INT16，INT32，INT64，DATE，DATETIME，FLOAT，DOUBLE，STRING，BLOB）\n    - optional（可选，代表该字段可以配置，也可以不配置）\n    - index（可选，该字段是否需要建索引）\n    - unique（可选，该字段是否建索引，并且是 unique 类型的，即全局唯一）\n    - pair_unique（可选，该字段是否建索引，并且是 pari_unique 类型的，即两点间唯一，仅用于边索引）unique与pair_unique只能设置一个，同时设置并运行将会因为输入异常而终止\n  - primary (仅点配置，必选，主键字段，需指定一个 property，用来唯一确定一个点)\n  - temproal (仅边配置，可选，指定时间戳属性用于存储层排序)\n  - temporal_field_order (仅边配置，可选，默认为\"ASC\"，表示升序，也可配置为\"DESC\"，表示降序)\n  - constraints (仅边配置，可选，数组形式，起点和终点的 label，不配置或者为空代表不限制)\n  - detach_property (点边都可配置，可选，默认是`false`。`true` 代表属性数据单独存放，在内存不够，属性数据比较多的场景下可以减少io读放大)\n- files （数组形式）\n  - path（必选，字符串，可以是文件路径或者目录的路径，如果是目录会导入此目录下的所有文件，需要保证有相同的 schema）\n  - header（可选，数字，头信息占文件起始的几行，没有就是 0）\n  - format（必须选，只能是 JSON 或者 CSV）\n  - label（必选，字符串）\n  - columns（数组形式）\n    - SRC_ID (特殊字符串，仅边有，代表这列是起始点数据)\n    - DST_ID (特殊字符串，仅边有，代表这列是目的点数据)\n    - SKIP   (特殊字符串，代表跳过这列数据)"
            },
            {
                "content": "- temporal_field_order (仅边配置，可选，默认为\"ASC\"，表示升序，也可配置为\"DESC\"，表示降序)\n  - constraints (仅边配置，可选，数组形式，起点和终点的 label，不配置或者为空代表不限制)\n  - detach_property (点边都可配置，可选，默认是`false`。`true` 代表属性数据单独存放，在内存不够，属性数据比较多的场景下可以减少io读放大)\n- files （数组形式）\n  - path（必选，字符串，可以是文件路径或者目录的路径，如果是目录会导入此目录下的所有文件，需要保证有相同的 schema）\n  - header（可选，数字，头信息占文件起始的几行，没有就是 0）\n  - format（必须选，只能是 JSON 或者 CSV）\n  - label（必选，字符串）\n  - columns（数组形式）\n    - SRC_ID (特殊字符串，仅边有，代表这列是起始点数据)\n    - DST_ID (特殊字符串，仅边有，代表这列是目的点数据)\n    - SKIP   (特殊字符串，代表跳过这列数据)\n    - [property]\n  - SRC_ID (仅边配置，值是起始点标签)\n  - DST_ID (仅边配置，值是目的点标签)"
            },
            {
                "content": "#### 3.1.2.索引长度\n因为TuGraph对key的长度有限制，唯一索引不允许建立超过限制长度的索引，而非唯一索引会对超过长度限制的属性进行截断处理，并且在通过迭代器遍历非唯一索引时，拿到的key也是经过截断的，可能和预期不一致。针对不同类型的非唯一索引，截断长度是不同的。\n##### 3.1.2.1.unique索引\nunique索引是全局唯一的，该索引key的最大长度是480bytes。primary作为特殊的unique索引，因此最大key的长度也是480bytes，超过无法建立索引。\n##### 3.1.2.2.pair_unique索引\npair_unique索引是指两点间唯一的索引，这种类型的索引只能创建于边的schema中，这种索引在用户指定的key后面加上了源点和目标点的vid，每个vid是5bytes长度。因此最大key的长度是470bytes，超过无法建立索引。\n##### 3.1.2.3.非唯一索引\n非唯一索引是指既没有设置unique为1，也没有设置pair_unique为1的索引，在TuGraph的实现中，此类索引一个key可能映射到多个值，为了加速查找和写入，在用户指定的key后面加上了一组vid或euid中的最大值。其中对于创建于点中的非唯一索引，key后面跟着vid，每个vid是5bytes长度，因此最大长度是475bytes。\n对于创建于边中的非唯一索引，key后面跟着euid，每个euid是24bytes长度，因此最大长度是456bytes。索引key超过对应长度则会自动截断。\n\n### 3.2.配置文件示例"
            },
            {
                "content": "```json\n{\n  \"schema\": [\n    {\n      \"label\": \"actor\",\n      \"type\": \"VERTEX\",\n      \"properties\": [\n        { \"name\": \"aid\", \"type\": \"STRING\" },\n        { \"name\": \"name\", \"type\": \"STRING\" }\n      ],\n      \"primary\": \"aid\"\n    },\n    {\n      \"label\": \"movie\",\n      \"type\": \"VERTEX\",\n      \"properties\": [\n        { \"name\": \"mid\", \"type\": \"STRING\" },\n        { \"name\": \"name\", \"type\": \"STRING\" },\n        { \"name\": \"year\", \"type\": \"INT16\" },\n        { \"name\": \"rate\", \"type\": \"FLOAT\", \"optional\": true }\n      ],\n      \"primary\": \"mid\",\n      \"detach_property\": false\n    },\n    {\n      \"label\": \"play_in\",\n      \"type\": \"EDGE\",\n      \"properties\": [{ \"name\": \"role\", \"type\": \"STRING\", \"optional\": true }],\n      \"constraints\": [[\"actor\", \"movie\"]]\n    }\n  ],\n  \"files\": [\n    {\n      \"path\": \"actors.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"actor\",\n      \"columns\": [\"aid\", \"name\"]\n    },\n    {\n      \"path\": \"movies.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"movie\","
            },
            {
                "content": "],\n      \"primary\": \"mid\",\n      \"detach_property\": false\n    },\n    {\n      \"label\": \"play_in\",\n      \"type\": \"EDGE\",\n      \"properties\": [{ \"name\": \"role\", \"type\": \"STRING\", \"optional\": true }],\n      \"constraints\": [[\"actor\", \"movie\"]]\n    }\n  ],\n  \"files\": [\n    {\n      \"path\": \"actors.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"actor\",\n      \"columns\": [\"aid\", \"name\"]\n    },\n    {\n      \"path\": \"movies.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"movie\",\n      \"columns\": [\"mid\", \"name\", \"year\", \"rate\"]\n    },\n    {\n      \"path\": \"roles.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"play_in\",\n      \"SRC_ID\": \"actor\",\n      \"DST_ID\": \"movie\",\n      \"columns\": [\"SRC_ID\", \"role\", \"DST_ID\"]\n    }\n  ]\n}\n```"
            },
            {
                "content": "对于上述配置文件，定义了三个 label：两个点类型`actor`和`movie`，一个边类型`role`。每个 label 都描述了：label 的名字、类型（点还是边）、属性字段有哪些以及每个字段的类型。对于点，另外定义了 primary 字段是哪个；对于边，另外定义了 constraints 字段，用来限制边的起点和终点只能是哪些组合。\n\n还描述了三个数据文件，两个点的数据文件`actors.csv`和`movies.csv`，一个边的数据文件`roles.csv`。每个部分都描述了：文件的路径（path）、数据类型（format）、信息头占开头几行（header）、是哪个 label 的数据（label）、文件中每行数据中的每个列对应的字段是哪个。\n\n对于上述配置文件，import 工具在执行的过程中会先在 TuGraph 中创建`actor`、`movie`、`role`这三个 label，然后再执行三个文件的数据导入。\n\n## 4.离线全量导入\n\n离线模式只能在离线状态的服务器使用。离线导入会创建一张新图，因此更适合新安装的 TuGraph 服务器上的第一次数据导入。\n要在离线模式下使用`lgraph_import`工具，可以指定`lgraph_import --online false`选项。要了解可用的命令行选项，请使用`lgraph_import --online false --help`：\n\n```shell\n$ ./lgraph_import --online false -help\nAvailable command line options:\n    --log               Log file to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    ...\n    -h, --help          Print this help message. Default=0.\n```\n\n命令行参数："
            },
            {
                "content": "```shell\n$ ./lgraph_import --online false -help\nAvailable command line options:\n    --log               Log file to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    ...\n    -h, --help          Print this help message. Default=0.\n```\n\n命令行参数：\n\n- **-c, --config_file** `config_file`: 导入配置文件名，其格式要求见下述。\n- **--log** `log_dir`: 日志目录。默认为空字符串，此时将日志信息输出到控制台。\n- **--verbose** `0/1/2`: 日志等级，等级越高输出信息越详细。默认为 1。\n- **-i, --continue_on_error** `true/false`: 在碰到错误时跳过错误并继续，默认为 false，碰到错误立即退出。\n- **-d, --dir** `{diretory}`: 数据库目录，导入工具会将数据写到这个目录。默认为`./db`。\n- **--delimiter** `{delimiter}`: 数据文件分隔符。只在数据源是 CSV 格式时使用，默认为`\",\"`。\n- **-u, --username** `{user}`: 数据库用户名。需要是管理员用户才能执行离线导入。\n- **-p, --password** `{password}`: 指定的数据库用户的密码\n- **--overwrite** `true/false`: 是否覆盖数据。设为 true 时，如果数据目录已经存在，则覆盖数据。默认为`false`。\n- **-g, --graph** `{graph_name}`: 指定需要导入的图种类。\n- **-h, --help**: 输出帮助信息。\n\n### 4.1.离线导入示例"
            },
            {
                "content": "### 4.1.离线导入示例\n\n在这个例子中，我们使用上面描述的电影-演员数据来演示导入工具的使用方法。待导入数据分为三个文件：`movies.csv`，`actors.csv`，`roles.csv`。\n\n`movies.csv`包含的是电影的信息，其中每部电影有一个 id（作为检索的 primary key），此外每部电影还拥有 title、year 和 rating 等属性。（数据来自[IMDb](http://www.imdb.com)）。\n\n```\n  [movies.csv]\n  id, name, year, rating\n  tt0188766,King of Comedy,1999,7.3\n  tt0286112,Shaolin Soccer,2001,7.3\n  tt4701660,The Mermaid,2016,6.3\n```\n\n对应的 jsonline 格式如下:\n也可以所有字段都是字符串形式，导入的时候会转换成对应的类型\n\n```json\n[\"tt0188766\",\"King of Comedy\",1999,7.3]\n[\"tt0286112\",\"Shaolin Soccer\",2001,7.3]\n[\"tt4701660\",\"The Mermaid\",2016,6.3]\n```\n\n```json\n[\"tt0188766\",\"King of Comedy\",\"1999\",\"7.3\"]\n[\"tt0286112\",\"Shaolin Soccer\",\"2001\",\"7.3\"]\n[\"tt4701660\",\"The Mermaid\",\"2016\",\"6.3\"]\n```\n\n`actors.csv`包含的是演员的信息。每个演员也拥有一个 id，以及 name 等属性。\n\n```\n  [actors.csv]\n  id, name\n  nm015950,Stephen Chow\n  nm0628806,Man-Tat Ng\n  nm0156444,Cecilia Cheung\n  nm2514879,Yuqi Zhang\n```\n\n> 对应的 jsonline 格式如下:"
            },
            {
                "content": "```json\n[\"tt0188766\",\"King of Comedy\",1999,7.3]\n[\"tt0286112\",\"Shaolin Soccer\",2001,7.3]\n[\"tt4701660\",\"The Mermaid\",2016,6.3]\n```\n\n```json\n[\"tt0188766\",\"King of Comedy\",\"1999\",\"7.3\"]\n[\"tt0286112\",\"Shaolin Soccer\",\"2001\",\"7.3\"]\n[\"tt4701660\",\"The Mermaid\",\"2016\",\"6.3\"]\n```\n\n`actors.csv`包含的是演员的信息。每个演员也拥有一个 id，以及 name 等属性。\n\n```\n  [actors.csv]\n  id, name\n  nm015950,Stephen Chow\n  nm0628806,Man-Tat Ng\n  nm0156444,Cecilia Cheung\n  nm2514879,Yuqi Zhang\n```\n\n> 对应的 jsonline 格式如下:\n\n```json\n[\"nm015950\",\"Stephen Chow\"]\n[\"nm0628806\",\"Man-Tat Ng\"]\n[\"nm0156444\",\"Cecilia Cheung\"]\n[\"nm2514879\",\"Yuqi Zhang\"]\n```\n\n`roles.csv`则包含了演员在哪个电影中扮演了哪个角色的信息。其中每一行记录的是指定演员在指定电影里饰演的角色，对应数据库中的一条边。`SRC_ID` 和 `DST_ID` 分别是边的源点和目标点，他们分别是`actors.csv`和`movies.csv`中定义的`primary`属性。\n\n```\n  [roles.csv]\n  actor, role, movie\n  nm015950,Tianchou Yin,tt0188766\n  nm015950,Steel Leg,tt0286112\n  nm0628806,,tt0188766\n  nm0628806,coach,tt0286112\n  nm0156444,PiaoPiao Liu,tt0188766\n  nm2514879,Ruolan Li,tt4701660\n```\n\n对应的 jsonline 格式如下:"
            },
            {
                "content": "`roles.csv`则包含了演员在哪个电影中扮演了哪个角色的信息。其中每一行记录的是指定演员在指定电影里饰演的角色，对应数据库中的一条边。`SRC_ID` 和 `DST_ID` 分别是边的源点和目标点，他们分别是`actors.csv`和`movies.csv`中定义的`primary`属性。\n\n```\n  [roles.csv]\n  actor, role, movie\n  nm015950,Tianchou Yin,tt0188766\n  nm015950,Steel Leg,tt0286112\n  nm0628806,,tt0188766\n  nm0628806,coach,tt0286112\n  nm0156444,PiaoPiao Liu,tt0188766\n  nm2514879,Ruolan Li,tt4701660\n```\n\n对应的 jsonline 格式如下:\n\n```json\n[\"nm015950\",\"Tianchou Yin\",\"tt0188766\"]\n[\"nm015950\",\"Steel Leg\",\"tt0286112\"]\n[\"nm0628806\",null,\"tt0188766\"]\n[\"nm0628806\",\"coach\",\"tt0286112\"]\n[\"nm0156444\",\"PiaoPiao Liu\",\"tt0188766\"]\n[\"nm2514879\",\"Ruolan Li\",\"tt4701660\"]\n```\n\n`配置文件import.conf`，注意每个文件中有两个标题行，因此我们需要指定`HEADER=2`选项。"
            },
            {
                "content": "```json\n{\n  \"schema\": [\n    {\n      \"label\": \"actor\",\n      \"type\": \"VERTEX\",\n      \"properties\": [\n        { \"name\": \"aid\", \"type\": \"STRING\" },\n        { \"name\": \"name\", \"type\": \"STRING\" }\n      ],\n      \"primary\": \"aid\"\n    },\n    {\n      \"label\": \"movie\",\n      \"type\": \"VERTEX\",\n      \"properties\": [\n        { \"name\": \"mid\", \"type\": \"STRING\" },\n        { \"name\": \"name\", \"type\": \"STRING\" },\n        { \"name\": \"year\", \"type\": \"INT16\" },\n        { \"name\": \"rate\", \"type\": \"FLOAT\", \"optional\": true }\n      ],\n      \"primary\": \"mid\"\n    },\n    {\n      \"label\": \"play_in\",\n      \"type\": \"EDGE\",\n      \"properties\": [{ \"name\": \"role\", \"type\": \"STRING\", \"optional\": true }],\n      \"constraints\": [[\"actor\", \"movie\"]]\n    }\n  ],\n  \"files\": [\n    {\n      \"path\": \"actors.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"actor\",\n      \"columns\": [\"aid\", \"name\"]\n    },\n    {\n      \"path\": \"movies.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"movie\","
            },
            {
                "content": "],\n      \"primary\": \"mid\"\n    },\n    {\n      \"label\": \"play_in\",\n      \"type\": \"EDGE\",\n      \"properties\": [{ \"name\": \"role\", \"type\": \"STRING\", \"optional\": true }],\n      \"constraints\": [[\"actor\", \"movie\"]]\n    }\n  ],\n  \"files\": [\n    {\n      \"path\": \"actors.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"actor\",\n      \"columns\": [\"aid\", \"name\"]\n    },\n    {\n      \"path\": \"movies.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"movie\",\n      \"columns\": [\"mid\", \"name\", \"year\", \"rate\"]\n    },\n    {\n      \"path\": \"roles.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"play_in\",\n      \"SRC_ID\": \"actor\",\n      \"DST_ID\": \"movie\",\n      \"columns\": [\"SRC_ID\", \"role\", \"DST_ID\"]\n    }\n  ]\n}\n```"
            },
            {
                "content": "使用导入配置文件，我们现在可以使用以下命令导入数据：\n\n```shell\n$ ./lgraph_import\n        -c import.conf             # 从import.conf读取配置信息\n        --dir /data/lgraph_db      # 将数据存放在/data/lgraph_db\n        --graph mygraph            # 导入名为 mygraph 的图\n```\n\n**注意**：\n\n- 如果名为`mygraph`的图已存在，导入工具将打印错误消息并退出。要强制覆盖图形，可以使用`--overwrite true` 选项。\n- 配置文件和数据文件必须使用 UTF-8 编码（或普通 ASCII 编码，即 UTF-8 的子集）存储。如果任何文件使用 UTF-8 以外的编码（例如，带有 BOM 或 GBK 的 UTF-8）编码，则导入将失败，并输出分析器错误。\n\n## 5.在线增量导入\n\n在线导入模式可用于将一批文件导入已在运行中的 TuGraph 实例中。这对于处理通常以固定的时间间隔进行的增量批处理更新非常便利。`lgraph_import --online true`选项使导入工具能够在线模式工作。与`离线模式`一样，在线模式有自己的命令行选项集，可以使用`-h，--help`选项进行打印输出：\n\n```shell\n$ lgraph_import --online true -h\nAvailable command line options:\n    --online            Whether to import online.\n    -h, --help          Print this help message. Default=0."
            },
            {
                "content": "Available command line options:\n    --log               Log file to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    -c, --config_file   Config file path.\n    -r, --url           DB REST API address.\n    -u, --username      DB username.\n    -p, --password      DB password.\n    -i, --continue_on_error\n                        When we hit a duplicate uid or missing uid, should we\n                        continue or abort. Default=0.\n    -g, --graph         The name of the graph to import into. Default=default.\n    --skip_packages     How many packages should we skip. Default=0.\n    --delimiter         Delimiter used in the CSV files\n    --breakpoint_continue\n                        When the transmission process is interrupted,whether\n                        to re-transmit from zero package next time. Default=false\n    -h, --help          Print this help message. Default=0.\n```"
            },
            {
                "content": "文件的相关配置在配置文件中指定，其格式与`离线模式`完全相同。但是，我们现在不是将数据导入本地数据库，而是将数据发送到正在运行的 TuGraph 实例中，该实例通常运行在与运行导入工具的客户端计算机不同的计算机上。因此，我们需要指定远程计算机的 HTTP 地址的URL、DB用户和密码。\n\n如果用户和密码有效，并且指定的图存在，导入工具将将数据发送到服务器，服务器随后解析数据并将其写入指定的图。数据将以大约 16MB 大小的包发送，在最近的换行符处中断。每个包都是以原子方式导入的，这意味着如果成功导入包，则成功导入所有数据，否则，任何数据都不会进入数据库。如果指定了`--continue_on_error true`，则忽略数据完整性错误，并忽略违规行。否则，导入将在第一个错误包处停止，并打印出已导入的包数。在这种情况下，用户可以修改数据以消除错误，然后使用`--skip_packages N`重做导入以跳过已导入的包。\n\n## 6.在线全量导入\n\n在线全量导入可用于将一批文件导入运行中的TuGraph实例，TuGraph支持将两种不同类型的数据在线导入到实例中：\n1. 和离线导入类型相同的原数据文件（csv等）\n2. TuGraph的底层存储文件，即data.mdb文件，该文件可以由离线导入生成，也可以是其他TuGraph db的文件。\n这两种方式的适用场景不同，第一种是直接将数据导入到TuGraph中，优点是一次性自动导入，操作步骤简单。但是会在server端启动一个离线导入线程，\n只适合单机情况下的小规模数据导入。第二种是将已经准备好的底层存储文件导入到TuGraph中，虽然需要提前准备好mdb文件，但是对系统资源却没有很高的要求，\n而且支持远程下载文件导入，非常方便，适用于高可用模式或者大规模数据的在线导入。"
            },
            {
                "content": "## 6.在线全量导入\n\n在线全量导入可用于将一批文件导入运行中的TuGraph实例，TuGraph支持将两种不同类型的数据在线导入到实例中：\n1. 和离线导入类型相同的原数据文件（csv等）\n2. TuGraph的底层存储文件，即data.mdb文件，该文件可以由离线导入生成，也可以是其他TuGraph db的文件。\n这两种方式的适用场景不同，第一种是直接将数据导入到TuGraph中，优点是一次性自动导入，操作步骤简单。但是会在server端启动一个离线导入线程，\n只适合单机情况下的小规模数据导入。第二种是将已经准备好的底层存储文件导入到TuGraph中，虽然需要提前准备好mdb文件，但是对系统资源却没有很高的要求，\n而且支持远程下载文件导入，非常方便，适用于高可用模式或者大规模数据的在线导入。\n\n### 6.1 从原数据导入\n从原数据导入的执行方式是向运行中的TuGraph实例发送导入请求，\n实例接到请求后先使用离线导入（V3）的方式将数据导入一个临时的db中，然后在实例中新建子图并将临时db的数据文件迁移到新子图中，最后刷新实例的元数据。\n相比在线增量导入，在线全量导入的性能更高。\n`lgraph_import --online true --online_type 1`选项使导入工具能够在线全量导入。\n与`离线模式`一样，在线模式有自己的命令行选项集，可以使用`-h，--help`选项进行打印输出：\n\n```shell\n$ lgraph_import --online true --online_type 1 -h\nAvailable command line options:\n    --online_type       The type of import online, 0 for increment, 1 for full\n                        import data,2 for full import file. Default=0.\n    --v3                Whether to use lgraph import V3. Default=1.\n    -h, --help          Print this help message. Default=0."
            },
            {
                "content": "```shell\n$ lgraph_import --online true --online_type 1 -h\nAvailable command line options:\n    --online_type       The type of import online, 0 for increment, 1 for full\n                        import data,2 for full import file. Default=0.\n    --v3                Whether to use lgraph import V3. Default=1.\n    -h, --help          Print this help message. Default=0.\n\nAvailable command line options:\n    --full              Whether to full import online. Default=0.\n    -h, --help          Print this help message. Default=0."
            },
            {
                "content": "Available command line options:\n    -c, --config_file   Config file path.\n    -r, --url           DB REST API address.\n    -u, --user          DB username.\n    -p, --password      DB password.\n    -i, --continue_on_error\n                        When we hit a duplicate uid or missing uid, should we\n                        continue or abort. Default=0.\n    -g, --graph         The name of the graph to import into. Default=default.\n    --delimiter         Delimiter used in the CSV files. Default=,.\n    --log               Log dir to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    --overwrite         Whether to overwrite the existing DB if it already\n                        exists. Default=0.\n    --parse_block_size  Block size per parse. Default=8388608.\n    --parse_block_threads\n                        How many threads to parse the data block. Default=5."
            },
            {
                "content": "--log               Log dir to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    --overwrite         Whether to overwrite the existing DB if it already\n                        exists. Default=0.\n    --parse_block_size  Block size per parse. Default=8388608.\n    --parse_block_threads\n                        How many threads to parse the data block. Default=5.\n    --parse_file_threadsHow many threads to parse the files. Default=5.\n    --generate_sst_threads\n                        How many threads to generate sst files. Default=15.\n    --read_rocksdb_threads\n                        How many threads to read rocksdb in the final stage.\n                        Default=15.\n    --vid_num_per_reading\n                        How many vertex data to read each time. Default=10000.\n    --max_size_per_reading\n                        Maximum size of kvs per reading. Default=33554432."
            },
            {
                "content": "--generate_sst_threads\n                        How many threads to generate sst files. Default=15.\n    --read_rocksdb_threads\n                        How many threads to read rocksdb in the final stage.\n                        Default=15.\n    --vid_num_per_reading\n                        How many vertex data to read each time. Default=10000.\n    --max_size_per_reading\n                        Maximum size of kvs per reading. Default=33554432.\n    --compact           Whether to compact. Default=0.\n    --keep_vid_in_memoryWhether to keep vids in memory. Default=1.\n    --enable_fulltext_index\n                        Whether to enable fulltext index. Default=0.\n    --fulltext_index_analyzer\n                        fulltext index analyzer. Default=StandardAnalyzer.\n                        Possible values: {<2>: SmartChineseAnalyzer,\n                        StandardAnalyzer}\n    -h, --help          Print this help message. Default=0.\n```"
            },
            {
                "content": "文件的相关配置在配置文件中指定，其格式与`离线模式`完全相同。但是，我们现在不是将数据导入本地数据库，而是将数据导入正在运行的 TuGraph 实例中，\n该实例通常运行在与运行导入工具的客户端计算机不同的计算机上。因此，我们需要指定远程计算机的 HTTP 地址的URL、DB用户和密码。\n并且，配置文件（config_file参数）要求是 TuGraph 实例机器上的uri路径，其file配置也要求是 TuGraph 实例机器上资源的绝对路径。\n\n如果用户和密码有效，导入工具将在服务器端执行在线全量导入。如果想导入的图已存在，可以使用`--overwrite true` 选项强制覆盖子图。\n\n### 6.2 从数据库文件导入\n从原数据在线全量导入尽管操作简单、性能较高，但是对服务器资源要求较高，且耗时较长。\n一种更加通用的方式是先使用离线导入在一个空db中导入子图，得到data.mdb文件，然后把该文件在线导入到\nTuGraph服务中。其使用方式如下所示：\n\n```shell\n$ ./lgraph_import --online true --online_type 2 -h\nAvailable command line options:\n    --online            Whether to import online. Default=0.\n    --v3                Whether to use lgraph import V3. Default=1.\n    -h, --help          Print this help message. Default=0.\n\nAvailable command line options:\n    --online_type       The type of import online, 0 for increment, 1 for full\n                        import data,2 for full import file. Default=0.\n    -h, --help          Print this help message. Default=0."
            },
            {
                "content": "Available command line options:\n    --online_type       The type of import online, 0 for increment, 1 for full\n                        import data,2 for full import file. Default=0.\n    -h, --help          Print this help message. Default=0.\n\nAvailable command line options:\n    -r, --url           DB REST API address.\n    -u, --user          DB username.\n    -p, --password      DB password.\n    -g, --graph         The name of the graph to import into. Default=default.\n    --path              The path of data file.\n    --remote            Whether to download file from remote server. Default=0.\n    -h, --help          Print this help message. Default=0.\n```\n\n除普通在线导入用到的url, user和password参数之外，从数据库文件导入的在线全量导入方式\n使用graph参数指定导入的子图名称，path参数指定文件路径，remote指定文件存在在远程或者本地。\n如果是本地文件，则需要保证HA集群中所有的节点在path路径下都有该文件。如果是远程文件，则会先下载再导入。\n需要注意的是，由于data.mdb只有一份，需要保证HA的各个节点和离线导入生成data.mdb的机器的环境完全一致，\n以保证不会出现环境问题。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/2.data-export.md",
        "chunks": [
            {
                "content": "# 数据导出\n\n> 此文档主要介绍 TuGraph 的数据导出功能。\n\n## 1.简介\n\nTuGraph 可以通过 `lgraph_export` 工具来对已经存放在TuGraph的图数据进行数据导出。 `lgraph_export` 工具可以将指定 TuGraph 数据库的数据以 `csv` 或者 `json` 文件形式导出到指定目录，同时导出这些数据进行再导入时需要的配置文件 `import.config` ，详细描述可参见[配置文件](1.data-import.md)。\n\n## 2.导出命令\n\n该工具的命令示例如下：\n\n```bash\n$ lgraph_export -d {database_dir} -e {export_destination_dir} -g {graph_to_use} -u {username} -p {password} -f {output_format}\n```\n\n其中：\n\n- `-d {database_dir}` 指定需要进行数据导出的数据库所在目录，默认值为 `./testdb`。\n- `-e {export_destination_dir}` 指定导出文件存放的目录，默认值为 `./exportdir`。\n- `-g {graph_to_use}` 指定图数据库的种类，默认为 `default` 。\n- `-u {username}` 指定进行该导出操作的用户的用户名。\n- `-p {password}` 指定进行该导出操作的用户的用户密码。\n- `-s {field_separator}` 指定导出文件的分隔符，默认为逗号。\n- `-f {output_format}` 指定导出数据的格式，`json`或者`csv`，默认为`csv`。\n- `-h` 除上述指定参数外，也可以使用该参数查看该工具的使用帮助。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/3.backup-and-restore.md",
        "chunks": [
            {
                "content": "# 备份恢复\n\n> 此文档主要介绍 TuGraph 的数据备份和恢复功能。\n\n## 1.数据备份\n\nTuGraph 可以通过 `lgraph_backup` 工具来进行数据备份。\n`lgraph_backup` 工具可以将一个 TuGraph 数据库中的数据备份到另一个目录下，它的用法如下：\n\n```bash\n$ lgraph_backup -s {source_dir} -d {destination_dir} -c {true/false}\n```\n\n其中：\n\n- `-s {source_dir}` 指定需要备份的数据库（源数据库）所在目录。\n- `-d {destination_dir}` 指定备份文件（目标数据库）所在目录。\n  如果目标数据库不为空，`lgraph_backup` 会提示是否覆盖该数据库。\n- `-c {true/false}` 指明是否在备份过程中进行 compaction。\n  compaction 能使产生的备份文件更紧凑，但备份时间也会变长。该选项默认为 `true`。\n\n## 2.数据恢复\n\n使用`lgraph_backup` 工具得到的目标数据库`{destination_dir}`备份了源数据库\n`{source_dir}`的所有子图，但不包含HA集群的raft信息，从而保证服务和集群能\n以备份数据库成功重启并与源数据库的数据一致。使用如下命令可以用备份数据库重启服务，\n在服务启动时会恢复所有子图的存储过程，保证备份服务和原服务完全一致。\n\n```bash\n$ lgraph_server -c lgraph.json --directory {destination_dir} -d start\n```\n\n其中：\n\n- `-d {destination_dir}` 指定备份文件（目标数据库）所在目录。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/4.data-warmup.md",
        "chunks": [
            {
                "content": "# 数据预热\n\n> 此文档主要介绍 TuGraph 的数据预热功能。\n\n## 1.简介\n\nTuGraph 是基于磁盘的数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。\n\n## 1.数据预热命令\n\n数据预热可以通过工具 `lgraph_warmup` 来进行。它的使用示例如下：\n\n```bash\n$ lgraph_warmup -d {directory} -g {graph_list}\n```\n\n其中：\n\n- `-d {db_dir}` 选项指定了 TuGraph 服务器的数据目录\n\n- `-g {graph_list}` 选项指定需要进行数据预热的图名称，用逗号分隔\n\n根据数据大小和所使用的磁盘类型不同，预热过程运行时间也不同。机械磁盘上预热一个大数据库可能耗时较长，请耐心等待。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/5.ha-cluster-management.md",
        "chunks": [
            {
                "content": "# 集群管理\n\n> 此文档主要介绍 TuGraph HA 集群的管理工具，主要包括删除节点、leader转移和生成snapshot功能\n\n## 1. 简介\n\nHA集群启动之后，可以使用`lgraph_peer`工具进行集群管理，可以执行删除节点，转移leader和生成snapshot等功能。\n\n## 2. 删除节点\n\n对于TuGraph HA集群中长期离线或者产生网络分区的节点，可以使用`lgraph_peer`的`remove_peer`命令删除节点。命令示例如下所示：\n```shell\n$ lgraph_peer --command remove_peer --peer {peer_id} --conf {group_conf}\n```\n\n其中：\n\n- `--command remove_peer` 指定要执行的操作为remove_peer，即删除节点。\n- `--peer {peer_id}` 指定要删除节点的rpc网络地址，如 `127.0.0.1:9092`。\n- `--conf {group_conf}` 指定HA集群的成员配置（可连通主节点即可），如 `127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094` 。\n\n## 3. leader 转移\n\n当需要对主节点执行停机或重启操作时，为减少集群的不可服务时间，可以使用`lgraph_peer`的`transfer_leader`命令转移主节点。命令示例如下所示：\n\n```shell\n$ lgraph_peer --command transfer_leader --peer {peer_id} --conf {group_conf}\n```\n\n其中：\n\n- `--command transfer_leader` 指定要执行的操作为transfer_leader，即转移主节点。\n- `--peer {peer_id}` 指定要成为主节点的rpc网络地址，如 `127.0.0.1:9092`。\n- `--conf {group_conf}` 指定HA集群的成员配置（可连通主节点即可），如 `127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094` 。\n\n## 4. 生成snapshot"
            },
            {
                "content": "## 3. leader 转移\n\n当需要对主节点执行停机或重启操作时，为减少集群的不可服务时间，可以使用`lgraph_peer`的`transfer_leader`命令转移主节点。命令示例如下所示：\n\n```shell\n$ lgraph_peer --command transfer_leader --peer {peer_id} --conf {group_conf}\n```\n\n其中：\n\n- `--command transfer_leader` 指定要执行的操作为transfer_leader，即转移主节点。\n- `--peer {peer_id}` 指定要成为主节点的rpc网络地址，如 `127.0.0.1:9092`。\n- `--conf {group_conf}` 指定HA集群的成员配置（可连通主节点即可），如 `127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094` 。\n\n## 4. 生成snapshot\n\n出于节点启动时设置ha_snapshot_interval_s为-1以默认不打snapshot或其他原因，\n当需要让某个节点手动生成snapshot时，可以使用`lgraph_peer`的`snapshot`命令。命令示例如下所示：\n\n```shell\n$ lgraph_peer --command snapshot --peer {peer_id}\n```\n\n其中：\n\n- `--command snapshot` 指定要执行的操作为snapshot，即生成快照。\n- `--peer {peer_id}` 指定要生成快照的节点的rpc网络地址，如 `127.0.0.1:9092`。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/6.tugraph-cli.md",
        "chunks": [
            {
                "content": "# 命令行工具\n\n> 此文档主要介绍 lgraph_cypher 文档的使用，注意不再更新维护，请使用 [lgraph_cli](../7.client-tools/6.bolt-console-client.md)\n\nTuGraph 发布版本附带名为`lgraph_cypher`的查询客户端，可用于向 TuGraph 服务器提交 OpenCypher 请求。`lgraph_cypher`客户端有两种执行模式：单命令模式和交互式模式。\n\n## 1.单命令模式\n\n在单命令模式下，`lgraph_cypher`可用于提交单个 Cypher 查询并将结果直接打印到终端，打印结果也可以容易地重定向写入指定文件。当用户需要从服务器获取大量结果并将其保存在文件中时，这非常便利。\n在此模式下，`lgraph_cypher`工具具有以下选项：\n\n### 1.1.命令行参数:"
            },
            {
                "content": "| 参数     | 类型   | 说明                                                                     |\n| -------- | ------ | ------------------------------------------------------------------------ | ------ | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| --help   | \\\\     | 列出所有参数及说明。                                                     |\n| -example | \\\\     | 列出命令实例。                                                           |\n| -c       | string | 数据库的配置文件，用于获取 ip 与 port 信息。                             |\n| -h       | string | 数据库服务器 ip 地址，如有配置文件则可舍去此参数。默认值为`127.0.0.1` 。 |\n| -p       | string | 数据库服务器端口，如有配置文件则可舍去此参数。默认值为`7071` 。          |\n| -u       | string | 数据库登录用户名。                                                       |\n| -P       | string | 数据库登录密码。                                                         |\n| -f       | string | 包含单条 Cypher 查询单文本文件的路径。                                   |"
            },
            {
                "content": "| -c       | string | 数据库的配置文件，用于获取 ip 与 port 信息。                             |\n| -h       | string | 数据库服务器 ip 地址，如有配置文件则可舍去此参数。默认值为`127.0.0.1` 。 |\n| -p       | string | 数据库服务器端口，如有配置文件则可舍去此参数。默认值为`7071` 。          |\n| -u       | string | 数据库登录用户名。                                                       |\n| -P       | string | 数据库登录密码。                                                         |\n| -f       | string | 包含单条 Cypher 查询单文本文件的路径。                                   |\n| -s       | string | 单行 cypher 查询命令。以`\"`开头结尾。                                    |\n| -t       | int    | 进行 cypher 查询时服务器的超时阈值。默认值为`150`秒。 -format            | string | 查询结果显示模式。支持`plain`与`table`两种格式。`plain`格式会将查询结果单列打印。`table`格式会将查询结果以表格方式显示。默认值为`table`。 |"
            },
            {
                "content": "### 1.2.命令示例:\n\n**cypher 命令文件查询：**\n\n```powershell\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u user -P password -f /home/usr/cypher.json\n```\n\n**cypher 命令单句查询：**\n\n```powershell\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u user -P password -s \"MATCH (n) RETURN n\"\n```\n\n## 2.交互模式\n\n`lgraph_cypher`也可以在交互模式下运行。在交互式模式下，客户端与服务器保持连接，并在读取-评估-打印-循环中与用户进行交互。\n\n### 2.1.进入 lgraph_cypher 交互模式:\n\n如不加`-f`或`-s`命令行选项，运行`lgraph_cypher`时将会进入交互模式。使用方式如下：\n\n```\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u admin -P 73@TuGraph\n```\n\n如成功进入则会显示相应登录成功信息："
            },
            {
                "content": "**cypher 命令单句查询：**\n\n```powershell\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u user -P password -s \"MATCH (n) RETURN n\"\n```\n\n## 2.交互模式\n\n`lgraph_cypher`也可以在交互模式下运行。在交互式模式下，客户端与服务器保持连接，并在读取-评估-打印-循环中与用户进行交互。\n\n### 2.1.进入 lgraph_cypher 交互模式:\n\n如不加`-f`或`-s`命令行选项，运行`lgraph_cypher`时将会进入交互模式。使用方式如下：\n\n```\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u admin -P 73@TuGraph\n```\n\n如成功进入则会显示相应登录成功信息：\n\n```\n**********************************************************************\n*                  TuGraph Graph Database X.Y.Z                      *\n*                                                                    *\n*        Copyright(C) 2023 Ant Group. All rights reserved.           *\n*                                                                    *\n**********************************************************************\nlogin success\n----------------------------------\nHost: 127.0.0.1\nPort: 7071\nUsername: admin\n----------------------------------\ntype \":help\" to see all commands.\n>\n```"
            },
            {
                "content": "现在我们也提供一个交互式 shell ，用于用户输入 Cypher 查询语句或使用`:help`命令来检查可用命令。\n\n### 2.2.command种类与说明:\n\n除 Cypher 查询外，`lgraph_cypher` 的 shell 还接受以下命令："
            },
            {
                "content": "| 命令                     | 对应参数                           | 说明                                                                                                |\n| ------------------------ | ---------------------------------- | --------------------------------------------------------------------------------------------------- |\n| :help                    | \\\\                                 | 显示服务器信息与所有 command 对应说明。                                                             |\n| :db_info                 | \\\\                                 | 当前服务器状态查询。对应 REST API 的/db/info。                                                      |\n| :clear                   | \\\\                                 | 清空屏幕。                                                                                          |\n| :use                     | {图的名称}                         | 使用该名称指定的图，默认值为`default` 。                                                            |"
            },
            {
                "content": "| :db_info                 | \\\\                                 | 当前服务器状态查询。对应 REST API 的/db/info。                                                      |\n| :clear                   | \\\\                                 | 清空屏幕。                                                                                          |\n| :use                     | {图的名称}                         | 使用该名称指定的图，默认值为`default` 。                                                            |\n| :source                  | `-t {查询timeout值} -f {查询文件}` | 可交互模式下的 cypher 命令文件查询。超时阈值默认值为`150`秒。查询文件格式参考无交互式查询参数。     |\n| :exit                    | \\\\                                 | 退出交互模式并返回原命令行。                                                                        |\n| :format                  | `plain` or `table`                 | 更改 cypher 查询结果的显示模式。支持`plain`与`table`模式。                                          |\n| :save all/command/result | `-f {文件路径}` `{cypher语句}`     | 存储 cypher 命令（command）或查询结果（result）或以上二者（all）。默认存储位置为`/saved_cypher.txt` |"
            },
            {
                "content": "**注意:**\n\n- 每条命令都应该以冒号开始 `:`.\n\n**:save 命令例子:**\n\n```\n:save all -f /home/usr/saved.txt match (n) where return n, n.name limit 1000\n```\n\n### 2.3.cypher 查询命令:\n\n在交互模式下，用户也可直接输入单句 cypher 命令进行查询，以\"`;`\"结束。输入命令不区分大小写。例子如下：\n\n```\nlogin success\n>MATCH (n) RETURN n, n.name;\n+---+---+-------------+\n|   | n |n.name       |\n+---+---+-------------+\n| 0 | 0 |david        |\n| 1 | 1 |Ann          |\n| 2 | 2 |first movie  |\n| 3 | 3 |Andres       |\n+---+---+-------------+\ntime spent: 0.000520706176758\nsize of query: 4\n>\n```\n\n`lgraph_cypher`输入命令时支持多行输入，用户可使用`ENTER`键将长查询语句分多行输入。多行输入情况下命令行开头会从`>`变为`=>`，然后用户可以继续输入查询的其余部分。\n\n例子如下：\n\n```\nlogin success\n>MATCH (n)\n=>WHERE n.uid='M11'\n=>RETURN n, n.name;\n```\n\n### 2.4.辅助功能:\n\n**历史查询：** 在交互模式下按上下方向键可查询输入历史。\n\n**自动补全：** lgraph_cypher 会根据输入历史进行自动补全。在补全提示出现的情况下，按下右方向键就会自动补全命令。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/7.tugraph-datax.md",
        "chunks": [
            {
                "content": "# TuGraph-DataX\n\n> 此文档主要介绍 TuGraph DataX 的安装编译和使用示例\n\n## 1.简介\n\nTuGraph 在阿里开源的 DataX 基础上添加了 TuGraph 的写插件以及 TuGraph jsonline 数据格式的支持，其他数据源可以通过 DataX 往 TuGraph 里面写数据。\nTuGraph DataX 介绍 [https://github.com/TuGraph-family/DataX](https://github.com/TuGraph-family/DataX)，支持的功能包括：\n\n- 从 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源导入 TuGraph\n- 将 TuGraph 导入相应的目标源 （待开发）\n\n![导入导出](../../../images/tugraph-datax.png)\n\nDataX 原始项目介绍参考 [https://github.com/alibaba/DataX](https://github.com/alibaba/DataX)\n\n## 2.编译安装\n\n```bash\ngit clone https://github.com/TuGraph-family/DataX.git\nyum install maven\nmvn -U clean package assembly:assembly -Dmaven.test.skip=true\n```\n\n编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`"
            },
            {
                "content": "DataX 原始项目介绍参考 [https://github.com/alibaba/DataX](https://github.com/alibaba/DataX)\n\n## 2.编译安装\n\n```bash\ngit clone https://github.com/TuGraph-family/DataX.git\nyum install maven\nmvn -U clean package assembly:assembly -Dmaven.test.skip=true\n```\n\n编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`\n\n```\ntt0188766,King of Comedy,1999,7.3\ntt0286112,Shaolin Soccer,2001,7.3\ntt4701660,The Mermaid,2016,6.3\n```\n\n`roles.csv`\n\n```\nnm015950,Tianchou Yin,tt0188766\nnm015950,Steel Leg,tt0286112\nnm0628806,,tt0188766\nnm0628806,coach,tt0286112\nnm0156444,PiaoPiao Liu,tt0188766\nnm2514879,Ruolan Li,tt4701660\n```\n\n然后建三个 DataX 的 job 配置文件：\n`job_actors.json`"
            },
            {
                "content": "然后建三个 DataX 的 job 配置文件：\n`job_actors.json`\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"actors.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"actor\",\n            \"batchNum\": 1000,\n            \"properties\": [\"aid\", \"name\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`job_movies.json`"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"movies.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\","
            },
            {
                "content": "\"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`job_roles.json`"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"roles.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,"
            },
            {
                "content": "{\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,\n            \"properties\": [\"SRC_ID\", \"role\", \"DST_ID\"],\n            \"startLabel\": {\"type\": \"actor\", \"key\": \"SRC_ID\"},\n            \"endLabel\": {\"type\": \"movie\", \"key\": \"DST_ID\"}\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后依次执行如下三个命令：\n\n```\npython3 datax/bin/datax.py  job_actors.json\n```\n\n```\npython3 datax/bin/datax.py  job_movies.json\n```\n\n```\npython3 datax/bin/datax.py  job_roles.json\n```\n\n### 3.2.MySQL数据通过DataX导入TuGraph\n\n我们在 `test` database 下建立如下电影 `movies` 表\n\n```sql\nCREATE TABLE `movies` (\n  `mid`  varchar(200) NOT NULL,\n  `name` varchar(100) NOT NULL,\n  `year` int(11) NOT NULL,\n  `rate` float(5,2) unsigned NOT NULL,\n  PRIMARY KEY (`mid`)\n);\n```\n\n往表中插入几条数据\n\n```sql\ninsert into\ntest.movies (mid, name, year, rate)\nvalues\n('tt0188766', 'King of Comedy', 1999, 7.3),\n('tt0286112', 'Shaolin Soccer', 2001, 7.3),\n('tt4701660', 'The Mermaid',   2016,  6.3);\n```\n\n建立一个 DataX 的 job 配置文件\n\n`job_mysql_to_tugraph.json`\n\n**配置字段方式**"
            },
            {
                "content": "**配置字段方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"column\": [\"mid\", \"name\", \"year\", \"rate\"],\n            \"splitPk\": \"mid\",\n            \"connection\": [\n              {\n                \"table\": [\"movies\"],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n**写简单 sql 方式**"
            },
            {
                "content": "**写简单 sql 方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"connection\": [\n              {\n                \"querySql\": [\n                  \"select mid, name, year, rate from test.movies where year > 2000;\"\n                ],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后执行如下命令：\n\n```shell\npython3 datax/bin/datax.py  job_mysql_to_tugraph.json\n```\n\n## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中"
            },
            {
                "content": "## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中\n\n```json\n{\n    \"job\": {\n        \"setting\": {\n            \"speed\": {\n                 \"channel\":1\n            }\n        },\n        \"content\": [\n            {\n                \"reader\": {\n                    \"name\": \"tugraphreader\",\n                    \"parameter\": {\n                        \"username\": \"admin\",\n                        \"password\": \"73@TuGraph\",\n                        \"graphName\": \"Movie_8C5C\",\n                        \"queryCypher\": \"match (n:person) return n.id,n.name,n.born;\",\n                        \"url\": \"bolt://127.0.0.1:27687\"\n                    }\n                },\n                \"writer\": {\n                    \"name\": \"txtfilewriter\",\n                    \"parameter\": {\n                        \"path\": \"./result\",\n                        \"fileName\": \"luohw\",\n                        \"writeMode\": \"truncate\"\n                    }\n                }\n            }\n        ]\n    }\n}\n```"
            },
            {
                "content": "使用这个配置文件，可以把TuGraph Movie_8C5C子图中person节点的id,name和born属性全部导出出来，\n导出到当前目录下的result目录中，文件名称为luohw+随机后缀。\n\n### 4.2.参数说明\n\n在使用DataX导出TuGraph数据时，需要将reader设置为tugraphreader并配置以下5个参数：\n\n* **url**\n    * 描述：TuGraph的bolt server地址 \n    * 必选：是 \n    * 默认值：无 \n\n* **username**\n    * 描述：TuGraph的用户名 \n    * 必选：是 \n    * 默认值：无 \n\n* **password**\n    * 描述：TuGraph的密码 \n    * 必选：是 \n    * 默认值：无 \n\n* **graphName**\n    * 描述：所选取的需要同步的TuGraph子图 \n    * 必选：是 \n    * 默认值：无 \n\n* **queryCypher**\n    * 描述：通过cypher语句读取TuGraph中的数据 \n    * 必选：否 \n    * 默认值：无"
            },
            {
                "content": "# TuGraph-DataX\n\n> 此文档主要介绍 TuGraph DataX 的安装编译和使用示例\n\n## 1.简介\n\nTuGraph 在阿里开源的 DataX 基础上添加了 TuGraph 的写插件以及 TuGraph jsonline 数据格式的支持，其他数据源可以通过 DataX 往 TuGraph 里面写数据。\nTuGraph DataX 介绍 [https://github.com/TuGraph-family/DataX](https://github.com/TuGraph-family/DataX)，支持的功能包括：\n\n- 从 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源导入 TuGraph\n- 将 TuGraph 导入相应的目标源 （待开发）\n\n![导入导出](../../../images/tugraph-datax.png)\n\nDataX 原始项目介绍参考 [https://github.com/alibaba/DataX](https://github.com/alibaba/DataX)\n\n## 2.编译安装\n\n```bash\ngit clone https://github.com/TuGraph-family/DataX.git\nyum install maven\nmvn -U clean package assembly:assembly -Dmaven.test.skip=true\n```\n\n编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`"
            },
            {
                "content": "DataX 原始项目介绍参考 [https://github.com/alibaba/DataX](https://github.com/alibaba/DataX)\n\n## 2.编译安装\n\n```bash\ngit clone https://github.com/TuGraph-family/DataX.git\nyum install maven\nmvn -U clean package assembly:assembly -Dmaven.test.skip=true\n```\n\n编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`\n\n```\ntt0188766,King of Comedy,1999,7.3\ntt0286112,Shaolin Soccer,2001,7.3\ntt4701660,The Mermaid,2016,6.3\n```\n\n`roles.csv`\n\n```\nnm015950,Tianchou Yin,tt0188766\nnm015950,Steel Leg,tt0286112\nnm0628806,,tt0188766\nnm0628806,coach,tt0286112\nnm0156444,PiaoPiao Liu,tt0188766\nnm2514879,Ruolan Li,tt4701660\n```\n\n然后建三个 DataX 的 job 配置文件：\n`job_actors.json`"
            },
            {
                "content": "然后建三个 DataX 的 job 配置文件：\n`job_actors.json`\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"actors.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"actor\",\n            \"batchNum\": 1000,\n            \"properties\": [\"aid\", \"name\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`job_movies.json`"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"movies.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\","
            },
            {
                "content": "\"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`job_roles.json`"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"roles.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,"
            },
            {
                "content": "{\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,\n            \"properties\": [\"SRC_ID\", \"role\", \"DST_ID\"],\n            \"startLabel\": {\"type\": \"actor\", \"key\": \"SRC_ID\"},\n            \"endLabel\": {\"type\": \"movie\", \"key\": \"DST_ID\"}\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后依次执行如下三个命令：\n\n```\npython3 datax/bin/datax.py  job_actors.json\n```\n\n```\npython3 datax/bin/datax.py  job_movies.json\n```\n\n```\npython3 datax/bin/datax.py  job_roles.json\n```\n\n### 3.2.MySQL数据通过DataX导入TuGraph\n\n我们在 `test` database 下建立如下电影 `movies` 表\n\n```sql\nCREATE TABLE `movies` (\n  `mid`  varchar(200) NOT NULL,\n  `name` varchar(100) NOT NULL,\n  `year` int(11) NOT NULL,\n  `rate` float(5,2) unsigned NOT NULL,\n  PRIMARY KEY (`mid`)\n);\n```\n\n往表中插入几条数据\n\n```sql\ninsert into\ntest.movies (mid, name, year, rate)\nvalues\n('tt0188766', 'King of Comedy', 1999, 7.3),\n('tt0286112', 'Shaolin Soccer', 2001, 7.3),\n('tt4701660', 'The Mermaid',   2016,  6.3);\n```\n\n建立一个 DataX 的 job 配置文件\n\n`job_mysql_to_tugraph.json`\n\n**配置字段方式**"
            },
            {
                "content": "**配置字段方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"column\": [\"mid\", \"name\", \"year\", \"rate\"],\n            \"splitPk\": \"mid\",\n            \"connection\": [\n              {\n                \"table\": [\"movies\"],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n**写简单 sql 方式**"
            },
            {
                "content": "**写简单 sql 方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"connection\": [\n              {\n                \"querySql\": [\n                  \"select mid, name, year, rate from test.movies where year > 2000;\"\n                ],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后执行如下命令：\n\n```shell\npython3 datax/bin/datax.py  job_mysql_to_tugraph.json\n```\n\n## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中"
            },
            {
                "content": "## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中\n\n```json\n{\n    \"job\": {\n        \"setting\": {\n            \"speed\": {\n                 \"channel\":1\n            }\n        },\n        \"content\": [\n            {\n                \"reader\": {\n                    \"name\": \"tugraphreader\",\n                    \"parameter\": {\n                        \"username\": \"admin\",\n                        \"password\": \"73@TuGraph\",\n                        \"graphName\": \"Movie_8C5C\",\n                        \"queryCypher\": \"match (n:person) return n.id,n.name,n.born;\",\n                        \"url\": \"bolt://127.0.0.1:27687\"\n                    }\n                },\n                \"writer\": {\n                    \"name\": \"txtfilewriter\",\n                    \"parameter\": {\n                        \"path\": \"./result\",\n                        \"fileName\": \"luohw\",\n                        \"writeMode\": \"truncate\"\n                    }\n                }\n            }\n        ]\n    }\n}\n```"
            },
            {
                "content": "使用这个配置文件，可以把TuGraph Movie_8C5C子图中person节点的id,name和born属性全部导出出来，\n导出到当前目录下的result目录中，文件名称为luohw+随机后缀。\n\n### 4.2.参数说明\n\n在使用DataX导出TuGraph数据时，需要将reader设置为tugraphreader并配置以下5个参数：\n\n* **url**\n    * 描述：TuGraph的bolt server地址 \n    * 必选：是 \n    * 默认值：无 \n\n* **username**\n    * 描述：TuGraph的用户名 \n    * 必选：是 \n    * 默认值：无 \n\n* **password**\n    * 描述：TuGraph的密码 \n    * 必选：是 \n    * 默认值：无 \n\n* **graphName**\n    * 描述：所选取的需要同步的TuGraph子图 \n    * 必选：是 \n    * 默认值：无 \n\n* **queryCypher**\n    * 描述：通过cypher语句读取TuGraph中的数据 \n    * 必选：否 \n    * 默认值：无"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/8.tugraph-explorer.md",
        "chunks": [
            {
                "content": "# TuGraph-Explorer\n\n> TuGraph Explorer 已经合并到 [TuGraph Browser](../4.user-guide/1.tugraph-browser.md)"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/9.restful.md",
        "chunks": [
            {
                "content": "# TuGraph-Restful-Server\n\n> TuGraph Restful Server 强依赖 TuGraph，Restful Server 与 Tugraph 共存\n\n## 1.TuGraph-Restful-Server 简介\nTuGraph Restful Server 使用brpc框架支持的http协议，提供restful接口查询功能，在实现中，restful server 与rpc server 使用同一个端口。目前restful接口提供文件上传，数据导入，导入进度查询，cypher查询，文件删除等功能\n\n## 2.启动 TuGraph-Restful-Server\n需要在启动Tugraph时设置enable_rpc参数为true的方式，正常启动TuGraph\n\n## 3.连接 TuGraph-Restful-Server\nTuGraph正常启动后，Restful Server 将监听在rpc_port上， 通过访问 http://${ip}:${rpc_port}/LGraphHttpService/Query/ url可以链接到TuGraph\n\n## 4.数据格式\n客户端与服务端数据交互的格式是 JSON。在发送请求时，请将发送数据的请求的报头设置为 `Accept:application/json, Content-Type:application/json`。\n例如在创建一个点时，请求报头包含以下内容：\n\n```\n    Accept: application/json; charset=UTF-8\n    Content-Type: application/json\n    server_version: 12\n```\n\n## 5.返回值\n\n通用返回格式\n\n|  body参数  | 参数说明  |  参数类型  |  是否必填  |\n|:--------:|:-----:|:------:| :-----: |\n| errorCode |  状态码  |  字符串  |  是  |\n| errorMessage | 错误信息  |  字符串  |  是  |\n| data | 返回的数据 |  字符串  |  是  |\n\nTuGraph 返回的 HTTP 状态码包含以下四种："
            },
            {
                "content": "## 4.数据格式\n客户端与服务端数据交互的格式是 JSON。在发送请求时，请将发送数据的请求的报头设置为 `Accept:application/json, Content-Type:application/json`。\n例如在创建一个点时，请求报头包含以下内容：\n\n```\n    Accept: application/json; charset=UTF-8\n    Content-Type: application/json\n    server_version: 12\n```\n\n## 5.返回值\n\n通用返回格式\n\n|  body参数  | 参数说明  |  参数类型  |  是否必填  |\n|:--------:|:-----:|:------:| :-----: |\n| errorCode |  状态码  |  字符串  |  是  |\n| errorMessage | 错误信息  |  字符串  |  是  |\n| data | 返回的数据 |  字符串  |  是  |\n\nTuGraph 返回的 HTTP 状态码包含以下四种：\n\n- 200 OK: 操作成功\n- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误\n- 401 Unauthorized: 未通过鉴权认证，例如用户名密码错误，token超过有效期等\n- 500 Internal Server Error: 服务器端错误\n  当操作成功时，返回的 data 中包含操作的返回值。\n  当发生输入错误或者服务器错误时，返回的 errorMessage 中包含错误提示。\n\n## 6.URI格式"
            },
            {
                "content": "## 5.返回值\n\n通用返回格式\n\n|  body参数  | 参数说明  |  参数类型  |  是否必填  |\n|:--------:|:-----:|:------:| :-----: |\n| errorCode |  状态码  |  字符串  |  是  |\n| errorMessage | 错误信息  |  字符串  |  是  |\n| data | 返回的数据 |  字符串  |  是  |\n\nTuGraph 返回的 HTTP 状态码包含以下四种：\n\n- 200 OK: 操作成功\n- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误\n- 401 Unauthorized: 未通过鉴权认证，例如用户名密码错误，token超过有效期等\n- 500 Internal Server Error: 服务器端错误\n  当操作成功时，返回的 data 中包含操作的返回值。\n  当发生输入错误或者服务器错误时，返回的 errorMessage 中包含错误提示。\n\n## 6.URI格式\n\n| URI               | 说明                 |\n|-------------------|--------------------|\n| /cypher           | 执行cypher查询请求       |\n| /refresh          | 刷新token请求          |\n| /login            | 用户登陆请求             |\n| /logout           | 用户登出请求             |\n| /upload_files     | 上传文件请求             |\n| /clear_cache      | 清理用户上传文件请求         |\n| /check_file       | 文件认证请求             |\n| /import_data      | 数据导入请求             |\n| /import_progress  | 导入进度查询请求           |\n| /import_schema    | 批量创建schema请求       |"
            },
            {
                "content": "## 7.接口\n### 7.1 用户登陆\n用于用户第一次与服务端通信时的鉴权操作，请求报文在 http body 中携带用户名和密码，响应报文在 http body 中会返回一个带有有效期的token，后续请求中需要在http header中携带该token作为凭证\n#### 7.1.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/login\n#### 7.1.2 REQUEST\n|  body参数  |  参数说明  |  参数类型  |  是否必填  |\n|:--------:|:------:|:------:| :-----: |\n | userName |  用户名  |  字符串  |  是  |\n | password |   密码   |  字符串  |  是  |\n#### 7.1.3 RESPONSE\n|    body参数     | 参数说明  |  参数类型  |  是否必填  |\n|:-------------:|:-----:|:------:| :-----: |\n| authorization | token |  字符串  |  是  |\n\n### 7.2 刷新token\ntoken到期后将无法使用此token与服务端正常通信，需要获取新的token作为后续请求的凭证，请求报文在http header中携带旧的token，响应报文在http body中返回新的token\n#### 7.2.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/refresh\n#### 7.2.2 REQUEST\n|   header参数    |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| Authorization | 旧的token |  字符串  |  是  |"
            },
            {
                "content": "### 7.2 刷新token\ntoken到期后将无法使用此token与服务端正常通信，需要获取新的token作为后续请求的凭证，请求报文在http header中携带旧的token，响应报文在http body中返回新的token\n#### 7.2.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/refresh\n#### 7.2.2 REQUEST\n|   header参数    |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| Authorization | 旧的token |  字符串  |  是  |\n\n#### 7.2.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| authorization | 新的token |  字符串  |  是  |\n\n### 7.3 用户登出\n用户不再需要与服务端进行通信时，需要请求登出接口，释放自己的token。请求报文在http header中携带旧的token，如果拿到返回errorCode为200的响应报文即为正常登出\n#### 7.3.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/logout\n#### 7.3.2 REQUEST\n|   header参数    |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| Authorization | 旧的token |  字符串  |  是  |"
            },
            {
                "content": "#### 7.2.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| authorization | 新的token |  字符串  |  是  |\n\n### 7.3 用户登出\n用户不再需要与服务端进行通信时，需要请求登出接口，释放自己的token。请求报文在http header中携带旧的token，如果拿到返回errorCode为200的响应报文即为正常登出\n#### 7.3.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/logout\n#### 7.3.2 REQUEST\n|   header参数    |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| Authorization | 旧的token |  字符串  |  是  |\n\n### 7.4 执行cypher查询请求\n用户通过此类请求发cypher给server端执行并获取执行结果，请求报文在http body 中将执行的cypher语句和目标子图发送给server，server执行完成后在响应报文的http body中返回执行结果\n#### 7.4.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/cypher\n\n#### 7.4.2 REQUEST\n| body参数 |    参数说明    |  参数类型  |  是否必填  |\n|:------:|:----------:|:------:| :-----: |\n| graph  |   查询目标子图   |  字符串  |  是  |\n| script | cypher查询语句 |  字符串  |  是  |\n\n#### 7.4.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| result | 返回结果 |  字符串  |  是  |"
            },
            {
                "content": "#### 7.4.2 REQUEST\n| body参数 |    参数说明    |  参数类型  |  是否必填  |\n|:------:|:----------:|:------:| :-----: |\n| graph  |   查询目标子图   |  字符串  |  是  |\n| script | cypher查询语句 |  字符串  |  是  |\n\n#### 7.4.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| result | 返回结果 |  字符串  |  是  |\n\n### 7.5 上传文件请求\n用户通过此类请求向server发送文件，可以对文件进行分片，分片大小不大于1MB，支持多线程乱序发送，请求报文在http header 中包含文件名，第一字节内容在文件中的偏移和分片大小，在body中包含文件内容，server收到请求后将验证分片大小是否与分片内容一致，一致时将文件分段写入文件。不一致时将返回errorCode为400的响应\n#### 7.5.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/upload_files\n\n#### 7.5.2 REQUEST\n| header参数  |    参数说明    |  参数类型  |  是否必填  |\n|:---------:|:----------:|:------:| :-----: |\n| File-Name |   文件名   |  字符串  |  是  |\n| Begin-Pos | 开始位置在文件内的偏移 |  字符串  |  是  |\n|   Size    | 文件分片大小 |  字符串  |  是  |\n|  body参数   |  参数说明   |  参数类型  |  是否必填  |\n|     -     | 文件内容 |  字符串  |  是  |"
            },
            {
                "content": "#### 7.5.2 REQUEST\n| header参数  |    参数说明    |  参数类型  |  是否必填  |\n|:---------:|:----------:|:------:| :-----: |\n| File-Name |   文件名   |  字符串  |  是  |\n| Begin-Pos | 开始位置在文件内的偏移 |  字符串  |  是  |\n|   Size    | 文件分片大小 |  字符串  |  是  |\n|  body参数   |  参数说明   |  参数类型  |  是否必填  |\n|     -     | 文件内容 |  字符串  |  是  |\n\n### 7.6 文件认证请求\n用户通过此类请求验证发送到server端的文件是否与期望一致，server端使用两种验证方式，md5值和文件长度，目前已支持文件长度验证。\n#### 7.6.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/check_file\n#### 7.6.2 REQUEST\n|  body参数  |          参数说明           |  参数类型  |  是否必填  |\n|:--------:|:-----------------------:|:------:| :-----: |\n| fileName |           文件名           |  字符串  |  是  |\n| checkSum |        文件对应md5值         |  字符串  |  否  |\n| fileSize |       文件长度(以字节计算)       |  字符串  |  否  |\n| flag | 标记位，为1时校验md5值，为2时校验文件长度 |  字符串  |  是  |\n\n#### 7.6.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| pass | 检查成功为true，否则为false |  bool  |  是  |"
            },
            {
                "content": "#### 7.6.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| pass | 检查成功为true，否则为false |  bool  |  是  |\n\n### 7.7 批量创建schema请求\n用户通过此类请求批量创建schema，请求报文在http body 中将创建schema的目标子图和schema信息发送给server，如果拿到返回errorCode为200的响应报文即为正常创建\n#### 7.7.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/import_schema\n#### 7.7.2 REQUEST\n|  body参数  |    参数说明    |  参数类型  |  是否必填  |\n|:--------:|:----------:|:------:| :-----: |\n| graph |   创建目标子图   |  字符串  |  是  |\n| schema | schema描述信息 |  字符串  |  是  |"
            },
            {
                "content": "### 7.8 数据导入请求\n用户通过此类请求导入已经上传的数据文件。导入不论成功或失败，都将删除已上传文件。数据导入请求在server中实现为一个异步任务，响应返回并不意味着导入已完成，返回的是任务id，后续可以通过此任务id查询导入进度\n#### 7.8.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/import_data\n#### 7.8.2 REQUEST\n|  body参数  |          参数说明           |  参数类型  | 是否必填 |\n|:--------:|:-----------------------:|:------:|:----:|\n| graph |         导入目标子图          |  字符串  |  是   |\n| schema |       导入schema描述        | json字符串  |  是   |\n| delimiter |           分隔符           |  字符串  |  是   |\n| continueOnError |     单行数据出错是否跳过错误并继续     |  boolean  |  否   |\n| skipPackages |         跳过的包个数          |  字符串  |  否   |\n| taskId |  任务id   |  字符串  |  否   |\n| other | 其他参数 |  json字符串  |  否   |\n\n#### 7.8.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| taskId | 任务编号 |  字符串  |  是  |"
            },
            {
                "content": "#### 7.8.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| taskId | 任务编号 |  字符串  |  是  |\n\n### 7.9 清理用户上传文件请求\n用户通过此类请求清理已经上传的文件，如果拿到返回errorCode为200的响应报文即为正常清理\n#### 7.9.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/clear_cache\n#### 7.9.2 REQUEST\n|  body参数  |    参数说明    |  参数类型  |  是否必填  |\n|:--------:|:----------:|:------:| :-----: |\n| fileName |    文件名称    |  字符串  |  否  |\n| userName |    用户名称    |  字符串  |  否  |\n| flag | 标记位， flag = 0时删除fileName指定文件, flag = 1时删除userName指定用户已经上传的所有文件， flag = 2时删除所有用户上传的文件 |  字符串  |  是  |\n\n### 7.10. 导入进度查询请求\n用户通过此类请求获得导入任务的状态\n#### 7.10.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/import_progress\n#### 7.10.2 REQUEST\n|  body参数  |          参数说明           |  参数类型  |  是否必填  |\n|:--------:|:-----------------------:|:------:| :-----: |\n| taskId |           任务编号           |  字符串  |  是  |"
            },
            {
                "content": "### 7.10. 导入进度查询请求\n用户通过此类请求获得导入任务的状态\n#### 7.10.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/import_progress\n#### 7.10.2 REQUEST\n|  body参数  |          参数说明           |  参数类型  |  是否必填  |\n|:--------:|:-----------------------:|:------:| :-----: |\n| taskId |           任务编号           |  字符串  |  是  |\n\n#### 7.10.3 RESPONSE\n| body参数 |                  参数说明                   |  参数类型  |  是否必填  |\n|:------:|:---------------------------------------:|:------:| :-----: |\n| state  | 状态标记，为0表示准备导入，为1表示导入中，为2表示导入成功，为3表示导入失败 |  字符串  |  是  |\n|  progress  |             导入进度，state为1时包含             |  字符串  |  否  |\n|  reason  |             失败原因，state为3时包含             |  字符串  |  否  |"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/7.client-tools/1.python-client.md",
        "chunks": [
            {
                "content": "# Python客户端\n\n> 此文档主要是TuGraph Python SDK的使用说明, 注意将来不再更新维护，建议使用 [bolt客户端](./5.bolt-client.md)\n\n## 1. 概述\nPython的TuGraph Client有两种，一种是RESTful的Client，使用HTTP方法向server发送请求，另一种是RPC的Client，使用RPC方法调用server远程服务，两者各有优劣。\nRESTful client的使用方式简单，在项目的src/client/python/TuGraphClient目录下可以找到Client的源码文件，直接安装到用户环境中即可使用，但是支持的功能较少，\n性能也不高。RPC Client既支持单机的server，也支持高可用集群和负载均衡，接口较多，功能强大。但是使用方式较为复杂，需要用户自己编译TuGraph项目得到liblgraph_client_python.so，\n或者使用runtime镜像时直接在/usr/local/lib64目录下找到该依赖库，将其引入python项目即可正常使用。接下来将详细介绍这两种Client的使用方式。\n\n## 2. RESTful Client\n\n### 2.1.安装Client\n\nTuGraph的Python RESTful client使用setuptools工具进行打包和分发，用户可以将client直接安装到本地环境中，在使用时即可直接引入。\n```shell\ncd src/client/python/TuGraphClient\npython3 setup.py build\npython3 setup.py install\n```\n注：使用setuptools工具安装python client时会安装httpx等依赖，需要在通外网的环境下执行。\n\n### 2.2.调用Cypher\n\n```python\nfrom TuGraphClient import TuGraphClient, AsyncTuGraphClient"
            },
            {
                "content": "## 2. RESTful Client\n\n### 2.1.安装Client\n\nTuGraph的Python RESTful client使用setuptools工具进行打包和分发，用户可以将client直接安装到本地环境中，在使用时即可直接引入。\n```shell\ncd src/client/python/TuGraphClient\npython3 setup.py build\npython3 setup.py install\n```\n注：使用setuptools工具安装python client时会安装httpx等依赖，需要在通外网的环境下执行。\n\n### 2.2.调用Cypher\n\n```python\nfrom TuGraphClient import TuGraphClient, AsyncTuGraphClient\n\nclient = TuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\ncypher = \"match (n) return properties(n) limit 1\"\nres = client.call_cypher(cypher)\nprint(res)\n\naclient = AsyncTuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\ncypher = \"match (n) return properties(n) limit 1\"\nres = await aclient.call_cypher(cypher)\nprint(res)\n```\n\n### 2.3.调用存储过程\n\n```python\nfrom TuGraphClient import TuGraphClient, AsyncTuGraphClient\n\nclient = TuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\nplugin_type = \"cpp\"\nplugin_name = \"khop\"\nplugin_input = \"{\\\"root\\\": 10, \\\"hop\\\": 3}\"\nres = client.call_plugin(plugin_type, plguin_name, plugin_input)\nprint(res)"
            },
            {
                "content": "aclient = AsyncTuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\ncypher = \"match (n) return properties(n) limit 1\"\nres = await aclient.call_cypher(cypher)\nprint(res)\n```\n\n### 2.3.调用存储过程\n\n```python\nfrom TuGraphClient import TuGraphClient, AsyncTuGraphClient\n\nclient = TuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\nplugin_type = \"cpp\"\nplugin_name = \"khop\"\nplugin_input = \"{\\\"root\\\": 10, \\\"hop\\\": 3}\"\nres = client.call_plugin(plugin_type, plguin_name, plugin_input)\nprint(res)\n\naclient = AsyncTuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\nres = await aclient.call_plugin(plugin_type, plguin_name, plugin_input)\nprint(res)\n```\n\n## 3.RPC Client\n\nPython的TuGraph Rpc Client是使用pybind11包装的CPP Client SDK，下表列出了Python和CPP Client SDK的对应关系。"
            },
            {
                "content": "| Python Client SDK                                                                                                                                                                                                     | CPP Client SDK                                                                                                                                                                                                                                                                              |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|"
            },
            {
                "content": "|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| client(self: liblgraph_client_python.client, url: str, user: str, password: str)                                                                                                                                      | RpcClient(const std::string& url, const std::string& user, const std::string& password)                                                                                                                                                                                                     |"
            },
            {
                "content": "| client(self: liblgraph_client_python.client, url: str, user: str, password: str)                                                                                                                                      | RpcClient(const std::string& url, const std::string& user, const std::string& password)                                                                                                                                                                                                     |\n| client(self: liblgraph_client_python.client, urls: list, user: str, password: str)                                                                                                                                    | RpcClient(std::vector& urls, std::string user, std::string password)                                                                                                                                                                                                           |"
            },
            {
                "content": "| client(self: liblgraph_client_python.client, urls: list, user: str, password: str)                                                                                                                                    | RpcClient(std::vector& urls, std::string user, std::string password)                                                                                                                                                                                                           |\n| callCypher(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)                                                                                 | bool CallCypher(std::string& result, const std::string& cypher, const std::string& graph, bool json_format, double timeout, const std::string& url)                                                                                                                                         |"
            },
            {
                "content": "| callCypher(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)                                                                                 | bool CallCypher(std::string& result, const std::string& cypher, const std::string& graph, bool json_format, double timeout, const std::string& url)                                                                                                                                         |\n| callCypherToLeader(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                                   | bool CallCypherToLeader(std::string& result, const std::string& cypher, const std::string& graph, bool json_format, double timeout)                                                                                                                                                         |"
            },
            {
                "content": "| callCypherToLeader(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                                   | bool CallCypherToLeader(std::string& result, const std::string& cypher, const std::string& graph, bool json_format, double timeout)                                                                                                                                                         |\n| callGql(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)                                                                                       | bool CallGql(std::string& result, const std::string& gql, const std::string& graph, bool json_format, double timeout, const std::string& url)                                                                                                                                               |"
            },
            {
                "content": "| callGql(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)                                                                                       | bool CallGql(std::string& result, const std::string& gql, const std::string& graph, bool json_format, double timeout, const std::string& url)                                                                                                                                               |\n| callGqlToLeader(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                                         | bool CallGqlToLeader(std::string& result, const std::string& gql, const std::string& graph = \"default\", bool json_format = true, double timeout = 0)                                                                                                                                        |"
            },
            {
                "content": "| callGqlToLeader(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                                         | bool CallGqlToLeader(std::string& result, const std::string& gql, const std::string& graph = \"default\", bool json_format = true, double timeout = 0)                                                                                                                                        |\n| callProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool, url: str) -> (bool, str)        | bool CallProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& param, double procedure_time_out, bool in_process, const std::string& graph, bool json_format, const std::string& url)                                     |"
            },
            {
                "content": "| callProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool, url: str) -> (bool, str)        | bool CallProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& param, double procedure_time_out, bool in_process, const std::string& graph, bool json_format, const std::string& url)                                     |\n| callProcedureToLeader(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool) -> (bool, str)          | CallProcedureToLeader(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& param, double procedure_time_out, bool in_process, const std::string& graph, bool json_format)                                                          |"
            },
            {
                "content": "| callProcedureToLeader(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool) -> (bool, str)          | CallProcedureToLeader(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& param, double procedure_time_out, bool in_process, const std::string& graph, bool json_format)                                                          |\n| loadProcedure(self: liblgraph_client_python.client, source_file: str, procedure_type: str, procedure_name: str, code_type: str, procedure_description: str, read_only: bool, version: str, graph: str) -> (bool, str) | bool LoadProcedure(std::string& result, const std::string& source_file, const std::string& procedure_type, const std::string& procedure_name, const std::string& code_type, const std::string& procedure_description, bool read_only, const std::string& version, const std::string& graph) |"
            },
            {
                "content": "| loadProcedure(self: liblgraph_client_python.client, source_file: str, procedure_type: str, procedure_name: str, code_type: str, procedure_description: str, read_only: bool, version: str, graph: str) -> (bool, str) | bool LoadProcedure(std::string& result, const std::string& source_file, const std::string& procedure_type, const std::string& procedure_name, const std::string& code_type, const std::string& procedure_description, bool read_only, const std::string& version, const std::string& graph) |\n| listProcedures(self: liblgraph_client_python.client, procedure_type: str, version: str, graph: str, url: str) -> (bool, str)                                                                                          | bool ListProcedures(std::string& result, const std::string& procedure_type, const std::string& version, const std::string& graph, const std::string& url)                                                                                                                                   |"
            },
            {
                "content": "| listProcedures(self: liblgraph_client_python.client, procedure_type: str, version: str, graph: str, url: str) -> (bool, str)                                                                                          | bool ListProcedures(std::string& result, const std::string& procedure_type, const std::string& version, const std::string& graph, const std::string& url)                                                                                                                                   |\n| deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)                                                                                            | bool DeleteProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& graph)                                                                                                                                                   |"
            },
            {
                "content": "| deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)                                                                                            | bool DeleteProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& graph)                                                                                                                                                   |\n| importSchemaFromContent(self: liblgraph_client_python.client, schema: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                              | bool ImportSchemaFromContent(std::string& result, const std::string& schema, const std::string& graph, bool json_format, double timeout)                                                                                                                                                    |"
            },
            {
                "content": "| importSchemaFromContent(self: liblgraph_client_python.client, schema: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                              | bool ImportSchemaFromContent(std::string& result, const std::string& schema, const std::string& graph, bool json_format, double timeout)                                                                                                                                                    |\n| importDataFromContent(self: liblgraph_client_python.client, desc: str, data: str, delimiter: str, continue_on_error: bool, thread_nums: int, graph: str, json_format: bool, timeout: float) -> (bool, str)            | ImportDataFromContent(std::string& result, const std::string& desc, const std::string& data, const std::string& delimiter, bool continue_on_error, int thread_nums, const std::string& graph, bool json_format, double timeout)                                                             |"
            },
            {
                "content": "| importDataFromContent(self: liblgraph_client_python.client, desc: str, data: str, delimiter: str, continue_on_error: bool, thread_nums: int, graph: str, json_format: bool, timeout: float) -> (bool, str)            | ImportDataFromContent(std::string& result, const std::string& desc, const std::string& data, const std::string& delimiter, bool continue_on_error, int thread_nums, const std::string& graph, bool json_format, double timeout)                                                             |\n| importSchemaFromFile(self: liblgraph_client_python.client, schema_file: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                            | ImportSchemaFromFile(std::string& result, const std::string& schema_file, const std::string& graph, bool json_format, double timeout)                                                                                                                                                       |"
            },
            {
                "content": "| importSchemaFromFile(self: liblgraph_client_python.client, schema_file: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                            | ImportSchemaFromFile(std::string& result, const std::string& schema_file, const std::string& graph, bool json_format, double timeout)                                                                                                                                                       |\n| importDataFromFile(self: liblgraph_client_python.client, conf_file: str, delimiter: str, continue_on_error: bool, thread_nums: int, skip_packages: int, graph: str, json_format: bool, timeout: float) -> (bool, str) | ImportDataFromFile(std::string& result, const std::string& conf_file, const std::string& delimiter, bool continue_on_error, int thread_nums, int skip_packages, const std::string& graph, bool json_format, double timeout)                                                                 |"
            },
            {
                "content": "Python RPC Client的使用方式较为复杂，用户可以在本地环境中编译TuGraph得到liblgraph_client_python.so，也可以使用官方提供的runtime镜像，\n在镜像中的/usr/local/lib64目录下可以直接找到该依赖库，引入用户项目即可使用。\n\n```python\nimport liblgraph_client_python\n```\n\n### 3.1.实例化client对象\n\n#### 3.1.1.实例化单节点client对象\n当以单节点模式启动server时，client按照如下格式进行实例化\n```python\nclient = liblgraph_client_python.client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, url: str, user: str, password: str)\n```\n\n#### 3.1.2.实例化HA集群直连连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。\n```python\nclient = liblgraph_client_python.client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, url: str, user: str, password: str)\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。"
            },
            {
                "content": "#### 3.1.2.实例化HA集群直连连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。\n```python\nclient = liblgraph_client_python.client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, url: str, user: str, password: str)\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。\n\n#### 3.1.3.实例化HA集群间接连接client对象\n当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，\nclient按照如下格式进行实例化\n```python\nclient = liblgraph_client_python.client([\"189.33.97.23:9091\",\"189.33.97.24:9091\", \"189.33.97.25:9091\"], \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, urls: list, user: str, password: str)\n```\n因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动\nclient时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。"
            },
            {
                "content": "#### 3.1.3.实例化HA集群间接连接client对象\n当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，\nclient按照如下格式进行实例化\n```python\nclient = liblgraph_client_python.client([\"189.33.97.23:9091\",\"189.33.97.24:9091\", \"189.33.97.25:9091\"], \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, urls: list, user: str, password: str)\n```\n因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动\nclient时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。\n\n### 3.2.调用cypher\n```python\nret, res = client.callCypher(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallCypher(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。"
            },
            {
                "content": "### 3.2.调用cypher\n```python\nret, res = client.callCypher(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallCypher(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n### 3.3.向leader发送cypher请求\n```python\nret, res = client.callCypherToLeader(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallCypherToLeader(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。\n\n### 3.4.调用GQL\n```python\nret, res = client.callGql(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallGql(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。"
            },
            {
                "content": "### 3.4.调用GQL\n```python\nret, res = client.callGql(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallGql(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n### 3.5.向leader发送GQL请求\n```python\nret, res = client.callGqlToLeader(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallGqlToLeader(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。"
            },
            {
                "content": "### 3.5.向leader发送GQL请求\n```python\nret, res = client.callGqlToLeader(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallGqlToLeader(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。\n\n### 3.6.调用存储过程\n```python\nret, res = client.callProcedure(\"CPP\", \"test_plugin1\", \"bcefg\", 1000, False, \"default\")\n```\n```\ncallProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。"
            },
            {
                "content": "### 3.6.调用存储过程\n```python\nret, res = client.callProcedure(\"CPP\", \"test_plugin1\", \"bcefg\", 1000, False, \"default\")\n```\n```\ncallProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n### 3.7.向leader调用存储过程\n```python\nret, res = client.callProcedureToLeader(\"CPP\", \"khop\", kHopParamGen(), 1000, false, \"default\")\n```\n```\ncallProcedureToLeader(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool) -> (bool, str)\n```\n本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。"
            },
            {
                "content": "### 3.7.向leader调用存储过程\n```python\nret, res = client.callProcedureToLeader(\"CPP\", \"khop\", kHopParamGen(), 1000, false, \"default\")\n```\n```\ncallProcedureToLeader(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool) -> (bool, str)\n```\n本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n\n### 3.8.加载存储过程\n```python\nret, res = client.loadProcedure(\"./test/procedure/khop.so\", \"CPP\", \"khop\", \"SO\", \"test loadprocedure\", true, \"v1\", \"default\");\n```\n```\nloadProcedure(self: liblgraph_client_python.client, source_file: str, procedure_type: str, procedure_name: str, code_type: str, procedure_description: str, read_only: bool, version: str, graph: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于加载存储过程是写请求，HA模式下的client只能向leader发送加载存储过程请求。"
            },
            {
                "content": "### 3.8.加载存储过程\n```python\nret, res = client.loadProcedure(\"./test/procedure/khop.so\", \"CPP\", \"khop\", \"SO\", \"test loadprocedure\", true, \"v1\", \"default\");\n```\n```\nloadProcedure(self: liblgraph_client_python.client, source_file: str, procedure_type: str, procedure_name: str, code_type: str, procedure_description: str, read_only: bool, version: str, graph: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于加载存储过程是写请求，HA模式下的client只能向leader发送加载存储过程请求。\n\n### 3.9.列举存储过程\n```python\nret, res = client.listProcedures(\"CPP\", \"any\", \"default\")\n```\n```\nlistProcedures(self: liblgraph_client_python.client, procedure_type: str, version: str, graph: str, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。"
            },
            {
                "content": "### 3.9.列举存储过程\n```python\nret, res = client.listProcedures(\"CPP\", \"any\", \"default\")\n```\n```\nlistProcedures(self: liblgraph_client_python.client, procedure_type: str, version: str, graph: str, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n### 3.10.删除存储过程\n```python\nret, res = client.deleteProcedure(\"CPP\", \"sortstr\", \"default\")\n```\n```\ndeleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。\n\n### 3.11.从字节流中导入schema\n```python\nret, res = client.importSchemaFromContent(schema, \"default\", 1000)\n```\n```\nimportSchemaFromContent(self: liblgraph_client_python.client, schema: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。"
            },
            {
                "content": "### 3.11.从字节流中导入schema\n```python\nret, res = client.importSchemaFromContent(schema, \"default\", 1000)\n```\n```\nimportSchemaFromContent(self: liblgraph_client_python.client, schema: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n### 3.12.从字节流中导入点边数据\n```python\nret, res = client.importDataFromContent(personDesc, person, \",\", true, 16, \"default\", 1000)\n```\n```\nimportDataFromContent(self: liblgraph_client_python.client, desc: str, data: str, delimiter: str, continue_on_error: bool, thread_nums: int, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。"
            },
            {
                "content": "### 3.12.从字节流中导入点边数据\n```python\nret, res = client.importDataFromContent(personDesc, person, \",\", true, 16, \"default\", 1000)\n```\n```\nimportDataFromContent(self: liblgraph_client_python.client, desc: str, data: str, delimiter: str, continue_on_error: bool, thread_nums: int, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。\n\n### 3.13.从文件中导入schema\n```python\nret, res = client.importSchemaFromFile(\"./test/data/yago.conf\", \"default\", 1000)\n```\n```\nimportSchemaFromFile(self: liblgraph_client_python.client, schema_file: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。"
            },
            {
                "content": "### 3.13.从文件中导入schema\n```python\nret, res = client.importSchemaFromFile(\"./test/data/yago.conf\", \"default\", 1000)\n```\n```\nimportSchemaFromFile(self: liblgraph_client_python.client, schema_file: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n### 3.14.从文件中导入点边数据\n```python\nret, res = client.importDataFromFile(\"./test/data/yago.conf\", \",\", true, 16, 0, \"default\", 1000000000)\n```\n```\nimportDataFromFile(self: liblgraph_client_python.client, conf_file: str, delimiter: str, continue_on_error: bool, thread_nums: int, skip_packages: int, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/7.client-tools/2.cpp-client.md",
        "chunks": [
            {
                "content": "# C++客户端\n\n> 此文档主要是TuGraph C++ SDK的使用说明。\n\n## 1.概述\nC++ Client 能够使用 RPC 连接lgraph_server，进行数据导入、执行存储过程、调用Cypher等操作。\n\n## 2.使用示例\n\n### 2.1.实例化client对象\n引入依赖并实例化\n\n#### 2.1.1.实例化单节点client对象\n当以单节点模式启动server时，client按照如下格式进行实例化\n``` C++\nRpcClient client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\nRpcClient(const std::string& url, const std::string& user, const std::string& password);\n@param url: tugraph host looks like ip:port\n@param user: login user name\n@param password: login password\n```\n\n#### 2.1.2.实例化HA集群直接连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化\n``` C++\nRpcClient client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\nRpcClient(const std::string& url, const std::string& user, const std::string& password);\n@param url: tugraph host looks like ip:port\n@param user: login user name \n@param password: login password\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。"
            },
            {
                "content": "#### 2.1.2.实例化HA集群直接连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化\n``` C++\nRpcClient client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\nRpcClient(const std::string& url, const std::string& user, const std::string& password);\n@param url: tugraph host looks like ip:port\n@param user: login user name \n@param password: login password\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。\n\n#### 2.1.3.实例化HA集群间接连接client对象\n当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，\nclient按照如下格式进行实例化。\n```java\nstd::vector urls = {\"189.33.97.23:9091\", \"189.33.97.24:9091\", \"189.33.97.25:9091\"};\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(urls, \"admin\", \"73@TuGraph\");\n```\n```\nRpcClient(std::vector& urls, std::string user, std::string password)\n@param urls: tugraph host list\n@param user: login user name\n@param password: login password\n```\n因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动\nclient时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。"
            },
            {
                "content": "### 2.2.调用cypher\n```C++\n    std::string str;\n    bool ret = client.CallCypher(str,\n        \"CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)\");\n\n```\n```\n    bool CallCypher(std::string& result, const std::string& cypher,\n                    const std::string& graph = \"default\", bool json_format = true,\n                    double timeout = 0, const std::string& url = \"\");\n    @param [out] result      The result.\n    @param [in]  cypher      inquire statement.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @param [in]  url         (Optional) Node address of calling cypher.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。"
            },
            {
                "content": "### 2.3.向leader发送cypher请求\n```C++\n    std::string str;\n    bool ret = client.CallCypherToLeader(str,\n        \"CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)\");\n```\n```\n    bool CallCypherToLeader(std::string& result, const std::string& cypher,\n                    const std::string& graph = \"default\", bool json_format = true,\n                    double timeout = 0);\n    @param [out] result      The result.\n    @param [in]  cypher      inquire statement.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。"
            },
            {
                "content": "### 2.4.调用GQL\n```C++\n    std::string str;\n    bool ret = client.CallGql(str,\n        \"CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)\");\n```\n```\n    bool CallGql(std::string& result, const std::string& gql,\n                    const std::string& graph = \"default\", bool json_format = true,\n                    double timeout = 0, const std::string& url = \"\");\n    @param [out] result      The result.\n    @param [in]  gql         inquire statement.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @param [in]  url         (Optional) Node address of calling gql.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。"
            },
            {
                "content": "### 2.5.向leader发送GQL请求\n```C++\n    std::string str;\n    bool ret = client.CallGqlToLeader(str,\n        \"CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)\");\n```\n```\n    bool CallGqlToLeader(std::string& result, const std::string& gql,\n                 const std::string& graph = \"default\", bool json_format = true,\n                 double timeout = 0);\n    @param [out] result      The result.\n    @param [in]  gql         inquire statement.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。"
            },
            {
                "content": "### 2.6.调用存储过程\n```C++\n    std::string str;\n    bool ret = client.CallProcedure(str, \"CPP\", \"test_plugin1\", \"bcefg\");\n```\n```\n    bool CallProcedure(std::string& result, const std::string& procedure_type,\n                       const std::string& procedure_name, const std::string& param,\n                       double procedure_time_out = 0.0, bool in_process = false,\n                       const std::string& graph = \"default\", bool json_format = true,\n                       const std::string& url = \"\");\n    @param [out] result              The result.\n    @param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  param               the execution parameters.\n    @param [in]  procedure_time_out  (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @param [in]  in_process          (Optional) support in future."
            },
            {
                "content": "@param [out] result              The result.\n    @param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  param               the execution parameters.\n    @param [in]  procedure_time_out  (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @param [in]  in_process          (Optional) support in future.\n    @param [in]  graph               (Optional) the graph to query.\n    @param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,\n                                     binary format.\n    @param [in]  url                 (Optional) Node address of calling procedure.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用，默认以json格式直接返回存储过程的执行结果，指定jsonFormat为false可以返回字符串格式的执行结果。\n其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。"
            },
            {
                "content": "### 2.7.向leader调用存储过程\n```C++\n    std::string str;\n    bool ret = client.CallProcedureToLeader(str, \"CPP\", \"test_plugin1\", \"bcefg\");\n```\n```\n    bool CallProcedureToLeader(std::string& result, const std::string& procedure_type,\n                       const std::string& procedure_name, const std::string& param,\n                       double procedure_time_out = 0.0, bool in_process = false,\n                       const std::string& graph = \"default\", bool json_format = true);\n    @param [out] result              The result.\n    @param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  param               the execution parameters.\n    @param [in]  procedure_time_out  (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @param [in]  in_process          (Optional) support in future.\n    @param [in]  graph               (Optional) the graph to query."
            },
            {
                "content": "@param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  param               the execution parameters.\n    @param [in]  procedure_time_out  (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @param [in]  in_process          (Optional) support in future.\n    @param [in]  graph               (Optional) the graph to query.\n    @param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,\n                                     binary format.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在HA模式下使用，默认以json格式直接返回存储过程的执行结果，指定jsonFormat为false可以返回字符串格式的执行结果。"
            },
            {
                "content": "### 2.8.加载存储过程\n```C++\n    std::string str;\n    bool ret = client.LoadProcedure(str, code_sleep, \"PY\", \"python_plugin1\", \"PY\", \"this is a test plugin\", true)\n```\n```\n    bool LoadProcedure(std::string& result, const std::string& source_file,\n                       const std::string& procedure_type, const std::string& procedure_name,\n                       const std::string& code_type, const std::string& procedure_description,\n                       bool read_only, const std::string& version = \"v1\",\n                       const std::string& graph = \"default\");\n    @param [out] result                  The result.\n    @param [in]  source_file             the source_file contain procedure code.\n    @param [in]  procedure_type          the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name          procedure name.\n    @param [in]  code_type               code type, currently supported PY, SO, CPP, ZIP.\n    @param [in]  procedure_description   procedure description."
            },
            {
                "content": "const std::string& graph = \"default\");\n    @param [out] result                  The result.\n    @param [in]  source_file             the source_file contain procedure code.\n    @param [in]  procedure_type          the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name          procedure name.\n    @param [in]  code_type               code type, currently supported PY, SO, CPP, ZIP.\n    @param [in]  procedure_description   procedure description.\n    @param [in]  read_only               procedure is read only or not.\n    @param [in]  version                 (Optional) the version of procedure.\n    @param [in]  graph                   (Optional) the graph to query.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于加载存储过程是写请求，HA模式下的client只能向leader发送加载存储过程请求。"
            },
            {
                "content": "### 2.9.列举存储过程\n```C++\n    std::string str;\n    bool ret = client.ListProcedures(str);\n```\n```\n    bool ListProcedures(std::string& result, const std::string& procedure_type,\n                        const std::string& version = \"any\",\n                        const std::string& graph = \"default\", const std::string& url = \"\");\n    @param [out] result          The result.\n    @param [in]  procedure_type  (Optional) the procedure type, \"\" for all procedures,\n                                 CPP and PY for special type.\n    @param [in]  version         (Optional) the version of procedure.\n    @param [in]  graph           (Optional) the graph to query.\n    @param [in]  url             Node address of calling procedure.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送请求。"
            },
            {
                "content": "### 2.10.删除存储过程\n```C++\n    std::string str;\n    bool ret = client.DeleteProcedure(str, \"CPP\", \"test_plugin1\");\n```\n```\n    bool DeleteProcedure(std::string& result, const std::string& procedure_type,\n                         const std::string& procedure_name, const std::string& graph = \"default\");\n    @param [out] result              The result.\n    @param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  graph               (Optional) the graph to query.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。"
            },
            {
                "content": "### 2.11.从字节流中导入schema\n```C++\n    std::string str;\n    bool ret = client.ImportSchemaFromContent(str, sImportContent[\"schema\"]);\n```\n```\n    bool ImportSchemaFromContent(std::string& result, const std::string& schema,\n                                 const std::string& graph = \"default\", bool json_format = true,\n                                 double timeout = 0);\n    @param [out] result      The result.\n    @param [in]  schema      the schema to be imported.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。"
            },
            {
                "content": "### 2.12.从字节流中导入点边数据\n```C++\n    std::string str;\n    ret = client.ImportDataFromContent(str, sImportContent[\"person_desc\"], sImportContent[\"person\"],\",\");\n```\n```\n    bool ImportDataFromContent(std::string& result, const std::string& desc,\n                               const std::string& data, const std::string& delimiter,\n                               bool continue_on_error = false, int thread_nums = 8,\n                               const std::string& graph = \"default\", bool json_format = true,\n                               double timeout = 0);\n    @param [out] result              The result.\n    @param [in]  desc                data format description.\n    @param [in]  data                the data to be imported.\n    @param [in]  delimiter           data separator.\n    @param [in]  continue_on_error   (Optional) whether to continue when importing data fails.\n    @param [in]  thread_nums         (Optional) maximum number of threads.\n    @param [in]  graph               (Optional) the graph to query."
            },
            {
                "content": "@param [out] result              The result.\n    @param [in]  desc                data format description.\n    @param [in]  data                the data to be imported.\n    @param [in]  delimiter           data separator.\n    @param [in]  continue_on_error   (Optional) whether to continue when importing data fails.\n    @param [in]  thread_nums         (Optional) maximum number of threads.\n    @param [in]  graph               (Optional) the graph to query.\n    @param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,\n                                     binary format.\n    @param [in]  timeout             (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。"
            },
            {
                "content": "### 2.13.从文件中导入schema\n```C++\n    std::string conf_file(\"./yago.conf\");\n    std::string str;\n    ret = client.ImportSchemaFromFile(str, conf_file);\n```\n```\n    bool ImportSchemaFromFile(std::string& result, const std::string& schema_file,\n                              const std::string& graph = \"default\", bool json_format = true,\n                              double timeout = 0);\n    @param [out] result      The result.\n    @param [in]  schema_file the schema_file contain schema.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。"
            },
            {
                "content": "### 2.14.从文件中导入点边数据\n```C++\n    std::string conf_file(\"./yago.conf\");\n    std::string str;\n    ret = client.ImportDataFromFile(str, conf_file, \",\");\n```\n```\n    bool ImportDataFromFile(std::string& result, const std::string& conf_file,\n                            const std::string& delimiter, bool continue_on_error = false,\n                            int thread_nums = 8, int skip_packages = 0,\n                            const std::string& graph = \"default\", bool json_format = true,\n                            double timeout = 0);\n    @param [out] result              The result.\n    @param [in]  conf_file           data file contain format description and data.\n    @param [in]  delimiter           data separator.\n    @param [in]  continue_on_error   (Optional) whether to continue when importing data fails.\n    @param [in]  thread_nums         (Optional) maximum number of threads.\n    @param [in]  skip_packages       (Optional) skip packages number."
            },
            {
                "content": "double timeout = 0);\n    @param [out] result              The result.\n    @param [in]  conf_file           data file contain format description and data.\n    @param [in]  delimiter           data separator.\n    @param [in]  continue_on_error   (Optional) whether to continue when importing data fails.\n    @param [in]  thread_nums         (Optional) maximum number of threads.\n    @param [in]  skip_packages       (Optional) skip packages number.\n    @param [in]  graph               (Optional) the graph to query.\n    @param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,\n                                     binary format.\n    @param [in]  timeout             (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/7.client-tools/3.java-client.md",
        "chunks": [
            {
                "content": "# Java客户端\n\n> 此文档主要是TuGraph Java SDK的使用说明，需要注意的是TuGraph Java SDK将来不再更新维护，建议使用 [bolt客户端](./5.bolt-client.md)\n\n## 1.编译java client代码\n```shell\ncd deps/tugraph-db-client-java\nsh local_build.sh\n```\n## 2.使用示例\n\n### 2.1.实例化client对象\n\n添加maven依赖\n\n```xml\n\ncom.antgroup.tugraph\ntugraph-db-java-rpc-client\n1.4.1\n\n```\n\n引入依赖\n```java\nimport com.antgroup.tugraph.TuGraphDbRpcClient;\n```\n\n#### 2.1.1.实例化单节点client对象\n当以单节点模式启动server时，client按照如下格式进行实例化\n```java\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\npublic TuGraphDbRpcClient(String url, String user, String pass)\n@param url: tugraph host looks like ip:port\n@param user: login user name\n@param password: login password\n```"
            },
            {
                "content": "### 2.1.实例化client对象\n\n添加maven依赖\n\n```xml\n\ncom.antgroup.tugraph\ntugraph-db-java-rpc-client\n1.4.1\n\n```\n\n引入依赖\n```java\nimport com.antgroup.tugraph.TuGraphDbRpcClient;\n```\n\n#### 2.1.1.实例化单节点client对象\n当以单节点模式启动server时，client按照如下格式进行实例化\n```java\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\npublic TuGraphDbRpcClient(String url, String user, String pass)\n@param url: tugraph host looks like ip:port\n@param user: login user name\n@param password: login password\n```\n\n#### 2.1.2.实例化HA集群直连连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。\n```java\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\npublic TuGraphDbRpcClient(String url, String user, String pass)\n@param url: tugraph host looks like ip:port\n@param user: login user name \n@param password: login password\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。"
            },
            {
                "content": "#### 2.1.3.实例化HA集群间接连接client对象\n当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，\nclient按照如下格式进行实例化\n```java\nList urls = new ArrayList<>();\nurls.add(\"189.33.97.23:9091\");\nurls.add(\"189.33.97.24:9091\");\nurls.add(\"189.33.97.25:9091\");\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(urls, \"admin\", \"73@TuGraph\");\n```\n```\npublic TuGraphDbRpcClient(List urls, String user, String password)\n@param urls: tugraph host list\n@param user: login user name\n@param password: login password\n```\n因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动\nclient时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。"
            },
            {
                "content": "### 2.2.调用cypher\n```java\n    String res = client.callCypher(\"CALL db.edgeLabels()\", \"default\", 10);\n    log.info(\"db.edgeLabels() : \" + res);\n```\n```\n    @param cypher: inquire statement.\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @param url: (Optional) Node address of calling cypher\n    @return: the result of cypher query execution\n    public String callCypher(String cypher, String graph, double timeout, String url)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n注：JAVA不支持默认参数，因此，JAVA中的默认参数是使用重载函数实现的。"
            },
            {
                "content": "### 2.3.向leader发送cypher请求\n```java\n    String res = client.callCypherToLeader(\"CALL db.edgeLabels()\", \"default\", 10);\n    log.info(\"db.edgeLabels() : \" + res);\n```\n```\n    @param cypher: inquire statement.\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of cypher query execution\n    public String callCypherToLeader(String cypher, String graph, double timeout)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。"
            },
            {
                "content": "### 2.4.调用GQL\n```java\n    String res = client.callGql(\"CALL db.edgeLabels()\", \"default\", 10);\n    log.info(\"db.edgeLabels() : \" + res);\n```\n```\n    @param gql: inquire statement.\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @param url: (Optional) Node address of calling GQL\n    @return: the result of GQL query execution\n    public String callGql(String gql, String graph, double timeout, String url)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n注：JAVA不支持默认参数，因此，JAVA中的默认参数是使用重载函数实现的。"
            },
            {
                "content": "### 2.5.向leader发送GQL请求\n```java\n    String res = client.callGqlToLeader(\"CALL db.edgeLabels()\", \"default\", 10);\n    log.info(\"db.edgeLabels() : \" + res);\n```\n```\n    @param gql: inquire statement.\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of cypher query execution\n    public String callGqlToLeader(String cypher, String graph, double timeout)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。"
            },
            {
                "content": "### 2.6.调用存储过程\n```java\n    String result = client.callProcedure(\"CPP\", \"khop\", kHopParamGen(), 1000, false, \"default\");\n    log.info(\"testCallProcedure : \" + result);\n```\n```\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param procedureName: procedure name\n    @param param: the execution parameters\n    @param procedureTimeOut: Maximum execution time, overruns will be interrupted\n    @param inProcess: Running query or not\n    @param graph: the graph to query\n    @param jsonFormat: (Optional) Return format of calling stored procedure\n    @param url: (Optional) Node address of calling procedure\n    @return: the result of procedure execution\n    public String callProcedure(String procedureType, String procedureName, String param, double procedureTimeOut,\n            boolean inProcess, String graph, String url)\n```\n本接口支持在单机模式和HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。"
            },
            {
                "content": "### 2.7.向leader调用存储过程\n```java\n    String result = client.callProcedureToLeader(\"CPP\", \"khop\", kHopParamGen(), 1000, false, \"default\");\n    log.info(\"testCallProcedureToLeader : \" + result);\n```\n```\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param procedureName: procedure name\n    @param param: the execution parameters\n    @param procedureTimeOut: Maximum execution time, overruns will be interrupted\n    @param inProcess: Running query or not\n    @param graph: the graph to query\n    @param jsonFormat: (Optional) Return format of calling stored procedure\n    @return: the result of procedure execution\n    public String callProcedureToLeader(String procedureType, String procedureName, String param, double procedureTimeOut,\n            boolean inProcess, String graph)\n```\n本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。"
            },
            {
                "content": "### 2.8.加载存储过程\n```java\n    boolean result = client.loadProcedure(\"./test/procedure/khop.so\", \"CPP\", \"khop\", \"SO\", \"test loadprocedure\", true, \"v1\", \"default\");\n    log.info(\"loadProcedure : \" + result);\n```\n```\n    @param sourceFile: the source_file contain procedure code\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param procedureName: procedure name\n    @param codeType: code type, currently supported PY, SO, CPP, ZIP\n    @param procedureDescription: procedure description\n    @param readOnly: procedure is read only or not\n    @param version: The version of procedure\n    @param graph: the graph to query.\n    @return: the result of procedure execution\n    public boolean loadProcedure(String sourceFile, String procedureType, String procedureName, String codeType,\n                              String procedureDescription, boolean readOnly, String version, String graph) throws Exception\n```\n本接口支持在单机模式和HA模式下使用。其中，由于加载存储过程是写请求，HA模式下的client只能向leader发送加载存储过程请求。"
            },
            {
                "content": "### 2.9.列举存储过程\n```java\n    String result = client.listProcedures(\"CPP\", \"any\", \"default\");\n    log.info(\"listProcedures : \" + result);\n```\n```\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param version: The version of procedure\n    @param graph: the graph to query.\n    @param url: (Optional) Node address of listing procedure\n    @return: the list of procedure\n    public String listProcedures(String procedureType, String version, String graph, String url) throws Exception\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。"
            },
            {
                "content": "### 2.10.删除存储过程\n```java\n    String result = client.deleteProcedure(\"CPP\", \"sortstr\", \"default\");\n    log.info(\"loadProcedure : \" + result);\n```\n```\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param procedureName: procedure name\n    @param graph: the graph to query.\n    @return: the result of procedure execution\n    public boolean deleteProcedure(String procedureType, String procedureName, String graph) throws Exception\n```\n本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。"
            },
            {
                "content": "### 2.11.从字节流中导入schema\n```java\n    boolean ret = client.importSchemaFromContent(schema, \"default\", 1000);\n    log.info(\"importSchemaFromContent : \" + ret);\n```\n```\n    @param schema: the schema to be imported\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of import schema\n    public boolean importSchemaFromContent(String schema, String graph, double timeout) throws UnsupportedEncodingException \n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。"
            },
            {
                "content": "### 2.12.从字节流中导入点边数据\n```java\n    boolean ret = client.importDataFromContent(personDesc, person, \",\", true, 16, \"default\", 1000);\n    log.info(\"importDataFromContent : \" + ret);\n```\n```\n    @param desc: data format description\n    @param data: the data to be imported\n    @param delimiter: data separator\n    @param continueOnError: whether to continue when importing data fails\n    @param threadNums: maximum number of threads\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of import data\n    public boolean importDataFromContent(String desc, String data, String delimiter, boolean continueOnError,\n            int threadNums, String graph, double timeout) throws UnsupportedEncodingException\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。"
            },
            {
                "content": "### 2.13.从文件中导入schema\n```java\n    boolean ret = client.importSchemaFromFile(\"./test/data/yago.conf\", \"default\", 1000);\n    log.info(\"importSchemaFromFile : \" + ret);\n```\n```\n    @param schemaFile: the schema_file contain schema\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of import schema\n    public boolean importSchemaFromFile(String schemaFile, String graph, double timeout) \n            throws UnsupportedEncodingException, IOException\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。"
            },
            {
                "content": "### 2.14.从文件中导入点边数据\n```java\n    boolean ret = client.importDataFromFile(\"./test/data/yago.conf\", \",\", true, 16, 0, \"default\", 1000000000);\n    log.info(\"importDataFromFile : \" + ret);\n```\n```\n    @param confFile: data file contain format description and data\n    @param delimiter: data separator\n    @param continueOnError: whether to continue when importing data fails\n    @param threadNums: maximum number of threads\n    @param skipPackages: skip packages number\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of import data\n    public boolean importDataFromFile(String confFile, String delimiter, boolean continueOnError, int threadNums,\n            int skipPackages, String graph, double timeout) throws IOException, UnsupportedEncodingException\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/7.client-tools/4.tugraph-ogm.md",
        "chunks": [
            {
                "content": "# TuGraph-OGM\n\n## 1.简介\n\n> TuGraph-OGM 项目在其他仓库开源。\n\nTuGraph-OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。同时 TuGraph-OGM 兼容 Neo4j-OGM，Neo4j 生态用户可以无缝迁移到 TuGraph 数据库上。\n\n### 1.1.TuGraph-OGM 功能\n\nTuGraph-OGM 提供以下函数操作 TuGraph："
            },
            {
                "content": "| 功能                            | 用法                                                                             |\n| ------------------------------- | -------------------------------------------------------------------------------- |\n| 插入单个节点\\边                 | void session.save(T object)                                                      |\n| 批量插入节点\\边                 | void session.save(T object)                                                      |\n| 删除节点与对应边                | void session.delete(T object)                                                    |\n| 删除指定 label 的全部节点       | void session.deleteAll(Class\\ type)                                           |\n| 清空数据库                      | void purgeDatabase()                                                             |\n| 更新节点                        | void session.save(T newObject)                                                   |\n| 根据 id 查询单个节点            | T load(Class type, ID id)                                                     |"
            },
            {
                "content": "| 删除指定 label 的全部节点       | void session.deleteAll(Class\\ type)                                           |\n| 清空数据库                      | void purgeDatabase()                                                             |\n| 更新节点                        | void session.save(T newObject)                                                   |\n| 根据 id 查询单个节点            | T load(Class type, ID id)                                                     |\n| 根据 ids 查询多个节点           | Collection\\ loadAll(Class\\ type, Collection ids)                       |\n| 根据 label 查询全部节点         | Collection\\ loadAll(Class\\ type)                                           |\n| 条件查询                        | Collection\\ loadAll(Class\\ type, Filters filters)                          |\n| Cypher 查询（指定返回结果类型） | T queryForObject(Class\\ objectType, String cypher, Map parameters) |\n| Cypher 查询                     | Result query(String cypher, Map parameters)                           |"
            },
            {
                "content": "## 2.编译 TuGraph-OGM\n\n```shell\ncd tugraph-ogm\nmvn clean install -DskipTests -Denforcer.skip=true\n```\n\n## 3.使用 TuGraph-OGM\n\n详细示例请参考 demo 文件夹下的 TuGraphOGMDemo ###在`pom.xml`中引入依赖\n\n```\n\norg.neo4j\nneo4j-ogm-api\n0.1.0-SNAPSHOT\n\n\norg.neo4j\nneo4j-ogm-core\n0.1.0-SNAPSHOT\n\n\norg.neo4j\ntugraph-rpc-driver\n0.1.0-SNAPSHOT\n\n```\n\n### 3.1.构建图对象\n\n```java\n@NodeEntity\npublic class Movie {      // 构建Movie节点\n    @Id\n    private Long id;      // Movie节点的id\n    private String title; // title属性\n    private int released; // released属性\n\n    // 构建边ACTS_IN    (actor)-[:ACTS_IN]->(movie)\n    @Relationship(type = \"ACTS_IN\", direction = Relationship.Direction.INCOMING)\n    Set actors = new HashSet<>();\n\n    public Movie(String title, int year) {\n        this.title = title;\n        this.released = year;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setReleased(int released) {\n        this.released = released;\n    }\n}"
            },
            {
                "content": "// 构建边ACTS_IN    (actor)-[:ACTS_IN]->(movie)\n    @Relationship(type = \"ACTS_IN\", direction = Relationship.Direction.INCOMING)\n    Set actors = new HashSet<>();\n\n    public Movie(String title, int year) {\n        this.title = title;\n        this.released = year;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setReleased(int released) {\n        this.released = released;\n    }\n}\n\n@NodeEntity\npublic class Actor {      // 构建Actor节点\n    @Id\n    private Long id;\n    private String name;\n\n    @Relationship(type = \"ACTS_IN\", direction = Relationship.Direction.OUTGOING)\n    private Set movies = new HashSet<>();\n\n    public Actor(String name) {\n        this.name = name;\n    }\n\n    public void actsIn(Movie movie) {\n        movies.add(movie);\n        movie.getActors().add(this);\n    }\n}\n```\n\n### 3.2.与TuGraph建立连接"
            },
            {
                "content": "@Relationship(type = \"ACTS_IN\", direction = Relationship.Direction.OUTGOING)\n    private Set movies = new HashSet<>();\n\n    public Actor(String name) {\n        this.name = name;\n    }\n\n    public void actsIn(Movie movie) {\n        movies.add(movie);\n        movie.getActors().add(this);\n    }\n}\n```\n\n### 3.2.与TuGraph建立连接\n\n```java\n// 配置\nString databaseUri = \"list://ip:port\";\nString username = \"admin\";\nString password = \"73@TuGraph\";\n//启动driver\nDriver driver = new RpcDriver();\nConfiguration.Builder baseConfigurationBuilder = new Configuration.Builder()\n                            .uri(databaseUri)\n                            .verifyConnection(true)\n                            .credentials(username, password);\n                            driver.configure(baseConfigurationBuilder.build());\ndriver.configure(baseConfigurationBuilder.build());\n// 开启session\nSessionFactory sessionFactory = new SessionFactory(driver, \"entity_path\");\nSession session = sessionFactory.openSession();\n```\n\n### 3.3.通过OGM进行增删改查"
            },
            {
                "content": "### 3.3.通过OGM进行增删改查\n\n```java\n// 增\nMovie jokes = new Movie(\"Jokes\", 1990);  // 新建Movie节点jokes\nsession.save(jokes);                     // 将jokes存储在TuGraph中\n\nMovie speed = new Movie(\"Speed\", 2019);\nActor alice = new Actor(\"Alice Neeves\");\nalice.actsIn(speed);                    // 将speed节点与alice节点通过ACTS_IN进行连接\nsession.save(speed);                    // 存储两个节点与一条边\n\n// 删\nsession.delete(alice);                  // 删除alice节点以及相连的边\nMovie m = session.load(Movie.class, jokes.getId());   // 根据jokes节点的id获取jokes节点\nsession.delete(m);                                    // 删除jokes节点\n\n// 改\nspeed.setReleased(2018);\nsession.save(speed);                   // 更新speed节点属性\n\n// 查\nCollection movies = session.loadAll(Movie.class);  // 获取所有Movie节点\nCollection moviesFilter = session.loadAll(Movie.class,\n        new Filter(\"released\", ComparisonOperator.LESS_THAN, 1995));  // 查询所有小于1995年发布的电影"
            },
            {
                "content": "// 改\nspeed.setReleased(2018);\nsession.save(speed);                   // 更新speed节点属性\n\n// 查\nCollection movies = session.loadAll(Movie.class);  // 获取所有Movie节点\nCollection moviesFilter = session.loadAll(Movie.class,\n        new Filter(\"released\", ComparisonOperator.LESS_THAN, 1995));  // 查询所有小于1995年发布的电影\n\n// 调用Cypher\nHashMap parameters = new HashMap<>();\nparameters.put(\"Speed\", 2018);\nMovie cm = session.queryForObject(Movie.class,\n        \"MATCH (cm:Movie{Speed: $Speed}) RETURN *\", parameters);      // 查询Speed为2018的Movie"
            },
            {
                "content": "// 调用Cypher\nHashMap parameters = new HashMap<>();\nparameters.put(\"Speed\", 2018);\nMovie cm = session.queryForObject(Movie.class,\n        \"MATCH (cm:Movie{Speed: $Speed}) RETURN *\", parameters);      // 查询Speed为2018的Movie\n\nsession.query(\"CALL db.createVertexLabel('Director', 'name', 'name',\" +\n        \"STRING, false, 'age', INT16, true)\", emptyMap());            // 创建节点Label Director\nsession.query(\"CALL db.createEdgeLabel('DIRECT', '[]')\", emptyMap()); // 创建边Label DIRECT\nResult createResult = session.query(\n        \"CREATE (n:Movie{title:\\\"The Shawshank Redemption\\\", released:1994})\" +\n        \"<-[r:DIRECT]-\" +\n        \"(n2:Director{name:\\\"Frank Darabont\\\", age:63})\",\n        emptyMap());\nQueryStatistics statistics = createResult.queryStatistics();          // 获取create结果\nSystem.out.println(\"created \" + statistics.getNodesCreated() + \" vertices\");    // 查看创建节点数目\nSystem.out.println(\"created \" + statistics.getRelationshipsCreated() + \" edges\");  //查看创建边数目"
            },
            {
                "content": "// 清空数据库\nsession.deleteAll(Movie.class);        // 删除所有Movie节点\nsession.purgeDatabase();               // 删除全部数据\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/7.client-tools/5.bolt-client.md",
        "chunks": [
            {
                "content": "# Bolt客户端\n\nTuGraph目前兼容了Neo4j的Bolt协议，可以直接使用Neo4j的客户端访问TuGraph。\n\n## 开启Bolt端口\n\nBolt端口是默认开启的，默认端口是7687。如果需要修改端口，请在配置文件中自行修改。基于docker方式部署的服务，配置文件在容器内 `/usr/local/etc/lgraph.json`文件中；如果是用rpm包部署的服务，配置文件在服务器的`/usr/local/etc/lgraph.json`。 修改端口后为了使端口生效，需要重启服务，重启服务的具体操作可见[数据库运行](../../5.installation&running/7.tugraph-running.md)。另外，配置文件中的详细配置项，可见[数据库运行](../../5.installation&running/7.tugraph-running.md)中的服务配置章节。\n\n## 使用示例\n\n添加Maven依赖\n\n```xml\n\norg.neo4j.driver\nneo4j-java-driver\n4.4.2\n\n```\nClient按照如下格式进行实例化:\n\n```java\n    Driver driver = GraphDatabase.driver(\"bolt://ip:port\", AuthTokens.basic(\"admin\", \"73@TuGraph\"));\n```\n\n常用语句"
            },
            {
                "content": "```java\n        //通过 driver 对象创建一个 Session，设置会话连接到特定的数据库，用于执行Cypher语句\n        Session session = driver.session(SessionConfig.forDatabase(\"default\"));\n        //清空图项目，请不要轻易尝试，它会清空你选中的图项目的模型以及数据\n        session.run(\"CALL db.dropDB()\");\n        //创建点模型\n        session.run(\"CALL db.createVertexLabel('person', 'id' , 'id' ,INT32, false, 'name' ,STRING, false)\");\n        //创建边模型\n        session.run(\"CALL db.createEdgeLabel('is_friend','[[\\\"person\\\",\\\"person\\\"]]')\");\n        //创建索引\n        session.run(\"CALL db.addIndex(\\\"person\\\", \\\"name\\\", false)\");\n        //插入点数据\n        session.run(\"create (n1:person {name:'jack',id:1}), (n2:person {name:'lucy',id:2})\");\n        //插入边数据\n        session.run(\"match (n1:person {id:1}), (n2:person {id:2}) create (n1)-[r:is_friend]->(n2)\");\n        //查询点和边\n        Result res = session.run(\"match (n)-[r]->(m) return n,r,m\");\n        //Parameterized Query\n        String cypherQuery = \"MATCH (n1:person {id:$id})-[r]-(n2:person {name:$name}) RETURN n1, r, n2\";"
            },
            {
                "content": "//插入点数据\n        session.run(\"create (n1:person {name:'jack',id:1}), (n2:person {name:'lucy',id:2})\");\n        //插入边数据\n        session.run(\"match (n1:person {id:1}), (n2:person {id:2}) create (n1)-[r:is_friend]->(n2)\");\n        //查询点和边\n        Result res = session.run(\"match (n)-[r]->(m) return n,r,m\");\n        //Parameterized Query\n        String cypherQuery = \"MATCH (n1:person {id:$id})-[r]-(n2:person {name:$name}) RETURN n1, r, n2\";\n        Result result1 = session.run(cypherQuery, parameters(\"id\", 1, \"name\", \"lucy\"));\n        while (result1.hasNext()) {\n        Record record = result1.next();\n        System.out.println(\"n1: \" + record.get(\"n1\").asMap());\n        System.out.println(\"r: \" + record.get(\"r\").asMap());\n        System.out.println(\"n2: \" + record.get(\"n2\").asMap());\n                }\n        //删除点数据\n        session.run(\"match (n1:person {id:1}) delete n1\");\n        //删除边数据\n        session.run(\"match (n1:person {id:1})-[r]-(n2:person{id:2}) delete r\");\n        //删除边模型"
            },
            {
                "content": "while (result1.hasNext()) {\n        Record record = result1.next();\n        System.out.println(\"n1: \" + record.get(\"n1\").asMap());\n        System.out.println(\"r: \" + record.get(\"r\").asMap());\n        System.out.println(\"n2: \" + record.get(\"n2\").asMap());\n                }\n        //删除点数据\n        session.run(\"match (n1:person {id:1}) delete n1\");\n        //删除边数据\n        session.run(\"match (n1:person {id:1})-[r]-(n2:person{id:2}) delete r\");\n        //删除边模型\n        session.run(\"CALL db.deleteLabel('edge', 'is_friend')\");\n        //删除点模型\n        session.run(\"CALL db.deleteLabel('vertex', 'person')\");\n```"
            },
            {
                "content": "详细Cypher和存储过程的使用可见[Cypher](../../8.query/1.cypher.md)\n\n## Neo4j客户端使用限制\n\n目前，我们的系统尚未全面兼容Neo4j Bolt协议的所有高级特性。特别地，对于Neo4j客户端所具备的即时事务处理功能及弱schema灵活性这两项独特能力，当前尚不提供支持。因此，在采用客户端进行操作时，请务必留意规避涉及此类特性的操作，以确保应用的顺畅运行与数据的一致性。\n\n## 客户端示例\n\n在代码目录中的demo/Bolt下面有Golang、Java、JavaScript、Python、Rust 这几个语言的的例子。想要了解更多可见[客户端示例](https://github.com/TuGraph-family/tugraph-db/tree/master/demo)"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/7.client-tools/6.bolt-console-client.md",
        "chunks": [
            {
                "content": "# TuGraph console client\n\n`lgraph_cli` 是基于bolt协议的 console client，c++编写，使用时需要连接tugraph的bolt端口。\n\n`lgraph_cli` 是一个二进制的可执行文件，不依赖其他动态库，拷贝到一台linux机器上就可执行。\n\n## `lgraph_cli`使用\n\n语句以分号结束，输入`exit`, `quit`或者Ctrl-C退出客户端。\n\n```powershell\nlgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph\n\nWelcome to the TuGraph console client. Commands end with ';'.\nCopyright(C) 2018-2023 Ant Group. All rights reserved.\nType 'exit', 'quit' or Ctrl-C to exit."
            },
            {
                "content": "语句以分号结束，输入`exit`, `quit`或者Ctrl-C退出客户端。\n\n```powershell\nlgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph\n\nWelcome to the TuGraph console client. Commands end with ';'.\nCopyright(C) 2018-2023 Ant Group. All rights reserved.\nType 'exit', 'quit' or Ctrl-C to exit.\n\nTuGraph> match(n) return n limit 1;\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+"
            },
            {
                "content": "TuGraph>\n```\n\n语句可以中间换行，多行输入。\n\n```powershell\nTuGraph> match(n)\n      -> return n\n      -> limit 1;\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n\nTuGraph>\n```\n\n非交互式\n```powershell"
            },
            {
                "content": "TuGraph>\n```\n\n非交互式\n```powershell\n\necho \"match(n) return n limit 1;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n1 rows\n\n```\n\n从文件读取多条命令\n\n```powershell\n\ncat query.txt\nmatch(n) return n limit 1;\nmatch(n) return n limit 1;"
            },
            {
                "content": "lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph < query.txt\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:3,born:1967,poster_image:\"https://image.tmdb.org/t/p/w185/8iATAc5z5XOKFFARLsvaawa8MTY.jpg\",name:\"Carrie-Anne Moss\"})   |"
            },
            {
                "content": "| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:3,born:1967,poster_image:\"https://image.tmdb.org/t/p/w185/8iATAc5z5XOKFFARLsvaawa8MTY.jpg\",name:\"Carrie-Anne Moss\"})   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n2 rows"
            },
            {
                "content": "+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:3,born:1967,poster_image:\"https://image.tmdb.org/t/p/w185/8iATAc5z5XOKFFARLsvaawa8MTY.jpg\",name:\"Carrie-Anne Moss\"})   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n2 rows\n```\n\n## 在线数据导出"
            },
            {
                "content": "## 在线数据导出\n\nlgraph_cli 支持流式读取，导出数据只需要把lgraph_cli的输出重定向到文件中即可，导出格式支持csv和json。\n\n### csv格式\n\n```powershell\n\necho \"match(n) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format csv > output.txt\n\n```\n\n### json格式\n\n```powershell\n\necho \"match(n) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format json > output.txt\n\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/7.client-tools/7.restful-api.md",
        "chunks": [
            {
                "content": "# RESTful API\n\n> 此文档主要介绍 TuGrpah 的 Rest API 的调用详情。\n\n## 1.简介\nTuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。\n\n本文档描述 TuGraph 的 HTTP API 使用方式。\n\n## 2.请求与响应格式\nTuGraph HTTP Server 接收json格式的请求，经过鉴权后开始提取请求中的字段，根据定义好的接口逻辑处理请求，并返回json格式的响应。\n\n### 2.1.标准响应格式\n每一个响应都以标准响应格式返回，格式如下：\n\n| body参数  | 参数说明         | 参数类型        | 是否必填       |\n| ------- |--------------|-------------|------------|\n| errorCode   | 业务级错误码       | int类型       | 是          |\n| success   | 请求是否成功       | int类型       | 是          |\n| errorMessage   | 业务级错误信息      | 字符串类型       | 是          |\n| data   | 请求成功时返回的响应信息 | json字符串     | 是          |\n\n### 2.2请求类型\n\n#### 2.2.1. 用户登陆\n用户在登陆请求中携带用户名和密码发送到服务端。登录成功会收到带有签名的令牌(Json Web Token)和判断是否为默认密码的布尔型变量，客户端储存该令牌，在后续的请求中将令牌加入请求头的Authorization域中。如果登录失败会收到“Authentication failed”错误。\n\n- **URI**:     /login\n- **METHOD**:  POST\n- **REQUEST**:\n\n| body参数 | 参数说明 | 参数类型  | 是否必填       |\n| ------ |------|-------|------------|\n| user   | 用户名  | 字符串类型   | 是          |\n| password | 用户密码 | 字符串类型 | 是          |"
            },
            {
                "content": "### 2.2请求类型\n\n#### 2.2.1. 用户登陆\n用户在登陆请求中携带用户名和密码发送到服务端。登录成功会收到带有签名的令牌(Json Web Token)和判断是否为默认密码的布尔型变量，客户端储存该令牌，在后续的请求中将令牌加入请求头的Authorization域中。如果登录失败会收到“Authentication failed”错误。\n\n- **URI**:     /login\n- **METHOD**:  POST\n- **REQUEST**:\n\n| body参数 | 参数说明 | 参数类型  | 是否必填       |\n| ------ |------|-------|------------|\n| user   | 用户名  | 字符串类型   | 是          |\n| password | 用户密码 | 字符串类型 | 是          |\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含令牌\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| jwt              | 令牌               | 字符串类型 |\n| is_admin         | 是否是admin用户    | 布尔类型   |\n| default_password  | 默认密码           | 布尔类型   |\n\n**Example request.**\n\n```\n    {\"user\" : \"admin\", \"password\" : \"73@TuGraph\"}\n```\n\n#### 2.2.2. 用户登出\n用户登出，同时删除已经认证的token，用户后续发送请求时，需要重新登陆，并获取新的token。\n\n- **URI**:     /logout\n- **METHOD**:  POST\n  - **REQUEST**:\n    http request header中携带调用login接口时返回的token，具体填写的字符串是`Bearer ${jwt}`，`${jwt}`就是login接口返回的jwt，body中没有参数"
            },
            {
                "content": "**Example request.**\n\n```\n    {\"user\" : \"admin\", \"password\" : \"73@TuGraph\"}\n```\n\n#### 2.2.2. 用户登出\n用户登出，同时删除已经认证的token，用户后续发送请求时，需要重新登陆，并获取新的token。\n\n- **URI**:     /logout\n- **METHOD**:  POST\n  - **REQUEST**:\n    http request header中携带调用login接口时返回的token，具体填写的字符串是`Bearer ${jwt}`，`${jwt}`就是login接口返回的jwt，body中没有参数\n\n| header参数           | 参数说明          | 参数类型   |\n|------------------|---------------|------------|\n| Authorization              | Bearer ${jwt} | 字符串类型 |\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| is_admin         | 是否是admin用户    | 布尔类型   |\n\n#### 2.2.3. 身份刷新\n已下发的token失效后，需要调用本接口重新认证。后端验证token合法性。token在初次登录后，1小时内有效，过期需要刷新\n\n- **URI**:     /refresh\n- **METHOD**:  POST\n- **REQUEST**:\n  http request header中携带调用login接口返回的token，具体填写的字符串是`Bearer ${jwt}`，`${jwt}`就是login接口返回的jwt，body中没有参数"
            },
            {
                "content": "- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| is_admin         | 是否是admin用户    | 布尔类型   |\n\n#### 2.2.3. 身份刷新\n已下发的token失效后，需要调用本接口重新认证。后端验证token合法性。token在初次登录后，1小时内有效，过期需要刷新\n\n- **URI**:     /refresh\n- **METHOD**:  POST\n- **REQUEST**:\n  http request header中携带调用login接口返回的token，具体填写的字符串是`Bearer ${jwt}`，`${jwt}`就是login接口返回的jwt，body中没有参数\n\n| header参数           | 参数说明          | 参数类型   |\n|------------------|---------------|------------|\n| Authorization              | Bearer ${jwt} | 字符串类型 |\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含令牌\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| jwt              | 令牌               | 字符串类型 |\n| is_admin         | 是否是admin用户    | 布尔类型   |\n\n#### 2.2.4. 调用cypher\n用户对TuGraph的增删改查请求需要调用cypher接口，并通过标准的cypher查询语言发起\n\n- **URI**:     /cypher\n- **METHOD**:  POST\n- **REQUEST**:"
            },
            {
                "content": "- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含令牌\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| jwt              | 令牌               | 字符串类型 |\n| is_admin         | 是否是admin用户    | 布尔类型   |\n\n#### 2.2.4. 调用cypher\n用户对TuGraph的增删改查请求需要调用cypher接口，并通过标准的cypher查询语言发起\n\n- **URI**:     /cypher\n- **METHOD**:  POST\n- **REQUEST**:\n\n| header参数           | 参数说明          | 参数类型   |\n|------------------|---------------|------------|\n| Authorization              | Bearer ${jwt} | 字符串类型 |\n\n| body参数  | 参数说明     | 参数类型  | 是否必填       |\n| ------- |----------|-------|------------|\n| graph   | 查询的子图名称  | 字符串类型   | 是          |\n| script   | cypher语句 | 字符串类型 | 是          |\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含查询结果\n\n| body参数  | 参数说明 | 参数类型    | 是否必填       |\n| ------- |------|---------|------------|\n| result   | 查询结果 | json字符串 | 是          |\n\n**Example request.**\n\n```\n    {\"script\" : \"Match (n) return n\", \"graph\" : \"default\"}\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/7.client-tools/8.rpc-api.md",
        "chunks": [
            {
                "content": "# RPC API\n\n> 此文档主要介绍 TuGraph 的 RPC API 的调用详情。\n\n## 1.简介\n\nTuGraph 提供丰富的 RPC API，以供开发者通过 RPC 请求远程调用 TuGraph 提供的服务。\n\nRPC（远程过程调用）是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n相比REST，RPC 面向方法，主要用于函数方法的调用，可以适合更复杂通信需求的场景，且性能更高。\nbrpc是用c++语言编写的工业级RPC框架，基于brpc，TuGraph 提供了丰富的RPC API，本文档描述\nTuGraph 的 RPC API 使用方式。\n\n## 2.请求\n\n### 2.1.建立连接\n\n开发者向TuGraph服务发送RPC请求，首先要建立连接。以C++语言为例，开发者创建指定url的通道（channel），\n由通道创建指定的服务存根（LGraphRPCService_Stub），后续即可通过存根像调用本地方法一样向远程\n服务器发送请求。\n\n```C++\n    std::shared_ptr options = std::make_shared();\n    options->protocol = \"baidu_std\";\n    options->connection_type = \"\";\n    options->timeout_ms = 60 * 60 * 1000 /*milliseconds*/;\n    options->max_retry = 3;\n    std::string load_balancer = \"\";\n    std::shared_ptr channel = std::make_shared();\n    if (channel->Init(url.c_str(), load_balancer, options.get()) != 0)\n        throw RpcException(\"Fail to initialize channel\");\n    LGraphRPCService_Stub stub(channel.get());\n```\n\n### 2.2.请求类型\n\nTuGraph支持10种RPC请求，其中每种请求的功能如下表所示："
            },
            {
                "content": "### 2.2.请求类型\n\nTuGraph支持10种RPC请求，其中每种请求的功能如下表所示：\n\n| 请求              | 功能         |\n|-----------------|------------|\n| GraphApiRequest | 点边索引操作请求   |\n| CypherRequest   | cypher请求   |\n| PluginRequest   | 存储过程请求     |\n| HARequest       | 高可用模式请求    |\n| ImportRequest   | 数据导入请求     |\n| GraphRequest    | 子图操作请求     |\n| AclRequest      | 权限管理请求     |\n| ConfigRequest   | 配置管理请求     |\n| RestoreRequest  | 备份请求       |\n| SchemaRequest   | schema管理请求 |\n\n用户发送请求时，需要传入以下参数：\n- client_version: 可选参数，HA模式下可通过对比`client_version`和`server_version`防止响应过时的请求\n- token: 必要参数，客户端登陆之后获得token，每次请求传入token以校验用户身份\n- is_write_op: 可选参数，标志请求是否是写请求\n- user: 可选参数，HA模式下主从之间同步请求时设置user，不需验证token\n\n服务处理完RPC请求之后发回响应，响应消息中除了包含每个请求的单独响应信息之外，还包含以下参数：\n- error_code: 必要参数，标志请求处理状态\n- redirect: 可选参数，HA模式下向follower发送写请求时处理失败，设置redirect为请求转发地址，即leader地址\n- error: 可选参数，请求错误信息\n- server_version: 可选参数，HA模式的请求响应中设置`server_version`以避免client读取数据时发生反向时间旅行问题\n\n:warning:  **除CypherRequest、PluginRequest、HARequest和AclRequest外，其余RPC接口将逐步废弃，其功能统一至CypherRequest接口。**\n\n## 3.登录"
            },
            {
                "content": "## 3.登录\n\n登录请求信息包含以下参数：\n- user: 必要参数，用户名\n- pass: 必要参数，密码\n以C++为例，用户使用构建好的服务存根发送登录请求：\n```C++\n    auto* req = request.mutable_acl_request();\n    auto* auth = req->mutable_auth_request()->mutable_login();\n    auth->set_user(user);\n    auth->set_password(pass);\n    // send data\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req->set_client_version(server_version);\n    req->set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), req, &resp, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    token = res.acl_response().auth_response().token();\n```\n登录响应信息包含以下参数：\n- token: 必要参数，登录成功会收到带有签名的令牌，即 Json Web Token，客户端储存该令牌，并且用于以后的每次发送请求。\n如果登录失败会收到“Authentication failed”错误。"
            },
            {
                "content": "## 4.查询\n用户可以通过Cypher查询和TuGraph进行绝大多数的交互，Cypher请求信息包含以下参数：\n- query: 必要参数，Cypher查询语句\n- param_names: 可选参数，参数名\n- param_values: 可选参数，参数值\n- result_in_json_format: 必要参数，查询结果是否以JSON格式返回\n- graph: 可选参数，Cypher语句执行的子图名称\n- timeout: 可选参数，Cypher语句执行的超时时间"
            },
            {
                "content": "以C++为例，用户发送Cypher请求的方式如下所示：\n```C++\n    LGraphResponse res;\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    LGraphRequest req;\n    req.set_client_version(server_version);\n    req.set_token(token);\n    lgraph::CypherRequest* cypher_req = req.mutable_cypher_request();\n    cypher_req->set_graph(graph);\n    cypher_req->set_query(query);\n    cypher_req->set_timeout(timeout);\n    cypher_req->set_result_in_json_format(true);\n    LGraphRPCService_Stub stub(channel.get());\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    server_version = std::max(server_version, res.server_version());\n    CypherResponse cypher_res = res.cypher_response();\n```\nCypher请求响应为以下两个参数之一：\n- json_result: JSON格式的cypher查询结果\n- binary_result: CypherResult格式的cypher查询结果"
            },
            {
                "content": "## 5.存储过程\n为满足用户较为复杂的查询/更新逻辑，TuGraph支持 C 语言和 Python 语言编写的存储过程。\n用户可以使用RPC请求对存储过程进行增删改查操作。\n\n### 5.1.加载存储过程\n加载存储过程的请求包含以下参数：\n- name: 必要参数，存储过程名称\n- read_only: 必要参数，是否只读\n- code: 必要参数，存储过程文件读入生成的ByteString\n- desc: 可选参数，存储过程描述\n- code_type: 可选参数，存储过程代码类型，PY、SO、CPP、ZIP四者之一"
            },
            {
                "content": "以C++为例，用户加载存储过程的方式如下所示：\n```C++\n    std::string content;\n    if (!FieldSpecSerializer::FileReader(source_file, content)) {\n        std::swap(content, result);\n        return false;\n    }\n    LGraphRequest req;\n    req.set_is_write_op(true);\n    lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();\n    pluginRequest->set_graph(graph);\n    pluginRequest->set_type(procedure_type == \"CPP\" ? lgraph::PluginRequest::CPP\n                                                    : lgraph::PluginRequest::PYTHON);\n    pluginRequest->set_version(version);\n    lgraph::LoadPluginRequest* loadPluginRequest = pluginRequest->mutable_load_plugin_request();\n    loadPluginRequest->set_code_type([](const std::string& type) {\n        std::unordered_map um{\n            {\"SO\", lgraph::LoadPluginRequest::SO},\n            {\"PY\", lgraph::LoadPluginRequest::PY},\n            {\"ZIP\", lgraph::LoadPluginRequest::ZIP},\n            {\"CPP\", lgraph::LoadPluginRequest::CPP}};\n        return um[type];\n    }(code_type));"
            },
            {
                "content": "pluginRequest->set_version(version);\n    lgraph::LoadPluginRequest* loadPluginRequest = pluginRequest->mutable_load_plugin_request();\n    loadPluginRequest->set_code_type([](const std::string& type) {\n        std::unordered_map um{\n            {\"SO\", lgraph::LoadPluginRequest::SO},\n            {\"PY\", lgraph::LoadPluginRequest::PY},\n            {\"ZIP\", lgraph::LoadPluginRequest::ZIP},\n            {\"CPP\", lgraph::LoadPluginRequest::CPP}};\n        return um[type];\n    }(code_type));\n    loadPluginRequest->set_name(procedure_name);\n    loadPluginRequest->set_desc(procedure_description);\n    loadPluginRequest->set_read_only(read_only);\n    loadPluginRequest->set_code(content);\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);"
            },
            {
                "content": "}(code_type));\n    loadPluginRequest->set_name(procedure_name);\n    loadPluginRequest->set_desc(procedure_description);\n    loadPluginRequest->set_read_only(read_only);\n    loadPluginRequest->set_code(content);\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n```\n加载存储过程的响应不包含参数，如果加载失败则抛出BadInput异常"
            },
            {
                "content": "### 5.2.调用存储过程\n\n调用存储过程的请求包含以下参数：\n- name: 必要参数，存储过程名称\n- param: 必要参数，存储过程参数\n- result_in_json_format: 可选参数，调用结果是否以JSON格式返回\n- in_process: 可选参数，未来支持\n- timeout: 可选参数，调用存储过程的超时时间"
            },
            {
                "content": "以C++为例，用户调用存储过程的方式如下所示：\n```C++\n    LGraphRequest req;\n    lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();\n    pluginRequest->set_graph(graph);\n    pluginRequest->set_type(procedure_type == \"CPP\" ? lgraph::PluginRequest::CPP\n                                                    : lgraph::PluginRequest::PYTHON);\n    lgraph::CallPluginRequest *cpRequest = pluginRequest->mutable_call_plugin_request();\n    cpRequest->set_name(procedure_name);\n    cpRequest->set_in_process(in_process);\n    cpRequest->set_param(param);\n    cpRequest->set_timeout(procedure_time_out);\n    cpRequest->set_result_in_json_format(json_format);\n    LGraphResponse res;\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());"
            },
            {
                "content": "cpRequest->set_param(param);\n    cpRequest->set_timeout(procedure_time_out);\n    cpRequest->set_result_in_json_format(json_format);\n    LGraphResponse res;\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    if (json_format) {\n        result = res.mutable_plugin_response()->mutable_call_plugin_response()->json_result();\n    } else {\n        result = res.mutable_plugin_response()->mutable_call_plugin_response()->reply();\n    }\n```\n调用存储过程的响应为以下两个参数之一：\n- reply: ByteString格式的存储过程调用结果\n- json_result: JSON格式的存储过程调用结果"
            },
            {
                "content": "### 5.3.删除存储过程\n\n删除存储过程的请求包含以下参数：\n- name: 必要参数，存储过程名称"
            },
            {
                "content": "以C++为例，用户删除存储过程的方式如下所示：\n```C++\n    LGraphRequest req;\n    req.set_is_write_op(true);\n    lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();\n    pluginRequest->set_graph(graph);\n    pluginRequest->set_type(procedure_type == \"CPP\" ? lgraph::PluginRequest::CPP\n                                                    : lgraph::PluginRequest::PYTHON);\n    lgraph::DelPluginRequest* dpRequest = pluginRequest->mutable_del_plugin_request();\n    dpRequest->set_name(procedure_name);\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n```"
            },
            {
                "content": "cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n```\n删除存储过程的响应不包含参数，如果删除失败则抛出BadInput异常"
            },
            {
                "content": "### 5.4.列举存储过程"
            },
            {
                "content": "列举存储过程请求不需要参数，以C++为例，用户列举存储过程的方式如下所示：\n```C++\n    LGraphRequest req;\n    req.set_is_write_op(false);\n    lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();\n    pluginRequest->set_graph(graph);\n    pluginRequest->set_type(procedure_type == \"CPP\" ? lgraph::PluginRequest::CPP\n                                                    : lgraph::PluginRequest::PYTHON);\n    pluginRequest->mutable_list_plugin_request();\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    result = res.mutable_plugin_response()->mutable_list_plugin_response()->reply();"
            },
            {
                "content": "req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    result = res.mutable_plugin_response()->mutable_list_plugin_response()->reply();\n```\n列举存储过程的响应的参数如下所示：\n- reply: JSON格式的procedure列表"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/7.client-tools/9.restful-api-legacy.md",
        "chunks": [
            {
                "content": "# RESTful API Legacy\n\n> 此文档主要介绍 TuGrpah 的 Rest API 的调用详情。\n\n## 1.简介\n\nTuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。\n\n本文档描述 TuGraph 的 HTTP API 使用方式。\n\n**注意：除\"登陆\"、\"查询\"和\"存储过程\"外，其余接口自 **2023年4月30日** 起将不再提供支持，统一使用Cypher接口提供服务。**\n\n## 2.请求与数据格式\n\n### 2.1请求\n\nTuGraph 支持 HTTP GET/POST/PUT/DELETE 请求。其中：\n\n- GET 请求用于只读请求，如读取点属性，边属性等操作；\n- POST 请求用于创建实体，提交 Cypher，以及加载和调用存储过程；\n- PUT 请求用于修改已有实体，如修改点属性，边属性等；\n- DELETE 请求用于删除已有实体，如删除点，边等。\n\n在高可用模式下，用户可以在请求的报头(request header)中设置 `server_version` 来保证请求的服务器有足够新的数据。\n当前的 `server_version` 可以从服务器返回的报头中获取。\n\n### 2.2.数据格式\n\n客户端与服务端数据交互的格式是 JSON。在发送请求时，请将发送数据的请求的报头设置为 `Accept:application/json, Content-Type:application/json`。\n例如在创建一个点时，请求报头包含以下内容：\n\n```\n    Accept: application/json; charset=UTF-8\n    Content-Type: application/json\n    server_version: 12\n```\n\n### 2.3.返回值\n\nTuGraph 返回的 HTTP 状态码包含以下四种：\n\n- 200 OK: 操作成功\n- 307 Temporary Redirect: 操作被重定向，一般用于高可用模式下，把操作重定向到 master 上\n- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误\n- 500 Internal Server Error: 服务器端错误"
            },
            {
                "content": "### 2.2.数据格式\n\n客户端与服务端数据交互的格式是 JSON。在发送请求时，请将发送数据的请求的报头设置为 `Accept:application/json, Content-Type:application/json`。\n例如在创建一个点时，请求报头包含以下内容：\n\n```\n    Accept: application/json; charset=UTF-8\n    Content-Type: application/json\n    server_version: 12\n```\n\n### 2.3.返回值\n\nTuGraph 返回的 HTTP 状态码包含以下四种：\n\n- 200 OK: 操作成功\n- 307 Temporary Redirect: 操作被重定向，一般用于高可用模式下，把操作重定向到 master 上\n- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误\n- 500 Internal Server Error: 服务器端错误\n\n当操作成功时，返回的 JSON 中包含操作的返回值。当操作重定向时，返回的 HTTP 报头中的 `location` 域包含重定向目的地址。\n当发生输入错误或者服务器错误时，返回的 JSON 中包含 `error_message` 域，其内容是错误提示。\n\n在高可用模式下，服务器还会在报头中设置 `server_version`，以告知客户端当前服务器的数据版本号。当客户端在不同的服务器之间切换时，该数据版本号可以保证客户端不会读到错误的历史数据。\n\n### 2.4.URI格式\n\nTuGraph REST API 提供以下功能：Service Root, login, info, label, index, node, relationship, cypher, cpp_plugin, 以及 python_plugin。\n各功能使用的 URI 格式如下："
            },
            {
                "content": "当操作成功时，返回的 JSON 中包含操作的返回值。当操作重定向时，返回的 HTTP 报头中的 `location` 域包含重定向目的地址。\n当发生输入错误或者服务器错误时，返回的 JSON 中包含 `error_message` 域，其内容是错误提示。\n\n在高可用模式下，服务器还会在报头中设置 `server_version`，以告知客户端当前服务器的数据版本号。当客户端在不同的服务器之间切换时，该数据版本号可以保证客户端不会读到错误的历史数据。\n\n### 2.4.URI格式\n\nTuGraph REST API 提供以下功能：Service Root, login, info, label, index, node, relationship, cypher, cpp_plugin, 以及 python_plugin。\n各功能使用的 URI 格式如下：\n\n| URI     | 说明                 |\n| ------- | -------------------- |\n| /web    | web 可视化界面       |\n| /cypher | cypher 请求          |\n| /acl    | 权限控制             |\n| /user   | 用户管理             |\n| /login  | 用户登录             |\n| /info   | 数据库状态及提示信息 |\n| /task   | 任务管理             |\n| /db     | 子图操作             |\n\n其中子图操作又分为："
            },
            {
                "content": "| URI     | 说明                 |\n| ------- | -------------------- |\n| /web    | web 可视化界面       |\n| /cypher | cypher 请求          |\n| /acl    | 权限控制             |\n| /user   | 用户管理             |\n| /login  | 用户登录             |\n| /info   | 数据库状态及提示信息 |\n| /task   | 任务管理             |\n| /db     | 子图操作             |\n\n其中子图操作又分为：\n\n| URI                              | 说明                 |\n| -------------------------------- | -------------------- |\n| /db                              | 子图的创建，删除     |\n| /db/_{graph_name}_/node          | 点操作             |\n| /db/_{graph_name}_/relationship  | 边操作               |\n| /db/_{graph_name}_/label         | Label 相关操作       |\n| /db/_{graph_name}_/index         | 索引相关操作         |\n| /db/_{graph_name}_/cypher        | 子图相关 cypher 操作 |\n| /db/_{graph_name}_/cpp_plugin    | C++存储过程          |\n| /db/_{graph_name}_/python_plugin | Python 存储过程      |\n| /db/_{graph_name}_/import        | 在线导入             |\n| /db/_{graph_name}_/misc          | 其它操作             |\n\n## 3.登录"
            },
            {
                "content": "## 3.登录\n\nTuGraph 提供基于 JWT 的用户认证方式，可以使用 HTTP 或 HTTPS 协议进行传输。系统默认使用 HTTP 协议，如果需要使用 HTTPS，需要在 lgraph.json 配置文件中将 ssl_auth 设为 1。\n\n### 3.1.登录\n\n用户通过用户名和密码发送登录请求。登录成功会收到带有签名的令牌(Json Web Token)和判断是否为默认密码的布尔型变量，客户端储存该令牌，并且用于以后的每次发送请求。如果登录失败会收到“Authentication failed”错误。\n\n- **URI**: `/login`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | user | 用户名 | 字符串 |\n  | password | 密码 | 字符串 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | jwt | 令牌 | 字符串 |\n  | default_password | 是否为默认密码 | 布尔值 |\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/login\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"user\":\"admin\",\n      \"password\":\"73@TuGraph\"\n    }\n```\n\n**Example response.**"
            },
            {
                "content": "- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | jwt | 令牌 | 字符串 |\n  | default_password | 是否为默认密码 | 布尔值 |\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/login\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"user\":\"admin\",\n      \"password\":\"73@TuGraph\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"jwt\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\",\n        \"default_password\": true\n    }\n```\n\n### 3.2.身份刷新\nToken失效后，前端发起刷新token接口，后端验证token合法性。初次登录后，1小时内有效，需刷新使用。即使刷新，24小时后也会强制退出，需要重新登陆。\n验证通过，生成新的token；验证失败返回状态码401。\n\n- **URI**: `/refresh`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | jwt | 令牌 | 字符串 |\n\n\n**Example request.**"
            },
            {
                "content": "### 3.2.身份刷新\nToken失效后，前端发起刷新token接口，后端验证token合法性。初次登录后，1小时内有效，需刷新使用。即使刷新，24小时后也会强制退出，需要重新登陆。\n验证通过，生成新的token；验证失败返回状态码401。\n\n- **URI**: `/refresh`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | jwt | 令牌 | 字符串 |\n\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/refresh\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\": \"Bearer eyJhbGciOiJIUz32NiIsInR5cCI6IkpXVDJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byj3fYVAH4D88dfTD_zYQ_uAvdizTMek\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"jwt\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\"\n    }\n```"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"jwt\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\"\n    }\n```\n\n### 3.3.修改Token有效期\n修改Token有效期，需要传输jwt，refresh_time和expire_time三个参数，其中jwt用于校验用户身份，refresh_time和expire_time等于0时，有效期为无期限，超过refresh_time时，需要调用refresh接口获取新的Token;超过expire_time时，需要重新登录。\n\n- **URI**: `/update_token_time`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n  | refresh_time | 有效时间（默认设置为0） | Int64 |\n  | expire_time | 有效时间（默认设置为0） | Int64 |\n\n- **RESPONSE**:  如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "### 3.3.修改Token有效期\n修改Token有效期，需要传输jwt，refresh_time和expire_time三个参数，其中jwt用于校验用户身份，refresh_time和expire_time等于0时，有效期为无期限，超过refresh_time时，需要调用refresh接口获取新的Token;超过expire_time时，需要重新登录。\n\n- **URI**: `/update_token_time`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n  | refresh_time | 有效时间（默认设置为0） | Int64 |\n  | expire_time | 有效时间（默认设置为0） | Int64 |\n\n- **RESPONSE**:  如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/update_token_time\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\" : \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU\",\n        \"refresh_time\":0,\n        \"expire_time\":0\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```"
            },
            {
                "content": "**Example request.**\n\n```\n    • POST http://localhost:7070/update_token_time\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\" : \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU\",\n        \"refresh_time\":0,\n        \"expire_time\":0\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 3.4.查询Token有效期\n查询Token有效期，需要传输jwt，用于校验用户身份，返回，refresh_time和expire_time，其中refresh_time表示刷新时间，超过时需要调用refresh接口获取新的Token;expire_time表示过期时间，超过时需要重新登录。\n- **URI**: `/get_token_time`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n\n- **RESPONSE**:  如果成功，返回\"refresh_time\"和\"expire_time\"。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n### 3.4.查询Token有效期\n查询Token有效期，需要传输jwt，用于校验用户身份，返回，refresh_time和expire_time，其中refresh_time表示刷新时间，超过时需要调用refresh接口获取新的Token;expire_time表示过期时间，超过时需要重新登录。\n- **URI**: `/get_token_time`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n\n- **RESPONSE**:  如果成功，返回\"refresh_time\"和\"expire_time\"。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/get_token_time\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\" : \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU\",\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"refresh_time\":600,\n        \"expire_time\":3600\n    }\n```\n\n### 3.5.登出\n用户登出，同时删除token。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"refresh_time\":600,\n        \"expire_time\":3600\n    }\n```\n\n### 3.5.登出\n用户登出，同时删除token。\n\n- **URI**: `/logout`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n- **RESPONSE**:  如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/logout\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\" : \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n## 4.查询\n\nURI 格式为\n\n```\n    http://{host}:{port}/cypher\n```\n\n### 4.1.调用Cypher\n\n- **URI**: `/cypher`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | graph | 数据库 | 字符串 |\n  | cypher | 查询语句 | 字符串 |"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n## 4.查询\n\nURI 格式为\n\n```\n    http://{host}:{port}/cypher\n```\n\n### 4.1.调用Cypher\n\n- **URI**: `/cypher`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | graph | 数据库 | 字符串 |\n  | cypher | 查询语句 | 字符串 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | result | 运行结果 | 列表 |\n  | elapsed | 运行时间（秒） | 浮点数 |\n  | header | 返回结果的表头 | 列表 |\n  | size | 结果数 | 整型 |\n\n其中 header 是一个列表，每一元素格式如下：\n\n| 域名 | 说明                                        | 类型   |\n| ---- | ------------------------------------------- | ------ |\n| name | 列名                                        | 字符串 |\n| type | 列数据类型，0 为标量，1 为点 id，2 为向量 |        |\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/cypher\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"graph\": \"default\",\n        \"script\": \"MATCH (n) RETURN n,n.name LIMIT 10\"\n    }\n```\n\n**Example response.**"
            },
            {
                "content": "**Example request.**\n\n```\n    • POST http://localhost:7070/cypher\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"graph\": \"default\",\n        \"script\": \"MATCH (n) RETURN n,n.name LIMIT 10\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"elapsed\": 0.001224517822265625,\n        \"header\": [\n            {\n                \"name\": \"n\",\n                \"type\": 1\n            },\n            {\n                \"name\": \"n.name\",\n                \"type\": 0\n            }\n        ]\n        \"result\": [\n            [\n                0,\n                \"Rachel Kempson\"\n            ],\n            [\n                1,\n                \"Michael Redgrave\"\n            ],\n            [\n                2,\n                \"Vanessa Redgrave\"\n            ]\n        ],\n        \"size\": 3\n    }\n```\n\n### 4.2.调用带参数的 Cypher\n\nCypher 支持使用参数进行查询。当调用带参数的 Cypher 查询时，TuGraph 会缓存该查询的\n执行计划（execution plan），以加速后续同类查询的速度。"
            },
            {
                "content": "### 4.2.调用带参数的 Cypher\n\nCypher 支持使用参数进行查询。当调用带参数的 Cypher 查询时，TuGraph 会缓存该查询的\n执行计划（execution plan），以加速后续同类查询的速度。\n\n- **URI**: `/cypher`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | graph | 数据库 | 字符串 |\n  | cypher | 查询语句 | 字符串 |\n  | parameters | 参数 | 列表 |\n\n- **RESPONSE**:\n\n与 [调用 Cypher](#%E8%B0%83%E7%94%A8Cypher) 相同。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/cypher\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"graph\": \"default\",\n      \"script\": \"MATCH (n:Person {name:$param1}) RETURN n.birthyear\",\n      \"parameters\": {\n        \"$param1\": \"Lindsay Lohan\"\n      }\n    }\n```\n\n**Example response.**"
            },
            {
                "content": "- **RESPONSE**:\n\n与 [调用 Cypher](#%E8%B0%83%E7%94%A8Cypher) 相同。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/cypher\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"graph\": \"default\",\n      \"script\": \"MATCH (n:Person {name:$param1}) RETURN n.birthyear\",\n      \"parameters\": {\n        \"$param1\": \"Lindsay Lohan\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"elapsed\": 0.005886077880859375,\n        \"header\": [\n            {\n                \"name\": \"n.birthyear\",\n                \"type\": 0\n            }\n        ],\n        \"result\": [\n            [\n                1986\n            ]\n        ],\n        \"size\": 1\n    }\n```\n\n\n## 5.存储过程\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/cpp_plugin|python_plugin\n```\n\n### 5.1.加载存储过程\n\nTuGraph 服务启动时，如果 load_plugins 为真，则会自动加载 plugin 目录下的所有 plugin。否则需要手动加载。此外，如果服务器运行过程中，管理员更新了 plugin 文件，也需要手动重新加载。重新加载 plugin 的调用格式为："
            },
            {
                "content": "## 5.存储过程\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/cpp_plugin|python_plugin\n```\n\n### 5.1.加载存储过程\n\nTuGraph 服务启动时，如果 load_plugins 为真，则会自动加载 plugin 目录下的所有 plugin。否则需要手动加载。此外，如果服务器运行过程中，管理员更新了 plugin 文件，也需要手动重新加载。重新加载 plugin 的调用格式为：\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 插件名称 | 字符串 |\n  | description | 插件说明 | 字符串 |\n  | code_base64 | 插件代码 | 字符串，使用 base64 编码 |\n  | read_only | 是否为只读存储过程 | 布尔值 |\n  | code_type | 上传代码的类型，C++类型可选 zip/so/cpp，Python 为 py | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/cpp_plugin\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"name\" : \"echo\",\n        \"description\" : \"A test plugin that returns the input\",\n        \"code_base64\" : \"{base64 encoded echo.zip}\",\n        \"read_only\" : true,\n        \"code_type\" : \"zip\"\n    }\n```"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/cpp_plugin\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"name\" : \"echo\",\n        \"description\" : \"A test plugin that returns the input\",\n        \"code_base64\" : \"{base64 encoded echo.zip}\",\n        \"read_only\" : true,\n        \"code_type\" : \"zip\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 5.2.列出所有存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin`\n- **METHOD**: GET\n- **RESPONSE**: 存储过程列表，其中每个元素是一个 plugin 的描述，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 存储过程名 | 字符串 |\n  | description | 存储过程描述 | 字符串 |\n  | read_only | 存储过程是否只读 | 布尔值 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/cpp_plugin\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n### 5.2.列出所有存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin`\n- **METHOD**: GET\n- **RESPONSE**: 存储过程列表，其中每个元素是一个 plugin 的描述，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 存储过程名 | 字符串 |\n  | description | 存储过程描述 | 字符串 |\n  | read_only | 存储过程是否只读 | 布尔值 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/cpp_plugin\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        [\n            {\n                \"description\":\"adds a vertex label to the db\",\n                \"name\":\"add_label\",\n                \"read_only\":false\n            },\n            {\n                \"description\": \"scans graph and get number of edges\",\n                \"name\": \"scan_graph\",\n                \"read_only\": true\n            }\n        ]\n    }\n```\n\n### 5.3.获取存储过程的详细信息"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        [\n            {\n                \"description\":\"adds a vertex label to the db\",\n                \"name\":\"add_label\",\n                \"read_only\":false\n            },\n            {\n                \"description\": \"scans graph and get number of edges\",\n                \"name\": \"scan_graph\",\n                \"read_only\": true\n            }\n        ]\n    }\n```\n\n### 5.3.获取存储过程的详细信息\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: GET\n- **RESPONSE**: 存储过程信息，包括代码，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 存储过程名 | 字符串 |\n  | description | 存储过程描述 | 字符串 |\n  | read_only | 存储过程是否只读 | 布尔值 |\n  | code_base64 | 存储过程的代码 | 字符串，使用 base64 编码 |\n  | code_type | 上传代码的类型，C++类型可选 zip/so/cpp，Python 为 py | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/cpp_plugin/echo\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/cpp_plugin/echo\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"name\" : \"echo\",\n        \"description\" : \"A test plugin that returns the input\",\n        \"code_base64\" : \"{base64 encoded echo.zip}\",\n        \"read_only\" : true,\n        \"code_type\" : \"zip\"\n    }\n```\n\n### 5.4.调用存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: POST\n- **REQUEST**: 字符串输入\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | data | 输入数据 | 字符串 |\n  | timeout | 超时长度（秒，可选，缺省值为 0） | 浮点 |\n  | in_process | 是否在本进程调用（可选，缺省值为 false） | 布尔值 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | result | 运行结果 | 字符串 |\n\n**Example request.**"
            },
            {
                "content": "### 5.4.调用存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: POST\n- **REQUEST**: 字符串输入\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | data | 输入数据 | 字符串 |\n  | timeout | 超时长度（秒，可选，缺省值为 0） | 浮点 |\n  | in_process | 是否在本进程调用（可选，缺省值为 false） | 布尔值 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | result | 运行结果 | 字符串 |\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/python_plugin/echo\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        data : \"Hello!\\n你好！\\nKonichiwa!\",\n        timeout : 0,\n        in_process : true\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n      \"result\": \"Hello!\\n你好！\\nKonichiwa!\"\n    }\n```\n\n### 5.5.删除存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n      \"result\": \"Hello!\\n你好！\\nKonichiwa!\"\n    }\n```\n\n### 5.5.删除存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/cpp_plugin/example_plugin\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n## 6.Deprecated\n\n以下接口将在4/30/2023之后被删除。\n\n### 6.1.用户管理\n\n系统默认创建一个管理员，管理员用户名为 _admin_，密码为 _73@TuGraph_。为了安全起见，请用户在第一次启动服务器后更改密码。\n\n\n#### 6.1.1.添加用户\n\n添加一个新的用户，并为其设置初始密码。只有管理员有权限进行此操作。其中用户名只能由字母，数字以及下划线构成，密码则可以包含任意字符。用户名和密码长度不能超过 64 字节。添加用户时还可以为用户增加一个描述，用户描述可以包含任意字符，最长不超过 512 字节。\n\n新用户默认拥有同名的角色，不具备任何图的权限。\n\n- **URI**: `/user`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | user | 用户名 | 字符串 |\n  | password | 密码 | 字符串 |\n  | description | 用户描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "以下接口将在4/30/2023之后被删除。\n\n### 6.1.用户管理\n\n系统默认创建一个管理员，管理员用户名为 _admin_，密码为 _73@TuGraph_。为了安全起见，请用户在第一次启动服务器后更改密码。\n\n\n#### 6.1.1.添加用户\n\n添加一个新的用户，并为其设置初始密码。只有管理员有权限进行此操作。其中用户名只能由字母，数字以及下划线构成，密码则可以包含任意字符。用户名和密码长度不能超过 64 字节。添加用户时还可以为用户增加一个描述，用户描述可以包含任意字符，最长不超过 512 字节。\n\n新用户默认拥有同名的角色，不具备任何图的权限。\n\n- **URI**: `/user`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | user | 用户名 | 字符串 |\n  | password | 密码 | 字符串 |\n  | description | 用户描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"user\": \"USER1\",\n        \"password\": \"AN_INITIAL_PASSWORD\",\n        \"description\": \"This is a user\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```"
            },
            {
                "content": "```\n    • POST http://localhost:7070/user\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"user\": \"USER1\",\n        \"password\": \"AN_INITIAL_PASSWORD\",\n        \"description\": \"This is a user\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.2.列出所有用户\n\n列出数据库的所有用户。只有管理员拥有该操作权限。\n\n- **URI**: `/user/`\n- **METHOD**: GET\n- **RESPONSE**: 所有用户及其信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/user\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**"
            },
            {
                "content": "```\n    • 200: OK\n```\n\n#### 6.1.2.列出所有用户\n\n列出数据库的所有用户。只有管理员拥有该操作权限。\n\n- **URI**: `/user/`\n- **METHOD**: GET\n- **RESPONSE**: 所有用户及其信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/user\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"admin\": {\n        \"disabled\": false,\n        \"description\": \"Builtin admin user\",\n        \"roles\": [\"admin\"]\n    },\n    \"guest1\": {\n        \"disabled\": true,\n        \"description\": \"\",\n        \"roles\": [\"guest1\", \"some_other_role\"]\n    }\n}\n```\n\n#### 6.1.3.获取用户信息\n\n列出给定用户的信息。\n\n- **URI**: `/user/{user_name}`\n- **METHOD**: GET\n- **RESPONSE**: 用户信息。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"admin\": {\n        \"disabled\": false,\n        \"description\": \"Builtin admin user\",\n        \"roles\": [\"admin\"]\n    },\n    \"guest1\": {\n        \"disabled\": true,\n        \"description\": \"\",\n        \"roles\": [\"guest1\", \"some_other_role\"]\n    }\n}\n```\n\n#### 6.1.3.获取用户信息\n\n列出给定用户的信息。\n\n- **URI**: `/user/{user_name}`\n- **METHOD**: GET\n- **RESPONSE**: 用户信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/user/guest1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"disabled\": true,\n    \"description\": \"A guest user\"\n    \"roles\": [\"guest1\", \"some_other_role\"]\n}\n```\n\n#### 6.1.4.列出用户权限\n\n列出给定用户有权限访问的所有图及相应权限。\n\n- **URI**: `/user/{user_name}/graph`\n- **METHOD**: GET\n- **RESPONSE**: 用户信息。"
            },
            {
                "content": "**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"disabled\": true,\n    \"description\": \"A guest user\"\n    \"roles\": [\"guest1\", \"some_other_role\"]\n}\n```\n\n#### 6.1.4.列出用户权限\n\n列出给定用户有权限访问的所有图及相应权限。\n\n- **URI**: `/user/{user_name}/graph`\n- **METHOD**: GET\n- **RESPONSE**: 用户信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/user/guest1/graph\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"graph1\" : \"FULL\",\n    \"graph2\" : \"READ\"\n}\n```\n\n#### 6.1.5.更改用户密码\n\n用户可以更改自己的密码，更改密码时需要同时提供原密码。管理员可以更改所有用户的密码。管理员更改其它用户密码时，可以不提供当前密码。\n\n- **URI**: `/user/{user_name}/password`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | current_password | 当前密码 | 字符串 |\n  | new_password | 新密码 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。"
            },
            {
                "content": "**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"graph1\" : \"FULL\",\n    \"graph2\" : \"READ\"\n}\n```\n\n#### 6.1.5.更改用户密码\n\n用户可以更改自己的密码，更改密码时需要同时提供原密码。管理员可以更改所有用户的密码。管理员更改其它用户密码时，可以不提供当前密码。\n\n- **URI**: `/user/{user_name}/password`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | current_password | 当前密码 | 字符串 |\n  | new_password | 新密码 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/user1/password\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"current_password\": \"THE_CURRENT_PASSWORD\"\n        \"new_password\": \"A_NEW_PASSWORD\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.6.修改用户描述\n\n用户可以修改自己的描述。管理员可以修改任意用户的描述。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.6.修改用户描述\n\n用户可以修改自己的描述。管理员可以修改任意用户的描述。\n\n- **URI**: `/user/{user_name}/description`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 用户描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/user1/description\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"description\": \"New description for this user.\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.7.删除用户\n\n删除用户及其所有相关权限，只有管理员拥有该操作权限。\n\n- **URI**: `/user/{user_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.7.删除用户\n\n删除用户及其所有相关权限，只有管理员拥有该操作权限。\n\n- **URI**: `/user/{user_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/user/guest1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.8.禁用用户\n\n用户可以被禁用。被禁用的用户将不能登陆，但是其资料仍然保存。被禁用的用户可以被重新启用。\n\n- **URI**: `/user/{user_name}/disable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.8.禁用用户\n\n用户可以被禁用。被禁用的用户将不能登陆，但是其资料仍然保存。被禁用的用户可以被重新启用。\n\n- **URI**: `/user/{user_name}/disable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/guest1/disable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.9.启用用户\n\n启用一个被禁用的用户。\n\n- **URI**: `/user/{user_name}/enable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.9.启用用户\n\n启用一个被禁用的用户。\n\n- **URI**: `/user/{user_name}/enable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/guest1/enable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.10.设置用户角色\n\n为指定用户设置角色。只有管理员可以执行此操作。\n\n用户角色列表必须是“全量列表”，即该列表需要包含该用户需要的所有角色。唯一的例外是用户的同名角色，即使列表中不含该角色，它也会被加到用户角色中。\n\n- **URI**: `/user/{user_name}/role`\n- **METHOD**: POST\n- **REQUEST**: 角色列表\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.10.设置用户角色\n\n为指定用户设置角色。只有管理员可以执行此操作。\n\n用户角色列表必须是“全量列表”，即该列表需要包含该用户需要的所有角色。唯一的例外是用户的同名角色，即使列表中不含该角色，它也会被加到用户角色中。\n\n- **URI**: `/user/{user_name}/role`\n- **METHOD**: POST\n- **REQUEST**: 角色列表\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/guest1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n        [\"role1\", \"role2\"]\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n此时用户`guest1`拥有角色`guest1`, `role1`和`role2`。\n\n### 6.2.角色管理\n\nTuGraph 使用基于角色的权限管理。\n\n同一用户可以拥有多个角色。新用户默认拥有与其同名的角色。删除用户时，同名角色也会被删除。如果新建用户时同名角色已经存在，则创建失败。\n\n同一角色可以对多个图有不同的权限。用户对某张图的权限由其所有角色对该图的最高权限决定。\n\nTuGraph 使用四级权限，不用的用户对不同的子图可以有不同的权限，四种权限及其说明如下："
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n此时用户`guest1`拥有角色`guest1`, `role1`和`role2`。\n\n### 6.2.角色管理\n\nTuGraph 使用基于角色的权限管理。\n\n同一用户可以拥有多个角色。新用户默认拥有与其同名的角色。删除用户时，同名角色也会被删除。如果新建用户时同名角色已经存在，则创建失败。\n\n同一角色可以对多个图有不同的权限。用户对某张图的权限由其所有角色对该图的最高权限决定。\n\nTuGraph 使用四级权限，不用的用户对不同的子图可以有不同的权限，四种权限及其说明如下：\n\n| 权限  | 说明                                                                             |\n| ----- | -------------------------------------------------------------------------------- |\n| NONE  | 无权限                                                                           |\n| READ  | 只读                                                                             |\n| WRITE | 可读写子图中的点和边                                                           |\n| FULL  | 完全权限，包括更改元数据（label, index），管理存储过程，以及删除子图中的所有数据 |\n\n管理员对所有子图都有完全权限，新建的用户对所有子图都没有权限。将用户加入管理员角色中可以将用户提升为管理员。\n\n#### 6.2.1.添加角色\n\n添加一个新的角色，并设置其描述。只有管理员有权限进行此操作。\n\n角色名只能由字母，数字以及下划线构成，密码则可以包含任意字符。角色名长度不能超过 64 字节。\n\n角色描述可以是任意字符串，长度不超过 512 字节。"
            },
            {
                "content": "管理员对所有子图都有完全权限，新建的用户对所有子图都没有权限。将用户加入管理员角色中可以将用户提升为管理员。\n\n#### 6.2.1.添加角色\n\n添加一个新的角色，并设置其描述。只有管理员有权限进行此操作。\n\n角色名只能由字母，数字以及下划线构成，密码则可以包含任意字符。角色名长度不能超过 64 字节。\n\n角色描述可以是任意字符串，长度不超过 512 字节。\n\n- **URI**: `/role`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | role | 角色名 | 字符串 |\n  | description | 角色描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"role\": \"new_role\",\n        \"description\": \"This is a new role.\",\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.2.修改角色描述\n\n修改角色的描述。只有管理员有权限进行此操作。角色描述可以是任意字符串，长度不超过 512 字节。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.2.修改角色描述\n\n修改角色的描述。只有管理员有权限进行此操作。角色描述可以是任意字符串，长度不超过 512 字节。\n\n- **URI**: `/role/{role_name}/description`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 新描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/description\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"description\": \"modified description\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.3.列出所有角色\n\n列出数据库的所有角色。只有管理员拥有该操作权限。\n\n- **URI**: `/role/`\n- **METHOD**: GET\n- **RESPONSE**: 所有角色及其信息。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.3.列出所有角色\n\n列出数据库的所有角色。只有管理员拥有该操作权限。\n\n- **URI**: `/role/`\n- **METHOD**: GET\n- **RESPONSE**: 所有角色及其信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/role\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"admin\": {\n        \"disabled\": false,\n        \"description\": \"Builtin administrator group.\",\n        \"permissions\": {\"default\":\"FULL\", \"graph1\":\"FULL\"}\n    },\n    \"role1\": {\n        \"disabled\": true,\n        \"description\": \"Another role\",\n        \"permissions\": {\"default\":\"READ\"}\n    }\n}\n```\n\n#### 6.2.4.获取角色信息\n\n列出给定角色的信息。\n\n- **URI**: `/role/{role_name}`\n- **METHOD**: GET\n- **RESPONSE**: 角色信息。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"admin\": {\n        \"disabled\": false,\n        \"description\": \"Builtin administrator group.\",\n        \"permissions\": {\"default\":\"FULL\", \"graph1\":\"FULL\"}\n    },\n    \"role1\": {\n        \"disabled\": true,\n        \"description\": \"Another role\",\n        \"permissions\": {\"default\":\"READ\"}\n    }\n}\n```\n\n#### 6.2.4.获取角色信息\n\n列出给定角色的信息。\n\n- **URI**: `/role/{role_name}`\n- **METHOD**: GET\n- **RESPONSE**: 角色信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/role/role1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"disabled\": true,\n    \"description\": \"Another role\",\n    \"permissions\": {\"default\":\"READ\"}\n}\n```\n\n#### 6.2.5.删除角色\n\n删除指定角色，只有管理员拥有该操作权限。"
            },
            {
                "content": "```\n    • GET http://localhost:7070/role/role1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"disabled\": true,\n    \"description\": \"Another role\",\n    \"permissions\": {\"default\":\"READ\"}\n}\n```\n\n#### 6.2.5.删除角色\n\n删除指定角色，只有管理员拥有该操作权限。\n\n- **URI**: `/role/{role_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/role/role1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.6.禁用角色"
            },
            {
                "content": "- **URI**: `/role/{role_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/role/role1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.6.禁用角色\n\n角色可以被禁用。角色被禁用后，具有该角色的用户将不再从该角色中获得任何权限。只有管理员可以执行此操作。\n\n- **URI**: `/role/{role_name}/disable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/disable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**"
            },
            {
                "content": "- **URI**: `/role/{role_name}/disable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/disable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.7.启用角色\n\n启用一个被禁用的角色。\n\n- **URI**: `/role/{role_name}/enable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/enable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```"
            },
            {
                "content": "启用一个被禁用的角色。\n\n- **URI**: `/role/{role_name}/enable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/enable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.8.设置角色权限\n\n为指定角色设置权限。只有管理员可以执行此操作。\n\n角色权限列表必须是“全量列表”，即该列表需要包含该角色能操作的所有图及其权限。\n\n- **URI**: `/role/{role_name}/permissions`\n- **METHOD**: POST\n- **REQUEST**: 图名称及相应权限的字典。\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.8.设置角色权限\n\n为指定角色设置权限。只有管理员可以执行此操作。\n\n角色权限列表必须是“全量列表”，即该列表需要包含该角色能操作的所有图及其权限。\n\n- **URI**: `/role/{role_name}/permissions`\n- **METHOD**: POST\n- **REQUEST**: 图名称及相应权限的字典。\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/permissions\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"graph1\" : \"FULL\",\n        \"graph2\" : \"READ\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n\n### 6.3.服务器状态\n\n#### 6.3.1.修改服务器配置\n\n修改服务器配置，配置修改后立即生效，并将影响所有服务器。这些配置的优先级高于配置文件以及命令行参数。\n\n- **URI**: `/config`\n- **METHOD**: PUT\n- **REQUEST**:\n\n请求为一个字典，使用 `{\"opt1\":v1}` 可以将名为`opt1`的配置修改为`v1`。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n\n### 6.3.服务器状态\n\n#### 6.3.1.修改服务器配置\n\n修改服务器配置，配置修改后立即生效，并将影响所有服务器。这些配置的优先级高于配置文件以及命令行参数。\n\n- **URI**: `/config`\n- **METHOD**: PUT\n- **REQUEST**:\n\n请求为一个字典，使用 `{\"opt1\":v1}` 可以将名为`opt1`的配置修改为`v1`。\n\n| 配置名               | 说明                   | 值类型 |\n| -------------------- | ---------------------- | ------ |\n| OPT_DB_ASYNC         | 是否启用异步模式       | 布尔值 |\n| OPT_TXN_OPTIMISTIC   | 是否默认使用乐观事务锁 | 布尔值 |\n| OPT_AUDIT_LOG_ENABLE | 是否启用审计日志       | 布尔值 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • PUT http://localhost:7070/config\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"OPT_DB_ASYNC\": true,\n        \"OPT_AUDIT_LOG_ENABLE\": false\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.3.2.当前服务器状态"
            },
            {
                "content": "```\n    • 200: OK\n```\n\n#### 6.3.2.当前服务器状态\n\n- **URI**: `/info`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | lgraph_version | 服务器版本号 | 字符串 |\n  | git_branch | 服务器代码分支 | 字符串 |\n  | git_commit | 服务器代码版本 | 字符串 |\n  | web_commit | 前端码版本 | 字符串 |\n  | cpp_id | CPP 编译器 ID | 字符串 |\n  | cpp_version | CPP 编译器版本 | 字符串 |\n  | python_version | PYTHON 版本 | 字符串 |\n  | node | 点 uri | 字符串 |\n  | relationship | 边 uri | 字符串 |\n  | cpu | cpu 信息 | 字典，格式参见[服务器 CPU 状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8CPU%E7%8A%B6%E6%80%81) |\n  | disk | 硬盘 IO 信息 | 字典，格式参见[服务器硬盘状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E7%9B%98%E7%8A%B6%E6%80%81) |\n  | memory | 内存信息 | 字典，格式参见[服务器内存状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81) |\n  | db_space | 图数据库占用空间 | 字典，格式参见[图数据库占用空间](#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4) |\n  | db_config | 图数据库配置信息 | 字典，格式参见[图数据库配置信息](#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF) |\n  | up_time | 数据库在线时长（秒） | 整型 |"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/info\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"lgraph_version\": \"1.2.0\",\n      \"git_branch\": \"master\",\n      \"git_commit\": \"9e2977d\",\n      \"web_commit\": \"1e2823d\",\n      \"cpu_id\": \"GUN\",\n      \"cpu_version\": \"4.8.5\",\n      \"python_version\": \"3.2\",\n      \"node\": \"/node\",\n      \"relationship\": \"/relationship\",\n      \"cpu\": {\n        \"self\": 25,\n        \"server\": 35,\n        \"unit\": \"%\"\n      },\n      \"disk\": {\n        \"read\": 2000,\n        \"write\": 2000,\n        \"unit\": \"B/s\"\n      },\n      \"memory\": {\n        \"self\": 25016,\n        \"server_avail\": 46865636,\n        \"server_total\": 65860552,\n        \"unit\": \"KB\"\n      },\n      \"db_space\": {\n        \"space\": 57344,\n        \"unit\": \"B\"\n      },\n      \"db_config\": {\n        \"db_async\": false,\n        \"disable_auth\": false,\n        \"enable_ha\": false,\n        ...\n      },\n      \"up_time\": 3235\n    }\n```\n\n#### 6.3.3.服务器 CPU 状态"
            },
            {
                "content": "#### 6.3.3.服务器 CPU 状态\n\n- **URI**: `/info/cpu`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | self | 图数据库应用程序 CPU 使用率 | 整型 |\n  | server | 服务器 CPU 使用率 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/cpu\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"self\": 25,\n      \"server\": 35,\n      \"unit\": \"%\"\n    }\n```\n\n#### 6.3.4.服务器硬盘状态\n\n- **URI**: `/info/disk`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | read | 服务器硬盘读速率 | 整型 |\n  | write | 服务器硬盘写速率 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/disk\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"read\": 2000,\n      \"write\": 2000,\n      \"unit\": \"B/s\"\n    }\n```"
            },
            {
                "content": "#### 6.3.4.服务器硬盘状态\n\n- **URI**: `/info/disk`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | read | 服务器硬盘读速率 | 整型 |\n  | write | 服务器硬盘写速率 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/disk\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"read\": 2000,\n      \"write\": 2000,\n      \"unit\": \"B/s\"\n    }\n```\n\n#### 6.3.5.服务器内存状态\n\n- **URI**: `/info/memory`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | self | 图数据库应用程序内存使用量 | 整型 |\n  | server_avail | 服务器可用内存 | 整型 |\n  | server_total | 服务器总内存 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/memory\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "#### 6.3.5.服务器内存状态\n\n- **URI**: `/info/memory`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | self | 图数据库应用程序内存使用量 | 整型 |\n  | server_avail | 服务器可用内存 | 整型 |\n  | server_total | 服务器总内存 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/memory\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"self\": 25016,\n      \"server_avail\": 46865636,\n      \"server_total\": 65860552,\n      \"unit\": \"KB\"\n    }\n```\n\n#### 6.3.6.图数据库占用空间\n\n- **URI**: `/info/db_space`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | space | 图数据库占用空间 | 整型 |\n  | disk_avail | 图数据库可用空间 | 整型 |\n  | disk_total | 服务器硬盘总空间 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/db_space\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "#### 6.3.6.图数据库占用空间\n\n- **URI**: `/info/db_space`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | space | 图数据库占用空间 | 整型 |\n  | disk_avail | 图数据库可用空间 | 整型 |\n  | disk_total | 服务器硬盘总空间 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/db_space\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"disk_avail\"::360074579968,\n      \"disk_total\"::984373800960,\n      \"space\": 57344,\n      \"unit\": \"B\"\n    }\n```\n\n#### 6.3.7.图数据库配置信息"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/info/db_space\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"disk_avail\"::360074579968,\n      \"disk_total\"::984373800960,\n      \"space\": 57344,\n      \"unit\": \"B\"\n    }\n```\n\n#### 6.3.7.图数据库配置信息\n\n- **URI**: `/info/db_config`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | db_async | 图数据库工作模式（同步或异步） | 布尔值 |\n  | disable_auth | 是否禁用身份验证 | 布尔值 |\n  | enable_ha | 是否启用高可用模式 | 布尔值 |\n  | enable_rpc | 是否启用 RPC 服务器 | 布尔值 |\n  | bind_host | REST 服务器的主机 | 字符串 |\n  | enable_audit_log | 是否启用日志审计 | 布尔值 |\n  | port | REST 服务器的端口 | 整型 |\n  | rpc_port | RPC 服务器的端口 | 整型 |\n  | optimistic_txn | 是否默认使用乐观事务锁 | 布尔值 |\n  | thread_limit | 图数据库应用程序的可用线程数 | 整型 |\n  | enable_ssl | 是否使用 SSL 进行身份验证 | 布尔值 |\n  | verbose | 输出的详细程度 | 整型 |\n\n**Example request.**"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/info/db_config\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"db_async\":false,\n      \"disable_auth\":false,\n      \"enable_ha\":false,\n      \"enable_rpc\":false,\n      \"bind_host\":\"127.0.0.1\",\n      \"enable_audit_log\":false,\n      \"port\":7070,\n      \"optimistic_txn\":false,\n      \"rpc_port\":9091,\n      \"thread_limit\":0,\n      \"enable_ssl\":false,\n      \"verbose\":2\n    }\n```\n\n#### 6.3.8.高可用服务器列表\n\n_(仅在高可用模式下有效)_\n\n- **URI**: `/info/peers`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回一个服务器信息列表，其中每个服务器信息格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | rpc_address | 服务器 RPC 地址 | 字符串 |\n  | rest_address | 服务器 REST 地址 | 字符串 |\n  | state | 服务器状态 | 字符串 |\n\n其中服务器状态可为 `MASTER`,`SLAVE`,`OFFLINE`。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/peers\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "#### 6.3.8.高可用服务器列表\n\n_(仅在高可用模式下有效)_\n\n- **URI**: `/info/peers`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回一个服务器信息列表，其中每个服务器信息格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | rpc_address | 服务器 RPC 地址 | 字符串 |\n  | rest_address | 服务器 REST 地址 | 字符串 |\n  | state | 服务器状态 | 字符串 |\n\n其中服务器状态可为 `MASTER`,`SLAVE`,`OFFLINE`。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/peers\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      [\n          {\n              \"rest_address\":\"192.168.1.22:17071\",\n              \"rpc_address\":\"192.168.1.22:19091\",\n              \"state\":\"MASTER\"\n          },\n          {\n              \"rest_address\":\"192.168.1.22:17072\",\n              \"rpc_address\":\"192.168.1.22:19092\",\n              \"state\":\"SLAVE\"\n          }\n      ]\n    }\n```\n\n#### 6.3.9.当前 Leader 信息\n\n_(仅在高可用模式下有效)_"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      [\n          {\n              \"rest_address\":\"192.168.1.22:17071\",\n              \"rpc_address\":\"192.168.1.22:19091\",\n              \"state\":\"MASTER\"\n          },\n          {\n              \"rest_address\":\"192.168.1.22:17072\",\n              \"rpc_address\":\"192.168.1.22:19092\",\n              \"state\":\"SLAVE\"\n          }\n      ]\n    }\n```\n\n#### 6.3.9.当前 Leader 信息\n\n_(仅在高可用模式下有效)_\n\n- **URI**: `/info/leader`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前 leader 服务器信息，格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | rpc_address | 服务器 RPC 地址 | 字符串 |\n  | rest_address | 服务器 REST 地址 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/leader\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "#### 6.3.9.当前 Leader 信息\n\n_(仅在高可用模式下有效)_\n\n- **URI**: `/info/leader`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前 leader 服务器信息，格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | rpc_address | 服务器 RPC 地址 | 字符串 |\n  | rest_address | 服务器 REST 地址 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/leader\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"rest_address\":\"192.168.1.22:17071\",\n      \"rpc_address\":\"192.168.1.22:19091\"\n    }\n```\n\n#### 6.3.10.服务器统计信息\n\n- **URI**: `/info/statistics`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前服务器统计信息，格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | requests/second | 每秒处理的请求数量 | 浮点型 |\n  | writes/second | 每秒处理的写请求数量 | 浮点型 |\n  | running_tasks | 正在执行的请求数量 | 整型 |\n  | failure_rate | 请求失败率 | 浮点型 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/statistics\n    • Accept: application/json; charset=UTF-8\n```"
            },
            {
                "content": "#### 6.3.10.服务器统计信息\n\n- **URI**: `/info/statistics`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前服务器统计信息，格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | requests/second | 每秒处理的请求数量 | 浮点型 |\n  | writes/second | 每秒处理的写请求数量 | 浮点型 |\n  | running_tasks | 正在执行的请求数量 | 整型 |\n  | failure_rate | 请求失败率 | 浮点型 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/statistics\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"failure_rate\": 2.3,\n        \"requests/second\": 122.3,\n        \"running_tasks\": 10,\n        \"writes/second\": 12.4\n    }\n```\n\n#### 6.3.11.审计日志信息"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/info/statistics\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"failure_rate\": 2.3,\n        \"requests/second\": 122.3,\n        \"running_tasks\": 10,\n        \"writes/second\": 12.4\n    }\n```\n\n#### 6.3.11.审计日志信息\n\n- **URI**: `/info/log/?begin_time={begin_time}&end_time={end_time}&user={user}#_log={num_log}&descending_order={descending_order}`\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | begin_time | 查询日志的起始时间(必填，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |\n  | end_time | 查询日志的结束时间(默认为当前时间，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |\n  | user | 查询日志的操作者(管理员可查询所有用户的日志，普通用户只能查询本人日志) | 字符串 |\n  | num_log | 查询日志的数量(默认为 100) | 整型 |\n  | descending_order | 查询结果是否降序输出(默认为 true) | 布尔值 |"
            },
            {
                "content": "#### 6.3.11.审计日志信息\n\n- **URI**: `/info/log/?begin_time={begin_time}&end_time={end_time}&user={user}#_log={num_log}&descending_order={descending_order}`\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | begin_time | 查询日志的起始时间(必填，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |\n  | end_time | 查询日志的结束时间(默认为当前时间，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |\n  | user | 查询日志的操作者(管理员可查询所有用户的日志，普通用户只能查询本人日志) | 字符串 |\n  | num_log | 查询日志的数量(默认为 100) | 整型 |\n  | descending_order | 查询结果是否降序输出(默认为 true) | 布尔值 |\n\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回审计日志列表，其中每个元素是一条操作日志，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | index | 该操作的索引值 | 整型 |\n  | begin_time | 该操作的开始时间 | 字符串 |\n  | end_time | 该操作的结束时间 | 字符串 |\n  | user | 该操作的发起者 | 字符串 |\n  | graph | 该操作的图 | 字符串 |\n  | type | 该操作的类型 | 字符串 |\n  | read_write | 该操作为读操作或者写操作 | 字符串 |\n  | success | 该操作是否成功 | 布尔值 |\n  | content | 该操作的简要内容 | 字符串 |\n\n**Example request.**"
            },
            {
                "content": "- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回审计日志列表，其中每个元素是一条操作日志，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | index | 该操作的索引值 | 整型 |\n  | begin_time | 该操作的开始时间 | 字符串 |\n  | end_time | 该操作的结束时间 | 字符串 |\n  | user | 该操作的发起者 | 字符串 |\n  | graph | 该操作的图 | 字符串 |\n  | type | 该操作的类型 | 字符串 |\n  | read_write | 该操作为读操作或者写操作 | 字符串 |\n  | success | 该操作是否成功 | 布尔值 |\n  | content | 该操作的简要内容 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/log/?begin_time=2020-02-17%2015:00:00&end_time=2020-02-20%2012:00:00&user=admin#_log=100&descending_order=false\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            {\n                \"begin_time\": \"2020-02-17 15:27:15\",\n                \"content\": \"post /login    Successful\",\n                \"end_time\": \"2020-02-17 15:27:15\",\n                \"graph\": \"\",\n                \"index\": 1,\n                \"read_write\": \"read\",\n                \"success\": true,\n                \"type\": \"Security\",\n                \"user\":\"admin\"\n            },\n            {\n                \"begin_time\": \"2020-02-17 15:27:15\",\n                \"content\": \"Load plugin : `echo`    Successful\",\n                \"end_time\": \"2020-02-17 15:27:15\",\n                \"graph\": \"default\",\n                \"index\": 2,\n                \"read_write\": \"write\",\n                \"success\": true,\n                \"type\": \"Plugin\",\n                \"user\": \"admin\"\n            },\n            ...\n        ]\n    }\n```\n\n### 6.4.任务管理"
            },
            {
                "content": "### 6.4.任务管理\n\nTuGraph 提供长任务的跟踪和中止功能。用户可以通过 REST API 来查询当前正在运行的在 Cypher 和存储过程查询，并选择中止正在执行的查询。\n\n任务管理对应的 URI 格式为\n\n```\n    http://{host}:{port}/task/{thread_id}/{task_id}\n```\n\n#### 6.4.1.查询正在执行的任务\n\n- **URI**: `/task`\n- **METHOD**: GET\n- **RESPONSE**:\n\n返回的 JSON 为一个数组，其中每一个元素格式如下：\n\n| 域名         | 说明                         | 类型   |\n| ------------ | ---------------------------- | ------ |\n| description  | 任务描述                     | 字符串 |\n| time_elapsed | 任务已经执行的时间，单位为秒 | 浮点   |\n| task_id      | 任务 ID                      | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/task\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "#### 6.4.1.查询正在执行的任务\n\n- **URI**: `/task`\n- **METHOD**: GET\n- **RESPONSE**:\n\n返回的 JSON 为一个数组，其中每一个元素格式如下：\n\n| 域名         | 说明                         | 类型   |\n| ------------ | ---------------------------- | ------ |\n| description  | 任务描述                     | 字符串 |\n| time_elapsed | 任务已经执行的时间，单位为秒 | 浮点   |\n| task_id      | 任务 ID                      | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/task\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            {\n                \"description\" : \"[CPP_PLUGIN] scan_graph\",\n                \"time_elapsed\" : 13.987,\n                \"task_id\" : \"3_10\"\n            },\n            {\n                \"description\" : \"[CYPHER] MATCH(n) return n\",\n                \"time_elapsed\" : 30.887,\n                \"task_id\" : \"2_6\"\n            }\n        ]\n    }\n```\n\n#### 6.4.2.中止任务"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            {\n                \"description\" : \"[CPP_PLUGIN] scan_graph\",\n                \"time_elapsed\" : 13.987,\n                \"task_id\" : \"3_10\"\n            },\n            {\n                \"description\" : \"[CYPHER] MATCH(n) return n\",\n                \"time_elapsed\" : 30.887,\n                \"task_id\" : \"2_6\"\n            }\n        ]\n    }\n```\n\n#### 6.4.2.中止任务\n\n- **URI**: `/task/{task_id}`\n  其中 `{task_id}` 是 `GET /task` 返回结果中的 `task_id`。\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/task/3_10\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.5.子图管理\n\nTuGraph 支持多子图，子图之间完全独立，不同的子图可以对不同用户开放不同权限。管理员可以添加和删除子图。\n\n#### 6.5.1.创建新子图"
            },
            {
                "content": "#### 6.4.2.中止任务\n\n- **URI**: `/task/{task_id}`\n  其中 `{task_id}` 是 `GET /task` 返回结果中的 `task_id`。\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/task/3_10\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.5.子图管理\n\nTuGraph 支持多子图，子图之间完全独立，不同的子图可以对不同用户开放不同权限。管理员可以添加和删除子图。\n\n#### 6.5.1.创建新子图\n\n- **URI**: `/db`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 子图名 | 字符串 |\n  | config | 配置 | 字典，格式为 { {列名 1}:{列值 1},... } |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"name\":\"graph1\",\n        \"config\" : {\n            \"max_size_GB\":2048,\n            \"description\": \"description of graph1\"\n        }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.5.2.删除子图"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"name\":\"graph1\",\n        \"config\" : {\n            \"max_size_GB\":2048,\n            \"description\": \"description of graph1\"\n        }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.5.2.删除子图\n\n- **URI**: `/db/{graph_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.5.3.列出所有子图\n\n- **URI**: `/db`\n- **METHOD**: GET\n- **RESPONSE**: 子图列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"graph1\": {\n            \"max_size_GB\":1024,\n            \"description\":\"description of graph1\"\n        }\n    }\n```\n\n#### 6.5.4.获取子图信息"
            },
            {
                "content": "```\n    • DELETE http://localhost:7070/db/graph1\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.5.3.列出所有子图\n\n- **URI**: `/db`\n- **METHOD**: GET\n- **RESPONSE**: 子图列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"graph1\": {\n            \"max_size_GB\":1024,\n            \"description\":\"description of graph1\"\n        }\n    }\n```\n\n#### 6.5.4.获取子图信息\n\n- **URI**: `/db/{graph_name}`\n- **METHOD**: GET\n- **RESPONSE**: 子图列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"max_size_GB\":1024,\n        \"description\":\"description of graph1\"\n    }\n```\n\n### 6.6.元数据管理\n\nTuGraph 是一个具备多图能力的强模式属性图数据库。在每一张子图中，每种点和边都需要有预定义的数据格式。数据格式由 Label 决定，每种 Label 都有自己的数据格式。用户可以使用 REST API 添加，删除和查询 Label 及其对应的数据格式。\n\nLabel 操作对应的 URI 格式为"
            },
            {
                "content": "- **URI**: `/db/{graph_name}`\n- **METHOD**: GET\n- **RESPONSE**: 子图列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"max_size_GB\":1024,\n        \"description\":\"description of graph1\"\n    }\n```\n\n### 6.6.元数据管理\n\nTuGraph 是一个具备多图能力的强模式属性图数据库。在每一张子图中，每种点和边都需要有预定义的数据格式。数据格式由 Label 决定，每种 Label 都有自己的数据格式。用户可以使用 REST API 添加，删除和查询 Label 及其对应的数据格式。\n\nLabel 操作对应的 URI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/label/{type}/{label_name}\n```\n\n其中{type}可以是 node 或者 relationship。\n\n#### 6.6.1.创建Label\n\n创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。\n\n- **URI**: `/db/{graph_name}/label`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | Label 名 | 字符串 |\n  | fields | 数据列定义 | 列表 |\n  | is_vertex | 是否是点 Label | 布尔值 |\n  | primary | 点的主键属性 | 字符串 |\n  | edge_constraints | 边的约束 | 列表 |\n\n`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。"
            },
            {
                "content": "其中{type}可以是 node 或者 relationship。\n\n#### 6.6.1.创建Label\n\n创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。\n\n- **URI**: `/db/{graph_name}/label`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | Label 名 | 字符串 |\n  | fields | 数据列定义 | 列表 |\n  | is_vertex | 是否是点 Label | 布尔值 |\n  | primary | 点的主键属性 | 字符串 |\n  | edge_constraints | 边的约束 | 列表 |\n\n`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。\n\n`edge_constraints` 在 `is_vertex` 为 `false` 的时候设置，这个字段只有边有。这个字段限制了该边的起点和终点只能是哪些点的组合，比如：`[[\"vertex_label1\",\"vertex_label2\"],[\"vertex_label3\",\"vertex_label4\"]]`，限制了该边只能是从 `vertex_label1` 到 `vertex_label2` 和 从 `vertex_label3` 到 `vertex_label4`。如果不想有任何限制，不设置该字段即可。\n\n其中`fields`为一个数组，其中每个元素定义数据的一列，内容如下："
            },
            {
                "content": "其中`fields`为一个数组，其中每个元素定义数据的一列，内容如下：\n\n| 域名     | 说明                                     | 类型                                                                                                |\n| -------- | ---------------------------------------- | --------------------------------------------------------------------------------------------------- |\n| name     | 列名                                     | 字符串                                                                                              |\n| type     | 列数据类型                               | 字符串，有以下类型： int8, int16, int32, int64, float, double, string, date, datetime, binary, bool |\n| optional | 数据是否可以为空（可选，缺省值为 false） | 布尔值                                                                                              |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/label\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"name\":\"Actor\",\n        \"fields\": [\n                {\"name\":\"uid\", \"type\":\"int64\", \"optional\":false},\n                {\"name\":\"name\", \"type\":\"string\", \"optional\":true}\n        ],\n        \"is_vertex\":true,\n        \"primary\" : \"uid\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.6.2.列出所有 Label\n\n- **URI**: `/db/{graph_name}/label`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | edge | 边 Label 列表 | 列表 |\n  | vertex | 点 Label 列表 | 列表 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/label\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.6.2.列出所有 Label\n\n- **URI**: `/db/{graph_name}/label`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | edge | 边 Label 列表 | 列表 |\n  | vertex | 点 Label 列表 | 列表 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/label\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"edge\": [\n            \"HAS_CHILD\",\n            \"MARRIED\",\n            \"BORN_IN\",\n            \"DIRECTED\",\n            \"WROTE_MUSIC_FOR\",\n            \"ACTED_IN\"\n        ],\n        \"vertex\": [\n            \"Person\",\n            \"City\",\n            \"Film\"\n        ]\n    }\n```\n\n#### 6.6.3.获取 Label 的数据格式定义\n\n- **URI**: `/db/{graph_name}/label/{[node|relationship]}/{label_name}`\n- **METHOD**: GET\n- **RESPONSE**: 数据列定义表，类型是一个词典，key 为列名，value 为列定义，列定义见如下：\n-"
            },
            {
                "content": "#### 6.6.3.获取 Label 的数据格式定义\n\n- **URI**: `/db/{graph_name}/label/{[node|relationship]}/{label_name}`\n- **METHOD**: GET\n- **RESPONSE**: 数据列定义表，类型是一个词典，key 为列名，value 为列定义，列定义见如下：\n-\n\n| 域名     | 说明             | 类型   |\n| -------- | ---------------- | ------ |\n| optional | 该列值是否可为空 | 布尔值 |\n| type     | 列值类型         | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/label/node/person\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"age\":{\n            \"optional\":false,\n            \"type\":\"int16\"\n        },\n        \"id\":{\n            \"optional\":false,\n            \"type\":\"int8\"\n        },\n        \"name\":{\n            \"optional\":false,\n            \"type\":\"string\"\n        }\n    }\n```\n\n#### 6.6.4.Schema 导入\n\n- **URI**: `/db/{graph_name}/schema/text`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 文件内容描述 | 字符串 |"
            },
            {
                "content": "#### 6.6.4.Schema 导入\n\n- **URI**: `/db/{graph_name}/schema/text`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 文件内容描述 | 字符串 |\n\ndescription 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。\n\n- **RESPONSE**:\n\nSchema 导入会根据 description 比较新的 Schema 和数据库中原有的 Schema 是否兼容，检查的粒度为 Label。如果不一致则出错，如果一致则添加原先 Schema 中不存在的 Label，返回 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/schema/text\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"description\": \"{\\\\\"schema\\\\\":[{\\\\\"label\\\\\":\\\\\"actor\\\\\",\\\\\"primary\\\\\":\\\\\"aid\\\\\",\\\\\"properties\\\\\":[{\\\\\"name\\\\\":\\\\\"aid\\\\\",\\\\\"type\\\\\":\\\\\"STRING\\\\\"}],\\\\\"type\\\\\":\\\\\"VERTEX\\\\\"}]}\"\n    }\n```\n\n上述 description 的值是如下 json 序列化后的字符串:\n\n```json\n{\n  \"schema\": [\n    {\n      \"label\": \"actor\",\n      \"type\": \"VERTEX\",\n      \"properties\": [{ \"name\": \"aid\", \"type\": \"STRING\" }],\n      \"primary\": \"aid\"\n    }\n  ]\n}\n```\n\n**Example response.**"
            },
            {
                "content": "上述 description 的值是如下 json 序列化后的字符串:\n\n```json\n{\n  \"schema\": [\n    {\n      \"label\": \"actor\",\n      \"type\": \"VERTEX\",\n      \"properties\": [{ \"name\": \"aid\", \"type\": \"STRING\" }],\n      \"primary\": \"aid\"\n    }\n  ]\n}\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"log\": \"\"\n    }\n```\n\n### 6.7.点操作\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/node/{vid}\n```\n\nNodes 提供节点（Vertex）的 CRUD 操作，接受 GET/POST/PUT/DELETE 请求。\n\n#### 6.7.1.列出点数量和label数量\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | num_label | 点 label 数量 | 整数 |\n  | num_vertex | 点数量 | 整数 |\n\n_注意 num_vertex 返回的并不是准确的点数量，只是一个估计值。_\n\n#### 6.7.2.创建一个点\n\n向数据库中插入一个点。\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | property | 点属性 | 字典，其中 key 是列名，value 是相应值。value 必须是与列类型相应的类型，如列为 int32，则 value 只能是整数。 |\n\n- **RESPONSE**: 如果成功，返回代码 200。并在 JSON 内容中返回新点 vid。该 ID 可用于后续的点操作中。"
            },
            {
                "content": "_注意 num_vertex 返回的并不是准确的点数量，只是一个估计值。_\n\n#### 6.7.2.创建一个点\n\n向数据库中插入一个点。\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | property | 点属性 | 字典，其中 key 是列名，value 是相应值。value 必须是与列类型相应的类型，如列为 int32，则 value 只能是整数。 |\n\n- **RESPONSE**: 如果成功，返回代码 200。并在 JSON 内容中返回新点 vid。该 ID 可用于后续的点操作中。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"label\" : \"Person\",\n        \"property\" : {\n            \"name\" : \"Passerby A\",\n            \"birthyear\" : 1989\n        }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        21\n    }\n```\n\n#### 6.7.3.批量创建点\n\nTuGraph 允许一次性插入多个点，以减少网络开销。"
            },
            {
                "content": "**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"label\" : \"Person\",\n        \"property\" : {\n            \"name\" : \"Passerby A\",\n            \"birthyear\" : 1989\n        }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        21\n    }\n```\n\n#### 6.7.3.批量创建点\n\nTuGraph 允许一次性插入多个点，以减少网络开销。\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | fields | 点属性 | 列表 |\n  | values | 点数据 | 列表 |\n\n其中 fields 是一个字符串列表，列出一系列列名；values 是一个列表，其中每个元素是一个列表，列表中每个元素是列数据。\n\n- **RESPONSE**: 如果成功，返回代码 200。并在 JSON 内容中返回新增加的点的 vid 列表，该列表中每一个 vid 按顺序对应请求中的每一个点。\n\n**Example request.**"
            },
            {
                "content": "#### 6.7.3.批量创建点\n\nTuGraph 允许一次性插入多个点，以减少网络开销。\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | fields | 点属性 | 列表 |\n  | values | 点数据 | 列表 |\n\n其中 fields 是一个字符串列表，列出一系列列名；values 是一个列表，其中每个元素是一个列表，列表中每个元素是列数据。\n\n- **RESPONSE**: 如果成功，返回代码 200。并在 JSON 内容中返回新增加的点的 vid 列表，该列表中每一个 vid 按顺序对应请求中的每一个点。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"label\" : \"Person\",\n        \"fields\" : [\"name\", \"birthyear\"],\n        \"values\" : [[\"alex\", 2000],\n                    [\"bob\", 1999]]\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            22,\n            23\n        ]\n    }\n```\n\n#### 6.7.4.获取点"
            },
            {
                "content": "```\n    • POST http://localhost:7070/db/{graph_name}/node\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"label\" : \"Person\",\n        \"fields\" : [\"name\", \"birthyear\"],\n        \"values\" : [[\"alex\", 2000],\n                    [\"bob\", 1999]]\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            22,\n            23\n        ]\n    }\n```\n\n#### 6.7.4.获取点\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | property | 属性 | 字典，格式为 { {列名 1}:{列值 1},...} |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "#### 6.7.4.获取点\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | property | 属性 | 字典，格式为 { {列名 1}:{列值 1},...} |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"property\": {\n            \"birthyear\": 1963,\n            \"name\": \"Natasha Richardson\"\n        },\n        \"label\": \"Person\"\n    }\n```\n\n#### 6.7.5.删除点\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | in | 被删掉的点的入边数量 | 整数值 |\n  | out | 被删掉的点的出边数量 | 整数值 |\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/{graph_name}/node/4\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "#### 6.7.5.删除点\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | in | 被删掉的点的入边数量 | 整数值 |\n  | out | 被删掉的点的出边数量 | 整数值 |\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/{graph_name}/node/4\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"in\": 0,\n        \"out\": 0\n    }\n```\n\n#### 6.7.6.获取点所有属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}/property`\n- **METHOD**: GET\n- **RESPONSE**: Node 所有属性（字典）\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5/property\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"birthyear\": 1963,\n        \"name\": \"Natasha Richardson\"\n    }\n```\n\n#### 6.7.7.获取点属性"
            },
            {
                "content": "#### 6.7.6.获取点所有属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}/property`\n- **METHOD**: GET\n- **RESPONSE**: Node 所有属性（字典）\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5/property\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"birthyear\": 1963,\n        \"name\": \"Natasha Richardson\"\n    }\n```\n\n#### 6.7.7.获取点属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}/property/{field}`\n- **METHOD**: GET\n- **RESPONSE**: Node 某一属性\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5/property/name\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"Natasha Richardson\"\n    }\n```\n\n#### 6.7.8.更新点属性"
            },
            {
                "content": "#### 6.7.7.获取点属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}/property/{field}`\n- **METHOD**: GET\n- **RESPONSE**: Node 某一属性\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5/property/name\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"Natasha Richardson\"\n    }\n```\n\n#### 6.7.8.更新点属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | property | 点属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • PUT http://localhost:7070/db/{graph_name}/node/5\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"property\" : {\n        \"birthyear\" : 1964,\n        \"mobile\" : \"********\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.8.边操作\n\nURI 格式为"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • PUT http://localhost:7070/db/{graph_name}/node/5\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"property\" : {\n        \"birthyear\" : 1964,\n        \"mobile\" : \"********\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.8.边操作\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/relationship/{euid}\n```\n\n与 Nodes 功能类似，Relationships 提供边（edge）的 CRUD 操作，接受 GET/POST/PUT/DELETE 请求。每一条边都可以由一个唯一 ID（euid）来标识。这个 ID 可以从在插入边时获得，或者在 [列出所有边](#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BE%B9) 操作中得到。\n\n#### 6.8.1.创建一条边\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | destination | 目的点 ID | 整数值 |\n  | property | 边属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid（字符串）。\n\n**Example request.**"
            },
            {
                "content": "与 Nodes 功能类似，Relationships 提供边（edge）的 CRUD 操作，接受 GET/POST/PUT/DELETE 请求。每一条边都可以由一个唯一 ID（euid）来标识。这个 ID 可以从在插入边时获得，或者在 [列出所有边](#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BE%B9) 操作中得到。\n\n#### 6.8.1.创建一条边\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | destination | 目的点 ID | 整数值 |\n  | property | 边属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid（字符串）。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node/{src}/relationship\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"destination\" : 14,\n      \"label\" : \"BORN_IN\",\n      \"property\" : {}\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"1_14_1_0\"\n    }\n```\n\n#### 6.8.2.批量创建边"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid（字符串）。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node/{src}/relationship\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"destination\" : 14,\n      \"label\" : \"BORN_IN\",\n      \"property\" : {}\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"1_14_1_0\"\n    }\n```\n\n#### 6.8.2.批量创建边\n\n- **URI**: `/db/{graph_name}/relationship`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | fields | 数据列名 | 列表 |\n  | edge | 边数据 | 列表 |\n\n其中 edge 是一个数据列表，其中每个元素都是一条边，其定义如下："
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"1_14_1_0\"\n    }\n```\n\n#### 6.8.2.批量创建边\n\n- **URI**: `/db/{graph_name}/relationship`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | fields | 数据列名 | 列表 |\n  | edge | 边数据 | 列表 |\n\n其中 edge 是一个数据列表，其中每个元素都是一条边，其定义如下：\n\n| 域名        | 说明     | 类型                                                   |\n| ----------- | -------- | ------------------------------------------------------ |\n| source      | 起点 id  | 整数                                                   |\n| destination | 终点 id  | 整数                                                   |\n| values      | 数据列表 | 列表，每列对应 fields 中的一个列，类型是该列对应的类型 |\n\n- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid 列表。\n\n**Example request.**"
            },
            {
                "content": "其中 edge 是一个数据列表，其中每个元素都是一条边，其定义如下：\n\n| 域名        | 说明     | 类型                                                   |\n| ----------- | -------- | ------------------------------------------------------ |\n| source      | 起点 id  | 整数                                                   |\n| destination | 终点 id  | 整数                                                   |\n| values      | 数据列表 | 列表，每列对应 fields 中的一个列，类型是该列对应的类型 |\n\n- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid 列表。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/relationship\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"label\" : \"knows\",\n      \"fields\" : [\"from_year\", \"weight\"],\n      \"edge\" : [\n          {\"source\":0, \"destination\":1, \"values\":[2011, 0.8]},\n          {\"source\":1, \"destination\":2, \"values\":[2008, 0.9]}\n      ]\n    }\n```\n\n**Example response.**"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid 列表。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/relationship\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"label\" : \"knows\",\n      \"fields\" : [\"from_year\", \"weight\"],\n      \"edge\" : [\n          {\"source\":0, \"destination\":1, \"values\":[2011, 0.8]},\n          {\"source\":1, \"destination\":2, \"values\":[2008, 0.9]}\n      ]\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"0_1_0_0\",\n            \"1_2_0_0\"\n        ]\n    }\n```\n\n#### 6.8.3.列出所有出边（outgoing relationships）\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship/out`\n- **METHOD**: GET\n- **RESPONSE**: 点 src 的所有出边 euid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationship/out\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"0_1_0_0\",\n            \"1_2_0_0\"\n        ]\n    }\n```\n\n#### 6.8.3.列出所有出边（outgoing relationships）\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship/out`\n- **METHOD**: GET\n- **RESPONSE**: 点 src 的所有出边 euid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationship/out\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"4_5_0_0\",\n            \"4_7_1_2\"\n        ]\n    }\n```\n\n#### 6.8.4.列出所有入边（incoming relationships）\n\n- **URI**: `/db/{graph_name}/node/{dst}/relationship/in`\n- **METHOD**: GET\n- **RESPONSE**: 点 dst 的所有入边 euid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationship/in\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"4_5_0_0\",\n            \"4_7_1_2\"\n        ]\n    }\n```\n\n#### 6.8.4.列出所有入边（incoming relationships）\n\n- **URI**: `/db/{graph_name}/node/{dst}/relationship/in`\n- **METHOD**: GET\n- **RESPONSE**: 点 dst 的所有入边 euid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationship/in\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"0_4_0_0\",\n            \"3_4_3_1\"\n        ]\n    }\n```\n\n#### 6.8.5.列出所有边\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship/all`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | in | 入边 | 列表 |\n  | out | 出边 | 列表 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationships/all\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "#### 6.8.5.列出所有边\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship/all`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | in | 入边 | 列表 |\n  | out | 出边 | 列表 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationships/all\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"out\": [\n            \"4_5_0_0\",\n            \"4_7_1_2\"\n        ],\n        \"in\": [\n            \"0_4_0_0\",\n            \"3_4_3_1\"\n        ]\n    }\n```\n\n#### 6.8.6.获取边\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | property | 边属性 | 字典 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/relationship/0_4_0_0\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "#### 6.8.6.获取边\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | property | 边属性 | 字典 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/relationship/0_4_0_0\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"property\": {\n        },\n        \"label\": \"MARRIED\"\n    }\n```\n\n#### 6.8.7.删除边\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/relationship/14_0_1_0\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.8.8.获取边的所有属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}/property`\n- **METHOD**: GET\n- **RESPONSE**: 边属性字典\n\n**Example request.**"
            },
            {
                "content": "#### 6.8.7.删除边\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/relationship/14_0_1_0\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.8.8.获取边的所有属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}/property`\n- **METHOD**: GET\n- **RESPONSE**: 边属性字典\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/relationship/14_0_2_0/property\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        {\n            \"weight\": 0.8,\n            \"begin\": 20180922\n        }\n    }\n```\n\n#### 6.8.9.获取边的属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}/property/{field}`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功,返回代码 200,同时返回边的属性。如果失败,返回代码 400,同时返回 \"Illegal field.\"。\n\n**Example request.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        {\n            \"weight\": 0.8,\n            \"begin\": 20180922\n        }\n    }\n```\n\n#### 6.8.9.获取边的属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}/property/{field}`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功,返回代码 200,同时返回边的属性。如果失败,返回代码 400,同时返回 \"Illegal field.\"。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/relationship/17_0_2_2/property/charactername\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"Henri Ducard\"\n    }\n```\n\n#### 6.8.10.更新边的属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | property | 边属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "```\n    • GET http://localhost:7070/db/graph1/relationship/17_0_2_2/property/charactername\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"Henri Ducard\"\n    }\n```\n\n#### 6.8.10.更新边的属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | property | 边属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • PUT http://localhost:7070/db/graph1/relationship/17_0_2_2\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"property\" : {\n        \"charactername\" : \"Henri Ducard/passer a\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.9.索引\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/index/{label}/{field}\n```\n\n提供索引操作，接受 GET/POST 请求。\n\n#### 6.9.1.创建索引\n\n该操作会启动一个创建索引的后台任务，用户可以通过列出该 Label 相关的所有索引来检查新建索引的状态。"
            },
            {
                "content": "```\n    • PUT http://localhost:7070/db/graph1/relationship/17_0_2_2\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"property\" : {\n        \"charactername\" : \"Henri Ducard/passer a\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.9.索引\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/index/{label}/{field}\n```\n\n提供索引操作，接受 GET/POST 请求。\n\n#### 6.9.1.创建索引\n\n该操作会启动一个创建索引的后台任务，用户可以通过列出该 Label 相关的所有索引来检查新建索引的状态。\n\n- **URI**: `/db/{graph_name}/index`\n- **METHOD**: POST\n- **REQUEST**:\n\n| 域名    | 说明     | 类型                                  |\n|-------|--------|-------------------------------------|\n| label | Label 名 | 字符串                                 |\n| field | 域名     | 字符串                                 |\n| type  | 索引类型   | int类型，0表示非唯一索引，1表示全局唯一索引，2表示两点间唯一索引 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**"
            },
            {
                "content": "提供索引操作，接受 GET/POST 请求。\n\n#### 6.9.1.创建索引\n\n该操作会启动一个创建索引的后台任务，用户可以通过列出该 Label 相关的所有索引来检查新建索引的状态。\n\n- **URI**: `/db/{graph_name}/index`\n- **METHOD**: POST\n- **REQUEST**:\n\n| 域名    | 说明     | 类型                                  |\n|-------|--------|-------------------------------------|\n| label | Label 名 | 字符串                                 |\n| field | 域名     | 字符串                                 |\n| type  | 索引类型   | int类型，0表示非唯一索引，1表示全局唯一索引，2表示两点间唯一索引 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/index\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"label\": \"Person\",\n      \"field\": \"birthyear\",\n      \"is_unique\" : false\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.2.列出所有索引\n\n- **URI**: `/db/{graph_name}/index`\n- **METHOD**: GET\n- **RESPONSE**: 索引列表，其中每一个元素是一个索引描述，格式与[创建索引](#indexspec)时使用格式相同。\n\n**Example request.**"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/index\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"label\": \"Person\",\n      \"field\": \"birthyear\",\n      \"is_unique\" : false\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.2.列出所有索引\n\n- **URI**: `/db/{graph_name}/index`\n- **METHOD**: GET\n- **RESPONSE**: 索引列表，其中每一个元素是一个索引描述，格式与[创建索引](#indexspec)时使用格式相同。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.2.列出所有索引\n\n- **URI**: `/db/{graph_name}/index`\n- **METHOD**: GET\n- **RESPONSE**: 索引列表，其中每一个元素是一个索引描述，格式与[创建索引](#indexspec)时使用格式相同。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            {\n                \"field\": \"name\",\n                \"label\": \"City\",\n                \"is_unique\": false\n            },\n            {\n                \"field\": \"title\",\n                \"label\": \"Film\",\n                \"is_unique\": false\n            },\n            {\n                \"field\": \"name\",\n                \"label\": \"Person\",\n                \"is_unique\": true\n            },\n            {\n                \"label\": \"Person\",\n                \"field\": \"age\",\n                \"is_unique\": false\n            }\n        ]\n    }\n```\n\n#### 6.9.3.列出所有与某个 Label 相关的索引"
            },
            {
                "content": "#### 6.9.3.列出所有与某个 Label 相关的索引\n\n- **URI**: `/db/{graph_name}/index/{label}`\n- **METHOD**: GET\n- **RESPONSE**: 索引列表，其中每一个元素是一个索引描述，格式与[创建索引](#indexspec)时使用格式相同。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index/Person\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            {\n                \"label\": \"Person\",\n                \"field\": \"name\",\n                \"is_unique\": true\n            },\n            {\n                \"label\": \"Person\",\n                \"field\": \"age\",\n                \"is_unique\": false\n            }\n        ]\n    }\n```\n\n#### 6.9.4.删除索引\n\n- **URI**: `/db/{graph_name}/index/{label}/{field}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/index/Person/name\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.5.根据索引获取点"
            },
            {
                "content": "#### 6.9.4.删除索引\n\n- **URI**: `/db/{graph_name}/index/{label}/{field}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/index/Person/name\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.5.根据索引获取点\n\n- **URI**: `/db/{graph_name}/index/{label}/?field={field}&value={value}`\n- **METHOD**: GET\n- **RESPONSE**: 点 vid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index/Person/?field=birthyear&value=1986\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        [\n            1,\n            8\n        ]\n    }\n```\n\n\n### 6.10.在线增量导入\n\n#### 6.10.1.指定文件内容导入"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.5.根据索引获取点\n\n- **URI**: `/db/{graph_name}/index/{label}/?field={field}&value={value}`\n- **METHOD**: GET\n- **RESPONSE**: 点 vid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index/Person/?field=birthyear&value=1986\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        [\n            1,\n            8\n        ]\n    }\n```\n\n\n### 6.10.在线增量导入\n\n#### 6.10.1.指定文件内容导入\n\n- **URI**: `/db/{graph_name}/import/text`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 文件内容描述 | 字符串 |\n  | data | 要导入的文件内容（建议最大在 16MB 左右，最长不超过 17MB） | 字符串 / 数组 / 对象 |\n  | continue_on_error | 出错后是否继续导入（可选，默认为`false`\n  ） | 布尔值 |\n  | delimiter | 分隔符（可选，默认为`“,”`\n  ） | 字符串 |\n\ndescription 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。\n\n分隔符可以是单字符，也可以是字符串，但不能包含`\\r`或者`\\n`。\n\ndata 可以是如下形式之一："
            },
            {
                "content": "### 6.10.在线增量导入\n\n#### 6.10.1.指定文件内容导入\n\n- **URI**: `/db/{graph_name}/import/text`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 文件内容描述 | 字符串 |\n  | data | 要导入的文件内容（建议最大在 16MB 左右，最长不超过 17MB） | 字符串 / 数组 / 对象 |\n  | continue_on_error | 出错后是否继续导入（可选，默认为`false`\n  ） | 布尔值 |\n  | delimiter | 分隔符（可选，默认为`“,”`\n  ） | 字符串 |\n\ndescription 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。\n\n分隔符可以是单字符，也可以是字符串，但不能包含`\\r`或者`\\n`。\n\ndata 可以是如下形式之一：\n\n- 字符串如 `\"1,2\\n3,4\\n\"`\n- ASCII 码组成的数组如 `[49,44,50,10,51,44,52,10]`\n- 形如上述数组的字典如 `{\"0\":49,\"1\":44,\"2\":50,\"3\":10,\"4\":51,\"5\":44,\"6\":52,\"7\":10}`\n\n- **RESPONSE**:\n\n系统**不会**自动执行新建 label、添加索引等操作。在此操作之前需要保证涉及的 label 已经存在并具有适当的索引。\n\n如果成功导入完毕，返回代码 200，并在 `log` 字段返回一些日志信息（可能为空）；否则，保证所有的数据均未被导入，并在 `error_message` 字段返回错误信息。\n\n**Example request.**"
            },
            {
                "content": "description 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。\n\n分隔符可以是单字符，也可以是字符串，但不能包含`\\r`或者`\\n`。\n\ndata 可以是如下形式之一：\n\n- 字符串如 `\"1,2\\n3,4\\n\"`\n- ASCII 码组成的数组如 `[49,44,50,10,51,44,52,10]`\n- 形如上述数组的字典如 `{\"0\":49,\"1\":44,\"2\":50,\"3\":10,\"4\":51,\"5\":44,\"6\":52,\"7\":10}`\n\n- **RESPONSE**:\n\n系统**不会**自动执行新建 label、添加索引等操作。在此操作之前需要保证涉及的 label 已经存在并具有适当的索引。\n\n如果成功导入完毕，返回代码 200，并在 `log` 字段返回一些日志信息（可能为空）；否则，保证所有的数据均未被导入，并在 `error_message` 字段返回错误信息。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/import/text\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"description\": \"{\\\\\"files\\\\\":[{\\\\\"columns\\\\\":[\\\\\"SRC_ID\\\\\",\\\\\"role\\\\\",\\\\\"DST_ID\\\\\"],\\\\\"format\\\\\":\\\\\"CSV\\\\\",\\\\\"label\\\\\":\\\\\"role\\\\\",\\\\\"SRC_ID\\\\\":\\\\\"actor\\\\\",\\\\\"DST_ID\\\\\":\\\\\"movie\\\\\"}]}\"}\",\n      \"data\": \"1,Role1,2\\n3,Role2,4\\n\",\n      \"continue_on_error\": true,\n      \"delimiter\": \",\"\n    }\n```\n\n上述 description 的值是如下 json 序列化后的字符串"
            },
            {
                "content": "```\n    • POST http://localhost:7070/db/graph1/import/text\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"description\": \"{\\\\\"files\\\\\":[{\\\\\"columns\\\\\":[\\\\\"SRC_ID\\\\\",\\\\\"role\\\\\",\\\\\"DST_ID\\\\\"],\\\\\"format\\\\\":\\\\\"CSV\\\\\",\\\\\"label\\\\\":\\\\\"role\\\\\",\\\\\"SRC_ID\\\\\":\\\\\"actor\\\\\",\\\\\"DST_ID\\\\\":\\\\\"movie\\\\\"}]}\"}\",\n      \"data\": \"1,Role1,2\\n3,Role2,4\\n\",\n      \"continue_on_error\": true,\n      \"delimiter\": \",\"\n    }\n```\n\n上述 description 的值是如下 json 序列化后的字符串\n\n```json\n{\n  \"files\": [\n    {\n      \"format\": \"CSV\",\n      \"label\": \"role\",\n      \"SRC_ID\": \"actor\",\n      \"DST_ID\": \"movie\",\n      \"columns\": [\"SRC_ID\", \"role\", \"DST_ID\"]\n    }\n  ]\n}\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"log\": \"Missing src uid 1\\n\"\n    }\n```\n\n由于请求中指定了在出错时继续，该返回信息说明 SRC_ID 为 1 的边没有被导入，而其他信息导入成功。\n\n### 6.11.其他\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/misc\n```\n\n#### 6.11.1.提取子图\n\n给出点 id 集合，返回包含该集合的最小子图。"
            },
            {
                "content": "上述 description 的值是如下 json 序列化后的字符串\n\n```json\n{\n  \"files\": [\n    {\n      \"format\": \"CSV\",\n      \"label\": \"role\",\n      \"SRC_ID\": \"actor\",\n      \"DST_ID\": \"movie\",\n      \"columns\": [\"SRC_ID\", \"role\", \"DST_ID\"]\n    }\n  ]\n}\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"log\": \"Missing src uid 1\\n\"\n    }\n```\n\n由于请求中指定了在出错时继续，该返回信息说明 SRC_ID 为 1 的边没有被导入，而其他信息导入成功。\n\n### 6.11.其他\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/misc\n```\n\n#### 6.11.1.提取子图\n\n给出点 id 集合，返回包含该集合的最小子图。\n\n- **URI**: `/db/{graph_name}/misc/sub_graph`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | vertex_ids | 点 id 集合 | 列表 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | nodes | 点数据 | 列表，每元素包含 vid, label, 以及属性 |\n  | relationships | 边数据 | 列表，每元素包含 src, dst, euid, label, 以及属性 |\n\n**Example request.**"
            },
            {
                "content": "### 6.11.其他\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/misc\n```\n\n#### 6.11.1.提取子图\n\n给出点 id 集合，返回包含该集合的最小子图。\n\n- **URI**: `/db/{graph_name}/misc/sub_graph`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | vertex_ids | 点 id 集合 | 列表 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | nodes | 点数据 | 列表，每元素包含 vid, label, 以及属性 |\n  | relationships | 边数据 | 列表，每元素包含 src, dst, euid, label, 以及属性 |\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/misc/sub_graph\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"vertex_ids\": [2, 5, 14, 20]\n    }\n```\n\n**Example response.**"
            },
            {
                "content": "```\n• 200: OK\n    Output:\n    {\n        \"nodes\": [\n            {\n                \"label\": \"Person\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"vid\": 2\n            },\n            {\n                \"label\": \"Person\",\n                \"properties\": {\n                    \"birthyear\": 1963,\n                    \"name\": \"Natasha Richardson\"\n                },\n                \"vid\": 5\n            },\n            {\n                \"label\": \"City\",\n                \"properties\": {\n                    \"name\": \"London\"\n                },\n                \"vid\": 14\n            },\n            {\n                \"label\": \"Film\",\n                \"properties\": {\n                    \"title\": \"Camelot\"\n                },\n                \"vid\": 20\n            }\n        ],\n        \"relationships\": [\n            {\n                \"destination\": 5,\n                \"label\": \"HAS_CHILD\",\n                \"properties\": {"
            },
            {
                "content": "{\n                \"label\": \"City\",\n                \"properties\": {\n                    \"name\": \"London\"\n                },\n                \"vid\": 14\n            },\n            {\n                \"label\": \"Film\",\n                \"properties\": {\n                    \"title\": \"Camelot\"\n                },\n                \"vid\": 20\n            }\n        ],\n        \"relationships\": [\n            {\n                \"destination\": 5,\n                \"label\": \"HAS_CHILD\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 14,\n                \"label\": \"BORN_IN\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 20,\n                \"label\": \"ACTED_IN\","
            },
            {
                "content": "\"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 14,\n                \"label\": \"BORN_IN\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 20,\n                \"label\": \"ACTED_IN\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"charactername\": \"Guenevere\",\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 14,\n                \"label\": \"BORN_IN\",\n                \"properties\": {\n                    \"birthyear\": 1963,\n                    \"name\": \"Natasha Richardson\"\n                },\n                \"source\": 5\n            }\n        ]\n    }\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/8.query/1.cypher.md",
        "chunks": [
            {
                "content": "# Cypher API\n\n> 此文档主要介绍了TuGraph-Cypher的详细使用说明\n\n## 1.Operators\n\n### 1.1.Summary\n\nOperators支持进度一览："
            },
            {
                "content": "| 类别                                 | 支持                                                                                                        | 待支持                             |\n| ------------------------------------ | ----------------------------------------------------------------------------------------------------------- | ---------------------------------- |\n| General operators                    | `DISTINCT`, `.` for property access                                                                     | `[]` for dynamic property access |\n| Mathematical operators               | `+`, `-`, `*`, `/`, `%`, `^`                                                                    |                                    |\n| Comparison operators                 | `=`, `<>`, `<`, `>`, `<=`, `>=`, `IS NULL`, `IS NOT NULL`                                   |                                    |"
            },
            {
                "content": "| Mathematical operators               | `+`, `-`, `*`, `/`, `%`, `^`                                                                    |                                    |\n| Comparison operators                 | `=`, `<>`, `<`, `>`, `<=`, `>=`, `IS NULL`, `IS NOT NULL`                                   |                                    |\n| String-specific comparison operators | `STARTS WITH`, `ENDS WITH`, `CONTAINS`, `REGEXP`                                                    |                                    |\n| Boolean operators                    | `AND`, `OR`, `XOR`, `NOT`                                                                           |                                    |\n| String operators                     | `+` for concatenation                                                                                     |                                    |"
            },
            {
                "content": "| Boolean operators                    | `AND`, `OR`, `XOR`, `NOT`                                                                           |                                    |\n| String operators                     | `+` for concatenation                                                                                     |                                    |\n| List operators                       | `+` for concatenation, `IN` to check existence of an element in a list, `[]` for accessing element(s) |                                    |"
            },
            {
                "content": "### 1.2.General operators\n\n- ✓ Using the DISTINCT operator\n\n```\nMATCH (p:person) RETURN DISTINCT p.born\n```\n\n- ❏ Accessing properties of a nested literal map using the `.` operator\n\n```\nWITH {person: {name: 'Anne', age: 25}} AS p\nRETURN p.person.name\n```\n\n- ❏ Filtering on a dynamically-computed property key using the `[]` operator\n\n```\nCREATE (a:Restaurant {name: 'Hungry Jo', rating_hygiene: 10, rating_food: 7}),\n       (b:Restaurant {name: 'Buttercup Tea Rooms', rating_hygiene: 5, rating_food:6}),\n       (c1:Category {name: 'hygiene'}), (c2:Category {name: 'food'})\n```\n\n```\nMATCH (restaurant:Restaurant), (category:Category)\nWHERE restaurant[\"rating_\" + category.name] > 6\nRETURN DISTINCT restaurant.name\n```\n\n### 1.3.Mathematical operators\n\n- ✓ Using the exponentiation operator  `^`\n\n```\nWITH 2 AS number, 3 AS exponent\nRETURN number ^ exponent AS result\n```\n\n- ✓ Using the unary minus operator `-`\n\n```\nWITH -3 AS a, 4 AS b\nRETURN b - a AS result\n```\n\n### 1.4.Comparison operators\n\n- ✓ Comparing two numbers"
            },
            {
                "content": "```\nMATCH (restaurant:Restaurant), (category:Category)\nWHERE restaurant[\"rating_\" + category.name] > 6\nRETURN DISTINCT restaurant.name\n```\n\n### 1.3.Mathematical operators\n\n- ✓ Using the exponentiation operator  `^`\n\n```\nWITH 2 AS number, 3 AS exponent\nRETURN number ^ exponent AS result\n```\n\n- ✓ Using the unary minus operator `-`\n\n```\nWITH -3 AS a, 4 AS b\nRETURN b - a AS result\n```\n\n### 1.4.Comparison operators\n\n- ✓ Comparing two numbers\n\n```\nWITH 4 AS one, 3 AS two\nRETURN one > two AS result\n```\n \n### 1.5.String-specific comparison operators\n\n- ✓ Using STARTS WITH to filter names\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate STARTS WITH 'Jo'\nRETURN candidate\n```\n\n- ✓ Using REGEXP to filter names\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate REGEXP 'Jo.*n'\nRETURN candidate\n```\n\n### 1.6.Boolean operators\n\n- ✓ Using boolean operators to filter numbers"
            },
            {
                "content": "- ✓ Using STARTS WITH to filter names\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate STARTS WITH 'Jo'\nRETURN candidate\n```\n\n- ✓ Using REGEXP to filter names\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate REGEXP 'Jo.*n'\nRETURN candidate\n```\n\n### 1.6.Boolean operators\n\n- ✓ Using boolean operators to filter numbers\n\n```\nWITH [2, 4, 7, 9, 12] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number = 4 OR (number > 6 AND number < 10)\nRETURN number\n```\n\n### 1.7.String operators\n\nString operators comprise:\n\n- ✓ concatenating strings: `+`\n\n### 1.8.List operators\n\n- ✓ Concatenating two lists using +\n\n```\nRETURN [1,2,3,4,5]+[6,7] AS myList\n```\n\n- ✓ Using IN to check if a number is in a list\n\n```\nWITH [2, 3, 4, 5] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number IN [2, 3, 8]\nRETURN number\n```"
            },
            {
                "content": "```\nWITH [2, 4, 7, 9, 12] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number = 4 OR (number > 6 AND number < 10)\nRETURN number\n```\n\n### 1.7.String operators\n\nString operators comprise:\n\n- ✓ concatenating strings: `+`\n\n### 1.8.List operators\n\n- ✓ Concatenating two lists using +\n\n```\nRETURN [1,2,3,4,5]+[6,7] AS myList\n```\n\n- ✓ Using IN to check if a number is in a list\n\n```\nWITH [2, 3, 4, 5] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number IN [2, 3, 8]\nRETURN number\n```\n\n- ✓ Accessing elements in a list using the [] operator\n\n```\nWITH ['Anne', 'John', 'Bill', 'Diane', 'Eve'] AS names\nRETURN names[1..3] AS result\n```\n\n## 2.Clauses\n\n### 2.1.Summary\n\nClauses支持进度一览："
            },
            {
                "content": "| 类别                    | 语法                                  | 备注   |\n| ----------------------- | ------------------------------------- | ------ |\n| Reading clauses         | MATCH                                 | 支持   |\n|                         | OPTIONAL MATCH                        | 支持   |\n|                         | MANDATORY MATCH                       | 待支持 |\n| Projecting clauses      | RETURN … [AS]                        | 支持   |\n|                         | WITH … [AS]                          | 支持   |\n|                         | UNWIND … [AS]                        | 支持   |\n| Reading sub-clauses     | WHERE                                 | 支持   |\n|                         | ORDER BY [ASC[ENDING] / DESC[ENDING]] | 支持   |\n|                         | SKIP                                  | 支持   |\n|                         | LIMIT                                 | 支持   |\n| Writing clauses         | CREATE                                | 支持   |"
            },
            {
                "content": "|                         | UNWIND … [AS]                        | 支持   |\n| Reading sub-clauses     | WHERE                                 | 支持   |\n|                         | ORDER BY [ASC[ENDING] / DESC[ENDING]] | 支持   |\n|                         | SKIP                                  | 支持   |\n|                         | LIMIT                                 | 支持   |\n| Writing clauses         | CREATE                                | 支持   |\n|                         | DELETE                                | 支持   |\n|                         | DETACH DELETE                         | 支持   |\n|                         | SET                                   | 支持   |\n|                         | REMOVE                                | 支持   |\n| Reading/Writing clauses | MERGE                                 | 支持   |\n|                         | CALL […YIELD]                        | 支持   |\n| Set operations          | UNION                                 | 待支持 |"
            },
            {
                "content": "|                         | DETACH DELETE                         | 支持   |\n|                         | SET                                   | 支持   |\n|                         | REMOVE                                | 支持   |\n| Reading/Writing clauses | MERGE                                 | 支持   |\n|                         | CALL […YIELD]                        | 支持   |\n| Set operations          | UNION                                 | 待支持 |\n|                         | UNION ALL                             | 支持   |"
            },
            {
                "content": "### 2.2.MATCH\n\n- Basic node finding\n\n  - ✓ Get all nodes\n\n  ```\n  MATCH (n)\n  RETURN n\n  ```\n\n  - ✓ Get all nodes with a label\n\n  ```\n  MATCH (movie:movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Related nodes\n\n  ```\n  MATCH (person {name: 'Laurence Fishburne'})-[]-(movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Match with labels\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[]-(movie:movie)\n  RETURN movie.title\n  ```\n\n- Relationship basics\n\n  - ✓ Outgoing relationships\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[]->(movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Directed relationships and variable\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[r]->(movie)\n  RETURN type(r)\n  ```\n\n  - ✓ Match on relationship type\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})<-[:acted_in]-(actor)\n  RETURN actor.name\n  ```\n\n  - ✓ Match on multiple relationship types\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[:acted_in|:directed]-(person)\n  RETURN person.name\n  ```"
            },
            {
                "content": "```\n  MATCH (:person {name: 'Laurence Fishburne'})-[]->(movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Directed relationships and variable\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[r]->(movie)\n  RETURN type(r)\n  ```\n\n  - ✓ Match on relationship type\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})<-[:acted_in]-(actor)\n  RETURN actor.name\n  ```\n\n  - ✓ Match on multiple relationship types\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[:acted_in|:directed]-(person)\n  RETURN person.name\n  ```\n\n  - ✓ Match on relationship type and use a variable\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[r:acted_in]-(actor)\n  RETURN r.role\n  ```\n- Relationships in depth\n\n  - ❏ Relationship types with uncommon characters\n\n  ```\n  MATCH (n {name: 'Rob Reiner'})-[r:`TYPE WITH SPACE`]->()\n  RETURN type(r)\n  ```\n\n  - ✓ Multiple relationships\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in]->(movie)<-[:directed]-(director)\n  RETURN movie.title, director.name\n  ```"
            },
            {
                "content": "- ✓ Match on relationship type and use a variable\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[r:acted_in]-(actor)\n  RETURN r.role\n  ```\n- Relationships in depth\n\n  - ❏ Relationship types with uncommon characters\n\n  ```\n  MATCH (n {name: 'Rob Reiner'})-[r:`TYPE WITH SPACE`]->()\n  RETURN type(r)\n  ```\n\n  - ✓ Multiple relationships\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in]->(movie)<-[:directed]-(director)\n  RETURN movie.title, director.name\n  ```\n\n  - ✓ Variable-length relationships\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in*1..3]-(movie:movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Relationship variable in variable-length relationships\n\n  ```\n  MATCH p = (laurence {name: 'Laurence Fishburne'})-[:acted_in*2]-(co_actor)\n  RETURN p\n  ```\n\n  - ❏ Match with properties on a variable-length path\n\n  ```\n  MATCH p = (charlie:person)-[* {blocked:false}]-(martin:person)\n  WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'\n  RETURN p\n  ```"
            },
            {
                "content": "```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in*1..3]-(movie:movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Relationship variable in variable-length relationships\n\n  ```\n  MATCH p = (laurence {name: 'Laurence Fishburne'})-[:acted_in*2]-(co_actor)\n  RETURN p\n  ```\n\n  - ❏ Match with properties on a variable-length path\n\n  ```\n  MATCH p = (charlie:person)-[* {blocked:false}]-(martin:person)\n  WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'\n  RETURN p\n  ```\n\n  - ✓ Zero-length paths\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})-[*0..1]-(x)\n  RETURN x\n  ```\n\n  - ✓ Named paths\n\n  ```\n  MATCH p = (michael {name: 'Michael Douglas'})-[]->() RETURN p\n  ```\n\n  - ✓ Matching on a bound relationship\n\n  ```\n  MATCH (a)-[r]->(b)\n  WHERE euid(r)=\"0_3937_0_0_0\"\n  RETURN a,b\n  ```\n\n- Shortest path\n\n  - ✓ Single shortest path"
            },
            {
                "content": "- ✓ Zero-length paths\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})-[*0..1]-(x)\n  RETURN x\n  ```\n\n  - ✓ Named paths\n\n  ```\n  MATCH p = (michael {name: 'Michael Douglas'})-[]->() RETURN p\n  ```\n\n  - ✓ Matching on a bound relationship\n\n  ```\n  MATCH (a)-[r]->(b)\n  WHERE euid(r)=\"0_3937_0_0_0\"\n  RETURN a,b\n  ```\n\n- Shortest path\n\n  - ✓ Single shortest path\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'})\n  CALL algo.shortestPath(martin, laurence) YIELD nodeCount,totalCost,path RETURN nodeCount,totalCost,path\n  ```\n\n  - ✓ All shortest paths\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'}) WITH martin, laurence\n  CALL algo.allShortestPaths(martin, laurence) YIELD nodeIds,relationshipIds,cost RETURN nodeIds,relationshipIds,cost\n  ```\n- Get node or relationship by id\n\n  - ✓ Node by id\n\n  ```\n  MATCH (n)\n  WHERE id(n)= 0\n  RETURN n\n  ```\n\n  - ✓ Relationship by id"
            },
            {
                "content": "- ✓ All shortest paths\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'}) WITH martin, laurence\n  CALL algo.allShortestPaths(martin, laurence) YIELD nodeIds,relationshipIds,cost RETURN nodeIds,relationshipIds,cost\n  ```\n- Get node or relationship by id\n\n  - ✓ Node by id\n\n  ```\n  MATCH (n)\n  WHERE id(n)= 0\n  RETURN n\n  ```\n\n  - ✓ Relationship by id\n\n  ```\n  MATCH ()-[r]->()\n  WHERE euid(r) = \"0_3937_0_0_0\"\n  RETURN r\n  ```\n\n  - ✓ Multiple nodes by id\n\n  ```\n  MATCH (n)\n  WHERE id(n) IN [0, 3, 5]\n  RETURN n\n  ```\n\n### 2.3.RETURN\n\n- ✓ Return nodes\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n\n```\n\n- ✓ Return relationships\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'})-[r:acted_in]->(c)\nRETURN r\n```\n\n- ✓ Return property\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n.born\n```\n\n- ❏ Return all elements\n\n```\nMATCH p = (a {name: 'A'})-[r]->(b)\nRETURN *\n```\n\n- ❏ Variable with uncommon characters"
            },
            {
                "content": "- ✓ Multiple nodes by id\n\n  ```\n  MATCH (n)\n  WHERE id(n) IN [0, 3, 5]\n  RETURN n\n  ```\n\n### 2.3.RETURN\n\n- ✓ Return nodes\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n\n```\n\n- ✓ Return relationships\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'})-[r:acted_in]->(c)\nRETURN r\n```\n\n- ✓ Return property\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n.born\n```\n\n- ❏ Return all elements\n\n```\nMATCH p = (a {name: 'A'})-[r]->(b)\nRETURN *\n```\n\n- ❏ Variable with uncommon characters\n\n```\nMATCH (`This isn\\'t a common variable`)\nWHERE `This isn\\'t a common variable`.name = 'A'\nRETURN `This isn\\'t a common variable`.happy\n```\n\n- ✓ Aliasing a field\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born AS SomethingTotallyDifferent\n```\n\n- ✓ Optional properties\n\n```\nMATCH (n)\nRETURN n.age\n```\n\n- ❏ Other expressions\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born > 1900, \"I'm a literal\", (a)-[]->()\n```\n\n`(a)-[]->()`  not supported.\n\n- ✓ Unique results"
            },
            {
                "content": "```\nMATCH (`This isn\\'t a common variable`)\nWHERE `This isn\\'t a common variable`.name = 'A'\nRETURN `This isn\\'t a common variable`.happy\n```\n\n- ✓ Aliasing a field\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born AS SomethingTotallyDifferent\n```\n\n- ✓ Optional properties\n\n```\nMATCH (n)\nRETURN n.age\n```\n\n- ❏ Other expressions\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born > 1900, \"I'm a literal\", (a)-[]->()\n```\n\n`(a)-[]->()`  not supported.\n\n- ✓ Unique results\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})-[]->(b)\nRETURN DISTINCT b\n```\n\n### 2.4.WHERE\n\n- Basic usage\n  - ✓ Boolean operations\n\n  ```\n  MATCH (n)\n  WHERE n.name = 'Laurence Fishburne' XOR (n.born > 1965 AND n.name = 'Carrie-Anne Moss')\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on node label\n\n  ```\n  MATCH (n)\n  WHERE n:person\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on node property\n\n  ```\n  MATCH (n)\n  WHERE n.born > 2000\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on relationship property"
            },
            {
                "content": "```\nMATCH (a {name: 'Carrie-Anne Moss'})-[]->(b)\nRETURN DISTINCT b\n```\n\n### 2.4.WHERE\n\n- Basic usage\n  - ✓ Boolean operations\n\n  ```\n  MATCH (n)\n  WHERE n.name = 'Laurence Fishburne' XOR (n.born > 1965 AND n.name = 'Carrie-Anne Moss')\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on node label\n\n  ```\n  MATCH (n)\n  WHERE n:person\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on node property\n\n  ```\n  MATCH (n)\n  WHERE n.born > 2000\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on relationship property\n\n  ```\n  MATCH (n)-[k:acted_in]->(f)\n  WHERE k.role = \"Trinity\"\n  RETURN f.title\n  ```\n\n  - ❏ Filter on dynamically-computed property\n\n  ```\n  WITH 'AGE' AS propname\n  MATCH (n)\n  WHERE n[toLower(propname)]< 30\n  RETURN n.name, n.age\n  ```\n\n  - ✓ Property existence checking\n\n  ```\n  MATCH (n)\n  WHERE exists(n.born)\n  RETURN n.name, n.born\n  ```\n\n- String matching\n  - ✓ Match the beginning of a string\n\n  ```\n  MATCH (n)\n  WHERE n.name STARTS WITH 'Pet'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Match the ending of a string"
            },
            {
                "content": "- ❏ Filter on dynamically-computed property\n\n  ```\n  WITH 'AGE' AS propname\n  MATCH (n)\n  WHERE n[toLower(propname)]< 30\n  RETURN n.name, n.age\n  ```\n\n  - ✓ Property existence checking\n\n  ```\n  MATCH (n)\n  WHERE exists(n.born)\n  RETURN n.name, n.born\n  ```\n\n- String matching\n  - ✓ Match the beginning of a string\n\n  ```\n  MATCH (n)\n  WHERE n.name STARTS WITH 'Pet'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Match the ending of a string\n\n  ```\n  MATCH (n)\n  WHERE n.name ENDS WITH 'ter'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Match anywhere within a string\n\n  ```\n  MATCH (n)\n  WHERE n.name CONTAINS 'ete'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ String matching negation\n\n  ```\n  MATCH (n)\n  WHERE NOT n.name ENDS WITH 's'\n  RETURN n.name, n.born\n  ```\n\n- Using path patterns in `WHERE`\n  - ❏ Filter on patterns\n\n  ```\n  MATCH (tobias {name: 'Tobias'}), (others)\n  WHERE others.name IN ['Andres', 'Peter'] AND (tobias)<-[]-(others)\n  RETURN others.name, others.age\n  ```\n\n  - ❏ Filter on patterns using NOT"
            },
            {
                "content": "- ✓ Match anywhere within a string\n\n  ```\n  MATCH (n)\n  WHERE n.name CONTAINS 'ete'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ String matching negation\n\n  ```\n  MATCH (n)\n  WHERE NOT n.name ENDS WITH 's'\n  RETURN n.name, n.born\n  ```\n\n- Using path patterns in `WHERE`\n  - ❏ Filter on patterns\n\n  ```\n  MATCH (tobias {name: 'Tobias'}), (others)\n  WHERE others.name IN ['Andres', 'Peter'] AND (tobias)<-[]-(others)\n  RETURN others.name, others.age\n  ```\n\n  - ❏ Filter on patterns using NOT\n\n  ```\n  MATCH (persons), (peter {name: 'Peter'})\n  WHERE NOT (persons)-[]->(peter)\n  RETURN persons.name, persons.age\n  ```\n\n  - ❏ Filter on patterns with properties\n\n  ```\n  MATCH (n)\n  WHERE (n)-[:KNOWS]-({name: 'Tobias'})\n  RETURN n.name, n.age\n  ```\n\n  - ✓ Filter on relationship type\n\n  ```\n  MATCH (n)-[r]->()\n  WHERE n.name='Laurence Fishburne' AND type(r) STARTS WITH 'ac'\n  RETURN type(r), r.role\n  ```\n\n- Lists\n  - ✓ IN operator"
            },
            {
                "content": "- ❏ Filter on patterns using NOT\n\n  ```\n  MATCH (persons), (peter {name: 'Peter'})\n  WHERE NOT (persons)-[]->(peter)\n  RETURN persons.name, persons.age\n  ```\n\n  - ❏ Filter on patterns with properties\n\n  ```\n  MATCH (n)\n  WHERE (n)-[:KNOWS]-({name: 'Tobias'})\n  RETURN n.name, n.age\n  ```\n\n  - ✓ Filter on relationship type\n\n  ```\n  MATCH (n)-[r]->()\n  WHERE n.name='Laurence Fishburne' AND type(r) STARTS WITH 'ac'\n  RETURN type(r), r.role\n  ```\n\n- Lists\n  - ✓ IN operator\n\n  ```\n  MATCH (a)\n  WHERE a.name IN ['Laurence Fishburne', 'Tobias']\n  RETURN a.name, a.born\n  ```\n\n- Missing properties and values\n  - ✓ Default to false if property is missing\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white'\n  RETURN n.name, n.age, n.belt\n  ```\n\n  - ✓ Default to true if property is missing\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white' OR n.belt IS NULL RETURN n.name, n.age, n.belt\n  ORDER BY n.name\n  ```\n\n  - ✓ Filter on null"
            },
            {
                "content": "- Lists\n  - ✓ IN operator\n\n  ```\n  MATCH (a)\n  WHERE a.name IN ['Laurence Fishburne', 'Tobias']\n  RETURN a.name, a.born\n  ```\n\n- Missing properties and values\n  - ✓ Default to false if property is missing\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white'\n  RETURN n.name, n.age, n.belt\n  ```\n\n  - ✓ Default to true if property is missing\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white' OR n.belt IS NULL RETURN n.name, n.age, n.belt\n  ORDER BY n.name\n  ```\n\n  - ✓ Filter on null\n\n  ```\n  MATCH (person)\n  WHERE person.name = 'Peter' AND person.belt IS NULL RETURN person.name, person.age,\n  person.belt\n  ```\n\n- Using ranges\n  - ✓ Simple range\n\n  ```\n  MATCH (a)\n  WHERE a.name >= 'Peter'\n  RETURN a.name, a.born\n  ```\n\n  - ✓ Composite range\n\n  ```\n  MATCH (a)\n  WHERE a.name > 'Andres' AND a.name < 'Tobias'\n  RETURN a.name, a.born\n  ```\n\n### 2.5.SKIP\n\n- ✓ Skip first three records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 3\n```\n\n- ✓ Return middle two records"
            },
            {
                "content": "```\n  MATCH (person)\n  WHERE person.name = 'Peter' AND person.belt IS NULL RETURN person.name, person.age,\n  person.belt\n  ```\n\n- Using ranges\n  - ✓ Simple range\n\n  ```\n  MATCH (a)\n  WHERE a.name >= 'Peter'\n  RETURN a.name, a.born\n  ```\n\n  - ✓ Composite range\n\n  ```\n  MATCH (a)\n  WHERE a.name > 'Andres' AND a.name < 'Tobias'\n  RETURN a.name, a.born\n  ```\n\n### 2.5.SKIP\n\n- ✓ Skip first three records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 3\n```\n\n- ✓ Return middle two records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 1\nLIMIT 2\n```\n\n- ❏ Using an expression with SKIP to return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP toInteger(3*rand())+ 1\n```\n\n### 2.6.LIMIT\n\n- ✓ Return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT 3\n```\n\n- ❏ Using an expression with LIMIT to return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT toInteger(3 * rand())+ 1\n```\n\n### 2.7.CREATE\n\n- Create nodes"
            },
            {
                "content": "```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 1\nLIMIT 2\n```\n\n- ❏ Using an expression with SKIP to return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP toInteger(3*rand())+ 1\n```\n\n### 2.6.LIMIT\n\n- ✓ Return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT 3\n```\n\n- ❏ Using an expression with LIMIT to return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT toInteger(3 * rand())+ 1\n```\n\n### 2.7.CREATE\n\n- Create nodes\n\n> **Note**\n> TuGraph不支持创建空的nodes，不支持多labels。\n\n  - ☒ Create single node\n\n  ```\n  CREATE (n)\n  ```\n\n  - ☒ Create multiple nodes\n\n  ```\n  CREATE (n), (m)\n  ```\n\n  - ☒ Create a node with a label\n\n  ```\n  CREATE (n:person)\n  ```\n\n  - ☒ Create a node with multiple labels\n\n  ```\n  CREATE (n:Person:Swedish)\n  ```\n\n  - ✓ Create node and add labels and properties\n\n  ```\n  CREATE (n:person {id:2001, name: 'Andres'})\n  ```\n\n  - ✓ Return created node\n\n  ```\n  CREATE (n:person {id:2002, name: 'Andres'})\n  RETURN n\n  ```"
            },
            {
                "content": "- ☒ Create single node\n\n  ```\n  CREATE (n)\n  ```\n\n  - ☒ Create multiple nodes\n\n  ```\n  CREATE (n), (m)\n  ```\n\n  - ☒ Create a node with a label\n\n  ```\n  CREATE (n:person)\n  ```\n\n  - ☒ Create a node with multiple labels\n\n  ```\n  CREATE (n:Person:Swedish)\n  ```\n\n  - ✓ Create node and add labels and properties\n\n  ```\n  CREATE (n:person {id:2001, name: 'Andres'})\n  ```\n\n  - ✓ Return created node\n\n  ```\n  CREATE (n:person {id:2002, name: 'Andres'})\n  RETURN n\n  ```\n\n- Create relationships\n  - ✓ Create a relationship between two nodes\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:write]->(m)\n  ```\n\n  - ✓ Create a relationship and set properties\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:acted_in{role: 'Trinity'}]->(m)\n  ```\n\n  - ❏ Create a full path"
            },
            {
                "content": "```\n  CREATE (n:person {id:2002, name: 'Andres'})\n  RETURN n\n  ```\n\n- Create relationships\n  - ✓ Create a relationship between two nodes\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:write]->(m)\n  ```\n\n  - ✓ Create a relationship and set properties\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:acted_in{role: 'Trinity'}]->(m)\n  ```\n\n  - ❏ Create a full path\n\n  ```\n  CREATE p = (andres:person {id: 2005, name:'Andres'})-[:acted_in {role: 'Trinity'}]->\n  (m:movie {id: 2006})<-[:acted_in {role: 'Trinity'}]-(michael {id: 2006, name:'Michael'})\n  RETURN p\n  ```\n\n- Use parameters with CREATE\n  - ❏ Create node with a parameter for the properties\n\n  ```\n  CREATE (n:Person $props)\n  RETURN n\n  ```\n\n  - ☒ Create multiple nodes with a parameter for their properties\n\n  ```\n  UNWIND $props AS map\n  CREATE (n)\n  SET n = map\n  ```\n  cannot create vertex without label."
            },
            {
                "content": "```\n  CREATE p = (andres:person {id: 2005, name:'Andres'})-[:acted_in {role: 'Trinity'}]->\n  (m:movie {id: 2006})<-[:acted_in {role: 'Trinity'}]-(michael {id: 2006, name:'Michael'})\n  RETURN p\n  ```\n\n- Use parameters with CREATE\n  - ❏ Create node with a parameter for the properties\n\n  ```\n  CREATE (n:Person $props)\n  RETURN n\n  ```\n\n  - ☒ Create multiple nodes with a parameter for their properties\n\n  ```\n  UNWIND $props AS map\n  CREATE (n)\n  SET n = map\n  ```\n  cannot create vertex without label.\n\n### 2.8.CALL[…YIELD]\n\n- ✓ Call a procedure using CALL\n\n```\nCALL db.vertexLabels\n```\n\n- ✓ View the signature for a procedure\n\n```\nCALL dbms.procedures() YIELD name, signature\nRETURN signature\n```\n\n- ❏ Call a procedure using a quoted namespace and name\n\n```\nCALL `db`.`vertexLabels`\n```\n\n- ✓ Call a procedure with literal arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0, 'name')\n```\n\n- ❏ Call a procedure with parameter arguments"
            },
            {
                "content": "### 2.8.CALL[…YIELD]\n\n- ✓ Call a procedure using CALL\n\n```\nCALL db.vertexLabels\n```\n\n- ✓ View the signature for a procedure\n\n```\nCALL dbms.procedures() YIELD name, signature\nRETURN signature\n```\n\n- ❏ Call a procedure using a quoted namespace and name\n\n```\nCALL `db`.`vertexLabels`\n```\n\n- ✓ Call a procedure with literal arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0, 'name')\n```\n\n- ❏ Call a procedure with parameter arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex($indexName,$node,$propKey)\n```\n\n- ❏ Call a procedure with mixed literal and parameter arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', $node, 'name')\n```\n\n- ✓ Call a procedure with literal and default arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0)\n```\n\n- ✓ Call a procedure within a complex query using CALL…YIELD\n\n```\nCALL db.vertexLabels() YIELD label\nRETURN count(label) AS numLabels\n```\n\n- ❏ Call a procedure and filter its results"
            },
            {
                "content": "- ❏ Call a procedure with mixed literal and parameter arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', $node, 'name')\n```\n\n- ✓ Call a procedure with literal and default arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0)\n```\n\n- ✓ Call a procedure within a complex query using CALL…YIELD\n\n```\nCALL db.vertexLabels() YIELD label\nRETURN count(label) AS numLabels\n```\n\n- ❏ Call a procedure and filter its results\n\n```\nCALL db.vertexLabels() YIELD label\nWHERE label CONTAINS 'User'\nRETURN count(label) AS numLabels\n```\n\n- ❏ Call a procedure within a complex query and rename its outputs\n\n```\nCALL db.propertyKeys() YIELD propertyKey AS prop\nMATCH (n)\nWHERE n[prop] IS NOT NULL RETURN prop, count(n) AS numNodes\n```\n\n### 2.9.UNION\n\n- ✓ Combine two queries and retain duplicates\n\n```\nMATCH (n:person)\nRETURN n.name AS name\nUNION ALL MATCH (n:movie)\nRETURN n.title AS name\n```\n\n- ❏ Combine two queries and remove duplicates"
            },
            {
                "content": "```\nCALL db.vertexLabels() YIELD label\nWHERE label CONTAINS 'User'\nRETURN count(label) AS numLabels\n```\n\n- ❏ Call a procedure within a complex query and rename its outputs\n\n```\nCALL db.propertyKeys() YIELD propertyKey AS prop\nMATCH (n)\nWHERE n[prop] IS NOT NULL RETURN prop, count(n) AS numNodes\n```\n\n### 2.9.UNION\n\n- ✓ Combine two queries and retain duplicates\n\n```\nMATCH (n:person)\nRETURN n.name AS name\nUNION ALL MATCH (n:movie)\nRETURN n.title AS name\n```\n\n- ❏ Combine two queries and remove duplicates\n\n```\nMATCH (n:Actor)\nRETURN n.name AS name\nUNION\nMATCH (n:Movie)\nRETURN n.title AS name\n```\n\n## 3.Functions\n\n### 3.1.Whole List Of Functions"
            },
            {
                "content": "| 种类                   | 功能               | 备注                      |\n| ---------------------- |------------------| ------------------------- |\n| Predicate functions    | exists()         |                           |\n|                        | all()            | 不支持                    |\n|                        | any()            | 不支持                    |\n|                        | single()         | 不支持                    |\n|                        | none()           | 不支持                    |\n| Scalar functions       | id()             |                           |\n|                        | euid()           |                           |\n|                        | properties()     |                           |\n|                        | head()           |                           |\n|                        | last()           |                           |\n|                        | toBoolean()      |                           |\n|                        | toFloat()        |                           |"
            },
            {
                "content": "|                        | euid()           |                           |\n|                        | properties()     |                           |\n|                        | head()           |                           |\n|                        | last()           |                           |\n|                        | toBoolean()      |                           |\n|                        | toFloat()        |                           |\n|                        | toInteger()      |                           |\n|                        | toString()       |                           |\n|                        | type()           |                           |\n|                        | startnode()      |                           |\n|                        | endnode()        |                           |\n|                        | size()           |                           |\n|                        | length()         |                           |"
            },
            {
                "content": "|                        | toString()       |                           |\n|                        | type()           |                           |\n|                        | startnode()      |                           |\n|                        | endnode()        |                           |\n|                        | size()           |                           |\n|                        | length()         |                           |\n|                        | substring()      |                           |\n|                        | concat()         |                           |\n|                        | label()          | OpenCypher扩展方法      |\n| Aggregating functions  | avg()            |                           |\n|                        | collect()        |                           |\n|                        | count()          |                           |\n|                        | max()            |                           |"
            },
            {
                "content": "|                        | substring()      |                           |\n|                        | concat()         |                           |\n|                        | label()          | OpenCypher扩展方法      |\n| Aggregating functions  | avg()            |                           |\n|                        | collect()        |                           |\n|                        | count()          |                           |\n|                        | max()            |                           |\n|                        | min()            |                           |\n|                        | percentileCont() |                           |\n|                        | percentileDisc() |                           |\n|                        | stDev()          |                           |\n|                        | stDevP()         |                           |\n|                        | variance()       |                           |"
            },
            {
                "content": "|                        | min()            |                           |\n|                        | percentileCont() |                           |\n|                        | percentileDisc() |                           |\n|                        | stDev()          |                           |\n|                        | stDevP()         |                           |\n|                        | variance()       |                           |\n|                        | varianceP()      |                           |\n|                        | sum()            |                           |\n| List functions         | keys()           |                           |\n|                        | labels()         | 返回结果有且只有一个label |\n|                        | nodes()          |                           |\n|                        | range()          |                           |\n|                        | subscript()      | 不支持                    |\n| Mathematical functions | abs()            |                           |"
            },
            {
                "content": "|                        | sum()            |                           |\n| List functions         | keys()           |                           |\n|                        | labels()         | 返回结果有且只有一个label |\n|                        | nodes()          |                           |\n|                        | range()          |                           |\n|                        | subscript()      | 不支持                    |\n| Mathematical functions | abs()            |                           |\n|                        | ceil()           |                           |\n|                        | floor()          |                           |\n|                        | rand()           |                           |\n|                        | round()          |                           |\n|                        | sign()           |                           |\n| String functions       | /                |                           |"
            },
            {
                "content": "### 3.2.Predicate functions\n\n- exists()\n  judge it whether a vertex or edge has the field  .\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nWHERE exists(n.born)\nRETURN n.name, n.born\n```\n\n**Example output:**\n\n| exists(name) |\n| ------------ |\n| true         |\n\n### 3.3.Scalar functions\n\n- id()\n  get the id of vertex.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN id(a)\n```\n\n**Example output:**\n\n| vid |\n| --- |\n| 1   |\n| 2   |\n| ... |\n\n- properties()\n  get  a map containing all the properties of a node or relationship.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person {name: 'Laurence Fishburne'})\nRETURN n\n```\n\n- head()\n  get the first element of a list.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, head(coll)\n```\n\n**Example output:**\n\n| coll                  | head(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"one\"         |"
            },
            {
                "content": "- properties()\n  get  a map containing all the properties of a node or relationship.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person {name: 'Laurence Fishburne'})\nRETURN n\n```\n\n- head()\n  get the first element of a list.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, head(coll)\n```\n\n**Example output:**\n\n| coll                  | head(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"one\"         |\n\n- last()\n  get the last element of a list.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, last(coll)\n```\n\n**Example output:**\n\n| coll                  | last(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"three\"       |\n\n- toFloat()\n  Converts an integer or string value to a floating point number.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toFloat('11.5')\n```\n\n**Example output:**"
            },
            {
                "content": "- last()\n  get the last element of a list.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, last(coll)\n```\n\n**Example output:**\n\n| coll                  | last(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"three\"       |\n\n- toFloat()\n  Converts an integer or string value to a floating point number.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toFloat('11.5')\n```\n\n**Example output:**\n\n| float |\n| ----- |\n| 11.5  |\n\n- toInteger()\n  Converts a floating point or string value to an integer value.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toInteger('2.3') AS integer\n```\n\n**Example output:**\n\n| integer |\n| ------- |\n| 2       |\n\n- toString()\n  Converts an integer, float, boolean value to a string.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toString(2.3)\n```\n\n- type()\n  get the string representation of the relationship type.\n  **Scope:** whole instance.\n  **Example input:**"
            },
            {
                "content": "- toInteger()\n  Converts a floating point or string value to an integer value.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toInteger('2.3') AS integer\n```\n\n**Example output:**\n\n| integer |\n| ------- |\n| 2       |\n\n- toString()\n  Converts an integer, float, boolean value to a string.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toString(2.3)\n```\n\n- type()\n  get the string representation of the relationship type.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)-[r]->()\nWHERE n.name = 'Laurence Fishburne'\nRETURN type(r)\n```\n\n**Example output:**\n\n| type     |\n| -------- |\n| acted_in |\n| acted_in |\n\n### 3.4.Aggregating functions\n\n- avg()\n  Returns the average of a set of numeric values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN avg(n.born)\n```\n\n**Example output:**\n\n| avg(n.born)        |\n| ------------------ |\n| 1869.2661654135338 |"
            },
            {
                "content": "```\nMATCH (n)-[r]->()\nWHERE n.name = 'Laurence Fishburne'\nRETURN type(r)\n```\n\n**Example output:**\n\n| type     |\n| -------- |\n| acted_in |\n| acted_in |\n\n### 3.4.Aggregating functions\n\n- avg()\n  Returns the average of a set of numeric values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN avg(n.born)\n```\n\n**Example output:**\n\n| avg(n.born)        |\n| ------------------ |\n| 1869.2661654135338 |\n\n- collect()\n  Returns a list containing the values returned by an expression.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN collect(n.born)\n```\n\n**Example output:**\n\n| collect(n.born) |\n| --------------- |\n| [1967,...]      |\n\n- count()\n  Returns the number of values or records.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n {name: 'Laurence Fishburne'})-[]->(x)\nRETURN labels(n), n.born, count(*)\n```\n\n**Example output:**\n\n| labels(n)  | n.born | count(*) |\n| ---------- | ------ | -------- |\n| [\"person\"] | 1961   | 3        |"
            },
            {
                "content": "```\nMATCH (n:person)\nRETURN collect(n.born)\n```\n\n**Example output:**\n\n| collect(n.born) |\n| --------------- |\n| [1967,...]      |\n\n- count()\n  Returns the number of values or records.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n {name: 'Laurence Fishburne'})-[]->(x)\nRETURN labels(n), n.born, count(*)\n```\n\n**Example output:**\n\n| labels(n)  | n.born | count(*) |\n| ---------- | ------ | -------- |\n| [\"person\"] | 1961   | 3        |\n\n- max()\n  Returns the maximum value in a set of values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN max(n.born)\n```\n\n**Example output:**\n\n| max(n.born) |\n| ----------- |\n| 2003        |\n\n- min()\n  Returns the minimum value in a set of values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN min(n.born)\n```\n\n**Example output:**\n\n| min(n.born) |\n| ----------- |\n| 1000        |"
            },
            {
                "content": "- max()\n  Returns the maximum value in a set of values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN max(n.born)\n```\n\n**Example output:**\n\n| max(n.born) |\n| ----------- |\n| 2003        |\n\n- min()\n  Returns the minimum value in a set of values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN min(n.born)\n```\n\n**Example output:**\n\n| min(n.born) |\n| ----------- |\n| 1000        |\n\n- percentileCont()\n  Returns the percentile of a value over a group using linear interpolation.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN percentileCont(n.born, 0.4)\n```\n\n**Example output:**\n\n| percentileCont(n.born, 0.4) |\n| --------------------------- |\n| 1953                        |\n\n- percentileDisc()\n  Returns the nearest value to the given percentile over a group using a rounding method.\n  **Scope:** whole instance.\n  **Output:** the percentile of the given value over a group.\n  **Example input:**"
            },
            {
                "content": "```\nMATCH (n:person)\nRETURN percentileCont(n.born, 0.4)\n```\n\n**Example output:**\n\n| percentileCont(n.born, 0.4) |\n| --------------------------- |\n| 1953                        |\n\n- percentileDisc()\n  Returns the nearest value to the given percentile over a group using a rounding method.\n  **Scope:** whole instance.\n  **Output:** the percentile of the given value over a group.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN percentileDisc(n.born, 0.5)\n```\n\n**Example output:**\n\n| percentileDisc(n.age, 0.5) |\n| -------------------------- |\n| 1959                       |\n\n- stDev()\n  Returns the standard deviation for the given value over a group for a sample of a population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN stDev(n.born)\n```\n\n**Example output:**\n\n| stDev(n.born)      |\n| ------------------ |\n| 279.53117993401725 |\n\n- stDevP()\n  Returns the standard deviation for the given value over a group for an entire population.\n  **Scope:** whole instance.\n  **Example input:**"
            },
            {
                "content": "- stDev()\n  Returns the standard deviation for the given value over a group for a sample of a population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN stDev(n.born)\n```\n\n**Example output:**\n\n| stDev(n.born)      |\n| ------------------ |\n| 279.53117993401725 |\n\n- stDevP()\n  Returns the standard deviation for the given value over a group for an entire population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN stDevP(n.born)\n```\n\n**Example output:**\n\n| stDevP(n.born)     |\n| ------------------ |\n| 279.3209270423399  |\n\n- variance()\n  Returns the variance for the given value over a group for a sample of a population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN variance(n.born)\n```\n\n**Example output:**\n\n| variance(n.age)   |\n| ----------------- |\n| 78137.68055530392 |\n\n- varianceP()\n  Returns the variance for the given value over a group for an entire population.\n  **Scope:** whole instance.\n  **Example input:**"
            },
            {
                "content": "| stDevP(n.born)     |\n| ------------------ |\n| 279.3209270423399  |\n\n- variance()\n  Returns the variance for the given value over a group for a sample of a population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN variance(n.born)\n```\n\n**Example output:**\n\n| variance(n.age)   |\n| ----------------- |\n| 78137.68055530392 |\n\n- varianceP()\n  Returns the variance for the given value over a group for an entire population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN varianceP(n.born)\n```\n\n**Example output:**\n\n| varianceP(n.age)  |\n| ----------------- |\n| 78020.18028379219 |\n\n- sum()\n  Returns the sum of a set of numeric values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN sum(n.born)\n```\n\n**Example output:**\n\n| sum(n.born) |\n| ----------- |\n| 1243062     |\n\n### 3.5.List Funtions:\n\n- keys()\n  get the field names of some vertex.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN keys(a) LIMIT 1\n```"
            },
            {
                "content": "**Example output:**\n\n| varianceP(n.age)  |\n| ----------------- |\n| 78020.18028379219 |\n\n- sum()\n  Returns the sum of a set of numeric values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN sum(n.born)\n```\n\n**Example output:**\n\n| sum(n.born) |\n| ----------- |\n| 1243062     |\n\n### 3.5.List Funtions:\n\n- keys()\n  get the field names of some vertex.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN keys(a) LIMIT 1\n```\n\n**Example output:**\n\n| keys(a)               |\n| --------------------- |\n| [\"name\",\"age\",\"eyes\"] |\n\n- labels()/label()\n  Returns a list containing the string representations for all the property names of a node, relationship, or map.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN labels(a) LIMIT 1\n```\n\n**Example output:**\n\n| labels                 |\n| ---------------------- |\n| [\"Person\"]             |\n\n- nodes()\n\n  Get vertex ids of a path\n\n  **Scope:** whole instance.\n\n  **Example input:**"
            },
            {
                "content": "| keys(a)               |\n| --------------------- |\n| [\"name\",\"age\",\"eyes\"] |\n\n- labels()/label()\n  Returns a list containing the string representations for all the property names of a node, relationship, or map.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN labels(a) LIMIT 1\n```\n\n**Example output:**\n\n| labels                 |\n| ---------------------- |\n| [\"Person\"]             |\n\n- nodes()\n\n  Get vertex ids of a path\n\n  **Scope:** whole instance.\n\n  **Example input:**\n\n  ```\n  MATCH p = (from {name: 'Bob'})-[*1..]->(to {name: 'Alice\"})\n  RETURN nodes(p)\n  ```\n\n  **Example output:**\n\n  | nodes(p)       |\n  | -------------- |\n  | [0, 1, 10, 12] |\n\n\n### 3.6.Mathematical functions\n\n- abs()\n  get the absolute value of some data.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a:person {name: 'Laurence Fishburne'}),(e:person {name: 'Carrie-Anne Moss'})\nRETURN a.born, e.born, abs(a.born-e.born)\n```\n\n**Example output:**"
            },
            {
                "content": "**Example input:**\n\n  ```\n  MATCH p = (from {name: 'Bob'})-[*1..]->(to {name: 'Alice\"})\n  RETURN nodes(p)\n  ```\n\n  **Example output:**\n\n  | nodes(p)       |\n  | -------------- |\n  | [0, 1, 10, 12] |\n\n\n### 3.6.Mathematical functions\n\n- abs()\n  get the absolute value of some data.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a:person {name: 'Laurence Fishburne'}),(e:person {name: 'Carrie-Anne Moss'})\nRETURN a.born, e.born, abs(a.born-e.born)\n```\n\n**Example output:**\n\n  | a.born | e.born | abs(a.born - e.born) |\n  |--------|--------|-----------------------|\n  | 1961   | 1967   | 6                     |\n\n- ceil()\n  Returns the smallest floating point number that is greater than or equal to a number and equal to a mathematical integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN ceil(0.1)\n```\n\n**Example output:**\n\n| ceil(0.1) |\n| --------- |\n| 1.0       |"
            },
            {
                "content": "**Example output:**\n\n  | a.born | e.born | abs(a.born - e.born) |\n  |--------|--------|-----------------------|\n  | 1961   | 1967   | 6                     |\n\n- ceil()\n  Returns the smallest floating point number that is greater than or equal to a number and equal to a mathematical integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN ceil(0.1)\n```\n\n**Example output:**\n\n| ceil(0.1) |\n| --------- |\n| 1.0       |\n\n- floor()\n  get the largest floating point number that is less than or equal to the given number and equal to a mathematical integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN floor(0.9)\n```\n\n**Example output:**\n\n| floor(0.9) |\n| ---------- |\n| 0.0        |\n\n- round()\n  Returns the value of a number rounded to the nearest integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN round(3.141592)\n```\n\n**Example output:**\n\n| round |\n| ----- |\n| 3     |"
            },
            {
                "content": "- floor()\n  get the largest floating point number that is less than or equal to the given number and equal to a mathematical integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN floor(0.9)\n```\n\n**Example output:**\n\n| floor(0.9) |\n| ---------- |\n| 0.0        |\n\n- round()\n  Returns the value of a number rounded to the nearest integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN round(3.141592)\n```\n\n**Example output:**\n\n| round |\n| ----- |\n| 3     |\n\n- rand()\n  Returns returns a random floating point number in the range from 0 (inclusive) to 1 exclusive).\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN rand()\n```\n\n**Example output:**\n\n| rand()             |\n| ------------------ |\n| 0.9797131960534085 |\n\n- sign()\n  Get the signum of the given number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN sign(-17), sign(0.1)\n```\n\n**Example output:**"
            },
            {
                "content": "- rand()\n  Returns returns a random floating point number in the range from 0 (inclusive) to 1 exclusive).\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN rand()\n```\n\n**Example output:**\n\n| rand()             |\n| ------------------ |\n| 0.9797131960534085 |\n\n- sign()\n  Get the signum of the given number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN sign(-17), sign(0.1)\n```\n\n**Example output:**\n\n| sign(-17) | sign(0.1) |\n| --------- | --------- |\n| -1        | 1         |\n\nTuGraph 查询语言与 OpenCypher 的不同点如下：\n\n- Label 数量\n  - TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.\n  - OpenCypher: One node/relationship may have 0 to many labels.\n- Schema.\n  - TuGraph: TuGraph has strong schema\n  - OpenCypher: schema-less\n\n## 4.附录1. 语法扩充及不同\n\nTuGraph查询语言与OpenCypher的不同点如下："
            },
            {
                "content": "| sign(-17) | sign(0.1) |\n| --------- | --------- |\n| -1        | 1         |\n\nTuGraph 查询语言与 OpenCypher 的不同点如下：\n\n- Label 数量\n  - TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.\n  - OpenCypher: One node/relationship may have 0 to many labels.\n- Schema.\n  - TuGraph: TuGraph has strong schema\n  - OpenCypher: schema-less\n\n## 4.附录1. 语法扩充及不同\n\nTuGraph查询语言与OpenCypher的不同点如下：\n\n- Label数量\n  - TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.\n  - OpenCypher: One node/relationship may have 0 to many labels.\n- Schema.\n  - TuGraph: TuGraph has strong schema\n  - OpenCypher: schema-less\n\n## 5.附录2. 内置procedures列表\n### 5.1.procedures样例\n\n* dbms.procedures()\n\n  Lists all available procedures.\n\n  **Scope:** whole instance."
            },
            {
                "content": "TuGraph查询语言与OpenCypher的不同点如下：\n\n- Label数量\n  - TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.\n  - OpenCypher: One node/relationship may have 0 to many labels.\n- Schema.\n  - TuGraph: TuGraph has strong schema\n  - OpenCypher: schema-less\n\n## 5.附录2. 内置procedures列表\n### 5.1.procedures样例\n\n* dbms.procedures()\n\n  Lists all available procedures.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {`signature`, `name`}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.procedures()\n  ```\n\n  **Example output:**"
            },
            {
                "content": "## 5.附录2. 内置procedures列表\n### 5.1.procedures样例\n\n* dbms.procedures()\n\n  Lists all available procedures.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {`signature`, `name`}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.procedures()\n  ```\n\n  **Example output:**\n\n  | signature                        | name         |\n  | ---------------------------------------------------- | -------------------- |\n  | db.vertexLabels() :: (label::STRING)               | db.vertexLabels        |\n  | db.edgeLabels() :: (edgeLabels::STRING) | db.edgeLabels |\n  | db.indexes() :: (index::LIST)            | db.indexes       |\n  | ...                          | ...          |\n\n* db.subgraph()\n\n  **Scope:** whole instance.\n\n  **Parameters:**"
            },
            {
                "content": "**Example output:**\n\n  | signature                        | name         |\n  | ---------------------------------------------------- | -------------------- |\n  | db.vertexLabels() :: (label::STRING)               | db.vertexLabels        |\n  | db.edgeLabels() :: (edgeLabels::STRING) | db.edgeLabels |\n  | db.indexes() :: (index::LIST)            | db.indexes       |\n  | ...                          | ...          |\n\n* db.subgraph()\n\n  **Scope:** whole instance.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description                                                           |\n  | ---------- | -------------- | --------------------------------------------------------------------- |\n  | vids       | list           | list of vertex id                                                     |\n\n  **Output:**\n\n  Get a json containing all the properties of nodes and relationships.\n\n  **Example input:**\n\n  ```\n  CALL db.subgraph([3937,4126,4066,4010])\n  ```\n\n  **Example output**"
            },
            {
                "content": "| subgraph |\n  | -------- |"
            },
            {
                "content": "| {\"nodes\":[{\"identity\":3937,\"label\":\"movie\",\"properties\":{\"duration\":136,\"id\":1,\"poster_image\":\"http://image.tmdb.org/t/p/w185/gynBNzwyaHKtXqlEKKLioNkjKgN.jpg\",\"rated\":\"R\",\"summary\":\"Thomas A. Anderson is a man living two lives. By day he is an average computer programmer and by night a malevolent hacker known as Neo who finds himself targeted by the police when he is contacted by Morpheus a legendary computer hacker who reveals the shocking truth about our reality.\",\"tagline\":\"Welcome to the Real World.\",\"title\":\"The"
            },
            {
                "content": "A. Anderson is a man living two lives. By day he is an average computer programmer and by night a malevolent hacker known as Neo who finds himself targeted by the police when he is contacted by Morpheus a legendary computer hacker who reveals the shocking truth about our reality.\",\"tagline\":\"Welcome to the Real World.\",\"title\":\"The Matrix\"}},{\"identity\":4010,\"label\":\"user\",\"properties\":{\"id\":44,\"login\":\"Howard\"}},{\"identity\":4066,\"label\":\"user\",\"properties\":{\"id\":202,\"login\":\"Enoch\"}},{\"identity\":4126,\"label\":\"user\",\"properties\":{\"id\":464,\"login\":\"Wilburn\"}}],\"relationships\":[{\"dst\":4126,\"forward\":true,\"identity\":0,\"label\":\"is_friend\",\"label_id\":3,\"src\":4010,\"temporal_id\":0},{\"dst\":4010,\"forward\":true,\"identity\":0,\"label\":\"is_friend\",\"label_id\":3,\"src\":4066,\"temporal_id\":0},{\"dst\":4066,\"forward\":true,\"identity\":0,\"label\":\"is_friend\",\"label_id\":3,\"src\":4126,\"temporal_id\":0}]} |"
            },
            {
                "content": "* db.vertexLabels()\n\n  Lists all available vertex labels of vertex.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {`name`}.\n\n  **Example input:**\n\n  ```\n  CALL db.vertexLabels()\n  ```\n  **Example output:**\n\n    | label   |\n    | ------- |\n    | genre   |\n    | keyword |\n    | movie   |\n    | ...     |\n\n* db.edgeLabels()\n\n  Lists all available labels of edges.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {edge labels}.\n\n  **Example input:**\n\n  ```\n  CALL db.edgeLabels()\n  ```\n\n  **Example output:**\n\n  | relationshipType |\n  | ---------------- |\n  | acted_in     |\n  | directed     |\n  | ...          |\n\n* db.createVertexLabel(label_name, primary_field, field_spec...)\n\n  Create a vertex label.\n\n  **Scope:** whole instance.\n\n  **Parameters:**"
            },
            {
                "content": "* db.edgeLabels()\n\n  Lists all available labels of edges.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {edge labels}.\n\n  **Example input:**\n\n  ```\n  CALL db.edgeLabels()\n  ```\n\n  **Example output:**\n\n  | relationshipType |\n  | ---------------- |\n  | acted_in     |\n  | directed     |\n  | ...          |\n\n* db.createVertexLabel(label_name, primary_field, field_spec...)\n\n  Create a vertex label.\n\n  **Scope:** whole instance.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description          |\n  | ---------- | -------------- | ------------------------ |\n  | label_name | string     | name of  vertex label    |\n  | primary_field | string  | primary field of vertex label |\n  | field_spec | list       | specification of a field |\n\n   in which each `field_spec` is a list of string in the form of `[field_name, field_type, true]`, where true is specified only for optional fields.\n\n    **Output:** If successful, it returns a success message.\n\n    **Example input:**"
            },
            {
                "content": "in which each `field_spec` is a list of string in the form of `[field_name, field_type, true]`, where true is specified only for optional fields.\n\n    **Output:** If successful, it returns a success message.\n\n    **Example input:**\n\n    ```\n    CALL db.createVertexLabel('Person', 'id', 'id', 'int64', false, 'name', 'string', true)\n    ```\n\n    **Example output:**\n\n    ```\n    Added label [Person]\n    ```\n\n* db.getLabelSchema(label_type, label_name)\n\n  Get the schema definition of the label in a subgraph.\n\n  **Scope:** subgraph, as specified in the `graph` parameter in REST or RPC request.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n\n  **Output:** a list of label specifications, in which each element is a list of the following fields:"
            },
            {
                "content": "Get the schema definition of the label in a subgraph.\n\n  **Scope:** subgraph, as specified in the `graph` parameter in REST or RPC request.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n\n  **Output:** a list of label specifications, in which each element is a list of the following fields:\n\n  | field_name | field_type | description           |\n  | ---------- | ---------- | ----------------------------- |\n  | name       | string     | name of the field         |\n  | type       | string     | type of the field         |\n  | optional   | boolean    | whether the field is optional |\n\n  **Example input:**\n\n  ```\n  CALL db.getLabelSchema('vertex', 'Person')\n  ```\n\n  **Example output:**"
            },
            {
                "content": "**Output:** a list of label specifications, in which each element is a list of the following fields:\n\n  | field_name | field_type | description           |\n  | ---------- | ---------- | ----------------------------- |\n  | name       | string     | name of the field         |\n  | type       | string     | type of the field         |\n  | optional   | boolean    | whether the field is optional |\n\n  **Example input:**\n\n  ```\n  CALL db.getLabelSchema('vertex', 'Person')\n  ```\n\n  **Example output:**\n\n  | name     | type   | optional |\n  | ------------ | ------ | -------- |\n  | id       | INT32  | false    |\n  | born     | INT32  | true     |\n  | name     | STRING | true     |\n  | poster_image | STRING | true     |\n\n* db.createLabel(label_type, label_name, extra, field_spec...)\n\n  Create a vertex or edge label.\n\n  **Parameters:**"
            },
            {
                "content": "**Example input:**\n\n  ```\n  CALL db.getLabelSchema('vertex', 'Person')\n  ```\n\n  **Example output:**\n\n  | name     | type   | optional |\n  | ------------ | ------ | -------- |\n  | id       | INT32  | false    |\n  | born     | INT32  | true     |\n  | name     | STRING | true     |\n  | poster_image | STRING | true     |\n\n* db.createLabel(label_type, label_name, extra, field_spec...)\n\n  Create a vertex or edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n  | extra      | string     | for edge, it means constraints; for vertex, it means primary property |\n  | field_spec | list       | specification of a field  |"
            },
            {
                "content": "* db.createLabel(label_type, label_name, extra, field_spec...)\n\n  Create a vertex or edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n  | extra      | string     | for edge, it means constraints; for vertex, it means primary property |\n  | field_spec | list       | specification of a field  |\n\n    in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.\n    for edge, `extra` should be a json array string, like this `[[\"label1\",\"label2\"], [\"label3\",\"label4\"]]`, if edge has no constraints, give an empty json array, like this `[]`\n\n  **Output:**\n\n  If successful, it returns a success message.\n\n  **Example input:**"
            },
            {
                "content": "in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.\n    for edge, `extra` should be a json array string, like this `[[\"label1\",\"label2\"], [\"label3\",\"label4\"]]`, if edge has no constraints, give an empty json array, like this `[]`\n\n  **Output:**\n\n  If successful, it returns a success message.\n\n  **Example input:**\n\n  ```\n  CALL db.createLabel('vertex', 'new_label', 'id', ['id','int32',false], ['name','string', true]);\n  CALL db.createLabel('edge', 'new_edge', '[[\"id1\",\"id2\"]]', ['id','int32',false], ['name', 'string', true]);\n  ```\n\n  **Example output:**\n\n  ```\n  Vertex label [new_label] successfully added.\n  ```\n\n* db.deleteLabel(label_type, label_name)\n\n  Delete a vertex or edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n\n  **Output:**"
            },
            {
                "content": "**Example output:**\n\n  ```\n  Vertex label [new_label] successfully added.\n  ```\n\n* db.deleteLabel(label_type, label_name)\n\n  Delete a vertex or edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n\n  **Output:**\n\n  | field_name | field_type | description              |\n  | ---------- | ---------- | -------------------------------- |\n  | affected   | integer    | number of vertexes/edges deleted |\n\n  **Example input:**\n\n  ```\n  CALL db.deleteLabel('vertex', 'Person')\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelDelFields(label_type, label_name, field_names)\n\n  Delete specified fields from the label.\n\n  **Parameters:**"
            },
            {
                "content": "**Output:**\n\n  | field_name | field_type | description              |\n  | ---------- | ---------- | -------------------------------- |\n  | affected   | integer    | number of vertexes/edges deleted |\n\n  **Example input:**\n\n  ```\n  CALL db.deleteLabel('vertex', 'Person')\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelDelFields(label_type, label_name, field_names)\n\n  Delete specified fields from the label.\n\n  **Parameters:**\n\n  | parameter   | parameter type  | description           |\n  | ----------- | --------------- | ----------------------------- |\n  | label_type  | string      | either 'vertex' or 'edge'     |\n  | label_name  | string      | name of the label         |\n  | field_names | list of strings | names of the fields to delete |\n\n  **Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**"
            },
            {
                "content": "**Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n  ```\n  CALL db.alterLabelDelFields('vertex', 'Person', ['name', 'image'])\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelAddFields(label_type, label_name, field_value_spec...)\n\n  Adds specified fields to the label.\n\n  **Parameters:**\n\n  | parameter    | parameter type | description           |\n  | ---------------- | -------------- | ------------------------- |\n  | label_type       | string     | either 'vertex' or 'edge' |\n  | label_name       | string     | name of the label     |\n  | field_value_spec | list       | specification of a field  |\n\n    in which each `field_value_spec` is a list of string in the form of `[field_name, field_type, field_value, optional]`, where: `field_value` is the default value of the field.\n\n  **Output:**"
            },
            {
                "content": "| parameter    | parameter type | description           |\n  | ---------------- | -------------- | ------------------------- |\n  | label_type       | string     | either 'vertex' or 'edge' |\n  | label_name       | string     | name of the label     |\n  | field_value_spec | list       | specification of a field  |\n\n    in which each `field_value_spec` is a list of string in the form of `[field_name, field_type, field_value, optional]`, where: `field_value` is the default value of the field.\n\n  **Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n  ```\n  CALL db.alterLabelAddFields(\n  'vertex',\n  'new_label',\n  ['birth_date', DATE, '', true],\n  ['img', BLOB, '', true])\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelModFields(label_type, label_name, field_spec...)"
            },
            {
                "content": "**Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n  ```\n  CALL db.alterLabelAddFields(\n  'vertex',\n  'new_label',\n  ['birth_date', DATE, '', true],\n  ['img', BLOB, '', true])\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelModFields(label_type, label_name, field_spec...)\n\n  Modifies the specified fields in the label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n  | field_spec | list       | specification of a field  |\n\n    in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.The target field should exist.\n\n  **Output:**"
            },
            {
                "content": "Modifies the specified fields in the label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n  | field_spec | list       | specification of a field  |\n\n    in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.The target field should exist.\n\n  **Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n    ```\n    CALL db.alterLabelModFields(\n    'vertex',\n    'new_label',\n    ['birth_date', DATETIME, true],\n    ['gender', BOOL, true])\n    ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.createEdgeLabel( label_name, field_spec...)\n\n  Create an edge label."
            },
            {
                "content": "| field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n    ```\n    CALL db.alterLabelModFields(\n    'vertex',\n    'new_label',\n    ['birth_date', DATETIME, true],\n    ['gender', BOOL, true])\n    ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.createEdgeLabel( label_name, field_spec...)\n\n  Create an edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description          |\n  | ---------- | -------------- | ------------------------ |\n  | label_name | string     | name of the label    |\n  | edge_constraints | string | edge constraints |\n  | field_spec | list       | specification of a field |\n\n  in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`, where optional is specified as true, only for  optional fields."
            },
            {
                "content": "Create an edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description          |\n  | ---------- | -------------- | ------------------------ |\n  | label_name | string     | name of the label    |\n  | edge_constraints | string | edge constraints |\n  | field_spec | list       | specification of a field |\n\n  in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`, where optional is specified as true, only for  optional fields.\n\n  `edge_constraints` is a json array string, This parameter limits the combination of starting and ending vertex of the edge, for example: `'[[\"vertex_label1\",\"vertex_label2\"],[\"vertex_label3\",\"vertex_label4\"]]'`, which limits the edge direction can only be from `vertex_label1` to `vertex_label2` or from `vertex_label3` to `vertex_label4`. If you don't want to have any constraints, give an empty array string, like this `'[]'`\n\n  **Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**"
            },
            {
                "content": "**Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL db.createEdgeLabel('KNOWS', '[]', 'name', 'int32', true)\n  ```\n\n  **Example output:**\n\n  ```\n  Added type [KNOWS]\n  ```\n\n* db.addIndex(label_name, field_name, unique)\n\n  create an index on some field of one vertex label .\n\n  **Parameters:**\n\n  | parameter | parameter type | description               |\n  | ---------- | -------------- | ------------------------------------- |\n  | label_name | string     | name of the label             |\n  | field_name | string     | specification of a field          |\n  | unique  | boolean    | Specifies whether the index is unique |\n\n   **Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL db.addIndex('Person', 'id', true)\n  ```\n\n   **Example output:**\n\n  ```\n  Added index [Perosn:id]\n  ```\n* db.addEdgeIndex(label_name, field_name, unique, pair_unique)\n\n  create an index on some field of one edge label .\n\n  **Parameters:**"
            },
            {
                "content": "**Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL db.addIndex('Person', 'id', true)\n  ```\n\n   **Example output:**\n\n  ```\n  Added index [Perosn:id]\n  ```\n* db.addEdgeIndex(label_name, field_name, unique, pair_unique)\n\n  create an index on some field of one edge label .\n\n  **Parameters:**\n\n  | parameter | parameter type | description               |\n    | ---------- | -------------- | ------------------------------------- |\n  | label_name | string     | name of the label             |\n  | field_name | string     | specification of a field          |\n  | unique  | boolean    | Specifies whether the index is unique |\n  | pair_unique | boolean    | Specifies whether the index is pair_unique |\n\n  **Output:**\n\n  If successful, it returns a success message.\n\n  **Example input:**\n\n  ```\n  CALL db.addEdgeIndex('BornIn', 'id', true, false)\n  ```\n\n  **Example output:**\n\n  ```\n  Added index [BornIn:id]\n  ```"
            },
            {
                "content": "**Output:**\n\n  If successful, it returns a success message.\n\n  **Example input:**\n\n  ```\n  CALL db.addEdgeIndex('BornIn', 'id', true, false)\n  ```\n\n  **Example output:**\n\n  ```\n  Added index [BornIn:id]\n  ```\n\n* dbms.security.changePassword(current_password ,new_password)\n\n  Change the current user's password.\n\n  **Parameters:**\n\n  | parameter    | parameter type | description      |\n  | ---------------- | -------------- | -------------------- |\n  | current_password | string     | the current password |\n  | new_password     | string     | new password     |\n\n  **Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.changePassword('73@TuGraph','admin')\n  ```\n\n   **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.changeUserPassword(user_name, new_password)\n\n  Change the current user's password.\n\n  **Parameters:**"
            },
            {
                "content": "**Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.changePassword('73@TuGraph','admin')\n  ```\n\n   **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.changeUserPassword(user_name, new_password)\n\n  Change the current user's password.\n\n  **Parameters:**\n\n  | parameter    | parameter type | description     |\n  | ------------ | -------------- | --------------- |\n  | user_name    | string     | the user's name |\n  | new_password | string     | new password    |\n\n  **Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.changeUserPassword('quest','73@TuGraph')\n  ```\n\n  **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.createUser(user_name, password)\n\n  create  new user on this graph database.\n\n  **Parameters:**"
            },
            {
                "content": "**Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.changeUserPassword('quest','73@TuGraph')\n  ```\n\n  **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.createUser(user_name, password)\n\n  create  new user on this graph database.\n\n  **Parameters:**\n\n  | parameter | parameter type | description              |\n  | --------- | -------------- | -------------------------------- |\n  | user_name | string     | the new user name        |\n  | password  | string     | the password of new user     |\n  \n   **Output:**\n  \n    If successful, it returns a success message.\n  \n   **Example input:**\n  \n  ```\n  CALL dbms.security.createUser('quest',\"admin\")\n  ```\n  \n   **Example output:**\n  \n  ```\n  true\n  ```\n  \n* dbms.security.deleteUser(user_name)\n\n  delete user on this graph database.\n\n  **Parameters:**"
            },
            {
                "content": "delete user on this graph database.\n\n  **Parameters:**\n\n  | parameter | parameter type | description         |\n  | --------- | -------------- | --------------------------- |\n  | user_name | string     | the user name to be deleted |\n\n  **Output:**\n\n    If successful, it returns a success message.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.deleteUser('quest')\n  ```\n\n  **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.listUsers()\n\n  get all user's name of the graph database.\n\n  **Output:**\n\n   a list of user names, in which each element is a list of the following fields:\n\n  | parameter | parameter type | description         |\n  | --------- | -------------- | --------------------------- |\n  | user.name | string     | the user name           |\n  | is.admin  | boolean    | the permission of this user |\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.listUsers()\n  ```\n\n  **Example output:**"
            },
            {
                "content": "* dbms.security.listUsers()\n\n  get all user's name of the graph database.\n\n  **Output:**\n\n   a list of user names, in which each element is a list of the following fields:\n\n  | parameter | parameter type | description         |\n  | --------- | -------------- | --------------------------- |\n  | user.name | string     | the user name           |\n  | is.admin  | boolean    | the permission of this user |\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.listUsers()\n  ```\n\n  **Example output:**\n\n  | user.name | is.admin |\n  | --------- | -------- |\n  | admin     | true     |\n  | ...       |  ...    |\n\n* dbms.security.showCurrentUser()\n\n  get current user's name.\n\n  **Output:**\n\n    a list of user names, in which each element is a list of the following fields:\n\n  | parameter | parameter type | description       |\n  | --------- | -------------- | --------------------- |\n  | user.user | string     | the current user name |\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.showCurrentUser()\n  ```"
            },
            {
                "content": "| user.name | is.admin |\n  | --------- | -------- |\n  | admin     | true     |\n  | ...       |  ...    |\n\n* dbms.security.showCurrentUser()\n\n  get current user's name.\n\n  **Output:**\n\n    a list of user names, in which each element is a list of the following fields:\n\n  | parameter | parameter type | description       |\n  | --------- | -------------- | --------------------- |\n  | user.user | string     | the current user name |\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.showCurrentUser()\n  ```\n\n  **Example output:**\n\n  | user.name |\n  | --------- |\n  | admin     |\n\n* dbms.security.listAllowedHosts()\n\n  get the list of ips to be allowed .\n\n  **Output:**\n\n   a list of  ips which are allowed.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.listAllowedHosts()\n  ```\n\n  **Example output:**\n\n  | host     |\n  | ------------ |\n  | 192.168.1.22 |\n  | ...      |\n\n* dbms.security.deleteAllowedHosts(hosts)\n\n  delete some ips from the list of ips to be allowed .\n\n  **Output:**"
            },
            {
                "content": "**Example output:**\n\n  | user.name |\n  | --------- |\n  | admin     |\n\n* dbms.security.listAllowedHosts()\n\n  get the list of ips to be allowed .\n\n  **Output:**\n\n   a list of  ips which are allowed.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.listAllowedHosts()\n  ```\n\n  **Example output:**\n\n  | host     |\n  | ------------ |\n  | 192.168.1.22 |\n  | ...      |\n\n* dbms.security.deleteAllowedHosts(hosts)\n\n  delete some ips from the list of ips to be allowed .\n\n  **Output:**\n\n   the number of ip which been deleted.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.deleteAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | 2       |\n\n* dbms.security.addAllowedHosts(hosts)\n\n  add some ips from the list of ips to be allowed .\n\n  **Output:**\n\n    the number of ip which been added.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.addAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | 2       |"
            },
            {
                "content": "**Example input:**\n\n  ```\n  CALL dbms.security.deleteAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | 2       |\n\n* dbms.security.addAllowedHosts(hosts)\n\n  add some ips from the list of ips to be allowed .\n\n  **Output:**\n\n    the number of ip which been added.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.addAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | 2       |\n\n* dbms.graph.createGraph(graph_name, description, max_size_GB)\n\n  create a new subgraph in this graph database .\n\n  **Parameters:**\n\n  | parameter   | parameter type | description              |\n  | ----------- | -------------- | -------------------------------- |\n  | graph_name  | string     | the name of new subgraph     |\n  | description | string     | description of new subgraph      |\n  | max_size_GB | integer    | Upper limit of subgraph capacity |\n\n   **Output:**\n\n    if successful , it will return true."
            },
            {
                "content": "create a new subgraph in this graph database .\n\n  **Parameters:**\n\n  | parameter   | parameter type | description              |\n  | ----------- | -------------- | -------------------------------- |\n  | graph_name  | string     | the name of new subgraph     |\n  | description | string     | description of new subgraph      |\n  | max_size_GB | integer    | Upper limit of subgraph capacity |\n\n   **Output:**\n\n    if successful , it will return true.\n\n   **Example input:**\n\n  ```\n  CALL dbms.graph.createGraph('graph1', 'description', 2045)\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.deleteGraph(graph_name)\n\n  delete a subgraph in this graph database .\n\n  | parameter  | parameter type | description              |\n  | ---------- | -------------- | ------------------------------------ |\n  | graph_name | string     | the name of subgraph to been deleted |\n\n  **Output:**\n\n    if successful , it will return true.\n\n  **Example input:**"
            },
            {
                "content": "```\n  CALL dbms.graph.createGraph('graph1', 'description', 2045)\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.deleteGraph(graph_name)\n\n  delete a subgraph in this graph database .\n\n  | parameter  | parameter type | description              |\n  | ---------- | -------------- | ------------------------------------ |\n  | graph_name | string     | the name of subgraph to been deleted |\n\n  **Output:**\n\n    if successful , it will return true.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.deleteGraph('graph1')\n  ```\n\n   **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.modGraph(graph_name, config)\n\n  delete a subgraph in this graph database .\n\n  **Parameters:**\n\n  | parameter  | parameter type | description              |\n  | ---------- | -------------- | ------------------------------------ |\n  | graph_name | string     | the name of subgraph to been deleted |\n  | config     | map        | the configuration to be modified     |\n\n  **Output:**"
            },
            {
                "content": "**Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.modGraph(graph_name, config)\n\n  delete a subgraph in this graph database .\n\n  **Parameters:**\n\n  | parameter  | parameter type | description              |\n  | ---------- | -------------- | ------------------------------------ |\n  | graph_name | string     | the name of subgraph to been deleted |\n  | config     | map        | the configuration to be modified     |\n\n  **Output:**\n\n    if successful , it will return true.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.modGraph('graph1',{description:'this graph', max_size_GB:20})\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.listGraphs()\n\n  get all subgraphs in this graph database.\n\n  **Output:**\n\n    a list of {subgraph and configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.listGraphs()\n  ```\n\n  **Example output:**"
            },
            {
                "content": "**Output:**\n\n    if successful , it will return true.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.modGraph('graph1',{description:'this graph', max_size_GB:20})\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.listGraphs()\n\n  get all subgraphs in this graph database.\n\n  **Output:**\n\n    a list of {subgraph and configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.listGraphs()\n  ```\n\n  **Example output:**\n\n  | graph.name | configuration                 |\n  | ---------- | --------------------------------------------- |\n  | default    | {\"description\":\"\",\"max_size_GB\":1024}     |\n  | graph1     | {\"description\":\"this graph\",\"max_size_GB\":20} |\n  | ...    |         ...                  |\n\n\n* dbms.graph.listUserGraphs(user_name)\n\n  get subgraph list which specified user can read or write\n\n  **Output:**\n\n  a list of {subgraph and configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.listUserGraphs(\"test_user\")\n  ```\n\n  **Example output:**"
            },
            {
                "content": "* dbms.graph.listUserGraphs(user_name)\n\n  get subgraph list which specified user can read or write\n\n  **Output:**\n\n  a list of {subgraph and configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.listUserGraphs(\"test_user\")\n  ```\n\n  **Example output:**\n\n  | graph.name | configuration                 |\n    | ---------- | --------------------------------------------- |\n  | default    | {\"description\":\"\",\"max_size_GB\":1024}     |\n  | graph1     | {\"description\":\"this graph\",\"max_size_GB\":20} |\n  | ...    |         ...                  |\n\n* dbms.config.list()\n\n  get config of this graph database.\n\n  **Output:**\n\n    a list of {configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.config.list()\n  ```\n\n  **Example output:**\n\n  | name      | value   |\n  |-----------| ---------|\n  | bind_host | 0.0.0.0 |\n  | durable   | true    |\n  | ...       |  ...    |\n\n* dbms.config.update(updates)\n\n  get some config of this graph database.\n\n  **Output:**\n\n    If successful, it returns a success message"
            },
            {
                "content": "* dbms.config.list()\n\n  get config of this graph database.\n\n  **Output:**\n\n    a list of {configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.config.list()\n  ```\n\n  **Example output:**\n\n  | name      | value   |\n  |-----------| ---------|\n  | bind_host | 0.0.0.0 |\n  | durable   | true    |\n  | ...       |  ...    |\n\n* dbms.config.update(updates)\n\n  get some config of this graph database.\n\n  **Output:**\n\n    If successful, it returns a success message\n\n  **Example input:**\n\n  ```\n  CALL dbms.config.update({\n    enable_ip_check:false,\n    durable:true,\n    optimistic_txn:true,\n    enable_audit_log:true})\n  ```\n\n  **Example output:**\n\n  ```\n  Update succeeded.\n  ```\n\n* dbms.takeSnapshot()\n\n  take the  snapshot  on this current graph database.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  CALL dbms.takeSnapshot()\n  ```\n\n  **Example output:**\n\n  | path                |\n  | ----------------------------------- |\n  | log/db/snapshot/2020-07-20_17.20.03 |"
            },
            {
                "content": "**Example output:**\n\n  ```\n  Update succeeded.\n  ```\n\n* dbms.takeSnapshot()\n\n  take the  snapshot  on this current graph database.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  CALL dbms.takeSnapshot()\n  ```\n\n  **Example output:**\n\n  | path                |\n  | ----------------------------------- |\n  | log/db/snapshot/2020-07-20_17.20.03 |\n\n* dbms.listBackupFiles()\n\n  get the path of backuped files.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  CALL dbms.listBackupFiles()\n  ```\n\n  **Example output:**\n\n  | path               |\n  | -------------------------- |\n  | tugraph/db/binlog/binlog_0 |\n\n* algo.shortestPath(startNode, endNode, config)\n\n  get one of the shortest paths between two vertexes.\n\n  **Parameters:**"
            },
            {
                "content": "* dbms.listBackupFiles()\n\n  get the path of backuped files.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  CALL dbms.listBackupFiles()\n  ```\n\n  **Example output:**\n\n  | path               |\n  | -------------------------- |\n  | tugraph/db/binlog/binlog_0 |\n\n* algo.shortestPath(startNode, endNode, config)\n\n  get one of the shortest paths between two vertexes.\n\n  **Parameters:**\n\n  | parameter | parameter type | description                          |\n  | --------- | -------------- | ------------------------------------------------------------ |\n  | startNode | Node       | the source node of paths                     |\n  | endNode   | Node       | the destination node paths                   |\n  | config    | MAP        | the filter of shortest paths, the formate as {maxHops:3, relationshipQuery:'HAS_CHILD'} |\n\n  **Output:**\n\n    If successful, it will returns one group result of the shortest path.\n\n  **Example input:**"
            },
            {
                "content": "**Output:**\n\n    If successful, it will returns one group result of the shortest path.\n\n  **Example input:**\n\n  ```\n  MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})\n  CALL algo.shortestPath(n1,n2) YIELD nodeCount,totalCost RETURN nodeCount,totalCost\n  ```\n\n  **Example output:**\n\n  | nodeCount | totalCost |\n  | --------- | --------- |\n  | 2     | 1     |\n\n* algo.allShortestPaths(startNode, endNode, config))\n\n  get the path of backuped files.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})\n  CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,cost RETURN nodeIds,cost\n  ```\n\n  **Example output:**\n\n  | nodeIds | cost |\n  | ------- | ---- |\n  | [2,665] | 1    |\n  | ...     |      |\n\n* algo.algo.native.extract(id, config))\n\n  get the field values of a list of vertexes or edges.\n\n  **Parameters:**"
            },
            {
                "content": "get the path of backuped files.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})\n  CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,cost RETURN nodeIds,cost\n  ```\n\n  **Example output:**\n\n  | nodeIds | cost |\n  | ------- | ---- |\n  | [2,665] | 1    |\n  | ...     |      |\n\n* algo.algo.native.extract(id, config))\n\n  get the field values of a list of vertexes or edges.\n\n  **Parameters:**\n\n  | parameter | parameter type | description                        |\n  | --------- | -------------- | ---------------------------------------------------------- |\n  | id    | ANY        | the id of vertexes or edges , the id must be variable      |\n  | config    | MAP        | the configuration of  this extraction of vertexes or edges |\n\n  in which each `config` is a map in the form of `{isNode:true, filed:'HAS_CHILD'}`, if `isNode` is specified true, the `id` is a vertex id, or  it is an edge id.\n\n  **Output:**"
            },
            {
                "content": "in which each `config` is a map in the form of `{isNode:true, filed:'HAS_CHILD'}`, if `isNode` is specified true, the `id` is a vertex id, or  it is an edge id.\n\n  **Output:**\n\n    If successful, it returns a list of the value of vertexes or edges specified field .\n\n  **Example input:**\n\n  ```\n  with [2,3] as vids CALL algo.native.extract(vids,{isNode:true, field:'id'})\n  YIELD value  RETURN value\n  ```\n\n  **Example output:**\n\n  | value |\n  | ----- |\n  | [4,5] |\n\n### 5.2.内置procedures完整列表"
            },
            {
                "content": "| Name                                  | Description                           | Signature                                                                                                                                                                               |\n|---------------------------------------|---------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| db.subgraph                           | 列出点的子图                                | db.subgraph(vids::LIST) :: (subgraph::STRING)                                                                                                                                           |"
            },
            {
                "content": "| db.subgraph                           | 列出点的子图                                | db.subgraph(vids::LIST) :: (subgraph::STRING)                                                                                                                                           |\n| db.vertexLabels                       | 列出所有Vertex Label                      | db.vertexLabels() :: (label::STRING)                                                                                                                                                    |\n| db.edgeLabels                         | 列出所有Edge Label                        | db.edgeLabels() :: (edgeLabels::STRING)                                                                                                                                                 |"
            },
            {
                "content": "| db.edgeLabels                         | 列出所有Edge Label                        | db.edgeLabels() :: (edgeLabels::STRING)                                                                                                                                                 |\n| db.indexes                            | 列出所有索引                                | db.indexes() :: (label::STRING,field::STRING,label_type:STRING,unique::BOOLEAN,pair_unique::BOOLEAN)                                                                                    |\n| db.listLabelIndexes                   | 列出所有与某个Label相关的索引                     | db.listLabelIndexes(label_name:STRING,label_type:STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)                                                          |"
            },
            {
                "content": "| db.listLabelIndexes                   | 列出所有与某个Label相关的索引                     | db.listLabelIndexes(label_name:STRING,label_type:STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)                                                          |\n| db.warmup                             | 预热数据                                  | db.warmup() :: (time_used::STRING)                                                                                                                                                      |\n| db.createVertexLabel                  | 创建Vertex Label                        | db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)                                                                                                                  |"
            },
            {
                "content": "| db.createVertexLabel                  | 创建Vertex Label                        | db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)                                                                                                                  |\n| db.createLabel                        | 创建Vertex/Edge Label                   | db.createLabel(label_type::STRING,label_name::STRING,extra::STRING,field_specs::LIST) :: ()                                                                                             |\n| db.getLabelSchema                     | 列出label schema                        | db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)                                                                               |"
            },
            {
                "content": "| db.getLabelSchema                     | 列出label schema                        | db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)                                                                               |\n| db.getVertexSchema                    | 列出点的 schema                           | db.getVertexSchema(label::STRING) :: (schema::MAP)                                                                                                                                      |\n| db.getEdgeSchema                      | 列出边的 schema                           | db.getEdgeSchema(label::STRING) :: (schema::MAP)                                                                                                                                        |"
            },
            {
                "content": "| db.getEdgeSchema                      | 列出边的 schema                           | db.getEdgeSchema(label::STRING) :: (schema::MAP)                                                                                                                                        |\n| db.deleteLabel                        | 删除Vertex/Edge Label                   | db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)                                                                                                                       |\n| db.alterLabelDelFields                | 修改label删除属性                           | db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)                                                                            |"
            },
            {
                "content": "| db.alterLabelDelFields                | 修改label删除属性                           | db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)                                                                            |\n| db.alterLabelAddFields                | 修改label添加field                        | db.alterLabelAddFields(label_type::STRING,label_name::STRING,add_field_spec_values::LIST) :: (record_affected::INTEGER)                                                                 |\n| db.alterLabelModFields                | 修改label field                         | db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)                                                                       |"
            },
            {
                "content": "| db.alterLabelModFields                | 修改label field                         | db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)                                                                       |\n| db.createEdgeLabel                    | 创建Edge Label                          | db.createEdgeLabel(type_name::STRING,field_specs::LIST) :: (::VOID)                                                                                                                     |\n| db.addIndex                           | 创建索引                                  | db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)                                                                                                          |"
            },
            {
                "content": "| db.addIndex                           | 创建索引                                  | db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)                                                                                                          |\n| db.addEdgeIndex                       | 创建索引                                  | db.addEdgeIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN,pair_unique::BOOLEAN) :: (::VOID)                                                                                 |\n| db.addVertexCompositeIndex            | 创建组合索引                                | db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)                                                                                            |"
            },
            {
                "content": "| db.addVertexCompositeIndex            | 创建组合索引                                | db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)                                                                                            |\n| db.deleteIndex                        | 删除索引                                  | db.deleteIndex(label_name::STRING,field_name::STRING) :: (::VOID)                                                                                                                       |\n| db.deleteCompositeIndex               | 删除组合索引                                | db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)                                                                                                                        |"
            },
            {
                "content": "| db.deleteCompositeIndex               | 删除组合索引                                | db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)                                                                                                                        |\n| db.backup                             | 备份数据                                  | db.backup(destination::STRING) :: ()                                                                                                                                                    |\n| dbms.procedures                       | 列出所有procedures                        | dbms.procedures() :: (name::STRING,signature::STRING)                                                                                                                                   |"
            },
            {
                "content": "| dbms.procedures                       | 列出所有procedures                        | dbms.procedures() :: (name::STRING,signature::STRING)                                                                                                                                   |\n| dbms.security.changePassword          | 更改当前用户的密码                             | dbms.security.changePassword(current_password::STRING,new_password::STRING) :: (::VOID)                                                                                                 |\n| dbms.security.changeUserPassword      | 更改指定用户的密码                             | dbms.security.changeUserPassword(user_name::STRING,new_password::STRING) :: (::VOID)                                                                                                    |"
            },
            {
                "content": "| dbms.security.changeUserPassword      | 更改指定用户的密码                             | dbms.security.changeUserPassword(user_name::STRING,new_password::STRING) :: (::VOID)                                                                                                    |\n| dbms.security.createUser              | 创建用户                                  | dbms.security.createUser(user_name::STRING,password::STRING) :: (::VOID)                                                                                                                |\n| dbms.security.deleteUser              | 删除用户                                  | dbms.security.deleteUser(user_name::STRING) :: (::VOID)                                                                                                                                 |"
            },
            {
                "content": "| dbms.security.deleteUser              | 删除用户                                  | dbms.security.deleteUser(user_name::STRING) :: (::VOID)                                                                                                                                 |\n| dbms.security.listUsers               | 列出所有用户                                | dbms.security.listUsers() :: (user_name::STRING,user_info::MAP)                                                                                                                         |\n| dbms.security.showCurrentUser         | 列出当前用户信息                              | dbms.security.showCurrentUser() :: (current_user::STRING)                                                                                                                               |"
            },
            {
                "content": "| dbms.security.showCurrentUser         | 列出当前用户信息                              | dbms.security.showCurrentUser() :: (current_user::STRING)                                                                                                                               |\n| dbms.security.getUserPermissions      | 列出指定用户的权限                             | dbms.security.getUserPermissions(user_name::STRING) :: (user_info::MAP)                                                                                                                 |\n| dbms.graph.createGraph                | 创建子图                                  | dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)                                                                                       |"
            },
            {
                "content": "| dbms.graph.createGraph                | 创建子图                                  | dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)                                                                                       |\n| dbms.graph.modGraph                   | 修改子图属性                                | dbms.graph.modGraph(graph_name::STRING,config::MAP) :: (::VOID)                                                                                                                         |\n| dbms.graph.deleteGraph                | 删除子图                                  | dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)                                                                                                                                  |"
            },
            {
                "content": "| dbms.graph.deleteGraph                | 删除子图                                  | dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)                                                                                                                                  |\n| dbms.graph.listGraphs                 | 列出所有子图                                | dbms.graph.listGraphs() :: (graph_name::STRING,configuration::MAP)                                                                                                                      |\n| dbms.graph.getGraphInfo               | 列出指定子图的信息                             | dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)                                                                                                    |"
            },
            {
                "content": "| dbms.graph.getGraphInfo               | 列出指定子图的信息                             | dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)                                                                                                    |\n| dbms.security.addAllowedHosts         | 添加ip到信任列表                             | dbms.security.addAllowedHosts(hosts::LIST) :: (num_new::INTEGER)                                                                                                                        |\n| dbms.security.deleteAllowedHosts      | 从信任列表删除ip                             | dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)                                                                                                             |"
            },
            {
                "content": "| dbms.security.deleteAllowedHosts      | 从信任列表删除ip                             | dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)                                                                                                             |\n| dbms.security.listAllowedHosts        | 列出信任列表中的主机ip                          | dbms.security.listAllowedHosts() :: (host::STRING)                                                                                                                                      |\n| dbms.config.update                    | 更新TuGraph配置                           | dbms.config.update(updates::MAP) :: (message::STRING)                                                                                                                                   |"
            },
            {
                "content": "| dbms.config.update                    | 更新TuGraph配置                           | dbms.config.update(updates::MAP) :: (message::STRING)                                                                                                                                   |\n| dbms.config.list                      | 列出TuGraph配置                           | dbms.config.list() :: (name::STRING,value::ANY)                                                                                                                                         |\n| algo.shortestPath                     | 查询两个点间的最短路径                           | algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)                                                                                   |"
            },
            {
                "content": "| algo.shortestPath                     | 查询两个点间的最短路径                           | algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)                                                                                   |\n| algo.allShortestPaths                 | 查询两个点间的所有最短路径                         | algo.allShortestPaths(startNode::NODE,endNode::NODE,config::MAP) :: (nodeIds::LIST,relationshipIds::LIST,cost::LIST)                                                                    |\n| algo.native.extract                   | 查询指定VertexId/EdgeUid（列表）指定field的值（列表） | algo.native.extract(id::ANY,config::MAP) :: (value::ANY)                                                                                                                                |"
            },
            {
                "content": "| algo.native.extract                   | 查询指定VertexId/EdgeUid（列表）指定field的值（列表） | algo.native.extract(id::ANY,config::MAP) :: (value::ANY)                                                                                                                                |\n| db.flushDB                            | 刷新db                                  | db.flushDB() :: (::VOID)                                                                                                                                                                |\n| dbms.security.listRoles               | 列出所有角色                                | dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)                                                                                                                         |"
            },
            {
                "content": "| dbms.security.listRoles               | 列出所有角色                                | dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)                                                                                                                         |\n| dbms.security.createRole              | 创建角色                                  | dbms.security.createRole(role_name::STRING,desc::STRING) :: (::VOID)                                                                                                                    |\n| dbms.security.deleteRole              | 删除角色                                  | dbms.security.deleteRole(role_name::STRING) :: (::VOID)                                                                                                                                 |"
            },
            {
                "content": "| dbms.security.deleteRole              | 删除角色                                  | dbms.security.deleteRole(role_name::STRING) :: (::VOID)                                                                                                                                 |\n| dbms.security.getRoleInfo             | 获取角色详细信息                              | dbms.security.getRoleInfo(role::STRING) :: (role_info::MAP)                                                                                                                             |\n| dbms.security.disableRole             | 禁用/启用角色                               | dbms.security.disableRole(role::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |"
            },
            {
                "content": "| dbms.security.disableRole             | 禁用/启用角色                               | dbms.security.disableRole(role::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n| dbms.security.modRoleDesc             | 修改角色描述信息                              | dbms.security.modRoleDesc(role::STRING,description::STRING) :: (::VOID)                                                                                                                 |\n| dbms.security.rebuildRoleAccessLevel  | 删除角色权限并重建                             | dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)                                                                                                        |"
            },
            {
                "content": "| dbms.security.rebuildRoleAccessLevel  | 删除角色权限并重建                             | dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)                                                                                                        |\n| dbms.security.modRoleAccessLevel      | 修改角色对指定图的访问权限                         | dbms.security.modRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)                                                                                                            |\n| dbms.security.modRoleFieldAccessLevel | 修改角色对指定属性的访问权限                        | dbms.security.modRoleFieldAccessLevel(role::STRING,graph::STRING,label::STRING,field::STRING,label_type::STRING,field_access_level::STRING) :: (::VOID)                                 |"
            },
            {
                "content": "| dbms.security.modRoleFieldAccessLevel | 修改角色对指定属性的访问权限                        | dbms.security.modRoleFieldAccessLevel(role::STRING,graph::STRING,label::STRING,field::STRING,label_type::STRING,field_access_level::STRING) :: (::VOID)                                 |\n| dbms.security.getUserInfo             | 获取用户详细信息                              | dbms.security.getUserInfo(user::STRING) :: (user_info::MAP)                                                                                                                             |\n| dbms.security.disableUser             | 禁用/启用用户                               | dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |"
            },
            {
                "content": "| dbms.security.disableUser             | 禁用/启用用户                               | dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n| dbms.security.setCurrentDesc          | 设置当前用户描述信息                            | dbms.security.setCurrentDesc(description::STRING) :: (::VOID)                                                                                                                           |\n| dbms.security.setUserDesc             | 设置用户描述信息                              | dbms.security.setUserDesc(user::STRING,description::STRING) :: (::VOID)                                                                                                                 |"
            },
            {
                "content": "| dbms.security.setUserDesc             | 设置用户描述信息                              | dbms.security.setUserDesc(user::STRING,description::STRING) :: (::VOID)                                                                                                                 |\n| dbms.security.getUserMemoryUsage      | 获取用户内存用量                              | dbms.security.getUserMemoryUsage(user::STRING) :: (memory_usage::INTEGER)                                                                                                               |\n| dbms.security.setUserMemoryLimit      | 设置用户内存限制                              | dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)                                                                                                         |"
            },
            {
                "content": "| dbms.security.setUserMemoryLimit      | 设置用户内存限制                              | dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)                                                                                                         |\n| dbms.security.deleteUserRoles         | 删除用户与角色的联系                            | dbms.security.deleteUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                     |\n| dbms.security.rebuildUserRoles        | 清空用户角色的关系并重建                          | dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                    |"
            },
            {
                "content": "| dbms.security.rebuildUserRoles        | 清空用户角色的关系并重建                          | dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                    |\n| dbms.security.addUserRoles            | 新增用户与角色的联系                            | dbms.security.addUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                        |\n| db.plugin.loadPlugin                  | 装载plugin                              | db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID) |"
            },
            {
                "content": "| db.plugin.loadPlugin                  | 装载plugin                              | db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID) |\n| db.plugin.deletePlugin                | 删除plugin                              | db.plugin.deletePlugin(plugin_type::STRING,plugin_name::STRING) :: (::VOID)                                                                                                             |\n| db.plugin.listPlugin                  | 列出已装载的plugin                          | db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)                                                                                          |"
            },
            {
                "content": "| db.plugin.listPlugin                  | 列出已装载的plugin                          | db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)                                                                                          |\n| db.plugin.getPluginInfo               | 获取plugin的详细信息                         | db.plugin.getPluginInfo(plugin_type::STRING,plugin_name::STRING,show_code::BOOLEAN)::(plugin_description::MAP)                                                                          |\n| db.plugin.callPlugin                  | 执行plugin                              | db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)                                    |"
            },
            {
                "content": "| db.plugin.callPlugin                  | 执行plugin                              | db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)                                    |\n| db.importor.dataImportor              | 导入点或边数据                               | db.importor.dataImportor(description::STRING,content::STRING,continue_on_error::BOOLEAN,thread_nums::INTEGER,delimiter::STRING) :: (::VOID)                                             |\n| db.importor.schemaImportor            | 导入点或边schema                           | db.importor.schemaImportor(description::STRING) :: (::VOID)                                                                                                                             |"
            },
            {
                "content": "| db.importor.schemaImportor            | 导入点或边schema                           | db.importor.schemaImportor(description::STRING) :: (::VOID)                                                                                                                             |\n| db.addFullTextIndex                   | 添加全文索引                                | db.addFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)                                                                                             |\n| db.deleteFullTextIndex                | 删除全文索引                                | db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)                                                                                          |"
            },
            {
                "content": "| db.deleteFullTextIndex                | 删除全文索引                                | db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)                                                                                          |\n| db.rebuildFullTextIndex               | 重建全文索引                                | db.rebuildFullTextIndex(vertex_labels::STRING, edge_labels::STRING) :: (::VOID)                                                                                                         |\n| db.fullTextIndexes                    | 查看全文索引                                | db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)                                                                                                              |"
            },
            {
                "content": "| db.fullTextIndexes                    | 查看全文索引                                | db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)                                                                                                              |\n| dbms.meta.count                       | 查看点边总数                                | db.dbms.meta.count() :: (type::STRING, number::INTEGER)                                                                                                                                 |\n| dbms.meta.countDetail                 | 查看点边总数详情                              | db.dbms.meta.countDetail() :: (is_vertex::BOOLEAN, label::STRING, count::INTEGER)                                                                                                       |"
            },
            {
                "content": "| dbms.meta.countDetail                 | 查看点边总数详情                              | db.dbms.meta.countDetail() :: (is_vertex::BOOLEAN, label::STRING, count::INTEGER)                                                                                                       |\n| dbms.meta.refreshCount                | 重新统计点边数量，统计期间停写。                      | db.dbms.meta.refreshCount() :: (::VOID)                                                                                                                                                 |\n| dbms.task.listTasks                   | 查询正在执行的任务                             | dbms.task.listTasks()::(tasks::LIST)                                                                                                                                                    |"
            },
            {
                "content": "| dbms.task.listTasks                   | 查询正在执行的任务                             | dbms.task.listTasks()::(tasks::LIST)                                                                                                                                                    |\n| dbms.task.terminateTask               | 中止任务                                  | dbms.task.terminateTask(task_id::STRING)::(::VOID)                                                                                                                                      |\n| dbms.ha.clusterInfo                   | HA模式下查看集群状态                           | dbms.ha.clusterInfo() :: (cluster_info::LIST, is_master::BOOLEAN)                                                                                                                       |"
            },
            {
                "content": "| dbms.ha.clusterInfo                   | HA模式下查看集群状态                           | dbms.ha.clusterInfo() :: (cluster_info::LIST, is_master::BOOLEAN)                                                                                                                       |\n| db.dropDB                             | 清空数据库                                 | db.dropDB() :: (::VOID)                                                                                                                                                                 |"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/8.query/2.gql.md",
        "chunks": [
            {
                "content": "# ISO GQL\n\n\n## 1.GQL简介\nGraph Query Language(GQL, 图查询语言)是一种国际标准语言，用于属性图查询，该语言建立在SQL的基础上，并整合了现有的[openCypher、PGQL、GSQL和G-CORE](https://gql.today/comparing-cypher-pgql-and-g-core/)语言的成熟思想。目前该标准仍然处于草稿阶段。\n\nTuGraph基于[ISO GQL (ISO/IEC 39075) Antlr4 语法文件](https://github.com/TuGraph-family/gql-grammar)实现了GQL，并做了一些扩展与改造。目前并未完全支持所有的GQL语法，我们会在未来逐步完善。\n\n## 2.Clauses\n\n| 类别                | 子句           |\n| ------------------- | -------------- |\n| Reading clauses     | MATCH          |\n|                     | OPTIONAL MATCH |\n| Projecting clauses  | RETURN         |\n|                     | NEXT           |\n| Reading sub-clauses | WHERE          |\n|                     | ORDER BY       |\n|                     | SKIP           |\n|                     | LIMIT          |\n\n### 2.1.MATCH\n\n`MATCH`子句式是GQL最基础的子句，几乎所有查询都是通过 `MATCH`展开。\n\n`MATCH`子句用于指定在图中搜索的匹配模式，用来匹配满足一定条件的点或者路径。\n\n#### 点查询\n\n##### 查询所有点\n\n```\nMATCH (n)\nRETURN n\n```\n\n##### 查询特定标签的点\n\n```\nMATCH (n:Person)\nRETURN n\n```\n\n##### 通过属性匹配点"
            },
            {
                "content": "### 2.1.MATCH\n\n`MATCH`子句式是GQL最基础的子句，几乎所有查询都是通过 `MATCH`展开。\n\n`MATCH`子句用于指定在图中搜索的匹配模式，用来匹配满足一定条件的点或者路径。\n\n#### 点查询\n\n##### 查询所有点\n\n```\nMATCH (n)\nRETURN n\n```\n\n##### 查询特定标签的点\n\n```\nMATCH (n:Person)\nRETURN n\n```\n\n##### 通过属性匹配点\n\n```\nMATCH (n:Person{name:'Michael Redgrave'})\nRETURN n.birthyear\n```\n\n返回结果\n```JSON\n[{\"n.birthyear\":1908}]\n```\n\n##### 通过过滤条件匹配点\n\n\n```\nMATCH (n:Person WHERE n.birthyear > 1910)\nRETURN n.name LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```\n\n#### 边查询\n\n##### 出边匹配\n\n```\nMATCH (n:Person WHERE n.birthyear = 1970)-[e]->(m)\nRETURN n.name, label(e), m.name\n```\n\n返回结果\n```JSON\n[{\"label(e)\":\"BORN_IN\",\"m.name\":\"London\",\"n.name\":\"Christopher Nolan\"},{\"label(e)\":\"DIRECTED\",\"m.name\":null,\"n.name\":\"Christopher Nolan\"}]\n```\n\n##### 入边匹配\n\n```\nMATCH (n:Person WHERE n.birthyear = 1939)<-[e]-(m)\nRETURN n.name, label(e), m.name\n```"
            },
            {
                "content": "返回结果\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```\n\n#### 边查询\n\n##### 出边匹配\n\n```\nMATCH (n:Person WHERE n.birthyear = 1970)-[e]->(m)\nRETURN n.name, label(e), m.name\n```\n\n返回结果\n```JSON\n[{\"label(e)\":\"BORN_IN\",\"m.name\":\"London\",\"n.name\":\"Christopher Nolan\"},{\"label(e)\":\"DIRECTED\",\"m.name\":null,\"n.name\":\"Christopher Nolan\"}]\n```\n\n##### 入边匹配\n\n```\nMATCH (n:Person WHERE n.birthyear = 1939)<-[e]-(m)\nRETURN n.name, label(e), m.name\n```\n\n返回结果\n```JSON\n[{\"label(e)\":\"HAS_CHILD\",\"m.name\":\"Rachel Kempson\",\"n.name\":\"Corin Redgrave\"},{\"label(e)\":\"HAS_CHILD\",\"m.name\":\"Michael Redgrave\",\"n.name\":\"Corin Redgrave\"}]\n```\n\n##### 带过滤条件的边匹配\n\n```\nMATCH (n:Person)-[e:BORN_IN WHERE e.weight > 20]->(m)\nRETURN n.name, e.weight, m.name\n```\n\n返回结果\n```JSON\n[{\"e.weight\":20.549999237060547,\"m.name\":\"New York\",\"n.name\":\"John Williams\"},{\"e.weight\":20.6200008392334,\"m.name\":\"New York\",\"n.name\":\"Lindsay Lohan\"}]\n```\n\n#### 路径匹配\n\n##### 不定跳查询\n\n```\nMATCH (n:Person)-[e]->{2,3}(m:Person)\nRETURN m.name LIMIT 2\n```"
            },
            {
                "content": "##### 带过滤条件的边匹配\n\n```\nMATCH (n:Person)-[e:BORN_IN WHERE e.weight > 20]->(m)\nRETURN n.name, e.weight, m.name\n```\n\n返回结果\n```JSON\n[{\"e.weight\":20.549999237060547,\"m.name\":\"New York\",\"n.name\":\"John Williams\"},{\"e.weight\":20.6200008392334,\"m.name\":\"New York\",\"n.name\":\"Lindsay Lohan\"}]\n```\n\n#### 路径匹配\n\n##### 不定跳查询\n\n```\nMATCH (n:Person)-[e]->{2,3}(m:Person)\nRETURN m.name LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"m.name\":\"Liam Neeson\"},{\"m.name\":\"Natasha Richardson\"}]\n```\n\n### 2.2.OPTIONAL MATCH\n\n`OPTIONAL MATCH`匹配图模式，如果未命中，则返回`null`。\n\n#### 查询命中\n\n```\nOPTIONAL MATCH (n:Person{name:'Michael Redgrave'})\nRETURN n.birthyear\n```\n\n返回结果\n```JSON\n[{\"n.birthyear\":1908}]\n```\n\n#### 查询未命中\n\n```\nOPTIONAL MATCH (n:Person{name:'Redgrave Michael'})\nRETURN n.birthyear\n```\n\n返回结果\n\n```JSON\n[{\"n.birthyear\":null}]\n```\n\n### 2.3.RETURN\n\n`RETURN`子句指定返回结果，包括返回点、边、路径、属性等。\n\n#### 返回点\n\n```\nMATCH (n)\nRETURN n LIMIT 2\n```"
            },
            {
                "content": "返回结果\n```JSON\n[{\"m.name\":\"Liam Neeson\"},{\"m.name\":\"Natasha Richardson\"}]\n```\n\n### 2.2.OPTIONAL MATCH\n\n`OPTIONAL MATCH`匹配图模式，如果未命中，则返回`null`。\n\n#### 查询命中\n\n```\nOPTIONAL MATCH (n:Person{name:'Michael Redgrave'})\nRETURN n.birthyear\n```\n\n返回结果\n```JSON\n[{\"n.birthyear\":1908}]\n```\n\n#### 查询未命中\n\n```\nOPTIONAL MATCH (n:Person{name:'Redgrave Michael'})\nRETURN n.birthyear\n```\n\n返回结果\n\n```JSON\n[{\"n.birthyear\":null}]\n```\n\n### 2.3.RETURN\n\n`RETURN`子句指定返回结果，包括返回点、边、路径、属性等。\n\n#### 返回点\n\n```\nMATCH (n)\nRETURN n LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"n\":{\"identity\":0,\"label\":\"Person\",\"properties\":{\"birthyear\":1910,\"name\":\"Rachel Kempson\"}}},{\"n\":{\"identity\":1,\"label\":\"Person\",\"properties\":{\"birthyear\":1908,\"name\":\"Michael Redgrave\"}}}]\n```\n\n#### 返回边\n\n```\nMATCH (n)-[e]->(m)\nRETURN e LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"e\":{\"dst\":2,\"forward\":false,\"identity\":0,\"label\":\"HAS_CHILD\",\"label_id\":0,\"src\":0,\"temporal_id\":0}},{\"e\":{\"dst\":3,\"forward\":false,\"identity\":0,\"label\":\"HAS_CHILD\",\"label_id\":0,\"src\":0,\"temporal_id\":0}}]\n```\n\n#### 返回属性"
            },
            {
                "content": "返回结果\n```JSON\n[{\"n\":{\"identity\":0,\"label\":\"Person\",\"properties\":{\"birthyear\":1910,\"name\":\"Rachel Kempson\"}}},{\"n\":{\"identity\":1,\"label\":\"Person\",\"properties\":{\"birthyear\":1908,\"name\":\"Michael Redgrave\"}}}]\n```\n\n#### 返回边\n\n```\nMATCH (n)-[e]->(m)\nRETURN e LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"e\":{\"dst\":2,\"forward\":false,\"identity\":0,\"label\":\"HAS_CHILD\",\"label_id\":0,\"src\":0,\"temporal_id\":0}},{\"e\":{\"dst\":3,\"forward\":false,\"identity\":0,\"label\":\"HAS_CHILD\",\"label_id\":0,\"src\":0,\"temporal_id\":0}}]\n```\n\n#### 返回属性\n\n```\nMATCH (n:Person)\nRETURN n.name LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```\n\n#### 不常见字符串作为变量名\n\n```\nMATCH (`/uncommon variable`:Person)\nRETURN `/uncommon variable`.name LIMIT 3\n```\n\n返回结果\n\n```JSON\n[{\"`/uncommon variable`.name\":\"Christopher Nolan\"},{\"`/uncommon variable`.name\":\"Corin Redgrave\"},{\"`/uncommon variable`.name\":\"Dennis Quaid\"}]\n```\n\n#### 列别名\n\n```\nMATCH (n:Person)\nRETURN n.name AS nname LIMIT 2\n```\n\n返回结果"
            },
            {
                "content": "#### 返回属性\n\n```\nMATCH (n:Person)\nRETURN n.name LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```\n\n#### 不常见字符串作为变量名\n\n```\nMATCH (`/uncommon variable`:Person)\nRETURN `/uncommon variable`.name LIMIT 3\n```\n\n返回结果\n\n```JSON\n[{\"`/uncommon variable`.name\":\"Christopher Nolan\"},{\"`/uncommon variable`.name\":\"Corin Redgrave\"},{\"`/uncommon variable`.name\":\"Dennis Quaid\"}]\n```\n\n#### 列别名\n\n```\nMATCH (n:Person)\nRETURN n.name AS nname LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"nname\":\"Christopher Nolan\"},{\"nname\":\"Corin Redgrave\"}]\n```\n\n#### 可选属性\n\n```\nMATCH (n:Person)\nRETURN n.age LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n.age\":null},{\"n.age\":null}]\n```\n\n#### 其它表达式\n\n```\nMATCH (n:Person)\nRETURN n.birthyear > 1970, \"I'm a literal\", 1 + 2, abs(-2)\nLIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"\\\"I'm a literal\\\"\":\"I'm a literal\",\"1 + 2\":3,\"abs(-2)\":2,\"n.birthyear > 1970\":false},{\"\\\"I'm a literal\\\"\":\"I'm a literal\",\"1 + 2\":3,\"abs(-2)\":2,\"n.birthyear > 1970\":false}]\n```\n\n#### 结果唯一性"
            },
            {
                "content": "返回结果\n\n```JSON\n[{\"nname\":\"Christopher Nolan\"},{\"nname\":\"Corin Redgrave\"}]\n```\n\n#### 可选属性\n\n```\nMATCH (n:Person)\nRETURN n.age LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n.age\":null},{\"n.age\":null}]\n```\n\n#### 其它表达式\n\n```\nMATCH (n:Person)\nRETURN n.birthyear > 1970, \"I'm a literal\", 1 + 2, abs(-2)\nLIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"\\\"I'm a literal\\\"\":\"I'm a literal\",\"1 + 2\":3,\"abs(-2)\":2,\"n.birthyear > 1970\":false},{\"\\\"I'm a literal\\\"\":\"I'm a literal\",\"1 + 2\":3,\"abs(-2)\":2,\"n.birthyear > 1970\":false}]\n```\n\n#### 结果唯一性\n\n\n```\nMATCH (n)\nRETURN DISTINCT label(n) AS label\n```\n\n返回结果\n\n```JSON\n[{\"label\":\"Person\"},{\"label\":\"City\"},{\"label\":\"Film\"}]\n```\n\n### 2.4.NEXT\n\n`NEXT`子句用于连接多个子句。\n\n#### 连接MATCH\n\n```\nMATCH (n:Person) WHERE n.birthyear = 1970\nRETURN n\nNEXT\nMATCH (m:Person) WHERE m.birthyear < 1968\nRETURN n.name, n.birthyear, m.name LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"m.name\":\"Rachel Kempson\",\"n.birthyear\":1970,\"n.name\":\"Christopher Nolan\"},{\"m.name\":\"Michael Redgrave\",\"n.birthyear\":1970,\"n.name\":\"Christopher Nolan\"}]\n```\n\n### 2.5.WHERE"
            },
            {
                "content": "返回结果\n\n```JSON\n[{\"label\":\"Person\"},{\"label\":\"City\"},{\"label\":\"Film\"}]\n```\n\n### 2.4.NEXT\n\n`NEXT`子句用于连接多个子句。\n\n#### 连接MATCH\n\n```\nMATCH (n:Person) WHERE n.birthyear = 1970\nRETURN n\nNEXT\nMATCH (m:Person) WHERE m.birthyear < 1968\nRETURN n.name, n.birthyear, m.name LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"m.name\":\"Rachel Kempson\",\"n.birthyear\":1970,\"n.name\":\"Christopher Nolan\"},{\"m.name\":\"Michael Redgrave\",\"n.birthyear\":1970,\"n.name\":\"Christopher Nolan\"}]\n```\n\n### 2.5.WHERE\n\n`WHERE`子句用于过滤记录。\n\n#### 过滤点\n\n```\nMATCH (n:Person WHERE n.birthyear > 1965)\nRETURN n.name\n```\n\n返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Lindsay Lohan\"}]\n```\n\n#### 过滤边\n\n```\nMATCH (n:Person WHERE n.birthyear > 1965)-[e:ACTED_IN]->(m:Film)\nWHERE e.charactername = 'Halle/Annie'\nRETURN m.title\n```\n\n返回结果\n\n```JSON\n[{\"m.title\":\"The Parent Trap\"}]\n```\n\n#### 布尔表达式\n\n`AND`, `OR`, `XOR`和 `NOT`布尔表达式可以用在 `WHERE`中用来过滤数据。\n\n```\nMATCH (n:Person)\nWHERE\n\tn.birthyear > 1930 AND (n.birthyear < 1950 OR n.name = 'Corin Redgrave')\nRETURN n LIMIT 2\n```\n\n返回结果"
            },
            {
                "content": "返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Lindsay Lohan\"}]\n```\n\n#### 过滤边\n\n```\nMATCH (n:Person WHERE n.birthyear > 1965)-[e:ACTED_IN]->(m:Film)\nWHERE e.charactername = 'Halle/Annie'\nRETURN m.title\n```\n\n返回结果\n\n```JSON\n[{\"m.title\":\"The Parent Trap\"}]\n```\n\n#### 布尔表达式\n\n`AND`, `OR`, `XOR`和 `NOT`布尔表达式可以用在 `WHERE`中用来过滤数据。\n\n```\nMATCH (n:Person)\nWHERE\n\tn.birthyear > 1930 AND (n.birthyear < 1950 OR n.name = 'Corin Redgrave')\nRETURN n LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n\":{\"identity\":3,\"label\":\"Person\",\"properties\":{\"birthyear\":1939,\"name\":\"Corin Redgrave\"}}},{\"n\":{\"identity\":11,\"label\":\"Person\",\"properties\":{\"birthyear\":1932,\"name\":\"John Williams\"}}}]\n```\n\n\n### 2.6.ORDER BY\n\n`ORDER BY`是`RETURN`的子句，对输出的结果进行排序。\n\n#### 对结果排序\n\n```\nMATCH (n:Person WHERE n.birthyear < 1970)\nRETURN n.birthyear AS q\nORDER BY q ASC\nLIMIT 5\n```\n\n返回结果\n```JSON\n[{\"q\":1873},{\"q\":1908},{\"q\":1910},{\"q\":1930},{\"q\":1932}]\n```\n\n### 2.7.SKIP\n\n`SKIP`指定结果偏移行数。\n\n#### 未使用SKIP\n\n```\nMATCH (n:Person)\nRETURN n.name LIMIT 3\n```\n\n返回结果"
            },
            {
                "content": "### 2.6.ORDER BY\n\n`ORDER BY`是`RETURN`的子句，对输出的结果进行排序。\n\n#### 对结果排序\n\n```\nMATCH (n:Person WHERE n.birthyear < 1970)\nRETURN n.birthyear AS q\nORDER BY q ASC\nLIMIT 5\n```\n\n返回结果\n```JSON\n[{\"q\":1873},{\"q\":1908},{\"q\":1910},{\"q\":1930},{\"q\":1932}]\n```\n\n### 2.7.SKIP\n\n`SKIP`指定结果偏移行数。\n\n#### 未使用SKIP\n\n```\nMATCH (n:Person)\nRETURN n.name LIMIT 3\n```\n\n返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"},{\"n.name\":\"Dennis Quaid\"}]\n```\n\n#### 使用SKIP\n\n```\nMATCH (n:Person)\nRETURN n.name SKIP 1 LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"n.name\":\"Corin Redgrave\"},{\"n.name\":\"Dennis Quaid\"}]\n```\n\n### 2.8.LIMIT\n\n`LIMIT`限制结果行数。\n\n#### 使用LIMIT\n\n```\nMATCH (n:Person)\nRETURN n.name LIMIT 2;\n```\n\n返回结果\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/8.query/3.vector_index.md",
        "chunks": [
            {
                "content": "# Vector index\n## 创建向量索引\n如下json定义了一个点类型，名字是`person`, 里面有个字段是`embedding`，类型是`FLOAT_VECTOR`，用来存储向量数据。\n目前向量数据只能在点上创建。\n\n```json\n{\n\t\"label\": \"person\",\n\t\"primary\": \"id\",\n\t\"type\": \"VERTEX\",\n\t\"properties\": [{\n\t\t\"name\": \"id\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false\n\t}, {\n\t\t\"name\": \"age\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false\n\t}, {\n\t\t\"name\": \"embedding\",\n\t\t\"type\": \"FLOAT_VECTOR\",\n\t\t\"optional\": false\n\t}]\n}\n\n```\n把上面这个json序列化成字符串，作为参数传入，建议使用驱动的参数化特性，避免自己拼接语句。\n```\nCALL db.createVertexLabelByJson($json_data)\n```\n给`embedding`字段添加向量索引，第三个参数是个map，里面可以设置一些向量索引的配置参数，如下，`dimension`设置向量维度是4\n```\nCALL db.addVertexVectorIndex('person','embedding', {dimension: 4});\n```\n\n再定义一个边，用来测试，如下json定义了一个边类型，名字是`like`。\n```json\n{\n  \"label\": \"like\",\n  \"type\": \"EDGE\",\n  \"constraints\": [\n    [\"person\", \"person\"]\n  ],\n  \"properties\": []\n}\n```\n把上面这个json序列化成字符串，作为参数传入。\n```\nCALL db.createEdgeLabelByJson($json_data)\n```"
            },
            {
                "content": "写入几条测试数据\n```\nCREATE (n1:person {id:1, age:10, embedding: [1.0,1.0,1.0,1.0]})\nCREATE (n2:person {id:2, age:20, embedding: [2.0,2.0,2.0,2.0]})\nCREATE (n3:person {id:3, age:30, embedding: [3.0,3.0,3.0,3.0]})\nCREATE (n1)-[r:like]->(n2),\n       (n2)-[r:like]->(n3),\n       (n3)-[r:like]->(n1);\n```\n## 向量查询\n### KnnSearch\n根据向量搜索出点，第四个参数是个map，里面可以指定一些向量搜索的参数。\n```\nCALL db.vertexVectorKnnSearch('person','embedding', [1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node return node\n```\n根据向量搜索出点，返回`age`小于30的\n```\nCALL db.vertexVectorKnnSearch('person','embedding',[1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node where node.age < 30 return node\n```\n根据向量搜索出点，返回age小于30的点，然后再查这些点的一度邻居是谁。\n```\nCALL db.vertexVectorKnnSearch('person','embedding',[1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node where node.age < 30 with node as p\nmatch(p)-[r]->(m) return m\n```\n### RangeSearch\n根据向量搜索出距离小于10的、age小于30的点，然后再查这些点的一度邻居是谁。\n```"
            },
            {
                "content": "yield node return node\n```\n根据向量搜索出点，返回`age`小于30的\n```\nCALL db.vertexVectorKnnSearch('person','embedding',[1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node where node.age < 30 return node\n```\n根据向量搜索出点，返回age小于30的点，然后再查这些点的一度邻居是谁。\n```\nCALL db.vertexVectorKnnSearch('person','embedding',[1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node where node.age < 30 with node as p\nmatch(p)-[r]->(m) return m\n```\n### RangeSearch\n根据向量搜索出距离小于10的、age小于30的点，然后再查这些点的一度邻居是谁。\n```\nCALL db.vertexVectorRangeSearch('person','embedding',[1.0,2.0,3.0,4.0], {radius:10.0, hnsw_ef_search:10})\nyield node where node.age < 30 with node as p\nmatch(p)-[r]->(m) return m\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/1.procedure/1.procedure.md",
        "chunks": [
            {
                "content": "# Procedure API\n\n> 此文档主要讲解 TuGraph 的存储过程使用说明\n\n## 1.简介\n\n当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个请求并在客户端完成整个处理流程的方式，TuGraph 提供的存储过程是更简洁和高效的选择。\n\n与传统数据库类似，TuGraph 的存储过程运行在服务器端，用户通过将处理逻辑（即多个操作）封装到一个过程单次调用，并且可以在实现时通过并行处理的方式（例如使用相关的 C++ OLAP 接口以及基于其实现的内置算法）进一步提升性能。\n\n存储过程中有一类特殊的API来进行数据的并行操作，我们叫 Traversal API，见[文档](2.traversal.md)。\n\n## 2.存储过程的版本支持\n\n目前TuGraph支持两个版本的存储过程，适用于不同的场景，v3.5版本只支持v1，可通过REST或RPC接口直接调用；从v3.5版本开始支持v2，能够在图查询语言（比如Cypher）中嵌入调用，我们称之为POG（Procedure On Graph query language，APOC）。"
            },
            {
                "content": "## 2.存储过程的版本支持\n\n目前TuGraph支持两个版本的存储过程，适用于不同的场景，v3.5版本只支持v1，可通过REST或RPC接口直接调用；从v3.5版本开始支持v2，能够在图查询语言（比如Cypher）中嵌入调用，我们称之为POG（Procedure On Graph query language，APOC）。\n\n|                        | Procedure v1                       | Procedure v2               |\n| ---------------------- | ---------------------------------- | -------------------------- |\n| 适用场景                 | 极致性能，或者复杂的多事务管理情形       | 一般情况，与Cypher高度联动 |\n| 事务                    | 函数内部创建，可自由控制多事务          | 外部传入函数，单一事务     |\n| 签名（参数定义）          | 无                                 | 有                    |\n| 输入输出参数类型          | 不需要指定                           | 需要指定参数类型        |\n| Cypher Standalone Call | 支持                                | 支持                  |\n| Cypher Embeded Call    | 不支持                              | 支持                  |\n| 语言                    | C++/Python/Rust                    | C++                  |\n| 调用模式                 | 直接传字符串，一般为JSON               | 通过Cypher语句中的变量  |\n\n在TuGraph中，存储过程v1和v2单独管理，支持增删查，但仍不建议重名。"
            },
            {
                "content": "在TuGraph中，存储过程v1和v2单独管理，支持增删查，但仍不建议重名。\n\n## 3.存储过程语言支持\n\n在 TuGraph 中，用户可以动态的加载，更新和删除存储过程。TuGraph 支持 C++ 语言、 Python 语言和 Rust 语言编写存储过程。在性能上 C++ 语言支持的最完整，性能最优。\n\n注意存储过程是在服务端编译执行的逻辑，和客户端的语言支持无关。\n\n## 4.Procedure v1接口\n\n## 4.1.编写存储过程\n\n### 4.1.1.编写C++存储过程\n\n用户可以通过使用 Procedure API 或者 Traversal API 来编写 C 存储过程。一个简单的 C 存储过程举例如下：\n\n```\n#include \n#include \"lgraph.h\"\nusing namespace lgraph_api;\n\nextern \"C\" LGAPI bool Process(GraphDB& db, const std::string& request, std::string& response) {\n\tauto txn = db.CreateReadTxn();\n\tsize_t n = 0;\n\tfor (auto vit = txn.GetVertexIterator(); vit.IsValid(); vit.Next()) {\n        if (vit.GetLabel() == \"student\") {\n            auto age = vit.GetField(\"age\");\n            if (!age.is_null() && age.integer() == 10) n++; ## 统计所有年龄为10的学生数量\n        }\n\t}\n    output = std::to_string(n);\n    return true;\n}\n```\n\n从代码中我们可以看到，存储过程的入口函数是`Process`函数，它的参数有三个，分别为：\n\n- `db`: 数据库实例\n- `request`: 输入请求数据，可以是二进制字节数组，或者 JSON 串等其它任意格式。\n- `response`: 输出数据，可以是字符串，也可以直接返回二进制数据。"
            },
            {
                "content": "从代码中我们可以看到，存储过程的入口函数是`Process`函数，它的参数有三个，分别为：\n\n- `db`: 数据库实例\n- `request`: 输入请求数据，可以是二进制字节数组，或者 JSON 串等其它任意格式。\n- `response`: 输出数据，可以是字符串，也可以直接返回二进制数据。\n\n`Process`函数的返回值是一个布尔值。当它返回`true`的时候，表示该请求顺利完成，反之表示这个存储过程在执行过程中发现了错误，此时用户可以通过`response`来返回错误信息以方便调试。\n\nC++存储过程编写完毕后需要编译成动态链接库。TuGraph 提供了`compile.sh`脚本来帮助用户自动编译存储过程。`compile.sh`脚本只有一个参数，是该存储过程的名称，在上面的例子中就是`age_10`。编译调用命令行如下：\n\n```bash\ng++ -fno-gnu-unique -fPIC -g --std=c++14 -I/usr/local/include/lgraph -rdynamic -O3 -fopenmp -o age_10.so age_10.cpp /usr/local/lib64/liblgraph.so -shared\n```\n\n如果编译顺利，会生成 age_10.so，然后用户就可以将它加载到服务器中了。\n\n### 4.1.2.编写Python存储过程\n\n与 C++类似，Python 存储过程也可以调用 core API，一个简单的例子如下：\n\n```python\ndef Process(db, input):\n    txn = db.CreateReadTxn()\n    it = txn.GetVertexIterator()\n    n = 0\n    while it.IsValid():\n        if it.GetLabel() == 'student' and it['age'] and it['age'] == 10:\n            n = n + 1\n        it.Next()\n    return (True, str(nv))\n```\n\nPython 存储过程返回的是一个 tuple，其中第一个元素是一个布尔值，表示该存储过程是否成功执行；第二个元素是一个`str`，里面是需要返回的结果。"
            },
            {
                "content": "如果编译顺利，会生成 age_10.so，然后用户就可以将它加载到服务器中了。\n\n### 4.1.2.编写Python存储过程\n\n与 C++类似，Python 存储过程也可以调用 core API，一个简单的例子如下：\n\n```python\ndef Process(db, input):\n    txn = db.CreateReadTxn()\n    it = txn.GetVertexIterator()\n    n = 0\n    while it.IsValid():\n        if it.GetLabel() == 'student' and it['age'] and it['age'] == 10:\n            n = n + 1\n        it.Next()\n    return (True, str(nv))\n```\n\nPython 存储过程返回的是一个 tuple，其中第一个元素是一个布尔值，表示该存储过程是否成功执行；第二个元素是一个`str`，里面是需要返回的结果。\n\nPython 存储过程不需要编译，可以直接加载。\n\n## 4.2.如何使用存储过程\n### 4.2.1.加载存储过程\n\n用户可以通过 REST API 和 RPC 来加载存储过程。以 REST API 为例，加载`age_10.so`的 C++代码如下：\n\n```python\nimport requests\nimport json\nimport base64"
            },
            {
                "content": "Python 存储过程返回的是一个 tuple，其中第一个元素是一个布尔值，表示该存储过程是否成功执行；第二个元素是一个`str`，里面是需要返回的结果。\n\nPython 存储过程不需要编译，可以直接加载。\n\n## 4.2.如何使用存储过程\n### 4.2.1.加载存储过程\n\n用户可以通过 REST API 和 RPC 来加载存储过程。以 REST API 为例，加载`age_10.so`的 C++代码如下：\n\n```python\nimport requests\nimport json\nimport base64\n\ndata = {'name':'age_10'}\nf = open('./age_10.so','rb')\ncontent = f.read()\ndata['code_base64'] = base64.b64encode(content).decode()\ndata['description'] = 'Custom Page Rank Procedure'\ndata['read_only'] = true\ndata['code_type'] = 'so'\njs = json.dumps(data)\nr = requests.post(url='http://127.0.0.1:7071/db/school/cpp_plugin', data=js,\n            headers={'Content-Type':'application/json'})\nprint(r.status_code)    ## 正常时返回200\n```\n\n需要注意的是，这时的`data['code']`是一个经过 base64 处理的字符串，`age_10.so`中的二进制代码是无法通过 JSON 直接传输的。此外，存储过程的加载和删除都只能由具有管理员权限的用户来操作。\n\n存储过程加载之后会被保存在数据库中，在服务器重启后也会被自动加载。此外，如果需要对存储过程进行更新，调用的 REST API 也是同样的。建议用户在更新存储过程时更新相应描述，以便区分不同版本的存储过程。\n\n\n### 4.2.2.列出已加载的存储过程\n\n在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下："
            },
            {
                "content": "需要注意的是，这时的`data['code']`是一个经过 base64 处理的字符串，`age_10.so`中的二进制代码是无法通过 JSON 直接传输的。此外，存储过程的加载和删除都只能由具有管理员权限的用户来操作。\n\n存储过程加载之后会被保存在数据库中，在服务器重启后也会被自动加载。此外，如果需要对存储过程进行更新，调用的 REST API 也是同样的。建议用户在更新存储过程时更新相应描述，以便区分不同版本的存储过程。\n\n\n### 4.2.2.列出已加载的存储过程\n\n在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin')\n>>> r.status_code\n200\n>>> r.text\n'{\"plugins\":[{\"description\":\"Custom Page Rank Procedure\", \"name\":\"age_10\", \"read_only\":true}]}'\n```\n\n### 4.2.3.获取存储过程详情\n\n在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/age_10')\n>>> r.status_code\n200\n>>> r.text\n'{\"description\":\"Custom Page Rank Procedure\", \"name\":\"age_10\", \"read_only\":true, \"code_base64\":, \"code_type\":\"so\"}'\n```\n\n### 4.2.4.调用存储过程\n\n调用存储过程的代码示例如下：\n\n```\n>>> r = requests.post(url='http://127.0.0.1:7071/db/school/cpp_plugin/age_10', data='',\n                headers={'Content-Type':'application/json'})\n>>> r.status_code\n200\n>>> r.text\n9\n```"
            },
            {
                "content": "在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/age_10')\n>>> r.status_code\n200\n>>> r.text\n'{\"description\":\"Custom Page Rank Procedure\", \"name\":\"age_10\", \"read_only\":true, \"code_base64\":, \"code_type\":\"so\"}'\n```\n\n### 4.2.4.调用存储过程\n\n调用存储过程的代码示例如下：\n\n```\n>>> r = requests.post(url='http://127.0.0.1:7071/db/school/cpp_plugin/age_10', data='',\n                headers={'Content-Type':'application/json'})\n>>> r.status_code\n200\n>>> r.text\n9\n```\n\n### 4.2.5.删除存储过程\n\n删除存储过程只需要如下调用：\n\n```python\n>>> r = requests.delete(url='http://127.0.0.1:7071/db/school/cpp_plugin/age_10')\n>>> r.status_code\n200\n```\n\n与加载存储过程类似，只有管理员用户才能删除存储过程。\n\n### 4.2.6.更新存储过程\n\n更新存储过程需要执行如下两个步骤：\n\n1.  删除已存在的存储过程\n2.  安装新的存储过程\n\nTuGraph 较为谨慎地管理存储过程操作的并发性，更新存储过程不会影响现有存储过程的运行。\n\n\n## 5.Procedure v2接口\n\n下面的说明以 REST API 为例，介绍存储过程v2的调用。\n\n### 5.1.编写存储过程\n\n\n用户可以通过使用 lgraph API 来编写 C++ 存储过程。一个简单的 C++ 存储过程举例如下："
            },
            {
                "content": "### 4.2.5.删除存储过程\n\n删除存储过程只需要如下调用：\n\n```python\n>>> r = requests.delete(url='http://127.0.0.1:7071/db/school/cpp_plugin/age_10')\n>>> r.status_code\n200\n```\n\n与加载存储过程类似，只有管理员用户才能删除存储过程。\n\n### 4.2.6.更新存储过程\n\n更新存储过程需要执行如下两个步骤：\n\n1.  删除已存在的存储过程\n2.  安装新的存储过程\n\nTuGraph 较为谨慎地管理存储过程操作的并发性，更新存储过程不会影响现有存储过程的运行。\n\n\n## 5.Procedure v2接口\n\n下面的说明以 REST API 为例，介绍存储过程v2的调用。\n\n### 5.1.编写存储过程\n\n\n用户可以通过使用 lgraph API 来编写 C++ 存储过程。一个简单的 C++ 存储过程举例如下：\n\n```c++\n// peek_some_node_salt.cpp\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/lgraph_types.h\"\n#include \"lgraph/lgraph_result.h\"\n\n#include \"tools/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace lgraph_api;\n\nextern \"C\" LGAPI bool GetSignature(SigSpec &sig_spec) {\n    sig_spec.input_list = {\n        {.name = \"limit\", .index = 0, .type = LGraphType::INTEGER},\n    };\n    sig_spec.result_list = {\n        {.name = \"node\", .index = 0, .type = LGraphType::NODE},\n        {.name = \"salt\", .index = 1, .type = LGraphType::FLOAT}\n    };\n    return true;\n}"
            },
            {
                "content": "#include \"tools/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace lgraph_api;\n\nextern \"C\" LGAPI bool GetSignature(SigSpec &sig_spec) {\n    sig_spec.input_list = {\n        {.name = \"limit\", .index = 0, .type = LGraphType::INTEGER},\n    };\n    sig_spec.result_list = {\n        {.name = \"node\", .index = 0, .type = LGraphType::NODE},\n        {.name = \"salt\", .index = 1, .type = LGraphType::FLOAT}\n    };\n    return true;\n}\n\nextern \"C\" LGAPI bool ProcessInTxn(Transaction &txn,\n                                   const std::string &request,\n                                   Result &response) {\n    int64_t limit;\n    try {\n        json input = json::parse(request);\n        limit = input[\"limit\"].get();\n    } catch (std::exception &e) {\n        response.ResetHeader({\n            {\"errMsg\", LGraphType::STRING}\n        });\n        response.MutableRecord()->Insert(\n            \"errMsg\",\n            FieldData::String(std::string(\"error parsing json: \") + e.what()));\n        return false;\n    }"
            },
            {
                "content": "response.ResetHeader({\n        {\"node\", LGraphType::NODE},\n        {\"salt\", LGraphType::FLOAT}\n    });\n    for (size_t i = 0; i < limit; i++) {\n        auto r = response.MutableRecord();\n        auto vit = txn.GetVertexIterator(i);\n        r->Insert(\"node\", vit);\n        r->Insert(\"salt\", FieldData::Float(20.23*float(i)));\n    }\n    return true;\n}\n```\n\n从代码中我们可以看到：\n- 存储过程定义了一个获取签名的方法`GetSignature`。该方法返回了存储过程的签名，其中包含输入参数名称及其类型，返回参数及其类型。这使得Cypher查询语句在调用存储过程能够利用签名信息校验输入数据以及返回数据是否合理。\n- 入口函数是`ProcessInTxn`函数，它的参数有三个，分别为：\n\n- `txn`: 存储过程所处的事务，通常来说即调用该存储过程的Cypher语句所处事务。\n- `request`: 输入数据，其内容为`GetSignature`中定义的输入参数类型及其Cypher查询语句中传入的值经过json序列化后的字符串。e.g. `{num_iteration: 10}`\n- `response`: 输出数据，为保证在Cypher语言中能够兼容，用户可以通过往`lgraph_api::Result` 写入存储过程处理后的数据，最后用`lgraph_api::Result::Dump`来序列化成json格式的数据。\n\n`ProcessInTxn`函数的返回值是一个布尔值。当它返回`true`的时候，表示该请求顺利完成，反之表示这个存储过程在执行过程中发现了错误。\n\nC++存储过程编写完毕后需要编译成动态链接库。TuGraph 提供了`compile.sh`脚本来帮助用户自动编译存储过程。`compile.sh`脚本只有一个参数，是该存储过程的名称，在上面的例子中就是`custom_pagerank`。编译调用命令行如下："
            },
            {
                "content": "- `txn`: 存储过程所处的事务，通常来说即调用该存储过程的Cypher语句所处事务。\n- `request`: 输入数据，其内容为`GetSignature`中定义的输入参数类型及其Cypher查询语句中传入的值经过json序列化后的字符串。e.g. `{num_iteration: 10}`\n- `response`: 输出数据，为保证在Cypher语言中能够兼容，用户可以通过往`lgraph_api::Result` 写入存储过程处理后的数据，最后用`lgraph_api::Result::Dump`来序列化成json格式的数据。\n\n`ProcessInTxn`函数的返回值是一个布尔值。当它返回`true`的时候，表示该请求顺利完成，反之表示这个存储过程在执行过程中发现了错误。\n\nC++存储过程编写完毕后需要编译成动态链接库。TuGraph 提供了`compile.sh`脚本来帮助用户自动编译存储过程。`compile.sh`脚本只有一个参数，是该存储过程的名称，在上面的例子中就是`custom_pagerank`。编译调用命令行如下：\n\n```bash\ng++ -fno-gnu-unique -fPIC -g --std=c++14 -I/usr/local/include/lgraph -rdynamic -O3 -fopenmp -o custom_pagerank.so custom_pagerank.cpp /usr/local/lib64/liblgraph.so -shared\n```\n\n如果编译顺利，会生成 custom_pagerank.so，然后用户就可以将它加载到服务器中了。\n\n\n### 5.2.加载存储过程\n\n用户可以通过 REST API 和 RPC 来加载存储过程。以 REST API 为例，加载`custom_pagerank.so`的 C++代码如下：\n\n```python\nimport requests\nimport json\nimport base64"
            },
            {
                "content": "```bash\ng++ -fno-gnu-unique -fPIC -g --std=c++14 -I/usr/local/include/lgraph -rdynamic -O3 -fopenmp -o custom_pagerank.so custom_pagerank.cpp /usr/local/lib64/liblgraph.so -shared\n```\n\n如果编译顺利，会生成 custom_pagerank.so，然后用户就可以将它加载到服务器中了。\n\n\n### 5.2.加载存储过程\n\n用户可以通过 REST API 和 RPC 来加载存储过程。以 REST API 为例，加载`custom_pagerank.so`的 C++代码如下：\n\n```python\nimport requests\nimport json\nimport base64\n\ndata = {'name':'custom_pagerank'}\nf = open('./custom_pagerank.so','rb')\ncontent = f.read()\ndata['code_base64'] = base64.b64encode(content).decode()\ndata['description'] = 'Custom Page Rank Procedure'\ndata['read_only'] = true\ndata['code_type'] = 'so'\njs = json.dumps(data)\nr = requests.post(url='http://127.0.0.1:7071/db/school/cpp_plugin', data=js,\n            headers={'Content-Type':'application/json'})\nprint(r.status_code)    ## 正常时返回200\n```\n\n需要注意的是，这时的`data['code']`是一个经过 base64 处理的字符串，`custom_pagerank.so`中的二进制代码是无法通过 JSON 直接传输的。此外，存储过程的加载和删除都只能由具有管理员权限的用户来操作。"
            },
            {
                "content": "需要注意的是，这时的`data['code']`是一个经过 base64 处理的字符串，`custom_pagerank.so`中的二进制代码是无法通过 JSON 直接传输的。此外，存储过程的加载和删除都只能由具有管理员权限的用户来操作。\n\n存储过程加载之后会被保存在数据库中，在服务器重启后也会被自动加载。此外，如果需要对存储过程进行更新，调用的 REST API 也是同样的。建议用户在更新存储过程时更新相应描述，以便区分不同版本的存储过程。\n\n\n#### 5.2.1.列出已加载的存储过程\n\n在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin')\n>>> r.status_code\n200\n>>> r.text\n'{\"plugins\":[{\"description\":\"Custom Page Rank Procedure\", \"name\":\"custom_pagerank\", \"read_only\":true}]}'\n```\n\n#### 5.2.2.获取存储过程详情\n\n在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')\n>>> r.status_code\n200\n>>> r.text\n'{\"description\":\"Custom Page Rank Procedure\", \"name\":\"custom_pagerank\", \"read_only\":true, \"code_base64\":, \"code_type\":\"so\"}'\n```\n\n#### 5.2.3.调用存储过程\n\n调用存储过程的代码示例如下：\n\n```Cypher\nCALL plugin.cpp.custom_pagerank(10)\nYIELD node, pr WITH node, pr\nMATCH(node)-[r]->(n) RETURN node, r, n, pr\n```\n\n#### 5.2.4.删除存储过程\n\n删除存储过程只需要如下调用："
            },
            {
                "content": "#### 5.2.2.获取存储过程详情\n\n在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')\n>>> r.status_code\n200\n>>> r.text\n'{\"description\":\"Custom Page Rank Procedure\", \"name\":\"custom_pagerank\", \"read_only\":true, \"code_base64\":, \"code_type\":\"so\"}'\n```\n\n#### 5.2.3.调用存储过程\n\n调用存储过程的代码示例如下：\n\n```Cypher\nCALL plugin.cpp.custom_pagerank(10)\nYIELD node, pr WITH node, pr\nMATCH(node)-[r]->(n) RETURN node, r, n, pr\n```\n\n#### 5.2.4.删除存储过程\n\n删除存储过程只需要如下调用：\n\n```python\n>>> r = requests.delete(url='http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')\n>>> r.status_code\n200\n```\n\n与加载存储过程类似，只有管理员用户才能删除存储过程。\n\n#### 5.2.5.更新存储过程\n\n更新存储过程需要执行如下两个步骤：\n\n1.  删除已存在的存储过程\n2.  安装新的存储过程\n\nTuGraph 较为谨慎地管理存储过程操作的并发性，更新存储过程不会影响现有存储过程的运行。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/1.procedure/2.traversal.md",
        "chunks": [
            {
                "content": "# Traversal API\n\n> 此文档主要讲解 TuGraph 的存储过程中的Traversal API\n\n## 1. 简介\n\nTuGraph 强大的在线分析处理（OLAP）能力是其区别于其它图数据库的一个重要特性。\n借助 C++ OLAP API（olap_on_db.h），用户可以快速地导出一个需要进行复杂分析的子图，然后在其上运行诸如 PageRank、连通分量、社区发现等迭代式图计算过程，最后根据结果做出相应决策。\n导出和计算的过程都可以通过并行处理的方式进行加速，从而实现几乎实时的分析处理，避免了传统解决方案需要将数据导出、转换、再导入（ETL）到专门的分析系统进行离线处理的冗长步骤。\n\nTuGraph 内置了大量常用的图分析算法和丰富的辅助接口，因此用户几乎不需要自己来实现具体的图计算过程，只需在实现自己的存储过程时将相应算法库的头文件（.h 文件）包含到自己程序中，并在编译时链接相应的动态库文件（.so）即可。\n一般情况下，用户需要自己实现的只有将需要分析的子图抽取出来的过程。\n\n目前 Traversal API 仅支持 C++。\n\n## 2. 接口说明\n\n### 2.1. Snapshot\n\nC++ OLAP API 中的 Snapshot 模版类用于表示抽取出来的静态子图，其中 EdgeData 用来表示该子图上每条边所用权值的数据类型（如果边不需要权值，使用 Empty 作为 EdgeData 即可）。\n\n抽取的子图通过 Snapshot 类的构造函数来描述：\n\n```c\nSnapshot::Snapshot(\n    GraphDB & db,\n    Transaction & txn,\n    size_t flags = 0,\n    std::function vertex_filter = nullptr,\n    std::function out_edge_filter = nullptr\n);\n```"
            },
            {
                "content": "目前 Traversal API 仅支持 C++。\n\n## 2. 接口说明\n\n### 2.1. Snapshot\n\nC++ OLAP API 中的 Snapshot 模版类用于表示抽取出来的静态子图，其中 EdgeData 用来表示该子图上每条边所用权值的数据类型（如果边不需要权值，使用 Empty 作为 EdgeData 即可）。\n\n抽取的子图通过 Snapshot 类的构造函数来描述：\n\n```c\nSnapshot::Snapshot(\n    GraphDB & db,\n    Transaction & txn,\n    size_t flags = 0,\n    std::function vertex_filter = nullptr,\n    std::function out_edge_filter = nullptr\n);\n```\n\n其中，db 为数据库句柄，txn 为事务句柄，flags 为生成时使用的选项，可选值包括以下的组合：SNAPSHOT_PARALLEL 表示导出时使用多个线程进行并行；SNAPSHOT_UNDIRECTED 表示需要将导出的图变为无向图。\nvertex_filter 是面向点的用户自定义过滤函数，返回值为 true 表示该点需要被包含到待抽取的子图中，反之则表示需要被排除。\nout_edge_filter 是面向边的用户自定义过滤函数，返回值为 true 表示该边需要被包含到待抽取的子图中，反之则表示需要被排除。\n当过滤函数为缺省值时，则表示需要将所有点/边都包含进来。\n\nSnapshot 类提供的其它方法请参考详细的 C++ API 文档（olap_on_db.h）。\n\n### 2.2. Traversal"
            },
            {
                "content": "其中，db 为数据库句柄，txn 为事务句柄，flags 为生成时使用的选项，可选值包括以下的组合：SNAPSHOT_PARALLEL 表示导出时使用多个线程进行并行；SNAPSHOT_UNDIRECTED 表示需要将导出的图变为无向图。\nvertex_filter 是面向点的用户自定义过滤函数，返回值为 true 表示该点需要被包含到待抽取的子图中，反之则表示需要被排除。\nout_edge_filter 是面向边的用户自定义过滤函数，返回值为 true 表示该边需要被包含到待抽取的子图中，反之则表示需要被排除。\n当过滤函数为缺省值时，则表示需要将所有点/边都包含进来。\n\nSnapshot 类提供的其它方法请参考详细的 C++ API 文档（olap_on_db.h）。\n\n### 2.2. Traversal\n\n图数据库中十分常见的一大类分析是基于一个或多个点出发，逐层地拓展并访问邻居。\n尽管这类分析也可以使用 Cypher 完成，但是当访问的层数较深时，其性能会受到串行解释执行的限制。\n使用 C++ Core API 编写存储过程尽管避免了解释执行，但依然受限于单个线程的处理能力。\n为了让用户能够方便地通过并行处理的方式加速这一类应用场景，我们基于 C++ OLAP API 封装了一个 Traversal 框架，用户可以直接使用其中的 FrontierTraversal 和 PathTraversal 类来完成这种逐层遍历的分析任务，具体的使用方法可以参考相应的 C++ API 文档（lgraph_traversal.h）。\n\n```c\nParallelVector FindVertices(\n    GraphDB & db,\n    Transaction & txn,\n    std::function filter,\n    bool parallel = false\n);\n```\n\n该方法可用于找到所有满足条件（filter 返回 true）的点，当 parallel 为 true 时则会并行该查找过程。"
            },
            {
                "content": "```c\nParallelVector FindVertices(\n    GraphDB & db,\n    Transaction & txn,\n    std::function filter,\n    bool parallel = false\n);\n```\n\n该方法可用于找到所有满足条件（filter 返回 true）的点，当 parallel 为 true 时则会并行该查找过程。\n\n```c\ntemplate \nParallelVector ExtractVertexData(\n    GraphDB & db,\n    Transaction & txn,\n    ParallelVector & frontier,\n    std::function extract,\n    bool parallel = false\n);\n```\n\n该方法可用于从指定点集（frontier）中（通过 extract 方法）抽取（类型为 VertexData 的）属性，当 parallel 为 true 时会并行该抽取过程。\n\nFrontierTraversal 适用于只关注遍历扩展到的点集的情况；当用户在遍历过程或是结果中需要访问路径上的信息（路径上的点/边）时，则需要使用 PathTraversal。\n两类 Traversal 的构造函数均有四个参数，分别为数据库句柄 db、事务句柄 txn、选项 flags 和 初始化数组容量 capacity。\n选项的可选值包括以下的组合：TRAVERSAL_PARALLEL 表示遍历时使用多个线程并行；TRAVERSAL_ALLOW_REVISITS 表示遍历时允许重复地访问点（PathTraversal 隐含了该选项）。capacity 表示初始化时路径集合的容量。\n\n```c\nvoid SetFrontier(size_t root_vid);\nvoid SetFrontier(ParallelVector & root_vids);\nvoid SetFrontier(std::function root_vertex_filter);\n```\n\n两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。"
            },
            {
                "content": "```c\nvoid SetFrontier(size_t root_vid);\nvoid SetFrontier(ParallelVector & root_vids);\nvoid SetFrontier(std::function root_vertex_filter);\n```\n\n两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。\n\n两类 Traversal 的遍历都是从当前层的点集合出发，根据使用的扩展函数访问每条出边/入边/出边和入边，通过用户自定义的过滤函数决定扩展是否成功，若成功则将邻居点/追加了该条边的路径加入下一层的点/路径集合。\n\n```c\nvoid ExpandOutEdges(\n    std::function out_edge_filter = nullptr,\n    std::function out_neighbour_filter = nullptr\n);\nvoid ExpandInEdges(\n    std::function in_edge_filter = nullptr,\n    std::function in_neighbour_filter = nullptr\n);\nvoid ExpandEdges(\n    std::function out_edge_filter = nullptr,\n    std::function in_edge_filter = nullptr,\n    std::function out_neighbour_filter = nullptr,\n    std::function in_neighbour_filter = nullptr\n);\n```\n\n上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter 则为面向邻居点的过滤函数），则将邻居点加入新的点集合。\n\n```c\nParallelVector & GetFrontier();\n```\n\n当前点集合的扩展结束后，新的点集合可以通过上述方法取得。"
            },
            {
                "content": "上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter 则为面向邻居点的过滤函数），则将邻居点加入新的点集合。\n\n```c\nParallelVector & GetFrontier();\n```\n\n当前点集合的扩展结束后，新的点集合可以通过上述方法取得。\n\n```c\nvoid ExpandOutEdges(\n    std::function out_edge_filter = nullptr,\n    std::function out_neighbour_filter = nullptr\n);\nvoid ExpandInEdges(\n    std::function in_edge_filter = nullptr,\n    std::function in_neighbour_filter = nullptr\n);\nvoid ExpandEdges(\n    std::function out_edge_filter = nullptr,\n    std::function in_edge_filter = nullptr,\n    std::function out_neighbour_filter = nullptr,\n    std::function in_neighbour_filter = nullptr\n);\n```\n\nPathTraversal 的三种遍历方式与 FrontierTraversal 类似，只是用户自定义的过滤函数中增加了两个参数，其中：Path 包含了到新扩展的这条边之前的路径，IteratorHelper 可用于将路径中的点/边转为数据库中对应的迭代器，相关文档可参考对应的 C++ API 文档。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/1.procedure/5.Rust-procedure.md",
        "chunks": [
            {
                "content": "# Rust 存储过程\n\n## 1. 介绍\nRust 存储过程目前仅支持v1版本，TuGraph能够支持一切编译成动态库的语言作为插件。Rust语言作为系统编程语言的新起之秀，在安全性上、可靠性以及人体工程学上相较于C++具有较大优势。\n\n我们提供了TuGraph的[Rust binding]库来支持在Rust中调用lgrahp api，同时提供[tugraph-plugin-util] 工具库来帮助大家更加简洁地编写Rust插件代码。\n\n[Rust binding]: https://crates.io/crates/tugraph\n[tugraph-plugin-util]: https://crates.io/crates/tugraph-plugin-util\n\n## 2. 如何使用\n\nRust存储过程的使用分三步：\n* 编译，从rust源码编译出so库。我们准备了一份一站式的插件编写教程，从IDE的插件安装，环境配置，到编译，详细参考`rust-tugraph-plugin-tutorial`。\n* 加载，将so库加载到服务端，可以通过REST或RPC接口，这一步和C++库的使用方式类似，可以参考[文档](1.procedure.md)。\n* 运行，和c++ procdure使用方式相同，不在赘述。\n\n## 3.API文档\nRust社区习惯，所有的代码和文档都可以从[`crates.io`](https://crates.io/crates/tugraph )以及[`docs.rs`](https://docs.rs/tugraph/latest/tugraph )找到。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/2.olap/1.tutorial.md",
        "chunks": [
            {
                "content": "# OLAP API\n\n> 本文档是为TuGraph的用户设计的引导程序，用户在阅读详细的文档之前，应该首先阅读该文档，对TuGraph的图计算运行流程有一个大致的了解，之后再阅读详细文档会更加方便。引导程序是基于Tugraph的一个简单的[BFS(宽度优先搜索)](https://en.wikipedia.org/wiki/Breadth-first_search \"wikipedia\")程序实例，我们将重点介绍其使用方式。\n\n## 1. TuGraph 图分析引擎介绍\n\nTuGraph的图分析引擎，面向的场景主要是全图/全量数据分析类的任务。借助TuGraph的 C++ / Python 图分析引擎 API ，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如PageRank、LPA、WCC等迭代式图算法，最后根据运行结果做出相应的对策。\n\n在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。\n\nTuGraph图计算系统社区版内置6个算法，商业版内置了25种算法，用户几乎不需要自己实现具体的图计算过程。其详细介绍可参考algorithms.md。\n\n根据数据来源及实现不同，可分为Procedure、Embed和Standalone三种运行方式，均继承于OlapBase API，OlapBase API接口文档可参考olapbase-api.md。\n\n其中Procedure和Embed的数据来源是图数据库中预加载的db数据，可以分别编译生成tugraph-web加载使用的.so文件和后台终端使用的embed文件，输入的图数据均通过db的加载形式，其接口文档可参考olapondb-api.md。\nStandalone用于编译生成standalone文件，区别于前者，该文件的输入图数据通过txt、二进制、ODPS文件的形式加载，其接口文档可参考olapondisk-api.md。\n\n## 2. Procedure 编译与运行\n\n该种方式主要用于tugraph-web界面进行可视化加载及运行。使用方法如下："
            },
            {
                "content": "TuGraph图计算系统社区版内置6个算法，商业版内置了25种算法，用户几乎不需要自己实现具体的图计算过程。其详细介绍可参考algorithms.md。\n\n根据数据来源及实现不同，可分为Procedure、Embed和Standalone三种运行方式，均继承于OlapBase API，OlapBase API接口文档可参考olapbase-api.md。\n\n其中Procedure和Embed的数据来源是图数据库中预加载的db数据，可以分别编译生成tugraph-web加载使用的.so文件和后台终端使用的embed文件，输入的图数据均通过db的加载形式，其接口文档可参考olapondb-api.md。\nStandalone用于编译生成standalone文件，区别于前者，该文件的输入图数据通过txt、二进制、ODPS文件的形式加载，其接口文档可参考olapondisk-api.md。\n\n## 2. Procedure 编译与运行\n\n该种方式主要用于tugraph-web界面进行可视化加载及运行。使用方法如下：\n\n### C++:\n在tugraph-db/procedures 目录下执行`bash make_so_cpp.sh bfs`即可在tugraph-db/procedures目录下得到bfs.so文件，将该文件以插件形式上传至tugraph-web，输入参数后即可执行。\n\n### Python:\n在tugraph-web的前端将python文件以插件形式上传，输入参数后即可执行。\n\n示例：\n在tugraph-db/procedures 编译.so算法文件\n`bash make_so_cpp.sh bfs`\n\n将bfs.so（或tugraph-db/procedures/algo_cython/bfs.py）文件以插件形式加载至tugraph-web后，输入如下json参数：\n\n```json\n{\n    \"root\":\"10\",\n    \"label\":\"user\",\n    \"field\":\"id\"\n}\n```\n即可得到返回结果如下。"
            },
            {
                "content": "## 2. Procedure 编译与运行\n\n该种方式主要用于tugraph-web界面进行可视化加载及运行。使用方法如下：\n\n### C++:\n在tugraph-db/procedures 目录下执行`bash make_so_cpp.sh bfs`即可在tugraph-db/procedures目录下得到bfs.so文件，将该文件以插件形式上传至tugraph-web，输入参数后即可执行。\n\n### Python:\n在tugraph-web的前端将python文件以插件形式上传，输入参数后即可执行。\n\n示例：\n在tugraph-db/procedures 编译.so算法文件\n`bash make_so_cpp.sh bfs`\n\n将bfs.so（或tugraph-db/procedures/algo_cython/bfs.py）文件以插件形式加载至tugraph-web后，输入如下json参数：\n\n```json\n{\n    \"root\":\"10\",\n    \"label\":\"user\",\n    \"field\":\"id\"\n}\n```\n即可得到返回结果如下。\n\n```json\n{\n  \"core_cost\": 0.013641119003295898,\n  \"found_vertices\": 3829,\n  \"num_edges\": 88234,\n  \"num_vertices\": 4039,\n  \"output_cost\": 8.821487426757813e-06,\n  \"prepare_cost\": 0.03479194641113281,\n  \"total_cost\": 0.04844188690185547\n}\n```\n\n输出内容解释如下：\n- core_cost: 表示算法运行所需要的时间。\n- found_vertices: 表示查找到点的个数。\n- num_edges: 表示该图数据的边数量。\n- num_vertices: 表示该图数据点的数量。\n- output_cost: 表示算法结果写回db所需要的时间。\n- prepare_cost: 表示预处理阶段所需要的时间。预处理阶段的工作：加载参数、图数据加载、索引初始化等。\n- total_cost: 表示执行该算法整体运行时间。"
            },
            {
                "content": "```json\n{\n  \"core_cost\": 0.013641119003295898,\n  \"found_vertices\": 3829,\n  \"num_edges\": 88234,\n  \"num_vertices\": 4039,\n  \"output_cost\": 8.821487426757813e-06,\n  \"prepare_cost\": 0.03479194641113281,\n  \"total_cost\": 0.04844188690185547\n}\n```\n\n输出内容解释如下：\n- core_cost: 表示算法运行所需要的时间。\n- found_vertices: 表示查找到点的个数。\n- num_edges: 表示该图数据的边数量。\n- num_vertices: 表示该图数据点的数量。\n- output_cost: 表示算法结果写回db所需要的时间。\n- prepare_cost: 表示预处理阶段所需要的时间。预处理阶段的工作：加载参数、图数据加载、索引初始化等。\n- total_cost: 表示执行该算法整体运行时间。\n\nmake_so.sh文件介绍：该文件用于将TuGraph-OLAP所涉及到的图算法文件编译成一个可供tugraph-web使用的.so文件。\n\n## 3. Embed 编译与运行\n\n该种方式主要用于TuGraph在后台程序中对预加载的db图数据进行算法分析。其使用方法如下：\n在tugraph-db/procedures 目录下对embed_main.cpp文件完善，补充数据名称、输入参数、数据路径等信息，示例如下：\n\n### C++:\n\n```C++\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/olap_base.h\"\nusing namespace std;\n\nextern \"C\" bool Process(lgraph_api::GraphDB &db, const std::string &request, std::string &response);"
            },
            {
                "content": "## 3. Embed 编译与运行\n\n该种方式主要用于TuGraph在后台程序中对预加载的db图数据进行算法分析。其使用方法如下：\n在tugraph-db/procedures 目录下对embed_main.cpp文件完善，补充数据名称、输入参数、数据路径等信息，示例如下：\n\n### C++:\n\n```C++\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/olap_base.h\"\nusing namespace std;\n\nextern \"C\" bool Process(lgraph_api::GraphDB &db, const std::string &request, std::string &response);\n\nint main(int argc, char **argv) {\n    // db_path表示预加载图数据存放的路径\n    std::string db_path = \"../fb_db/\";\n    if (argc > 1)\n        db_path = argv[1];\n    lgraph_api::Galaxy g(db_path);\n    g.SetCurrentUser(\"admin\", \"73@TuGraph\");\n    // 指定图数据的名称\n    lgraph_api::GraphDB db = g.OpenGraph(\"fb_db\");\n    std::string resp;\n    // 以json形式输入算法参数\n    bool r = Process(db, \"{\\\"root_id\\\":\\\"0\\\", \\\"label\\\":\\\"node\\\",\\\"field\\\":\\\"id\\\"}\", resp);\n    cout << r << endl;\n    cout << resp << endl;\n    return 0;\n}\n```\n保存后在tugraph-db/procedures 目录下执行`bash make_embed.sh bfs`即可在tugraph-db/procedures/algo_cpp 目录下得到bfs_procedure文件。\n\n在tugraph-db/procedures 文件夹下执行`./algo_cpp/bfs_procedure` 即可得到返回结果："
            },
            {
                "content": "在tugraph-db/procedures 文件夹下执行`./algo_cpp/bfs_procedure` 即可得到返回结果：\n\n```json\n{\n  \"core_cost\":0.025603055953979492,\n  \"found_vertices\":3829,\n  \"num_edges\":88234,\n  \"num_vertices\":4039,\n  \"output_cost\":9.059906005859375e-06,\n  \"prepare_cost\":0.056738853454589844,\n  \"total_cost\":0.0823509693145752\n}\n```\n\n参数解释同上。\n\n### Python：\n在tugraph-db/procedures文件夹下执行\n`bash make_so_cython.sh bfs`\n或在tugraph-db/procedures/algo_cython文件夹下执行\n`python3 setup.py build_ext -i`\n得到bfs.so后，在Python中import bfs可使用，如tugraph-db/procedures/run_embed.py所示\n\n```python\n# tugraph-db/procedures/run_embed.py\nfrom lgraph_db_python import *\n\nimport bfs as python_plugin\n\nif __name__ == \"__main__\":\n    galaxy = PyGalaxy(\"../build/output/lgraph_db\")\n    galaxy.SetCurrentUser(\"admin\", \"73@TuGraph\")\n    db = galaxy.OpenGraph(\"default\", False)\n    res = python_plugin.Process(db, \"{\\\"root_id\\\":\\\"0\\\", \\\"label\\\":\\\"node\\\",\\\"field\\\":\\\"id\\\"}\".encode('utf-8'))\n    print(res)\n    del db\n    del galaxy\n```\n通过如下命令执行\n\n```bash\npython3 run_embed.py\n```\n\n输出结果与C++相同。"
            },
            {
                "content": "```python\n# tugraph-db/procedures/run_embed.py\nfrom lgraph_db_python import *\n\nimport bfs as python_plugin\n\nif __name__ == \"__main__\":\n    galaxy = PyGalaxy(\"../build/output/lgraph_db\")\n    galaxy.SetCurrentUser(\"admin\", \"73@TuGraph\")\n    db = galaxy.OpenGraph(\"default\", False)\n    res = python_plugin.Process(db, \"{\\\"root_id\\\":\\\"0\\\", \\\"label\\\":\\\"node\\\",\\\"field\\\":\\\"id\\\"}\".encode('utf-8'))\n    print(res)\n    del db\n    del galaxy\n```\n通过如下命令执行\n\n```bash\npython3 run_embed.py\n```\n\n输出结果与C++相同。\n\n## 4. Standalone 编译与运行\n\n该文件主要用于在终端处直接加载图数据，并运行打印输出结果。使用方法如下：\n在tugraph-db/build目录下执行`make bfs_standalone` (需要在g++默认include路径中包含boost/sort/sort.hpp)即可得到bfs_standalone文件,该文件生成于tugraph-db/build/output/algo文件夹下。\n运行方式：在tugraph-db/build目录下执行`./output/algo/bfs_standalone -–type [type] –-input_dir [input_dir] --id_mapping [id_mapping] -–vertices [vertices] --root [root] –-output_dir [output_dir]`即可运行。"
            },
            {
                "content": "```bash\npython3 run_embed.py\n```\n\n输出结果与C++相同。\n\n## 4. Standalone 编译与运行\n\n该文件主要用于在终端处直接加载图数据，并运行打印输出结果。使用方法如下：\n在tugraph-db/build目录下执行`make bfs_standalone` (需要在g++默认include路径中包含boost/sort/sort.hpp)即可得到bfs_standalone文件,该文件生成于tugraph-db/build/output/algo文件夹下。\n运行方式：在tugraph-db/build目录下执行`./output/algo/bfs_standalone -–type [type] –-input_dir [input_dir] --id_mapping [id_mapping] -–vertices [vertices] --root [root] –-output_dir [output_dir]`即可运行。\n\n- `[type]`：表示输入图文件的类型来源，包含text文本文件、BINARY_FILE二进制文件和ODPS源。\n- `[input_dir]`：表示输入图文件的文件夹路径，文件夹下可包含一个或多个输入文件。TuGraph在读取输入文件时会读取[input_dir]下的所有文件，要求[input_dir]下只能包含输入文件，不能包含其它文件。参数不可省略。\n- `[id_mapping]`：当读入边表时，是否对输入数据做id映射，使达到符合算法运行的形式。1为需要做id映射，0为不需要做。该过程会消耗一定时间。参数可省略，默认值为0。\n- `[vertices]`：表示图的点个数，为0时表示用户希望系统自动识别点数量；为非零值时表示用户希望自定义点个数，要求用户自定义点个数需大于最大的点ID。参数可省略，默认值为0。\n- `[root]`：表示进行bfs的起始点id。参数不可省略。\n- `[output_dir]`：表示输出数据保存的文件夹路径，将输出内容保存至该文件中，参数不可省略。\n\n示例：\n\n### C++:\n在tugraph-db/build编译standalone算法程序\n\n```bash\nmake bfs_standalone\n```\n\n在tugraph-db/build/output目录下运行text源文件"
            },
            {
                "content": "示例：\n\n### C++:\n在tugraph-db/build编译standalone算法程序\n\n```bash\nmake bfs_standalone\n```\n\n在tugraph-db/build/output目录下运行text源文件\n\n```bash\n./output/algo/bfs_standalone --type text --input_dir ../test/integration/data/algo/fb_unweighted --root 0\n```\n\n得到运行结果：\n\n```text\nprepare_cost = 0.10(s)\ncore_cost = 0.02(s)\nfound_vertices = 3829\noutput_cost = 0.00(s)\ntotal_cost = 0.11(s)\nDONE.\n```\n\n结果参数解释同上。\n\n对于新的算法，运行时不了解该算法的所需参数时，可通过`./output/algo/bfs_standalone -h`进行查阅对应参数。\n\n### Python:\nPython语言的bfs拓展编译过程与embed模式无区别，在运行时通过`Standalone`接口调用，示例如下：\n```python\n# tugraph-db/procedures/run_standalone.py\nimport bfs as python_plugin\n\nif __name__ == \"__main__\":\n    python_plugin.Standalone(input_dir=\n                             \"../test/integration/data/algo/fb_unweighted\",\n                             root=0)\n```\n\n通过如下命令执行\n\n```bash\npython3 run_standalone.py\n```\n\n至此，通过TuGraph对上图进行bfs运算的过程已经完成。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/2.olap/2.olap-base-api.md",
        "chunks": [
            {
                "content": "# OlapBase API\n\n> 此文档主要详细介绍了OlapBase API的使用说明\n\n\n## 1. 概述\n\n本手册将介绍使用TuGraph图计算系统需要的简单配置，同时结合代码对TuGraph中几个共同的重要文件和接口进行解释。\n\n## 2. 配置要求\n\n如果要使用TuGraph图计算编写以及编译自己的应用程序，需要的配置要求为：\n\n- linux操作系统，目前在Ubuntu16.04, Ubuntu18.04, Ubuntu20.04和Centos7, Centos8系统上可成功运行。\n- 支持C++17的编译器，要求GCC版本为8.4.0或更新的版本。\n\n## 3. 原子操作\n\nTuGraph使用了多线程技术进行批处理操作，在这种情况下可能会出现访存冲突现象。为了保证并行计算时修改操作的正确性，TuGraph实现了原子操作。代码部分见lgraph文件夹下的lgraph_atomic.cpp文件。\nTuGraph还自定义了4个常用的原子操作。当我们需要在多线程模式下修改点的数据时，我们都应该使用原子操作来确保并行环境下修改操作的正确性。除了这4个原子操作外，用户也可以使用“cas”来构建自己的原子操作函数。\n\n- `bool cas(T * ptr, T oldv, T newv)`：如果ptr指向的值等于oldv，则将ptr指向的值赋为newv并返回true，否则返回false\n- `bool write_min(T *a, T b)`：如果b比a指向的值更小，那么将a指向的值赋为b并返回true，否则返回false。\n- `bool write_max(T *a, T b)`：如果b比a指向的值更大，那么将a指向的值赋为b并返回true，否则返回false。\n- `void write_add(T *a, T b)`：将b的值加到a指向的值上。\n- `void write_sub(T *a, T b)`：将a指向的值减去b的值。\n\n## 4. 点集合类ParallelBitset\n\n在使用TuGraph进行批处理操作时，需要使用点集合来表示需要处理的点。ParallelBitset实现了点集合类，以bit为单位表示点，因此能够节省大量内存。对应的代码见lgraph文件夹下的olap_base.h文件。\n\n### 4.1 ParallelBitset类成员"
            },
            {
                "content": "- `bool cas(T * ptr, T oldv, T newv)`：如果ptr指向的值等于oldv，则将ptr指向的值赋为newv并返回true，否则返回false\n- `bool write_min(T *a, T b)`：如果b比a指向的值更小，那么将a指向的值赋为b并返回true，否则返回false。\n- `bool write_max(T *a, T b)`：如果b比a指向的值更大，那么将a指向的值赋为b并返回true，否则返回false。\n- `void write_add(T *a, T b)`：将b的值加到a指向的值上。\n- `void write_sub(T *a, T b)`：将a指向的值减去b的值。\n\n## 4. 点集合类ParallelBitset\n\n在使用TuGraph进行批处理操作时，需要使用点集合来表示需要处理的点。ParallelBitset实现了点集合类，以bit为单位表示点，因此能够节省大量内存。对应的代码见lgraph文件夹下的olap_base.h文件。\n\n### 4.1 ParallelBitset类成员\n\n- `size_t Size()`：表示Bitmap中的点个数。\n- `ParallelBitset(size_t size)`：初始化size和data，data长度为(size >> 6)+1\n- `void Clear()`：清空集合\n- `void Fill()`：将所有点加入集合\n- `bool Has(size_t i)`：检查点i是否在集合中\n- `bool Add(size_t i)`：将点i加入集合中\n- `void Swap(ParallelBitset &other)`：和另一组ParallelBitset集合交换元素\n\n## 5. 点数组类ParallelVector\n\n在使用TuGraph进行批处理操作时，需要使用点数组来表示对点的处理结果。ParallelVector实现了点数组类。对应的代码见lgraph文件夹下的olap_base.h文件。\n\n### 5.1 ParallelVector类成员"
            },
            {
                "content": "## 5. 点数组类ParallelVector\n\n在使用TuGraph进行批处理操作时，需要使用点数组来表示对点的处理结果。ParallelVector实现了点数组类。对应的代码见lgraph文件夹下的olap_base.h文件。\n\n### 5.1 ParallelVector类成员\n\n- `ParallelVector(size_t capacity)` 构建ParallelVector，capacity为点数组的初始容量大小\n- `T &operator[](size_t i)`：下标为i的数据\n- `T *begin()`：ParallelVector的起始指针\n- `T *end()`：ParallelVector的结束指针。begin和end的用法类似于vector容器的begin和end指针，可以使用这两个指针对数组进行顺序访问\n- `T &Back()`：ParallelVector最后一个数据\n- `T *Data()`：表示数组本身数据\n- `void Destroy()`：清空ParallelVector数组内数据并删除数组\n- `size_t Size()`：表示ParallelVector中的数据个数\n- `size_t Capacity()`：表示ParallelVector的容量大小\n- `void Resize(size_t size)`：更改ParallelVector为size大小，该size应大于等于更改前的大小且小于capacity\n- `void Clear()`：清空ParallelVector内数据\n- `void ReAlloc(size_t capacity)`：给ParallelVector分配新的容量大小，若数组有数据则将数据迁移至新内存\n- `void Fill(T elem)`：为ParallelVector的全部数据赋值为elem\n- `void Append(const T &elem, bool atomic = true)`：向ParallelVector结尾添加一个数据\n- `void Swap(ParallelVector &other)`：和其他的ParallelVector交换数据\n- `ParallelVector Copy()`：复制当前的ParallelVector数据存至Copy数组中\n\n## 6. 自定义数据结构"
            },
            {
                "content": "## 6. 自定义数据结构\n\n### 6.1 基本数据类型\n\n我们自定义了点和边的数据结构表示，用于在覆盖所有点的同时节省内存空间：\n\n- `Empty`：内容为空的特殊数据类型。\n\n### 6.2 组合数据结构\n\n为了便于计算，我们根据计算场景不同，定义了几种点和边数据的数据结构，分别是：\n\n- `EdgeUnit`：表示权值类型为EdgeData的边，用于解析输入文件，包含三个成员变量：\n  - `size_t src`：边的起始点\n  - `size_t dst`：边的终点\n  - `EdgeData edge_data`：边的权值\n- `AdjUnit`：表示权值类型为EdgeData的边，用于批处理计算过程中，包含两个成员变量：\n  - `size_t neighbour`：边的邻居点\n  - `EdgeData edge_data`：边的权值\n- `AdjList`：权值类型为EdgeData的点的邻接表，常用于表示点的入边和出边集合，包含两个成员变量：\n  - `AdjUnit * begin`：列表的起始指针\n  - `AdjUnit * end`：列表的结束指针。begin和end的用法类似于vector容器的begin和end指针，可以使用这两个指针对邻接表进行循环访问。\n\n## 7. 图类OlapBase\n\n图类OlapBase是TuGraph用于加载图以及进行图计算操作的主类，常用OlapBase表示权值类型为EdgeData的图，代码部分见lgraph文件夹下的olap_base.hpp。本章将介绍Graph类中常用的类型和API接口。上文介绍Procedure、Embed及Standalone功能所使用的类均为该类的子类。\n\n### 7.1 基本信息\n\n- `size_t NumVertices()`：获取点数\n- `size_t NumEdges()`：获取边数\n- `size_t OutDegree(size_t vid)`：点vid的出度\n- `size_t InDegree(size_t vid)`：点vid的入度\n\n### 7.2 点集和边集及其相关操作"
            },
            {
                "content": "### 7.1 基本信息\n\n- `size_t NumVertices()`：获取点数\n- `size_t NumEdges()`：获取边数\n- `size_t OutDegree(size_t vid)`：点vid的出度\n- `size_t InDegree(size_t vid)`：点vid的入度\n\n### 7.2 点集和边集及其相关操作\n\n- `ParallelVector AllocVertexArray()`：分配一个类型为VertexData的数组，大小为点个数\n- `void fill_vertex_array(V * array, V value)`：将数组array中的所有元素赋值为value\n- `ParallelBitset AllocVertexSubset()`：分配一个ParallelBitset集合，用于表示所有点的状态是否激活\n- `AdjList OutEdges(size_t vid)`：获取点v的所有出边集合\n- `AdjList InEdges(size_t vid)`：获取点v的所有入边集合\n- `void Transpose()`：对有向图进行图反转\n- `LoadFromArray(char * edge_array, VertexId input_vertices, EdgeId input_edges,  EdgeDirectionPolicy edge_direction_policy)`：从数组中加载图数据，包含四个参数，其含义分别表示：\n  - `edge_array`：将该数组中的数据读入图，一般情况下该数组包含多条边。\n  - `input_vertices`：指定数组读入图的点个数。\n  - `input_edges`：指定数组读入图的边的条数。\n  - `edge_direction_policy`：指定图为有向或无向，包含三种模式，分别为DUAL_DIRECTION、MAKE_SYMMETRIC以及INPUT_SYMMETRIC。对应的详细介绍见include/lgraph/olap_base.h文件的`enum EdgeDirectionPolicy`。\n\n### 7.3 锁机制\n\nTuGraph实现了一对锁机制，来控制程序对于点数据的访存权限。分别是："
            },
            {
                "content": "### 7.3 锁机制\n\nTuGraph实现了一对锁机制，来控制程序对于点数据的访存权限。分别是：\n\n- `void AcquireVertexLock(size_t vid)`：对点vid加锁，禁止其它线程对该锁对应的点数据进行访存\n- `void ReleaseVertexLock(size_t vid)`：对点vid解锁，所有线程均可访存该锁对应的点数据\n- `VertexLockGuard GuardVertexLock(size_t vid)`：在对vid操作时，对点vid加锁，退出作用域时时自动释放锁\n\n### 7.4 批处理操作\n\nTuGraph提供了两个批处理操作来并行地进行以点为中心的批处理过程。分别是：\n\n```c++\n/*\n    函数名称:ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper,\n                ReducedSum zero = 0,std::function reduce =reduce_plus)\n\t\t\t\t\n    函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；\n    第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n    具体实现请参考include/lgraph/olap_base.h中具体代码\n\n    使用示例:统计数组parent数组中有出边的点个数\n*/\n\nauto vertex_num = graph.ProcessVertexInRange(\n    [&](size_t i) {\n        if (graph.OutDegree(parent[i]) > 0) {\n            return 1;\n        }\n    },\n    0, parent.Size()\n);\nprintf(\"the number is %lu\\n\",vertex_num);\n```\n\n其中graph为图类OlapBase的实例化对象"
            },
            {
                "content": "使用示例:统计数组parent数组中有出边的点个数\n*/\n\nauto vertex_num = graph.ProcessVertexInRange(\n    [&](size_t i) {\n        if (graph.OutDegree(parent[i]) > 0) {\n            return 1;\n        }\n    },\n    0, parent.Size()\n);\nprintf(\"the number is %lu\\n\",vertex_num);\n```\n\n其中graph为图类OlapBase的实例化对象\n\n```C++\n/*\n    函数名称:ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices,\n                ReducedSum zero = 0,std::function reduce =reduce_plus)\n\t\t\t\t\n    函数用途:对active_vertices中对应为1的节点执行work函数，第三个参数表示累加的基数，默认为0；\n    第四个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n    具体实现请参考/include/lgraph/olap_base.h中具体代码\n    \n    使用示例:输出Graph中节点1，2，3的所有出度邻居，并统计这三个节点的总出度\n*/"
            },
            {
                "content": "其中graph为图类OlapBase的实例化对象\n\n```C++\n/*\n    函数名称:ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices,\n                ReducedSum zero = 0,std::function reduce =reduce_plus)\n\t\t\t\t\n    函数用途:对active_vertices中对应为1的节点执行work函数，第三个参数表示累加的基数，默认为0；\n    第四个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n    具体实现请参考/include/lgraph/olap_base.h中具体代码\n    \n    使用示例:输出Graph中节点1，2，3的所有出度邻居，并统计这三个节点的总出度\n*/\n\nauto active_in = graph.AllocVertexSubset();\nactive_in.Add(1);\nactive_in.Add(2);\nactive_in.Add(3);\nauto total_outdegree = graph.ProcessVertexActive(\n    [&](size_t vi) {\n        size_t local_outdegree = 0;\n        for (auto & edge : graph.OutEdges(vi)) {\n            size_t dst = edge.neighbour;\n            printf(\"node %lu has neighbour %lu\\n\",vi,dst);\n            local_outdegree += 1;\n        }\n        return local_outdegree;\n    },\n    active_in\n);\nprintf(\"total outdegree of node1,2,3 is %lu\\n\",total_outdegree);\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/2.olap/3.olap-on-db-api.md",
        "chunks": [
            {
                "content": "# OlapOnDB API\n\n> 此文档主要详细介绍了OlapOnDB API的使用说明\n\n\n## 1. 简介\n\n一般用户需要自己实现的只是将需要分析的子图抽取出来的过程。用户也可以通过使用TuGraph中丰富的辅助接口实现自己的图分析算法。\n\n该文档主要介绍Procedure及Embed的接口设计，并介绍部分常用接口，具体的接口信息参见include/lgraph/olap_on_db.h文件。\n\n## 2. 模型\n\nProcedure及Embed使用到的辅助函数主要包含在OlapOnDB类，还有一些使用频率较高的函数都会逐一介绍\n\n在TuGraph中OLAP相关的有以下常用的数据结构：\n\n1. DB图分析类 `OlapOnDB`\n2. 点数组`ParallelVector`\n3. 点集合`ParallelBitset`\n4. 边数据结构`AdjUnit/AdjUnit`\n5. 边集合数据结构`AdjList`\n\n### 2.1 基于快照的存储结构\n\nTuGraph中的OlapOnDB类能够提供数据“快照”，即建立一个对指定数据集的完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的镜像。由于OLAP的操作仅涉及读操作而不涉及写操作，OlapOnDB会以一种更紧凑的方式对数据进行排布，在节省空间的同时，提高数据访问的局部性。\n\n### 2.2 BSP计算模型\n\nTuGraph在计算的过程中使用了BSP（Bulk Synchronous Parallel）模型，使得该过程能够并行执行，极大的提高了程序运行效率。\n\nBSP计算模型的核心思路为超步（Super Step）的提出和使用。在OlapOnDB创建后，在该数据上的计算分为多个超步，比如PageRank，分为多轮迭代，每轮迭代就是一个超步。不同超步之间用存在显式同步，从而保证所有线程在完成同一超步后同时进入下一个超步。在一个超步内部，所有的线程异步执行，利用并行提升计算效率。\n\n利用BSP计算模型能够有效避免死锁，通过障碍同步的方式能够以硬件方式实现粗粒度的全局同步，使得图计算能够并行化执行，而程序员无需在同步互斥上大费周章。\n\n## 3. 算法举例\n\n在这里对PageRank算法分块做解释，大体上分为主函数`Process`和PageRank算法流程`PageRank`函数\n\n### 3.1 主函数"
            },
            {
                "content": "### 2.2 BSP计算模型\n\nTuGraph在计算的过程中使用了BSP（Bulk Synchronous Parallel）模型，使得该过程能够并行执行，极大的提高了程序运行效率。\n\nBSP计算模型的核心思路为超步（Super Step）的提出和使用。在OlapOnDB创建后，在该数据上的计算分为多个超步，比如PageRank，分为多轮迭代，每轮迭代就是一个超步。不同超步之间用存在显式同步，从而保证所有线程在完成同一超步后同时进入下一个超步。在一个超步内部，所有的线程异步执行，利用并行提升计算效率。\n\n利用BSP计算模型能够有效避免死锁，通过障碍同步的方式能够以硬件方式实现粗粒度的全局同步，使得图计算能够并行化执行，而程序员无需在同步互斥上大费周章。\n\n## 3. 算法举例\n\n在这里对PageRank算法分块做解释，大体上分为主函数`Process`和PageRank算法流程`PageRank`函数\n\n### 3.1 主函数\n\n主函数输入有三个参数，`TuGraph`数据库参数`db`，从网页端获取的请求`request`，给网页端的返回值`response`，整体流程可以分为一下几步：\n\n1. 相关参数的获取\n2. 快照类的创建\n3. PageRank算法主流程\n4. 网页端返回值的获取和发送\n\n```C++\nextern \"C\" bool Process(GraphDB & db, const std::string & request, std::string & response) {\n    \n    // 从网页端请求中获取迭代次数（num_iterations），\n    int num_iterations = 20;\n    try {\n        json input = json::parse(request);\n        num_iterations = input[\"num_iterations\"].get();\n    } catch (std::exception & e) {\n        throw std::runtime_error(\"json parse error\");\n        return false;\n    }"
            },
            {
                "content": "// 读事务的创建以及快照类的创建\n    auto txn = db.CreateReadTxn();\n    OlapOnDB olapondb(\n        db,\n        txn,\n        SNAPSHOT_PARALLEL\n    );\n\t\n    // 创建pr数组用于存储每个节点的pr值\n    ParallelVector pr = olapondb.AllocVertexArray();\n    // pagerank算法主流程，获取每个节点的pagerank值\n    PageRankCore(olapondb, num_iterations, pr);\n    \n    auto all_vertices = olapondb.AllocVertexSubset();\n    all_vertices.Fill();\n    /*\n        函数用途：从所有节点中获取pagerank值最大的节点编号\n    \n        函数流程描述：该函数对点集合all_vertices中所有为1的位对应的节点vi（又称为活跃点）执行Func A，再将Func A的返回值作为Func B的第二个输入参数，得到局部最大值（因为第一个输入参数为0，因此实际上返回值就是每个节点的pagerank值），最后再将所有线程的返回值汇总，再次 执行Func B得到全局返回值，并存入max_pr_vi变量中\n    */\n    size_t max_pr_vi = olapondb.ProcessVertexActive(\n        \n        //Func A\n        [&](size_t vi) {\n            return vi;\n        },\n        all_vertices,\n        0,\n        \n        //Func B\n        [&](size_t a, size_t b) {\n            return pr[a] > pr[b] ? a : b;\n        }\n    );\n    \n    // 网页端返回值的获取和发送\n    json output;"
            },
            {
                "content": "*/\n    size_t max_pr_vi = olapondb.ProcessVertexActive(\n        \n        //Func A\n        [&](size_t vi) {\n            return vi;\n        },\n        all_vertices,\n        0,\n        \n        //Func B\n        [&](size_t a, size_t b) {\n            return pr[a] > pr[b] ? a : b;\n        }\n    );\n    \n    // 网页端返回值的获取和发送\n    json output;\n    output[\"max_pr_vid\"] = olapondb.OriginalVid(max_pr_vi);\n    output[\"max_pr_val\"] = pr[max_pr_vi];\n    response = output.dump();\n    return true;\n}\n```"
            },
            {
                "content": "### 3.2 PageRank算法流程\n\n`pagerank`主流程有两个输入参数，快照类（子图）还有迭代次数，整体流程可以分为以下几步：\n\n1. 相关数据结构的初始化\n1. 每个节点pagerank值的初始化\n1. 每个节点pagerank值的计算，活跃点为所有点（意味着所有点都需要计算pagerank值）\n1. 得到每个节点经过`num_iterations`次迭代后的pagerank值\n\n```C++\nvoid PageRankCore(OlapBase& graph, int num_iterations, ParallelVector& curr) {\n    \n    // 相关数据结构的初始化\n    auto all_vertices = olapondb.AllocVertexSubset();\n    all_vertices.Fill();\n    auto curr = olapondb.AllocVertexArray();\n    auto next = olapondb.AllocVertexArray();\n    size_t num_vertices = olapondb.NumVertices();\n    double one_over_n = (double)1 / num_vertices;\n\n    // 每个节点pagerank值的初始化，和该节点的出度成反比\n    double delta = graph.ProcessVertexActive(\n        [&](size_t vi) {\n            curr[vi] = one_over_n;\n            if (olapondb.OutDegree(vi) > 0) {\n                curr[vi] /= olapondb.OutDegree(vi);\n            }\n            return one_over_n;\n        },\n        all_vertices);"
            },
            {
                "content": "// 每个节点pagerank值的初始化，和该节点的出度成反比\n    double delta = graph.ProcessVertexActive(\n        [&](size_t vi) {\n            curr[vi] = one_over_n;\n            if (olapondb.OutDegree(vi) > 0) {\n                curr[vi] /= olapondb.OutDegree(vi);\n            }\n            return one_over_n;\n        },\n        all_vertices);\n\n    // 总迭代过程\n    double d = (double)0.85;\n        for (int ii = 0;ii < num_iterations;ii ++) {\n        printf(\"delta(%d)=%lf\\n\", ii, delta);\n        next.Fill((double)0);\n\n        /*\n            函数用途：计算所有节点的pagerank值\n\n            函数流程描述：该函数用于计算所有节点的pagerank值，对all_vertices中所有为1的位对应的节点vi执行Func C，得到本轮迭代中vi的pagerank值，并返回vi节点的pagerank变化值，最终经过函数内部处理汇总所有活跃节点的总变化值并返回，该值被存储在delta变量中\n        */\n        delta = graph.ProcessVertexActive(\n            // Func C\n            [&](size_t vi) {\n                double sum = 0;"
            },
            {
                "content": "/*\n            函数用途：计算所有节点的pagerank值\n\n            函数流程描述：该函数用于计算所有节点的pagerank值，对all_vertices中所有为1的位对应的节点vi执行Func C，得到本轮迭代中vi的pagerank值，并返回vi节点的pagerank变化值，最终经过函数内部处理汇总所有活跃节点的总变化值并返回，该值被存储在delta变量中\n        */\n        delta = graph.ProcessVertexActive(\n            // Func C\n            [&](size_t vi) {\n                double sum = 0;\n\n                // 从邻居中获取当前节点的pagerank值\n                for (auto & edge : olapondb.InEdges(vi)) {\n                    size_t src = edge.neighbour;\n                    sum += curr[src];\n                }\n                next[vi] = sum;"
            },
            {
                "content": "// 从邻居中获取当前节点的pagerank值\n                for (auto & edge : olapondb.InEdges(vi)) {\n                    size_t src = edge.neighbour;\n                    sum += curr[src];\n                }\n                next[vi] = sum;\n\n                // pagerank值计算核心公式\n                next[vi] = (1 - d) * one_over_n + d * next[vi];\n                if (ii == num_iterations - 1) {\n                    return (double)0;\n                } else {\n    \n                    // 相关中间变量统计\n                    if (olapondb.OutDegree(vi) > 0) {\n                        next[vi] /= olapondb.OutDegree(vi);\n                        return fabs(next[vi] - curr[vi]) * olapondb.OutDegree(vi);\n                    } else {\n                        return fabs(next[vi] - curr[vi]);\n                    }\n                }\n            },\n            all_vertices\n        );\n\n        // 将本轮迭代得到的pagerank值输出作为下一轮迭代的输入\n        curr.Swap(next);\n    }\n}\n```\n\n## 4. 其他常用函数功能描述\n\n### 4.1 事务的创建\n\n```C++\n//读事务的创建\nauto txn = db.CreateReadTxn();"
            },
            {
                "content": "// 将本轮迭代得到的pagerank值输出作为下一轮迭代的输入\n        curr.Swap(next);\n    }\n}\n```\n\n## 4. 其他常用函数功能描述\n\n### 4.1 事务的创建\n\n```C++\n//读事务的创建\nauto txn = db.CreateReadTxn();\n\n//写事务的创建\nauto txn = db.CreateWriteTxn();\n```\n\n### 4.2 并行化创建有向图\n\n```C++\nOlapOnDB olapondb(\n    db,\n    txn,\n    SNAPSHOT_PARALLEL\n)\n```\n\n### 4.3 并行化创建无向图\n\n```C++\nOlapOnDB olapondb(\n    db,\n    txn,\n    SNAPSHOT_PARALLEL | SNAPSHOT_UNDIRECTED\n)\n```\n\n### 4.4 获取出度\n\n```C++\nsize_t OutDegree(size_t vid)\n```\n\n### 4.5 获取入度\n\n```C++\nsize_t InDegree(size_t vid)\n```\n\n### 4.6 获取出边集合\n\n```C++\n/*\n    函数名称：AdjList OutEdges(size_t vid)\n    数据结构:\n        AdjList 可以理解为类型为AdjUnit结构体的数组\n        AdjUnit 有两个成员变量： 1. size_t neighbour 2. edge_data，其中neighbour表示该出边指向的目标节点编号，如果为有权图，则edge_data数据类型和输入文件中边的权重值相同，否则数据类型为Empty\n\n    使用示例：输出节点vid的所有出度邻居\n*/\nfor (auto & edge : olapondb.OutEdges(vid)) {\n    size_t dst = edge.neighbour;\n    printf(\"src = %lu,dst = %lu\\n\",vid,dst);\n}\n```\n\n### 4.7 获取入边集合\n\n```C++\nAdjList InEdges(size_t vid)"
            },
            {
                "content": "### 4.5 获取入度\n\n```C++\nsize_t InDegree(size_t vid)\n```\n\n### 4.6 获取出边集合\n\n```C++\n/*\n    函数名称：AdjList OutEdges(size_t vid)\n    数据结构:\n        AdjList 可以理解为类型为AdjUnit结构体的数组\n        AdjUnit 有两个成员变量： 1. size_t neighbour 2. edge_data，其中neighbour表示该出边指向的目标节点编号，如果为有权图，则edge_data数据类型和输入文件中边的权重值相同，否则数据类型为Empty\n\n    使用示例：输出节点vid的所有出度邻居\n*/\nfor (auto & edge : olapondb.OutEdges(vid)) {\n    size_t dst = edge.neighbour;\n    printf(\"src = %lu,dst = %lu\\n\",vid,dst);\n}\n```\n\n### 4.7 获取入边集合\n\n```C++\nAdjList InEdges(size_t vid)\n\n// 使用示例：输出节点vid的所有入度邻居\nfor (auto & edge : olapondb.InEdges(vid)) {\n    size_t dst = edge.neighbour;\n    printf(\"src = %lu,dst = %lu\\n\",vid,dst);\n}\n```\n\n### 4.8 获取TuGraph中节点对应OlapOnDB的节点编号\n\n```C++\nsize_t OriginalVid(size_t vid)\n\n// 备注： TuGraph中输入的节点编号可以是非数字，比如人名等，在生成OlapOnDB子图的时候，会将人名等转化为数字进行后续处理，因此该方法可能不适用于某些特定场景\n```\n\n### 4.9 获取OlapOnDB中节点对应TuGraph的节点编号\n\n```C++\nsize_t MappedVid(size_t original_vid)\n```\n\n### 4.10 活跃点的描述\n\n活跃点指的是在批处理函数中需要处理的点，在本例子中只是输出了活跃点的编号，并且汇总活跃点的数量："
            },
            {
                "content": "```C++\nAdjList InEdges(size_t vid)\n\n// 使用示例：输出节点vid的所有入度邻居\nfor (auto & edge : olapondb.InEdges(vid)) {\n    size_t dst = edge.neighbour;\n    printf(\"src = %lu,dst = %lu\\n\",vid,dst);\n}\n```\n\n### 4.8 获取TuGraph中节点对应OlapOnDB的节点编号\n\n```C++\nsize_t OriginalVid(size_t vid)\n\n// 备注： TuGraph中输入的节点编号可以是非数字，比如人名等，在生成OlapOnDB子图的时候，会将人名等转化为数字进行后续处理，因此该方法可能不适用于某些特定场景\n```\n\n### 4.9 获取OlapOnDB中节点对应TuGraph的节点编号\n\n```C++\nsize_t MappedVid(size_t original_vid)\n```\n\n### 4.10 活跃点的描述\n\n活跃点指的是在批处理函数中需要处理的点，在本例子中只是输出了活跃点的编号，并且汇总活跃点的数量：\n\n```C++\nParallelBitset temp = 000111;\t//当前活跃点为3，4，5号点\n\nsize_t delta = ForEachActiveVertex(\n    //void c\n    [&](size_t vi) {\n        printf(\"active_vertexId = %lu\\n\",vi);\n        return 1;\n    },\n    all_vertices\n);\n```\n\n函数的运行结果显而易见，因为多线程的关系，一下输出顺序可能有所变化：\n\n```\nactive_vertexId = 3\nactive_vertexId = 4\nactive_vertexId = 5\n```\n\n局部返回值均为1，该函数会在保证线程安全的情况下将所有的局部返回值累加得到最终的返回值，并存储在`delta`变量中，该值最终为3"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/2.olap/4.olap-on-disk-api.md",
        "chunks": [
            {
                "content": "# OlapOnDisk API\n\n> 此文档主要详细介绍了OlapOnDisk API的使用说明\n\n    \n## 1. 简介\n\nTuGraph的Standalone模式可用于加载图数据文件，其中图数据文件来源可包含text文本文件、BINARY_FILE二进制文件和ODPS源。在该模式下，TuGraph可实现多数据来源快速加载成图，然后在该图上运行如BFS、WCC、SSSP等迭代式算法，并输出最终结果至终端。\n\n在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。\n\nTuGraph内置了大量的常见图分析算法和丰富的辅助接口，因此用户几乎不需要自己实现具体的图计算过程，只需要在实现自己的存储过程的时候将相应算法库的头文件(.h)包含到自己的程序中，并在编译阶段链接自己的动态库文件即可。\n\n该文档主要介绍了Standalone的常用接口，使用到的辅助函数主要包含在OlapOnDB类。同时为帮助用户理解方便，对BFS算法进行举例说明。\n\n## 2. 算法举例\n\n在这里对BFS算法分块做解释，大体上分为主函数`main`、BFS算法流程`BFSCore`函数和配置类MyConfig。\n\n### 2.1 头文件\n\n```C++\n#include \"olap/olap_on_disk.h\"   \n#include \"tools/json.hpp\"      //使用 TuGraph 时需要包含的头文件\n#include \"./algo.h\"   //包含各种算法逻辑函数的头文件\n```\n\n在使用 TuGraph 实现图数据文件计算应用时，一般首先建立StandaloneGraph类对象graph，将图文件数据加载进graph中，之后通过调用图逻辑函数实现图计算过程，最后对图计算的结果进行打印输出。\n\n### 2.2 配置类MyConfig\n\nMyConfig配置类函数用于提供算法逻辑计算时所需的配置信息，继承于ConfigBase,其中EdgeDate可根据加载图类型不同选择Empty（无权图）、int（带权图权重为整数）或者double（带权图权重为double）类型。\n\nMyConfig配置类一般根据算法不同，需要额外配置信息如下："
            },
            {
                "content": "## 2. 算法举例\n\n在这里对BFS算法分块做解释，大体上分为主函数`main`、BFS算法流程`BFSCore`函数和配置类MyConfig。\n\n### 2.1 头文件\n\n```C++\n#include \"olap/olap_on_disk.h\"   \n#include \"tools/json.hpp\"      //使用 TuGraph 时需要包含的头文件\n#include \"./algo.h\"   //包含各种算法逻辑函数的头文件\n```\n\n在使用 TuGraph 实现图数据文件计算应用时，一般首先建立StandaloneGraph类对象graph，将图文件数据加载进graph中，之后通过调用图逻辑函数实现图计算过程，最后对图计算的结果进行打印输出。\n\n### 2.2 配置类MyConfig\n\nMyConfig配置类函数用于提供算法逻辑计算时所需的配置信息，继承于ConfigBase,其中EdgeDate可根据加载图类型不同选择Empty（无权图）、int（带权图权重为整数）或者double（带权图权重为double）类型。\n\nMyConfig配置类一般根据算法不同，需要额外配置信息如下：\n\n1.算法所需参数\n2.算法名称\n3.配置类内Print函数\n其余公用成员继承与ConfigBase，可参考src/olap/olap_config.h查阅。\n\n```C++\nclass MyConfig : public ConfigBase {\n public:"
            },
            {
                "content": "1.算法所需参数\n2.算法名称\n3.配置类内Print函数\n其余公用成员继承与ConfigBase，可参考src/olap/olap_config.h查阅。\n\n```C++\nclass MyConfig : public ConfigBase {\n public:\n\n    // 算法所需参数初始化\n    size_t root = 0;\n    std::string name = std::string(\"bfs\");\n    void AddParameter(fma_common::Configuration & config) {\n        ConfigBase::AddParameter(config);\n        config.Add(root, \"root\", true)\n                .Comment(\"the root of bfs\");\n    }\n    void Print() {\n        ConfigBase::Print();\n        std::cout << \"  name: \" << name << std::endl;\n        if (root != size_t(-1)) {\n            std::cout << \"  root: \" << root << std::endl;\n        } else {\n            std::cout << \"  root: UNSET\" << std::endl;\n        }\n    }\n    // 配置文件接受命令行参数，该用例会顺次读取命令行调用算法时的参数，优先使用用户指定数值，若用户并未指定则选择默认参数。\n    MyConfig(int &argc, char** &argv): ConfigBase(argc, argv) {\n        fma_common::Configuration config;\n        AddParameter(config);\n        config.ExitAfterHelp(true);\n        config.ParseAndFinalize(argc, argv);\n        Print();\n    }\n};\n```\n\n### 2.3 主函数"
            },
            {
                "content": "### 2.3 主函数\n\n```C++\nint main(int argc, char** argv) {\n    double start_time;\n    // 统计内存消耗类MemUsage实例化\n    MemUsage memUsage;\n    memUsage.startMemRecord();\n\n    // prepare\n    start_time = get_time();\n    // 配置类MyConfig实例化\n    MyConfig config(argc, argv);\n    size_t root_vid = config.root;\n    // OlapOnDisk类实例化\n    OlapOnDisk graph;\n    graph.Load(config, DUAL_DIRECTION);\n    memUsage.print();\n    memUsage.reset();\n    // 统计图加载消耗时间\n    auto prepare_cost = get_time() - start_time;\n    printf(\"prepare_cost = %.2lf(s)\\n\", prepare_cost);\n\n    // core\n    start_time = get_time();\n    // 创建数组用于统计某节点是否遍历过\n    auto parent = graph.AllocVertexArray();\n    // 宽度优先搜索算法，返回图内root_vid根结点连接的节点个数\n    size_t count = BFSCore(graph, root_vid, parent);\n    memUsage.print();\n    memUsage.reset();\n    auto core_cost = get_time() - start_time;\n    printf(\"core_cost = %.2lf(s)\\n\", core_cost);"
            },
            {
                "content": "// core\n    start_time = get_time();\n    // 创建数组用于统计某节点是否遍历过\n    auto parent = graph.AllocVertexArray();\n    // 宽度优先搜索算法，返回图内root_vid根结点连接的节点个数\n    size_t count = BFSCore(graph, root_vid, parent);\n    memUsage.print();\n    memUsage.reset();\n    auto core_cost = get_time() - start_time;\n    printf(\"core_cost = %.2lf(s)\\n\", core_cost);\n\n    // output\n    start_time = get_time();\n    // 打印相关信息至终端\n    printf(\"found_vertices = %ld\\n\", count);\n    auto output_cost = get_time() - start_time;\n    printf(\"output_cost = %.2lf(s)\\n\", output_cost);\n\n    printf(\"total_cost = %.2lf(s)\\n\", prepare_cost + core_cost + output_cost);\n    printf(\"DONE.\");\n\n    return 0;\n}\n```\n\n### 2.4 bfs算法流程\n\n`bfs`主流程有两个输入参数，快照类（子图）还有迭代次数，整体流程可以分为以下几步：\n\n1. 相关定义、数据结构的初始化\n2. 使用批处理函数对每个节点进行循环计算，每一轮找到与当前节点相邻的全部节点，并在该轮次终止时进行交换。\n3. 直到找到全部节点，返回节点个数discovered_vertices。\n\n```C++\nsize_t BFSCore(Graph& graph, size_t root_vid, ParallelVector& parent){"
            },
            {
                "content": "printf(\"total_cost = %.2lf(s)\\n\", prepare_cost + core_cost + output_cost);\n    printf(\"DONE.\");\n\n    return 0;\n}\n```\n\n### 2.4 bfs算法流程\n\n`bfs`主流程有两个输入参数，快照类（子图）还有迭代次数，整体流程可以分为以下几步：\n\n1. 相关定义、数据结构的初始化\n2. 使用批处理函数对每个节点进行循环计算，每一轮找到与当前节点相邻的全部节点，并在该轮次终止时进行交换。\n3. 直到找到全部节点，返回节点个数discovered_vertices。\n\n```C++\nsize_t BFSCore(Graph& graph, size_t root_vid, ParallelVector& parent){\n\n  size_t root = root_vid;\n  auto active_in = graph.AllocVertexSubset();   //分配数组，active_in用于存放上一循环阶段已找到的节点\n  active_in.Add(root);            //把跟节点加入数组中\n  auto active_out = graph.AllocVertexSubset();  //分配数组active_out用于存放当前循环阶段找到的节点\n  parent.Fill((size_t)-1);               //将parent数组中的节点赋值为-1，-1表示未被找到\n  parent[root] = root;\n  size_t num_activations = 1;       //表示当前循环阶段找到的节点个数\n  size_t discovered_vertices = 0;    //表示当前循环阶段找到节点的总个数"
            },
            {
                "content": "for (int ii = 0; num_activations != 0; ii++) {       //num_activations表示当前循环阶段找到的节点个数\n      printf(\"activates(%d) <= %lu\\n\", ii, num_activations);\n      discovered_vertices += num_activations;         //discovered_vertices表示当前循环阶段找到节点的总个数\n      active_out.Clear();\n      num_activations = graph.ProcessVertexActive(\n          [&](size_t vi) {\n              size_t num_activations = 0;\n              for (auto& edge : graph.OutEdges(vi)) {   //每一次循环从根节点出发，查找邻近的相邻节点，对其parent值改变，并num_activations+1操作\n                  size_t dst = edge.neighbour;\n                  if (parent[dst] == (size_t)-1) {\n                      auto lock = graph.GuardVertexLock(dst);\n                      if (parent[dst] == (size_t)-1) {\n                          parent[dst] = vi;\n                          num_activations += 1;\n                          active_out.Add(dst);       //存放当前循环阶段找到的节点\n                      }\n                  }\n              }\n              return num_activations;\n          },\n          active_in);"
            },
            {
                "content": "size_t dst = edge.neighbour;\n                  if (parent[dst] == (size_t)-1) {\n                      auto lock = graph.GuardVertexLock(dst);\n                      if (parent[dst] == (size_t)-1) {\n                          parent[dst] = vi;\n                          num_activations += 1;\n                          active_out.Add(dst);       //存放当前循环阶段找到的节点\n                      }\n                  }\n              }\n              return num_activations;\n          },\n          active_in);\n      active_in.Swap(active_out);\n  }\n  // 返回全部节点数\n  return discovered_vertices;\n}\n```"
            },
            {
                "content": "## 3. 其他常用函数功能描述\n\n### 3.1 图加载\n\nTuGraph-Standalone对于图数据文件的加载来源主要分为三大类：文本文件、二进制文件和ODPS。二进制文件为将边数据的二进制表示按顺序排列的文件，能够节省大量存储空间。其加载函数分为三种，分别是：\n\n- `void Load(ConfigBase config,EdgeDirectionPolicy edge_direction_policy = DUAL_DIRECTION)`：图数据文件的加载方式，包含两个参数，其含义分别表示：\n  - `config`：需要加载的配置参数。该参数内保存了该图的一般信息（如数据来源，算法名称，数据输入、输出路径，点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数。\n  - `edge_direction_policy`：指定图为有向或无向，包含三种模式，分别为DUAL_DIRECTION、MAKE_SYMMETRIC以及INPUT_SYMMETRIC。其中DUAL_DIRECTION为默认的图加载方式。\n  DUAL_DIRECTION : 输入文件为非对称图，加载图为非对称图。\n  MAKE_SYMMETRIC : 输入文件为非对称图，加载图为对称图。\n  INPUT_SYMMETRIC : 输入文件为对称图，加载图为对称图。\n  对应的详细介绍见lgraph文件夹下的olap_config.h文件的`enum EdgeDirectionPolicy`。\n\n- `void LoadVertexArrayTxt(V * array, std::string path, std::function &)> parse_line)`：将文件中的点-数据对按照点id的顺序加载到数组中。各参数表示意义分别为：\n  - `array`：待读入数据的数组\n  - `path`：读取文件的路径，文件中每行表示一对点-数据对\n  - `parse_line`：用户自定义函数，告诉系统如何将一行文本数据解析为一个点-数据对。"
            },
            {
                "content": "- `void LoadVertexArrayTxt(V * array, std::string path, std::function &)> parse_line)`：将文件中的点-数据对按照点id的顺序加载到数组中。各参数表示意义分别为：\n  - `array`：待读入数据的数组\n  - `path`：读取文件的路径，文件中每行表示一对点-数据对\n  - `parse_line`：用户自定义函数，告诉系统如何将一行文本数据解析为一个点-数据对。\n\n\n### 3.2 图写入\n- `void Write(ConfigBase & config, ParallelVector& array, size_t array_size, std::string name, std::function filter_output = filter_output_default)`：把array中数据写回文件中，各参数表示意义分别是：\n  - `config`：需要加载的配置参数。该参数内保存了该图的一般信息（如数据来源，算法名称，数据输入、输出路径，点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数。\n  - `array`：待写入数据的数组\n  - `array_size`：待写入数据的数字长度\n  - `name`：算法名称\n  - `filter_output`：写入数据规则函数，待写入数据需要满足该函数的要求。\n\n### 3.3 图解析函数\n- `std::tuple parse_line_unweighted(const char *p, const char *end, EdgeUnit &e)`：对图数据文件进行解析，加载图为无权图。\n\n- `std::tuple parse_line_weighted(const char* p, const char* end, EdgeUnit& e)`：对图数据文件进行解析，加载图为有权图，权重数据类型可以通过修改指定。\n\n该函数可通过MyConfig类定义时的构造函数parse_line进行指定。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/2.olap/5.python-api.md",
        "chunks": [
            {
                "content": "# Python Olap API\n\n> 本文档主要介绍 OlapBase OlapOnDB 和 OlapOnDisk 在Python中的API用法\n\n\n## 1. 概述\n\n本手册将介绍使用TuGraph图计算系统Python接口需要的简单配置，同时结合代码对TuGraph Python API进行解释。关于ParallelBitset、OlapBase各类的作用，详见olap-base-api.md，olap-on-db-api.md和olap-on-disk-api.md\n\n## 2. 配置要求\n\n如果要使用TuGraph图计算编写以及编译自己的应用程序，需要的配置要求为：\n\n- linux操作系统，目前在Ubuntu16.04, Ubuntu18.04, Ubuntu20.04和Centos7, Centos8系统上可成功运行。\n- 支持C++17的编译器，要求GCC版本为8.4.0或更新的版本。\n- Cython，版本要求3.0.0以上，已测试可运行版本为3.0.0a11\n\n## 3. Cython\nCython是一种高效的编程语言，是Python的超集。Cython能将py文件翻译为C/C++代码后编译为Python拓展类，在Python中通过import调用。在TuGraph中，所有的Python plugin都由Cython编译为Python拓展类后使用。\n\nCython的Pure Python模式在保证Python语法的同时具有C/C++的性能，TuGraph Python接口均使用Cython实现。\n\n[Cython 文档](https://cython.readthedocs.io/en/latest/index.html)\n\n## 4. Olap API\n见procedures/algo_cython/olap_base.pxd文件，用法与功能基本与C++接口相同，olap_base.pxd中声明的接口都由C++实现，在py文件中必须通过`from cython.cimports.olap_base import *`的方式导入，由Cython编译py文件后才能运行。"
            },
            {
                "content": "## 3. Cython\nCython是一种高效的编程语言，是Python的超集。Cython能将py文件翻译为C/C++代码后编译为Python拓展类，在Python中通过import调用。在TuGraph中，所有的Python plugin都由Cython编译为Python拓展类后使用。\n\nCython的Pure Python模式在保证Python语法的同时具有C/C++的性能，TuGraph Python接口均使用Cython实现。\n\n[Cython 文档](https://cython.readthedocs.io/en/latest/index.html)\n\n## 4. Olap API\n见procedures/algo_cython/olap_base.pxd文件，用法与功能基本与C++接口相同，olap_base.pxd中声明的接口都由C++实现，在py文件中必须通过`from cython.cimports.olap_base import *`的方式导入，由Cython编译py文件后才能运行。\n\n### 原子操作\n- `cas[T](ptr: cython.pointer(T), oldv: T, newv: T)-> cython.bint`：如果ptr指向的值等于oldv，则将ptr指向的值赋为newv并返回true，否则返回false\n- `write_min[T](a: cython.pointer(T), b: T)-> cython.bint`：如果b比a指向的值更小，那么将a指向的值赋为b并返回true，否则返回false。\n- `write_max[T](a: cython.pointer(T), b: T)-> cython.bint`：如果b比a指向的值更大，那么将a指向的值赋为b并返回true，否则返回false。\n- `write_add[T](a: cython.pointer(T), b: T)-> cython.bint`：将b的值加到a指向的值上。\n- `write_sub[T](a: cython.pointer(T), b: T)-> cython.bint`：将a指向的值减去b的值。"
            },
            {
                "content": "### 原子操作\n- `cas[T](ptr: cython.pointer(T), oldv: T, newv: T)-> cython.bint`：如果ptr指向的值等于oldv，则将ptr指向的值赋为newv并返回true，否则返回false\n- `write_min[T](a: cython.pointer(T), b: T)-> cython.bint`：如果b比a指向的值更小，那么将a指向的值赋为b并返回true，否则返回false。\n- `write_max[T](a: cython.pointer(T), b: T)-> cython.bint`：如果b比a指向的值更大，那么将a指向的值赋为b并返回true，否则返回false。\n- `write_add[T](a: cython.pointer(T), b: T)-> cython.bint`：将b的值加到a指向的值上。\n- `write_sub[T](a: cython.pointer(T), b: T)-> cython.bint`：将a指向的值减去b的值。\n\n### 点集合类ParallelBitset\n- `Size()-> size_t`：表示Bitmap中的点个数。\n- `ParallelBitset(size: size_t)`：初始化size和data，data长度为(size >> 6)+1\n- `Clear()-> cython.void`：清空集合\n- `Fill()-> cython.void`：将所有点加入集合\n- `Has(size_t i)-> cython.bint`：检查点i是否在集合中\n- `Add(size_t i)-> cython.bint`：将点i加入集合中\n- `Swap(ParallelBitset &other)-> cython.void`：和另一组ParallelBitset集合交换元素"
            },
            {
                "content": "### 点数组类ParallelVector\n- `ParallelVector[T](size_t capacity)` 构建ParallelVector，capacity为点数组的初始容量大小\n- `operator[](i: size_t)-> T`：下标为i的数据\n- `begin()-> cython.pointer(T)`：ParallelVector的起始指针\n- `end()-> cython.pointer(T)`：ParallelVector的结束指针。begin和end的用法类似于vector容器的begin和end指针，可以使用这两个指针对数组进行顺序访问\n- `Back()-> T`：ParallelVector最后一个数据\n- `Data()-> cython.pointer(T)`：表示数组本身数据\n- `Destroy()-> cython.void`：清空ParallelVector数组内数据并删除数组\n- `Size()-> size_t`：表示ParallelVector中的数据个数\n- `Resize(size: size_t)-> cython.void`：更改ParallelVector为size大小，该size应大于等于更改前的大小且小于capacity\n- `Clear()-> cython.void`：清空ParallelVector内数据\n- `ReAlloc(capacity: size_t)-> cython.void`：给ParallelVector分配新的容量大小，若数组有数据则将数据迁移至新内存\n- `Fill(elem: T)-> cython.void`：为ParallelVector的全部数据赋值为elem\n- `Append(elem: T, atomic: cython.bint = true)-> cython.void`：向ParallelVector结尾添加一个数据\n- `Swap(other: ParallelVector[T])-> cython.void`：和其他的ParallelVector交换数据\n- `Copy()-> ParallelVector[T]`：复制当前的ParallelVector数据存至Copy数组中"
            },
            {
                "content": "### 自定义数据结构\n- `Empty`：内容为空的特殊数据类型。\n- `EdgeUnit[EdgeData]`：表示权值类型为EdgeData的边，用于解析输入文件，包含三个成员变量：\n    - `src: size_t`：边的起始点\n    - `dst: size_t`：边的终点\n    - `edge_data: EdgeData`：边的权值\n- `AdjUnit[EdgeData]`：表示权值类型为EdgeData的边，用于批处理计算过程中，包含两个成员变量：\n    - `neighbour: size_t`：边的邻居点\n    - `edge_data: EdgeData`：边的权值\n- `AdjList[EdgeData]`：权值类型为EdgeData的点的邻接表，常用于表示点的入边和出边集合，包含两个成员变量：\n    - `begin()-> cython.pointer(AdjUnit[T])`：列表的起始指针\n    - `end()-> cython.pointer(AdjUnit[T])`：列表的结束指针。\n    - `operator[](i: size_t)-> AdjUnit[EdgeData]`: 下标为i的数据\n\n### 图类OlapBase\n- `NumVertices()-> size_t`：获取点数\n- `NumEdges()-> size_t`：获取边数\n- `OutDegree(size_t vid)-> size_t`：点vid的出度\n- `InDegree(size_t vid)-> size_t`：点vid的入度"
            },
            {
                "content": "### 图类OlapBase\n- `NumVertices()-> size_t`：获取点数\n- `NumEdges()-> size_t`：获取边数\n- `OutDegree(size_t vid)-> size_t`：点vid的出度\n- `InDegree(size_t vid)-> size_t`：点vid的入度\n\n- `AllocVertexArray[VertexData]() ->ParallelVector[VertexData]`：分配一个类型为VertexData的数组，大小为点个数\n- `AllocVertexSubset()-> ParallelBitset`：分配一个ParallelBitset集合，用于表示所有点的状态是否激活\n- `OutEdges(vid: size_t)-> AdjList[EdgeData]`：获取点v的所有出边集合\n- `InEdges(vid: size_t)-> AdjList[EdgeData]`：获取点v的所有入边集合\n- `Transpose()-> cython.void`：对有向图进行图反转\n- `LoadFromArray(edge_array: cython.p_char, input_vertices: size_t, input_edges: size_t, edge_direction_policy: EdgeDirectionPolicy)`：从数组中加载图数据，包含四个参数，其含义分别表示：\n    - `edge_array`：将该数组中的数据读入图，一般情况下该数组包含多条边。\n    - `input_vertices`：指定数组读入图的点个数。\n    - `input_edges`：指定数组读入图的边的条数。\n    - `edge_direction_policy`：指定图为有向或无向，包含三种模式，分别为DUAL_DIRECTION、MAKE_SYMMETRIC以及INPUT_SYMMETRIC。对应的详细介绍见include/lgraph/olap_base.h文件的`enum EdgeDirectionPolicy`。"
            },
            {
                "content": "- `AcquireVertexLock(vid: size_t)-> cython.void`：对点vid加锁，禁止其它线程对该锁对应的点数据进行访存\n- `void ReleaseVertexLock(vid: size_t)-> cython.void`：对点vid解锁，所有线程均可访存该锁对应的点数据\n\nTuGraph提供了两个批处理操作来并行地进行以点为中心的批处理过程，在Python中与C++使用方法稍有不同。\n\n```python\n# 函数名称:ProcessVertexInRange[ReducedSum, Algorithm](\n#           work: (algo: Algorithm, vi: size_t)-> ReducedSum,\n#           lower: size_t, upper: size_t,\n#           algo: Algorithm,\n#           zero: ReducedSum = 0,\n#           reduce: (a: ReducedSum, b: ReducedSum)-> ReducedSum = reduce_plus[ReducedSum])\n#\n#     函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；\n#     第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n#     具体实现请参考include/lgraph/olap_base.h中具体代码\n#\n#     使用示例:统计数组parent数组中有出边的点个数\n\nimport cython\nfrom cython.cimports.olap_base import *\n\n\n@cython.cclass\nclass CountCore:\n    graph: cython. pointer(OlapBase[Empty])\n    parent: ParallelVector[size_t]"
            },
            {
                "content": "import cython\nfrom cython.cimports.olap_base import *\n\n\n@cython.cclass\nclass CountCore:\n    graph: cython. pointer(OlapBase[Empty])\n    parent: ParallelVector[size_t]\n\n    @cython.cfunc\n    @cython.nogil\n    def Work(self, vi: size_t) -> size_t:\n        if self.graph.OutDegree(self.parent[vi]) > 0:\n            return 1\n        return 0\n\n    def run(self, pointer_g: cython. pointer(OlapBase[Empty])):\n        self.graph = pointer_g\n        self.parent = self.graph.AllocVertexArray[size_t]()\n        vertex_num: size_t\n        vertex_num = self.graph.ProcessVertexInRange[size_t, CountCore](self.Work, 0, self.parent.Size(), self)\n        print(\"the number is\", vertex_num)\n\nif __name__ == \"__main__\":\n    count_core = CountCore()\n    count_core.run(cython.address(g))\n```\n其中g为图类OlapBase的实例化对象"
            },
            {
                "content": "def run(self, pointer_g: cython. pointer(OlapBase[Empty])):\n        self.graph = pointer_g\n        self.parent = self.graph.AllocVertexArray[size_t]()\n        vertex_num: size_t\n        vertex_num = self.graph.ProcessVertexInRange[size_t, CountCore](self.Work, 0, self.parent.Size(), self)\n        print(\"the number is\", vertex_num)\n\nif __name__ == \"__main__\":\n    count_core = CountCore()\n    count_core.run(cython.address(g))\n```\n其中g为图类OlapBase的实例化对象\n\n```python\n# 函数名称:ProcessVertexActive[ReducedSum, Algorithm](\n#           work: (algo: Algorithm, vi: size_t)-> ReducedSum,\n#           active: ParallelBitset,\n#           algo: Algorithm,\n#           zero: ReducedSum = 0,\n#           reduce: (a: ReducedSum, b: ReducedSum)-> ReducedSum = reduce_plus[ReducedSum])\n#\n#   函数用途:对active_vertices中对应为1的节点执行work函数，第三个参数表示累加的基数，默认为0；\n#   第四个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n#   具体实现请参考/include/lgraph/olap_base.h中具体代码\n#\n# 使用示例:输出Graph中节点1，2，3的所有出度邻居，并统计这三个节点的总出度"
            },
            {
                "content": "import cython\nfrom cython.cimports.olap_base import *\nfrom cython.cimports.libc.stdio import printf\n\n\n@cython.cclass\nclass NeighborCore:\n    graph: cython.pointer(OlapBase[Empty])\n    active_in: ParallelBitset\n\n    @cython.cfunc\n    @cython.nogil\n    def Work(self, vi: size_t) -> size_t:\n        degree = self.graph.OutDegree(vi)\n        dst: size_t\n        edges = self.graph.OutEdges(vi)\n        local_out_degree: size_t\n        for i in range(degree):\n            dst = edges[i].neighbour\n            printf(\"node %lu has neighbour %lu\\n\", vi, dst)\n            local_out_degree += 1\n        return local_out_degree"
            },
            {
                "content": "@cython.cfunc\n    @cython.nogil\n    def Work(self, vi: size_t) -> size_t:\n        degree = self.graph.OutDegree(vi)\n        dst: size_t\n        edges = self.graph.OutEdges(vi)\n        local_out_degree: size_t\n        for i in range(degree):\n            dst = edges[i].neighbour\n            printf(\"node %lu has neighbour %lu\\n\", vi, dst)\n            local_out_degree += 1\n        return local_out_degree\n\n    def run(self, pointer_g: cython.pointer(OlapBase[Empty])):\n        self.graph = pointer_g\n        self.active_in = self.graph.AllocVertexSubset()\n        self. active_in. Add(1)\n        self. active_in. Add(2)\n        self. active_in. Add(3)\n        total_outdegree = cython.declare(\n            size_t,\n            self.graph.ProcessVertexActive[size_t, CountCore](self.Work, self.active_in, self))\n        printf(\"total outdegree of node1,2,3 is %lu\\n\",total_outdegree)\n\nif __name__ == \"__main__\":\n    neighbor_core = NeighborCore()\n    neighbor_core.run(cython.address(g))\n```"
            },
            {
                "content": "if __name__ == \"__main__\":\n    neighbor_core = NeighborCore()\n    neighbor_core.run(cython.address(g))\n```\n\n如上面两个例子所展示，在Python中ProcessVertexActive与ProcessVertexInRange比在C++中额外需要一个算法类指针参数，Work函数一般也作为该算法类的成员函数，满足Work函数访问成员变量的需求（如图graph，点数组parent），在调用批处理函数时将Work函数和算法类的self指针传入批处理函数。\n\n其中Work函数会在多线程中调用，因此加上修饰器`@cython.nogil`释放Python全局解释锁，在多线程执行的代码中（例如批处理函数中的Work函数，`cython.parallel.prange`中），不能包含Python对象，最好通过`dst: type`或者`dst = cython.declare(type)`的方式声明变量为C/C++类型。\n\n### 图类OlapOnDB:\n并行化创建有向图：\n```python\nolapondb = OlapOnDB[Empty](db, txn, SNAPSHOT_PARALLEL)\n```\n并行化创建无向图\n```python\nolapondb = OlapOnDB[Empty](db, txn, SNAPSHOT_PARALLEL | SNAPSHOT_UNDIRECTED)\n```\nID_MAPPING创建有向图\n```python\nolapondb = OlapOnDB[Empty](db, txn, SNAPSHOT_PARALLEL | SNAPSHOT_IDMAPPING)\n```\n\n### 图类OlapOnDisk\n\n#### ConfigBase：\n- `ConfigBase()`: 构造函数\n- `std::string input_dir`: 图边表数据路径\n- `std::string output_dir`: 输出结果路径\n\n\n- `Load(config: ConfigBase[EdgeData], edge_direction_policy: EdgeDirectionPolicy)-> void`: 读入图数据"
            },
            {
                "content": "### 图类OlapOnDisk\n\n#### ConfigBase：\n- `ConfigBase()`: 构造函数\n- `std::string input_dir`: 图边表数据路径\n- `std::string output_dir`: 输出结果路径\n\n\n- `Load(config: ConfigBase[EdgeData], edge_direction_policy: EdgeDirectionPolicy)-> void`: 读入图数据\n\n\n## 5. lgraph_db API\n见procedures/algo_cython/lgraph_db.pxd与lgraph_db_python.py文件。\n\nlgraph_db.pxd中接口用法与功能基本与C++接口相同，lgraph_db.pxd中声明的接口都由C++实现，在py文件中必须通过`from cython.cimports.olap_base import *`的方式导入，由Cython编译py文件后才能运行。\n\n### VertexIndexIterator\n- `GetVid()-> int64_t`: 获取点的vid\n\n### Galaxy\n- `Galaxy(dir_path: std::string)`: 构造函数，dir_path为db路径\n- `SetCurrentUser(user: std::string, password: std::string)-> cython.void`: 设置用户\n- `SetUser(user: std::string)-> cython.void`: 设置用户\n- `OpenGraph(graph: std::string, read_only: bint)-> GraphDB`: 创建GraphDB\n\n### GraphDB：\n- `CreateReadTxn()-> Transaction`: 创建只读事务\n- `CreateWriteTxn()-> Transaction`: 创建写事务\n- `ForkTxn(txn: Transaction)-> Transaction`: 复制事务，只能复制读事务"
            },
            {
                "content": "### VertexIndexIterator\n- `GetVid()-> int64_t`: 获取点的vid\n\n### Galaxy\n- `Galaxy(dir_path: std::string)`: 构造函数，dir_path为db路径\n- `SetCurrentUser(user: std::string, password: std::string)-> cython.void`: 设置用户\n- `SetUser(user: std::string)-> cython.void`: 设置用户\n- `OpenGraph(graph: std::string, read_only: bint)-> GraphDB`: 创建GraphDB\n\n### GraphDB：\n- `CreateReadTxn()-> Transaction`: 创建只读事务\n- `CreateWriteTxn()-> Transaction`: 创建写事务\n- `ForkTxn(txn: Transaction)-> Transaction`: 复制事务，只能复制读事务\n\n### Transaction：\n```\nGetVertexIndexIterator(\n                label: std::string,\n                field: std::string,\n                key_start: std::string,\n                key_end: std::string)-> VertexIndexIterator\n```\n获取索引迭代器。迭代器的field值为 [key_start, key_end]。所以在key_start=key_end=v时，返回指向field值为v的点的迭代器\n\nlgraph_db_python.py是lgraph_db.pxd中C++类 Galaxy与GraphDB的包装，将C++类包装为Python类，将lgraph_db_python.py编译为Python拓展后，可以直接在Python文件或Python命令行中`import lgraph_db_python`访问lgraph_db_python.PyGraphDB与PyGraphDB.PyGalaxy。"
            },
            {
                "content": "### Transaction：\n```\nGetVertexIndexIterator(\n                label: std::string,\n                field: std::string,\n                key_start: std::string,\n                key_end: std::string)-> VertexIndexIterator\n```\n获取索引迭代器。迭代器的field值为 [key_start, key_end]。所以在key_start=key_end=v时，返回指向field值为v的点的迭代器\n\nlgraph_db_python.py是lgraph_db.pxd中C++类 Galaxy与GraphDB的包装，将C++类包装为Python类，将lgraph_db_python.py编译为Python拓展后，可以直接在Python文件或Python命令行中`import lgraph_db_python`访问lgraph_db_python.PyGraphDB与PyGraphDB.PyGalaxy。\n\n### PyGalaxy:\n- `PyGalaxy(self, dir_path: str)`: 构造函数，dir_path为db路径\n- `SetCurrentUser(self, user: str password: str)-> void`: 设置用户\n- `SetUser(self, user: std::string)-> void`: 设置用户\n- `OpenGraph(self, graph: str, read_only: bool)-> PyGraphDB`: 创建PyGraphDB\n\n### PyGraphDB:\n- `get_pointer(self)-> cython.Py_ssize_t`: C++ 类GraphDB的地址\n\n## 6. 算法插件示例\n下面为Python实现的BFS算法的代码示例：\n```python\n# cython: language_level=3, cpp_locals=True, boundscheck=False, wraparound=False, initializedcheck=False\n# distutils: language = c++"
            },
            {
                "content": "### PyGalaxy:\n- `PyGalaxy(self, dir_path: str)`: 构造函数，dir_path为db路径\n- `SetCurrentUser(self, user: str password: str)-> void`: 设置用户\n- `SetUser(self, user: std::string)-> void`: 设置用户\n- `OpenGraph(self, graph: str, read_only: bool)-> PyGraphDB`: 创建PyGraphDB\n\n### PyGraphDB:\n- `get_pointer(self)-> cython.Py_ssize_t`: C++ 类GraphDB的地址\n\n## 6. 算法插件示例\n下面为Python实现的BFS算法的代码示例：\n```python\n# cython: language_level=3, cpp_locals=True, boundscheck=False, wraparound=False, initializedcheck=False\n# distutils: language = c++\n\n# 注释作用如下：\n# language_level=3: 使用Python3\n# cpp_locals=True: 需要c++17，使用std::optional管理Python代码中的C++对象，可以避免C++对象的拷贝构造\n# boundscheck=False: 关闭索引的边界检查\n# wraparound=False: 关闭负数下标的处理（类似Python List）\n# initializedcheck=False: 关闭检查内存是否初始化，关闭检查后运行性能更快\n# language = c++: 将此py文件翻译为C++而不是C文件，TuGraph使用大量模板函数，所以都应该使用C++\n\nimport json\n\nimport cython\nfrom cython.cimports.olap_base import *\nfrom cython.cimports.lgraph_db import *\n# 从procedures/algo_cython/ 中cimportolap_base.pxd与lgraph_db.pxd, 类似C++中#include \"xxx.h\""
            },
            {
                "content": "# 注释作用如下：\n# language_level=3: 使用Python3\n# cpp_locals=True: 需要c++17，使用std::optional管理Python代码中的C++对象，可以避免C++对象的拷贝构造\n# boundscheck=False: 关闭索引的边界检查\n# wraparound=False: 关闭负数下标的处理（类似Python List）\n# initializedcheck=False: 关闭检查内存是否初始化，关闭检查后运行性能更快\n# language = c++: 将此py文件翻译为C++而不是C文件，TuGraph使用大量模板函数，所以都应该使用C++\n\nimport json\n\nimport cython\nfrom cython.cimports.olap_base import *\nfrom cython.cimports.lgraph_db import *\n# 从procedures/algo_cython/ 中cimportolap_base.pxd与lgraph_db.pxd, 类似C++中#include \"xxx.h\"\n\nfrom cython.cimports.libc.stdio import printf\n# 类似C++中#include \n# 其他常见的还有cython.cimports.libcpp.unordered_map等\n\nimport time"
            },
            {
                "content": "import json\n\nimport cython\nfrom cython.cimports.olap_base import *\nfrom cython.cimports.lgraph_db import *\n# 从procedures/algo_cython/ 中cimportolap_base.pxd与lgraph_db.pxd, 类似C++中#include \"xxx.h\"\n\nfrom cython.cimports.libc.stdio import printf\n# 类似C++中#include \n# 其他常见的还有cython.cimports.libcpp.unordered_map等\n\nimport time\n\n\n@cython.cclass\n# cython.cclass 表示BFSCore为C类型的Class\nclass BFSCore:\n    graph: cython.pointer(OlapBase[Empty])\n    # cython.pointer(OlapBase[Empty])表示OlapBase[Empty]的指针，类似C++中OlapBase[Empty]*\n    # cython提供了常见类型的指针，如cython.p_int, cython.p_char等，表示int*, char*, ...\n    parent: ParallelVector[size_t]\n    active_in: ParallelBitset\n    active_out: ParallelBitset\n    root: size_t\n    # root: size_t 声明root为C++ size_t类型变量，等效于root = cython.declare(size_t)\n    # 不声明类型的变量为Python object类型\n    # 声明变量类型会大幅提高性能，同时在多线程部分，只有C/C++类型的变量可以访问"
            },
            {
                "content": "@cython.cfunc\n    # cython.cfunc 表示Work为C类型的函数，参数与返回值应声明\n    # cfunc性能好，能接受C/C++对象为参数、返回值，但是不能在其他python文件中调用\n    # 类似的有cython.ccall，如Standalone函数，可以在其他python文件中调用\n    @cython.nogil\n    # cython.nogil 表示释放Python全局解释锁，在nogil修饰的部分，不能访问Python对象\n    # 在多线程部分，都应有nogil修饰器\n    @cython.exceptval(check=False)\n    # cython.exceptval(check=False) 表示禁用异常传播，将忽略函数内部引发的Python异常\n    def Work(self, vi: size_t) -> size_t:\n        degree = cython.declare(size_t, self.graph.OutDegree(vi))\n        out_edges = cython.declare(AdjList[Empty], self.graph.OutEdges(vi))\n        i = cython.declare(size_t, 0)\n        local_num_activations = cython.declare(size_t, 0)\n        dst: size_t\n        for i in range(degree):\n            dst = out_edges[i].neighbour\n            if self.parent[dst] == cython.cast(size_t, -1):\n                # parent[dst] == -1 表示dst没有被bfs访问过\n                if self.active_out.Add(dst):\n                    # 将dst设置为为活跃节点；ParallelBitmap.Add为原子操作，防止重复计算\n                    self.parent[dst] = vi"
            },
            {
                "content": "i = cython.declare(size_t, 0)\n        local_num_activations = cython.declare(size_t, 0)\n        dst: size_t\n        for i in range(degree):\n            dst = out_edges[i].neighbour\n            if self.parent[dst] == cython.cast(size_t, -1):\n                # parent[dst] == -1 表示dst没有被bfs访问过\n                if self.active_out.Add(dst):\n                    # 将dst设置为为活跃节点；ParallelBitmap.Add为原子操作，防止重复计算\n                    self.parent[dst] = vi\n                    local_num_activations += 1\n        return local_num_activations"
            },
            {
                "content": "@cython.cfunc\n    @cython.nogil\n    @cython.exceptval(check=False)\n    def run(self, g: cython.pointer(OlapBase[Empty]), r: size_t) -> cython.size_t:\n        self.graph = g\n        self.root = r\n        self.active_in = g.AllocVertexSubset()\n        self.active_out = g.AllocVertexSubset()\n        self.parent = g.AllocVertexArray[size_t]()\n        self.parent.Fill(-1)\n        num_vertices = cython.declare(size_t, self.graph.NumVertices())\n        printf(\"num_vertices = %lu\\n\", num_vertices)\n        self.parent[self.root] = self.root\n        num_activations = cython.declare(size_t, 1)\n        discovered_vertices = cython.declare(size_t, num_activations)\n        self.active_in.Add(self.root)\n        while num_activations > 0:\n            self.active_out.Clear()\n            num_activations = g.ProcessVertexActive[size_t, BFSCore](self.Work, self.active_in, self)\n            discovered_vertices += num_activations\n            self.active_out.Swap(self.active_in)"
            },
            {
                "content": "self.parent[self.root] = self.root\n        num_activations = cython.declare(size_t, 1)\n        discovered_vertices = cython.declare(size_t, num_activations)\n        self.active_in.Add(self.root)\n        while num_activations > 0:\n            self.active_out.Clear()\n            num_activations = g.ProcessVertexActive[size_t, BFSCore](self.Work, self.active_in, self)\n            discovered_vertices += num_activations\n            self.active_out.Swap(self.active_in)\n            printf(\"num_activations = %lu\\n\", num_activations)\n        return discovered_vertices"
            },
            {
                "content": "@cython.cfunc\ndef procedure_process(db: cython.pointer(GraphDB), request: dict, response: dict) -> cython.bint:\n    cost = time.time()\n    root_id = \"0\"\n    label = \"node\"\n    field = \"id\"\n    if \"root\" in request:\n        root_id = request[\"root\"]\n    if \"label\" in request:\n        label = request[\"label\"]\n    if \"field\" in request:\n        field = request[\"field\"]"
            },
            {
                "content": "txn = db.CreateReadTxn()\n    olapondb = OlapOnDB[Empty](db[0], txn, SNAPSHOT_PARALLEL)\n    # 并行创建OlapOnDB\n    # Cython不支持如 *db 的解引用操作，通过db[0]来解引用\n    root_vid = txn.GetVertexIndexIterator(\n        label.encode('utf-8'), field.encode('utf-8'),\n        root_id.encode('utf-8'), root_id.encode('utf-8')\n    ).GetVid()\n    # 通过 GetVertexIndexIterator 根据root节点label名和filed名与filed值（root_id）\n    # 获取root节点的迭代器，通过迭代器获取vid，在无ID_MAPPING时，该vid与OlapOnDB中的id相同\n    cost = time.time() - cost\n    printf(\"prepare_cost = %lf s\\n\", cython.cast(cython.double, cost))\n    a = BFSCore()\n    cost = time.time()\n    count = a.run(cython.address(olapondb), root_vid)\n    cost = time.time() - cost\n    printf(\"core_cost = %lf s\\n\", cython.cast(cython.double, cost))\n    response[\"found_vertices\"] = count\n    response[\"num_vertices\"] = olapondb.NumVertices()\n    response[\"num_edges\"] = olapondb.NumEdges()\n    return True"
            },
            {
                "content": "@cython.ccall\ndef Process(db: lgraph_db_python.PyGraphDB, inp: bytes):\n    # Process为embed模式和procedure模式下插件入口，用cython.ccall修饰\n    # Process函数必须名为Process，参数为lgraph_db_python.PyGraphDB与bytes\n    # 返回值必须为(bool, str)\n    _inp = inp.decode(\"utf-8\")\n    request = json.loads(_inp)\n    response = {}\n    addr = cython.declare(cython.Py_ssize_t, db.get_pointer())\n    # 获取PyGraphDB中GraphDB对象的地址，转换为指针后传递\n    procedure_process(cython.cast(cython.pointer(GraphDB), addr),\n                      request, response)\n    return (True, json.dumps(response))\n\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/2.olap/6.algorithms.md",
        "chunks": [
            {
                "content": "# 内置算法\n\n> 此文档主要详细介绍了TuGraph内置的算法程序，社区版6种算法可参考基础算法报\n\n## 简介\n\nTuGraph目前包含以下6个基础算法28种扩展算法，共34个图算法：\n\n### 基础算法包：\n| 中文算法名 | 英文算法名 | 程序名\n|  :----:  | :----: | :----: |\n| 广度优先搜索 | Breadth-First Search  | bfs \n| 网页排序 | Pagerank | pagerank \n| 单源最短路径 | Single-Source Shortest Path | sssp \n| 弱连通分量 | Weakly Connected Components | wcc \n| 平均集聚系数 | Local Clustering Coefficient  | lcc\n| 标签传播 | Label Propagation Algorithm | lpa"
            },
            {
                "content": "### 扩展算法包：\n| 中文算法名 | 英文算法名 | 程序名\n| :----: | :----: | :----: |\n| 全对最短路径 | All-Pair Shortest Path  | apsp \n| 介数中心度 | Betweenness Centrality | bc \n| 置信度传播 | Belief Propagation | bp\n| 距离中心度 | Closeness Centrality | clce\n| 共同邻居 | Common Neighborhood | cn \n| 度数关联度 | Degree Correlation  | dc\n| 直径估计 | Dimension Estimation | de \n| EgoNet算法 | EgoNet | en\n| 超链接主题搜索 | Hyperlink-Induced Topic Search | hits\n| 杰卡德系数 | Jaccard Index | ji\n| K核算法 | K-core | kcore\n| 鲁汶社区发现 | Louvain | louvain \n| 多源最短路径 | Multiple-source Shortest Paths | mssp\n| 个性化网页排序 | Personalized PageRank | ppr\n| 强连通分量 | Strongly Connected Components | scc \n| 监听标签传播 | Speaker-listener Label Propagation Algorithm | slpa\n| 两点间最短路径 | Single-Pair Shortest Path | spsp\n| 三角计数 | Triangle Counting | triangle \n| 信任指数排名 | Trustrank | trustrank \n| 带权重的标签传播 | Weighted Label Propagation Algorithm | wlpa \n| 带权重的网页排序 | Weighted Pagerank Algorithm | wpagerank \n| 最大独立集算法 | Maximal independent set | mis \n| sybil检测算法 | Sybil Rank | sybilrank"
            },
            {
                "content": "| 多源最短路径 | Multiple-source Shortest Paths | mssp\n| 个性化网页排序 | Personalized PageRank | ppr\n| 强连通分量 | Strongly Connected Components | scc \n| 监听标签传播 | Speaker-listener Label Propagation Algorithm | slpa\n| 两点间最短路径 | Single-Pair Shortest Path | spsp\n| 三角计数 | Triangle Counting | triangle \n| 信任指数排名 | Trustrank | trustrank \n| 带权重的标签传播 | Weighted Label Propagation Algorithm | wlpa \n| 带权重的网页排序 | Weighted Pagerank Algorithm | wpagerank \n| 最大独立集算法 | Maximal independent set | mis \n| sybil检测算法 | Sybil Rank | sybilrank \n| 子图匹配算法 | Subgraph Isomorphism | subgraph_isomorphism\n| 模式匹配算法 | Motif | motif\n| k阶团计数算法 | Kcliques | kcliques\n| k阶桁架计数算法 | Ktruss | ktruss \n| 莱顿算法 | Leiden | leiden"
            },
            {
                "content": "## 基础算法包\n\n### 广度优先搜索\n\n广度优先搜索实现了Breadth-first Search算法，从根点开始，沿着图的宽度遍历所有可访问点。返回结果为遍历点个数。算法内容请参考 [https://en.wikipedia.org/wiki/Breadth-first_search](https://en.wikipedia.org/wiki/Breadth-first_search \"bfs wiki\")。\n\n### 网页排序\n\n网页排序程序实现了常用的Pagerank算法。该算法根据图中边和边权值计算所有点的重要性排名，PageRank值越高，表示该点在图中的重要性越高。计算时以点数量的倒数为各点初始Rank值，然后将点的Rank值按照出边平均传递到相邻点，重复该传递过程直到满足给定的收敛阈值或达到给定迭代轮数。每轮传递结束后，所有点的Rank值会有一定的的比例随机传递到任意点上。算法内容请参考 [https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank \"pagerank wiki\")。\n\n### 单源最短路径\n\n单源最短路径实现了Single Source Shortest Path算法，根据给定的源点，计算从该源点出发到其他任意点的最短路径长度。算法内容请参考 [https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem \"shortest path wiki\")。\n\n### 弱连通分量\n\n弱连通分量程序实现了Weakly Connected Components算法，该算法会计算图中所有的弱连通分量。弱连通分量是图的一个子图，子图中任意两点之间均存在可达路径。算法内容请参考[https://en.wikipedia.org/wiki/Connected_component_(graph_theory)](https://en.wikipedia.org/wiki/Connected_component_(graph_theory) \"scc wiki\")。\n\n### 平均集聚系数"
            },
            {
                "content": "### 单源最短路径\n\n单源最短路径实现了Single Source Shortest Path算法，根据给定的源点，计算从该源点出发到其他任意点的最短路径长度。算法内容请参考 [https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem \"shortest path wiki\")。\n\n### 弱连通分量\n\n弱连通分量程序实现了Weakly Connected Components算法，该算法会计算图中所有的弱连通分量。弱连通分量是图的一个子图，子图中任意两点之间均存在可达路径。算法内容请参考[https://en.wikipedia.org/wiki/Connected_component_(graph_theory)](https://en.wikipedia.org/wiki/Connected_component_(graph_theory) \"scc wiki\")。\n\n### 平均集聚系数\n\n平均集聚系数程序实现了Local Clustering Coefficient算法，计算图中点之间聚集程度的系数。返回结果包括整体集聚系数和点集聚系数。整体集聚系数反映了图中整体的集聚程度的评估，点集聚系数包括任意点的集聚系数，反映了该点附近的集聚程度。集聚系数越高，表示集聚程度越高。算法内容请参考[https://en.wikipedia.org/wiki/Clustering_coefficient](https://en.wikipedia.org/wiki/Clustering_coefficient \"lcc wiki\")。\n\n### 标签传播"
            },
            {
                "content": "### 平均集聚系数\n\n平均集聚系数程序实现了Local Clustering Coefficient算法，计算图中点之间聚集程度的系数。返回结果包括整体集聚系数和点集聚系数。整体集聚系数反映了图中整体的集聚程度的评估，点集聚系数包括任意点的集聚系数，反映了该点附近的集聚程度。集聚系数越高，表示集聚程度越高。算法内容请参考[https://en.wikipedia.org/wiki/Clustering_coefficient](https://en.wikipedia.org/wiki/Clustering_coefficient \"lcc wiki\")。\n\n### 标签传播\n\n标签传播算法程序实现了Label Propagation Algorithm算法。该算法是基于标签传播的社区发现算法，计算对象为无权图。在标签传递时，每个点对收到的所有标签进行次数累加，在累加和最高的标签中随机选择一个。迭代收敛或执行到给定轮数后算法终止。最终输出结果为每个点的标签，标签值相同的点视为在同一社区。算法内容请参考 [https://en.wikipedia.org/wiki/Label_Propagation_Algorithm](https://en.wikipedia.org/wiki/Label_Propagation_Algorithm \"lpa wiki\")。\n\n\n## 扩展算法包\n\n### 全对最短路径\n\n全对最短路径程序实现了All-Pair Shortest Path算法，计算图中任意两点间的最短路径。返回结果为任意存在路径的点对之间的最短路径长度。算法内容请参考[https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm](https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm \"Floyd-Warshall algorighm wiki\")\n\n### 介数中心度"
            },
            {
                "content": "## 扩展算法包\n\n### 全对最短路径\n\n全对最短路径程序实现了All-Pair Shortest Path算法，计算图中任意两点间的最短路径。返回结果为任意存在路径的点对之间的最短路径长度。算法内容请参考[https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm](https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm \"Floyd-Warshall algorighm wiki\")\n\n### 介数中心度\n\n介数中心度程序实现了Betweenness Centrality算法，估算图中所有点的介数中心度值。介数中心度值反映了图中任一最短路径经过该点的可能性，值越高表示有越多的最短路径经过了该点。计算时需给定抽样点个数，分别以这些抽样点为中心进行计算。算法内容请参考[https://en.wikipedia.org/wiki/Betweenness_centrality](https://en.wikipedia.org/wiki/Betweenness_centrality \"bc wiki\")。\n\n### 置信度传播\n\n置信度传播程序实现了Belief Propagation算法。该算法给定已观测点的边缘分布，利用点之间相互传递消息的机制来估算未观测点的边缘分布。算法内容请参考[https://en.wikipedia.org/wiki/Belief_propagation](https://en.wikipedia.org/wiki/Belief_propagation)。\n\n### 距离中心度\n\n距离中心度程序实现了Closeness Centrality算法，估算任意点到图中其他点的最短路径的平均长度。距离中心度越小，表示该点到其他点的平均最短距离最小，意味着该点从几何角度看更位于图的中心位置。计算时需要给定抽样点个数，分别以这些抽样点为中心进行计算。算法内容请参考[https://en.wikipedia.org/wiki/Closeness_centrality](https://en.wikipedia.org/wiki/Closeness_centrality \"clce wiki\")。\n\n### 共同邻居"
            },
            {
                "content": "### 置信度传播\n\n置信度传播程序实现了Belief Propagation算法。该算法给定已观测点的边缘分布，利用点之间相互传递消息的机制来估算未观测点的边缘分布。算法内容请参考[https://en.wikipedia.org/wiki/Belief_propagation](https://en.wikipedia.org/wiki/Belief_propagation)。\n\n### 距离中心度\n\n距离中心度程序实现了Closeness Centrality算法，估算任意点到图中其他点的最短路径的平均长度。距离中心度越小，表示该点到其他点的平均最短距离最小，意味着该点从几何角度看更位于图的中心位置。计算时需要给定抽样点个数，分别以这些抽样点为中心进行计算。算法内容请参考[https://en.wikipedia.org/wiki/Closeness_centrality](https://en.wikipedia.org/wiki/Closeness_centrality \"clce wiki\")。\n\n### 共同邻居\n\n共同邻居程序实现了Common Neighborhood算法，计算任意给定相邻点对之间的共同邻居数量。计算时给定待查询的若干个点对，返回结果为待查询的任意点对的共同邻居数量。\n\n### 度数关联度\n\n度数关联度程序实现了Degree Correlation算法，通过计算任意相邻点对之间的Pearson关联系数来计算图的度数关联度，可用来表征图中高度数点之间关联程度。度数关联度越高，表示图中高度数点之间的关联程度越高。算法内容请参考[https://en.wikipedia.org/wiki/Pearson_correlation_coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient \"dc wiki\")\n\n### 直径估计\n\n直径估计程序实现了Dimension Estimation算法。该算法会计算图中最长的最短路径长度，用来表征图的直径大小。算法内容请参考[http://mathworld.wolfram.com/GraphDiameter.html](http://mathworld.wolfram.com/GraphDiameter.html \"graph diameter\")。"
            },
            {
                "content": "### 度数关联度\n\n度数关联度程序实现了Degree Correlation算法，通过计算任意相邻点对之间的Pearson关联系数来计算图的度数关联度，可用来表征图中高度数点之间关联程度。度数关联度越高，表示图中高度数点之间的关联程度越高。算法内容请参考[https://en.wikipedia.org/wiki/Pearson_correlation_coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient \"dc wiki\")\n\n### 直径估计\n\n直径估计程序实现了Dimension Estimation算法。该算法会计算图中最长的最短路径长度，用来表征图的直径大小。算法内容请参考[http://mathworld.wolfram.com/GraphDiameter.html](http://mathworld.wolfram.com/GraphDiameter.html \"graph diameter\")。\n\n### EgoNet算法\n\nEgoNet算法需要给定根点和K值，以根点为源点进行宽度优先搜索，找出所有K度以内的邻居组成的子图。找到的子图称为根点的EgoNet。\n\n### 超链接主题搜索\n\n超链接主题搜索算法实现了Hyperlink-Induced Topic Search算法，该算法假定每个点具有权威性Authority和枢纽性Hub两个属性，一个好的枢纽点应该指向许多高权威性的点，而一个良好的权威点应该被许多高枢纽型的点指向。算法将返回每个点的权威性值和枢纽性值。算法内容请参考[https://en.wikipedia.org/wiki/HITS_algorithm](https://en.wikipedia.org/wiki/HITS_algorithm \"HITS algorithm\")。\n\n### 杰卡德系数"
            },
            {
                "content": "### EgoNet算法\n\nEgoNet算法需要给定根点和K值，以根点为源点进行宽度优先搜索，找出所有K度以内的邻居组成的子图。找到的子图称为根点的EgoNet。\n\n### 超链接主题搜索\n\n超链接主题搜索算法实现了Hyperlink-Induced Topic Search算法，该算法假定每个点具有权威性Authority和枢纽性Hub两个属性，一个好的枢纽点应该指向许多高权威性的点，而一个良好的权威点应该被许多高枢纽型的点指向。算法将返回每个点的权威性值和枢纽性值。算法内容请参考[https://en.wikipedia.org/wiki/HITS_algorithm](https://en.wikipedia.org/wiki/HITS_algorithm \"HITS algorithm\")。\n\n### 杰卡德系数\n\n杰卡德系数程序实现了Jaccard Index算法。该算法计算了给定点对之间的Jaccard系数，可用来表示这两个点的相似度。Jaccard系数越高，表示点对之间的相似程度越高。计算时给定带查询的若干点对，返回结果为这些点对的Jaccard系数。算法内容请参考[https://en.wikipedia.org/wiki/Jaccard_index](https://en.wikipedia.org/wiki/Jaccard_index \"ji wiki\")。\n\n### k核算法\n\nk核算法实现了k-core算法。该算法计算所有点的核数，或找出图中所有的K核子图。K核子图是一种特殊子图，子图中任意点度数都不小于给定K值。算法内容请参考 [https://en.wikipedia.org/wiki/Degeneracy_(graph_theory)](https://en.wikipedia.org/wiki/Degeneracy_(graph_theory) \"kcore wiki\")。\n\n### 鲁汶社区发现"
            },
            {
                "content": "### 杰卡德系数\n\n杰卡德系数程序实现了Jaccard Index算法。该算法计算了给定点对之间的Jaccard系数，可用来表示这两个点的相似度。Jaccard系数越高，表示点对之间的相似程度越高。计算时给定带查询的若干点对，返回结果为这些点对的Jaccard系数。算法内容请参考[https://en.wikipedia.org/wiki/Jaccard_index](https://en.wikipedia.org/wiki/Jaccard_index \"ji wiki\")。\n\n### k核算法\n\nk核算法实现了k-core算法。该算法计算所有点的核数，或找出图中所有的K核子图。K核子图是一种特殊子图，子图中任意点度数都不小于给定K值。算法内容请参考 [https://en.wikipedia.org/wiki/Degeneracy_(graph_theory)](https://en.wikipedia.org/wiki/Degeneracy_(graph_theory) \"kcore wiki\")。\n\n### 鲁汶社区发现\n\n鲁汶社区发现程序实现了Fast-unfolding算法。该算法是基于模块度的社区发现算法，通过不断合并点社区来最大化图的模块度，能够发现层次性的社区结构。算法内容请参考 [https://en.wikipedia.org/wiki/Louvain_Modularity](https://en.wikipedia.org/wiki/Louvain_Modularity \"louvain modularity wiki\")。\n\n### 多源最短路径\n\n多源最短路径程序实现了Multiple-source Shortest Paths算法，根据给定的多个源点，从这些源点出发，计算到达任意点的最短路径值。其中，多个源点到某一点的最短路径值为分别从每个源点出发到达该点的最短路径的最小值。算法内容请参考 [https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem \"shortest path wiki\")。\n\n### 个性化网页排序"
            },
            {
                "content": "### 鲁汶社区发现\n\n鲁汶社区发现程序实现了Fast-unfolding算法。该算法是基于模块度的社区发现算法，通过不断合并点社区来最大化图的模块度，能够发现层次性的社区结构。算法内容请参考 [https://en.wikipedia.org/wiki/Louvain_Modularity](https://en.wikipedia.org/wiki/Louvain_Modularity \"louvain modularity wiki\")。\n\n### 多源最短路径\n\n多源最短路径程序实现了Multiple-source Shortest Paths算法，根据给定的多个源点，从这些源点出发，计算到达任意点的最短路径值。其中，多个源点到某一点的最短路径值为分别从每个源点出发到达该点的最短路径的最小值。算法内容请参考 [https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem \"shortest path wiki\")。\n\n### 个性化网页排序\n\n个性化网页排序程序实现了Personalized PageRank算法。该算法根据给定的源点，基于该源点个性化计算所有点对于源点的重要性排名。Rank值越高，表示该点对于源点越重要。与PageRank不同的是，初始化时源点Rank值为1，其余点Rank值为0；并且每轮传递结束后，Rank值会有一定的比例随即传递回源点。算法内容请参考 [https://cs.stanford.edu/people/plofgren/Fast-PPR_KDD_Talk.pdf](https://cs.stanford.edu/people/plofgren/Fast-PPR_KDD_Talk.pdf)。\n\n### 强连通分量"
            },
            {
                "content": "### 个性化网页排序\n\n个性化网页排序程序实现了Personalized PageRank算法。该算法根据给定的源点，基于该源点个性化计算所有点对于源点的重要性排名。Rank值越高，表示该点对于源点越重要。与PageRank不同的是，初始化时源点Rank值为1，其余点Rank值为0；并且每轮传递结束后，Rank值会有一定的比例随即传递回源点。算法内容请参考 [https://cs.stanford.edu/people/plofgren/Fast-PPR_KDD_Talk.pdf](https://cs.stanford.edu/people/plofgren/Fast-PPR_KDD_Talk.pdf)。\n\n### 强连通分量\n\n强连通分量程序实现了Strongly Connected Components算法。该算法计算了图中所有的强连通分量，强连通分量是图的一个子图，子图中可从任意点出发到达其他任意点。算法内容请参考[https://en.wikipedia.org/wiki/Strongly_connected_component](https://en.wikipedia.org/wiki/Strongly_connected_component \"scc wiki\")。\n\n### 监听标签传播\n\n监听标签传播算法程序实现了Speaker-listener Label Propagation Algorithm算法。该算法是基于标签传播和历史标签记录的社区发现算法，是对标签传播算法的扩展。与标签传播算法不同的是，本算法会对所有点记录其历史标签，在迭代中对标签进行累加时，会将历史标签也计算在内。最终输出结果为每个点的所有历史标签记录。算法内容请参考论文：“SLPA: Uncovering Overlapping Communities in Social Networks via a Speaker-Listener Interaction Dynamic Process”。\n\n### 两点间最短路径"
            },
            {
                "content": "### 监听标签传播\n\n监听标签传播算法程序实现了Speaker-listener Label Propagation Algorithm算法。该算法是基于标签传播和历史标签记录的社区发现算法，是对标签传播算法的扩展。与标签传播算法不同的是，本算法会对所有点记录其历史标签，在迭代中对标签进行累加时，会将历史标签也计算在内。最终输出结果为每个点的所有历史标签记录。算法内容请参考论文：“SLPA: Uncovering Overlapping Communities in Social Networks via a Speaker-Listener Interaction Dynamic Process”。\n\n### 两点间最短路径\n\n两点间最短路径程序实现了Bidirectional Breadth-First Search算法，在有向无权图上从起点沿着出边做正向宽度优先搜搜，从终点沿着入边做反向宽度优先搜索，通过起点和终点共同遍历到的点来确定从起点到终点的最短路径长度。算法内容请参考[https://en.wikipedia.org/wiki/Bidirectional_search](https://en.wikipedia.org/wiki/Bidirectional_search \"Bidirectional search\")。\n\n### 三角计数\n\n三角计数实现了Triangle-counting算法，计算无向图中的三角形个数，可用来表征图中点的关联程度。三角形数越多，表示图中点的关联程度越高。算法内容请参考论文：“Finding, Counting and Listing All Triangles in Large Graphs, an Experimental Study” 。\n\n### 信任指数排名\n\n信任指数排名算法实现了Trustrank算法，可以根据给定的白名单，计算任意点的信任指数。信任指数越高，表示该点为非法点的可能性越小。算法内容请参考 [https://en.wikipedia.org/wiki/TrustRank](https://en.wikipedia.org/wiki/TrustRank \"trustrank wiki\")。\n\n### 带权重的标签传播"
            },
            {
                "content": "### 三角计数\n\n三角计数实现了Triangle-counting算法，计算无向图中的三角形个数，可用来表征图中点的关联程度。三角形数越多，表示图中点的关联程度越高。算法内容请参考论文：“Finding, Counting and Listing All Triangles in Large Graphs, an Experimental Study” 。\n\n### 信任指数排名\n\n信任指数排名算法实现了Trustrank算法，可以根据给定的白名单，计算任意点的信任指数。信任指数越高，表示该点为非法点的可能性越小。算法内容请参考 [https://en.wikipedia.org/wiki/TrustRank](https://en.wikipedia.org/wiki/TrustRank \"trustrank wiki\")。\n\n### 带权重的标签传播\n\n带权重的标签传播算法程序实现了Weighted Label Propagation Algorithm算法。=与标签传播算法不同的是，标签的传递跟边的权重相关，在标签传递时，每个点会根据标签的入边进行权重累加，在累加和最高的标签中随机选择一个。算法内容请参考 [https://en.wikipedia.org/wiki/Label_Propagation_Algorithm](https://en.wikipedia.org/wiki/Label_Propagation_Algorithm \"lpa wiki\")。\n\n### 带权重的网页排序\n\n带权重的网页排序算法程序实现了Weighted Pagerank算法。与PageRank算法不同的是，Rank值的传递跟边的权重有关，点的Rank值将按照边权重加权传递到相邻点。算法内容请参考[https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank)。\n\n### 最大独立集算法"
            },
            {
                "content": "### 带权重的标签传播\n\n带权重的标签传播算法程序实现了Weighted Label Propagation Algorithm算法。=与标签传播算法不同的是，标签的传递跟边的权重相关，在标签传递时，每个点会根据标签的入边进行权重累加，在累加和最高的标签中随机选择一个。算法内容请参考 [https://en.wikipedia.org/wiki/Label_Propagation_Algorithm](https://en.wikipedia.org/wiki/Label_Propagation_Algorithm \"lpa wiki\")。\n\n### 带权重的网页排序\n\n带权重的网页排序算法程序实现了Weighted Pagerank算法。与PageRank算法不同的是，Rank值的传递跟边的权重有关，点的Rank值将按照边权重加权传递到相邻点。算法内容请参考[https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank)。\n\n### 最大独立集算法\n\n最大独立集算法实现了Maximal independent set算法。最大独立集是指在这个独立集之外没有可以加入它的点。一个图可能有许多大小差异很大的 MIS，算法找出其中一个。算法内容请参考 [https://en.wikipedia.org/wiki/Maximal_independent_set#Sequential_algorithm](https://en.wikipedia.org/wiki/Maximal_independent_set#Sequential_algorithm \"Maximal independent set wiki\")。\n\n### Sybil检测算法\n\nSybil检测算法实现了Sybil Rank算法。SybilRank算法从非Sybil节点开始进行提前终止的随机游走。算法内容请参考论文：“Aiding the Detection of Fake Accounts in Large Scale Social Online Services”。\n\n### 子图匹配算法"
            },
            {
                "content": "### 最大独立集算法\n\n最大独立集算法实现了Maximal independent set算法。最大独立集是指在这个独立集之外没有可以加入它的点。一个图可能有许多大小差异很大的 MIS，算法找出其中一个。算法内容请参考 [https://en.wikipedia.org/wiki/Maximal_independent_set#Sequential_algorithm](https://en.wikipedia.org/wiki/Maximal_independent_set#Sequential_algorithm \"Maximal independent set wiki\")。\n\n### Sybil检测算法\n\nSybil检测算法实现了Sybil Rank算法。SybilRank算法从非Sybil节点开始进行提前终止的随机游走。算法内容请参考论文：“Aiding the Detection of Fake Accounts in Large Scale Social Online Services”。\n\n### 子图匹配算法\n\n子图匹配算法实现了subgraph_isomorphism算法。subgraph_isomorphism算法对全图所有节点匹配子图，最后输出每个节点被匹配的次数。算法内容参考 [https://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=18105](https://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=18105)\n\n### 模式匹配算法\n\n模式匹配算法实现了motif算法。motif算法对指定的节点匹配k阶子图，最后输出每个指定节点每种k阶子图个数，每个k阶子图用一个64位整数表示，整数的第$i \\times k + j$位为1表示子图中有边i->j。算法内容参考 [https://en.wikipedia.org/wiki/Network_motif#mfinder](https://en.wikipedia.org/wiki/Network_motif#mfinder)\n\n### k阶团计数算法"
            },
            {
                "content": "### 子图匹配算法\n\n子图匹配算法实现了subgraph_isomorphism算法。subgraph_isomorphism算法对全图所有节点匹配子图，最后输出每个节点被匹配的次数。算法内容参考 [https://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=18105](https://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=18105)\n\n### 模式匹配算法\n\n模式匹配算法实现了motif算法。motif算法对指定的节点匹配k阶子图，最后输出每个指定节点每种k阶子图个数，每个k阶子图用一个64位整数表示，整数的第$i \\times k + j$位为1表示子图中有边i->j。算法内容参考 [https://en.wikipedia.org/wiki/Network_motif#mfinder](https://en.wikipedia.org/wiki/Network_motif#mfinder)\n\n### k阶团计数算法\n\nk阶团计数算法实现了k-cliques算法。k-cliques算法对计算图中所有的k阶完全子图的个数，最后输出每个节点所在的k阶完全子图个数。算法内容参考 [https://en.wikipedia.org/wiki/Clique_problem#Cliques_of_fixed_size](https://en.wikipedia.org/wiki/Clique_problem#Cliques_of_fixed_size)\n\n### k阶桁架计数算法\n\nk阶桁架计数算法实现了k-truss算法。k-truss指每条边都至少是k-2个三角形的边的子图。k-truss算法找出图的k-truss子图，最后输出每个节点在子图中的邻居节点列表。算法内容参考 [https://louridas.github.io/rwa/assignments/finding-trusses/](https://louridas.github.io/rwa/assignments/finding-trusses/)\n### 莱顿算法"
            },
            {
                "content": "### k阶团计数算法\n\nk阶团计数算法实现了k-cliques算法。k-cliques算法对计算图中所有的k阶完全子图的个数，最后输出每个节点所在的k阶完全子图个数。算法内容参考 [https://en.wikipedia.org/wiki/Clique_problem#Cliques_of_fixed_size](https://en.wikipedia.org/wiki/Clique_problem#Cliques_of_fixed_size)\n\n### k阶桁架计数算法\n\nk阶桁架计数算法实现了k-truss算法。k-truss指每条边都至少是k-2个三角形的边的子图。k-truss算法找出图的k-truss子图，最后输出每个节点在子图中的邻居节点列表。算法内容参考 [https://louridas.github.io/rwa/assignments/finding-trusses/](https://louridas.github.io/rwa/assignments/finding-trusses/)\n### 莱顿算法\n\n莱顿算法实现了了leiden算法。leiden算法是基于模块度的社区发现算法，与louvain算法优势在于leiden算法检测出社区中的断链，保证每个社区具有良好的连通性。算法内容参考 [https://www.nature.com/articles/s41598-019-41695-z#Sec4](https://www.nature.com/articles/s41598-019-41695-z#Sec4)"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/3.learn/1.tutorial.md",
        "chunks": [
            {
                "content": "# Learn Tutorial\n\n> 本文档是为 TuGraph 的用户设计的引导程序，用户在阅读详细的文档之前，应该首先阅读该文档，对 TuGraph 的图学习运行流程有一个大致的了解，之后再阅读详细文档会更加方便。引导程序是基于 Tugraph 的一个简单的程序实例，我们将重点介绍其使用方式。\n\n## 1.TuGraph 图学习模块简介\n图学习是一种机器学习方法，其核心思想是利用图结构中的拓扑信息，通过顶点之间的联系及规律来进行数据分析和建模。不同于传统机器学习方法，图学习利用的数据形式为图结构，其中顶点表示数据中的实体，而边则表示实体之间的关系。通过对这些顶点和边进行特征提取和模式挖掘，可以揭示出数据中深层次的关联和规律，从而用于各种实际应用中。\n\n这个模块是一个基于图数据库的图学习模块，主要提供了四种采样算子：Neighbor Sampling、Edge Sampling、Random Walk Sampling 和 Negative Sampling。这些算子可以用于对图中的顶点和边进行采样，从而生成训练数据。采样过程是在并行计算环境下完成的，具有高效性和可扩展性。\n\n在采样后，我们可以使用得到的训练数据来训练一个模型。该模型可以用于各种图学习任务，比如预测、分类等。通过训练，模型可以学习到图中的顶点和边之间的关系，从而能够对新的顶点和边进行预测和分类。在实际应用中，这个模块可以被用来处理各种大规模的图数据，比如社交网络、推荐系统、生物信息学等。\n\n## 2. 运行流程\nTuGraph 图学习模块将TuGraph中的图数据采样，采样后的顶点和边作为图学习的特征，进行学习训练。运行流程如下图所示：\n![Alt text](../../../../images/learn_flow_chart_zh.png)\n\n## 3.TuGraph编译及数据准备\nTuGraph编译请参考：[编译](../../5.installation&running/6.compile.md)\n在build/output目录下执行：\n```bash\ncp -r ../../test/integration/data/ ./ && cp -r ../../learn/examples/* ./\n```\n\n该指令将数据集相关文件拷贝到build/output目录下。"
            },
            {
                "content": "在采样后，我们可以使用得到的训练数据来训练一个模型。该模型可以用于各种图学习任务，比如预测、分类等。通过训练，模型可以学习到图中的顶点和边之间的关系，从而能够对新的顶点和边进行预测和分类。在实际应用中，这个模块可以被用来处理各种大规模的图数据，比如社交网络、推荐系统、生物信息学等。\n\n## 2. 运行流程\nTuGraph 图学习模块将TuGraph中的图数据采样，采样后的顶点和边作为图学习的特征，进行学习训练。运行流程如下图所示：\n![Alt text](../../../../images/learn_flow_chart_zh.png)\n\n## 3.TuGraph编译及数据准备\nTuGraph编译请参考：[编译](../../5.installation&running/6.compile.md)\n在build/output目录下执行：\n```bash\ncp -r ../../test/integration/data/ ./ && cp -r ../../learn/examples/* ./\n```\n\n该指令将数据集相关文件拷贝到build/output目录下。\n\n## 4. 数据导入\n数据导入请参考[数据导入](../../6.utility-tools/1.data-import.md)\n\n导入过程以cora数据集为例：\n\n在build/output目录下执行\n```bash\n./lgraph_import -c ./data/algo/cora.conf --dir ./coradb --overwrite 1\n```\n其中cora.conf为图schema文件，代表图数据的格式。coradb为导入后的图数据文件名称，代表图数据的存储位置。\n## 5. feature特征转换\n由于图学习中的feature特征一般表示为较长的float类型数组，TuGraph暂不支持float数组类型加载，因此可将其按照string类型导入后，转换成char*方便后续存取，具体实现可参考feature_float.cpp文件。\n具体执行过程如下：\n\n在build目录下编译导入plugin(如果TuGraph已编译可跳过)：\n`make feature_float_embed`"
            },
            {
                "content": "该指令将数据集相关文件拷贝到build/output目录下。\n\n## 4. 数据导入\n数据导入请参考[数据导入](../../6.utility-tools/1.data-import.md)\n\n导入过程以cora数据集为例：\n\n在build/output目录下执行\n```bash\n./lgraph_import -c ./data/algo/cora.conf --dir ./coradb --overwrite 1\n```\n其中cora.conf为图schema文件，代表图数据的格式。coradb为导入后的图数据文件名称，代表图数据的存储位置。\n## 5. feature特征转换\n由于图学习中的feature特征一般表示为较长的float类型数组，TuGraph暂不支持float数组类型加载，因此可将其按照string类型导入后，转换成char*方便后续存取，具体实现可参考feature_float.cpp文件。\n具体执行过程如下：\n\n在build目录下编译导入plugin(如果TuGraph已编译可跳过)：\n`make feature_float_embed`\n\n在build/output目录下执行\n`./algo/feature_float_embed ./coradb`\n即可进行转换。\n## 6. 采样算子及编译\nTuGraph在cython层实现了一种获取全图数据的算子及4种采样算子，具体如下：\n### 6.1.采样算子介绍\n| 采样算子 | 采样方式 |\n| --- | --- |\n| GetDB | 从数据库中获取图数据并转换成所需数据结构 |\n| Neighbor Sampling | 根据给定的顶点采样其邻居顶点，得到采样子图 |\n| Edge Sampling | 根据采样率采样图中的边，得到采样子图 |\n| Random Walk Sampling | 根据给定的顶点，进行随机游走，得到采样子图 |\n| Negative Sampling | 生成不存在边的子图。 |\n\n### 6.2.编译\n如果TuGraph已编译，可跳过此步骤。\n在tugraph-db/build文件夹下执行\n`make -j2`\n\n或在tugraph-db/learn/procedures文件夹下执行\n`python3 setup.py build_ext -i`"
            },
            {
                "content": "在build/output目录下执行\n`./algo/feature_float_embed ./coradb`\n即可进行转换。\n## 6. 采样算子及编译\nTuGraph在cython层实现了一种获取全图数据的算子及4种采样算子，具体如下：\n### 6.1.采样算子介绍\n| 采样算子 | 采样方式 |\n| --- | --- |\n| GetDB | 从数据库中获取图数据并转换成所需数据结构 |\n| Neighbor Sampling | 根据给定的顶点采样其邻居顶点，得到采样子图 |\n| Edge Sampling | 根据采样率采样图中的边，得到采样子图 |\n| Random Walk Sampling | 根据给定的顶点，进行随机游走，得到采样子图 |\n| Negative Sampling | 生成不存在边的子图。 |\n\n### 6.2.编译\n如果TuGraph已编译，可跳过此步骤。\n在tugraph-db/build文件夹下执行\n`make -j2`\n\n或在tugraph-db/learn/procedures文件夹下执行\n`python3 setup.py build_ext -i`\n\n得到算子so后，在Python中import 即可使用。\n\n## 7. 模型训练及保存\nTuGraph在python层调用cython层的算子，实现图学习模型的训练。\n使用 TuGraph 图学习模块使用方式介绍如下:\n在build/output文件夹下执行\n`python3 train_full_cora.py --model_save_path ./cora_model`\n即可进行训练。\n最终打印loss数值小于0.9，即为训练成功。至此，图模型训练完成，模型保存在cora_model文件。\n\n## 8. 模型加载\n```python\nmodel = build_model()\nmodel.load_state_dict(torch.load(model_save_path))\nmodel.eval()\n```\n在使用保存的模型之前，首先需要对其进行加载。代码中，使用如上的代码对已训练模型进行加载。"
            },
            {
                "content": "或在tugraph-db/learn/procedures文件夹下执行\n`python3 setup.py build_ext -i`\n\n得到算子so后，在Python中import 即可使用。\n\n## 7. 模型训练及保存\nTuGraph在python层调用cython层的算子，实现图学习模型的训练。\n使用 TuGraph 图学习模块使用方式介绍如下:\n在build/output文件夹下执行\n`python3 train_full_cora.py --model_save_path ./cora_model`\n即可进行训练。\n最终打印loss数值小于0.9，即为训练成功。至此，图模型训练完成，模型保存在cora_model文件。\n\n## 8. 模型加载\n```python\nmodel = build_model()\nmodel.load_state_dict(torch.load(model_save_path))\nmodel.eval()\n```\n在使用保存的模型之前，首先需要对其进行加载。代码中，使用如上的代码对已训练模型进行加载。\n\n加载之后，我们可以使用模型对新的顶点和边进行预测和分类。在预测时，我们可以输入一个或多个顶点，模型将输出相应的预测结果。在分类时，我们可以将整个图作为输入，模型将对图中的顶点和边进行分类，以实现任务的目标。\n使用已训练的模型可以避免重新训练模型的时间和资源消耗。此外，由于模型已经学习到了图数据中顶点和边之间的关系，它可以很好地适应新的数据，从而提高预测和分类的准确度。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/3.learn/2.sampling_api.md",
        "chunks": [
            {
                "content": "# Sampling API\n\n> 此文档主要详细介绍了Sampling API的使用说明\n\n## 1. 概述\n\n本手册介绍使用TuGraph的Sampling API接口。\n\n## 2. 图数据预处理\n在采样操作之前，根据图数据路径加载图数据，并映射成olapondb图分析类，代码如下：\n\n```python\ngalaxy = PyGalaxy(args.db_path) # 根据路径创建一个galaxy实例\ngalaxy.SetCurrentUser(args.username, args.password) # 设置当前用户\ndb = galaxy.OpenGraph('default', False) # 打开图数据库指定db\ntxn = db.CreateReadTxn() # 创建一个事务实例\nolapondb = PyOlapOnDB('Empty', db, txn) # 根据图加载方式、图数据库实例、事务实例实例化OlapOnDB\ndel txn\ndel db\ndel galaxy\n```\n## 3. 图采样算子介绍\n图采样算子在cython层实现，用于对输入的图进行采样处理，生成的NodeInfo用于保存feature属性、label属性等点信息，EdgeInfo用于保存边信息，这些元数据信息可以被用于特征抽取、网络嵌入等任务中。目前TuGraph图学习模块支持GetDB、NeighborSampling、EdgeSampling、RandomWalkSampling、NegativeSampling五种采样算子。\n### 3.1.RandomWalk算子：\n在给定的采样点周围进行指定次数的随机游走，得到采样子图。"
            },
            {
                "content": "```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_node: list, step: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_node: list类型，采样点列表。\nstep: size_t类型，采样步数。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n### 3.2.NeighborSample算子：\n在给定采样点的一度邻居中采样一定数量的点，得到采样子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_node: list, nei_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_node: list类型，采样点列表。\nnei_num: size_t类型，邻居采样点数。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值: 无。"
            },
            {
                "content": "### 3.2.NeighborSample算子：\n在给定采样点的一度邻居中采样一定数量的点，得到采样子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_node: list, nei_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_node: list类型，采样点列表。\nnei_num: size_t类型，邻居采样点数。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n### 3.3.Nagetive算子：\n采用负采样算法，生成不存在边的子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, num_samples: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nnum_samples: size_t类型，生成不存在边的数量。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值： 无。"
            },
            {
                "content": "### 3.3.Nagetive算子：\n采用负采样算法，生成不存在边的子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, num_samples: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nnum_samples: size_t类型，生成不存在边的数量。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值： 无。\n\n### 3.4.EdgeSampling算子：\n根据边采样率，生成采样边的子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb:lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_rate: double, NodeInfo: list, EdgeInfo: list,EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_rate: double类型，采样率。\nNodeInfo: list类型，一个点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，一个边属性字典的列表，表示边的元数据信息。\n返回值: 无。"
            },
            {
                "content": "### 3.4.EdgeSampling算子：\n根据边采样率，生成采样边的子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb:lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_rate: double, NodeInfo: list, EdgeInfo: list,EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_rate: double类型，采样率。\nNodeInfo: list类型，一个点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，一个边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n### 3.5.GetDB算子：\n从数据库中获取图数据并转换成所需数据结构。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb:lgraph_db_python.PyOlapOnDB, feature_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nNodeInfo: list类型，一个点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，一个边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n## 4. 用户自定义采样算法\n用户也可以通过TuGraph Olap接口实现自定义采样算法，接口文档参见[此处](../2.olap/5.python-api.md)，该文档主要介绍图采样算法使用的相关函数的接口设计。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/3.learn/3.training.md",
        "chunks": [
            {
                "content": "# Training\n\n> 本文档详细介绍了如何使用TuGraph进行图神经网络（GNN）的训练。\n\n## 1. 训练\n使用TuGraph 图学习模块进行训练时，可以分为全图训练和mini-batch训练。\n全图训练即把全图从TuGraph db加载到内存中，再进行GNN的训练。而mini-batch训练则使用上面提到的TuGraph 图学习模块的采样算子，将全图数据进行采样后，再送入训练框架中进行训练。\n## 2. Mini-Batch训练\nMini-Batch训练需要使用TuGraph 图学习模块的采样算子，目前支持Neighbor Sampling、Edge Sampling、Random Walk Sampling和Negative Sampling。\nTuGraph 图学习模块的采样算子进行采样后的结果以List的形式返回。\n下面以Neighbor Sampling为例，介绍如何将采样后的结果，进行格式转换，送入到训练框架中进行训练。\n用户需要提供一个Sample类：\n```python\nclass TuGraphSample(object):\n    def __init__(self, args=None):\n        super(TuGraphSample, self).__init__()\n        self.args = args\n\n    def sample(self, g, seed_nodes):\n        args = self.args\n        # 1. 加载图数据\n        galaxy = PyGalaxy(args.db_path)\n        galaxy.SetCurrentUser(args.username, args.password)\n        db = galaxy.OpenGraph(args.graph_name, False)\n\n        sample_node = seed_nodes.tolist()\n        length = args.randomwalk_length\n        NodeInfo = []\n        EdgeInfo = []"
            },
            {
                "content": "def sample(self, g, seed_nodes):\n        args = self.args\n        # 1. 加载图数据\n        galaxy = PyGalaxy(args.db_path)\n        galaxy.SetCurrentUser(args.username, args.password)\n        db = galaxy.OpenGraph(args.graph_name, False)\n\n        sample_node = seed_nodes.tolist()\n        length = args.randomwalk_length\n        NodeInfo = []\n        EdgeInfo = []\n\n        # 2. 采样方法，结果存储在NodeInfo和EdgeInfo中\n        if args.sample_method == 'randomwalk':\n            randomwalk.Process(db, 100, sample_node, length, NodeInfo, EdgeInfo)\n        elif args.sample_method == 'negative':\n            negativesample.Process(db, 100)\n        else:\n            neighborsample(db, 100, sample_node, args.nbor_sample_num, NodeInfo, EdgeInfo)\n        del db\n        del galaxy"
            },
            {
                "content": "# 2. 采样方法，结果存储在NodeInfo和EdgeInfo中\n        if args.sample_method == 'randomwalk':\n            randomwalk.Process(db, 100, sample_node, length, NodeInfo, EdgeInfo)\n        elif args.sample_method == 'negative':\n            negativesample.Process(db, 100)\n        else:\n            neighborsample(db, 100, sample_node, args.nbor_sample_num, NodeInfo, EdgeInfo)\n        del db\n        del galaxy\n\n        # 3. 对结果进行格式转换，使之符合训练格式\n        remap(EdgeInfo[0], EdgeInfo[1], NodeInfo[0])\n        g = dgl.graph((EdgeInfo[0], EdgeInfo[1]))\n        g.ndata['feat'] = torch.tensor(NodeInfo[1])\n        g.ndata['label'] = torch.tensor(NodeInfo[2])\n        return g\n```\n如代码所示，首先将图数据加载到内存中。然后使用采样算子对图数据进行采样，结果存储在NodeInfo和EdgeInfo中。NodeInfo和EdgeInfo是python list结果，其存储的信息结果如下：\n\n| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |"
            },
            {
                "content": "最后对结果进行格式转换，使之符合训练格式。这里我们使用的是DGL训练框架，因此使用结果数据构造了DGL Graph，最终将DGL Graph返回。\n我们提供TuGraphSample类之后，就可以使用它进行Mini-Batch训练了。\n令DGL的数据加载部分使用TuGraphSample的实例sampler：\n```python\n    sampler = TugraphSample(args)\n    fake_g = construct_graph() # just make dgl happy\n    dataloader = dgl.dataloading.DataLoader(fake_g,\n        torch.arange(train_nids),\n        sampler,\n        batch_size=batch_size,\n        device=device,\n        use_ddp=True,\n        num_workers=0,\n        drop_last=False,\n        )\n```\n使用DGL进行模型训练：\n```python\ndef train(dataloader, model):\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-2, weight_decay=5e-4)\n    model.train()\n    s = time.time()\n    for graph in dataloader:\n        load_time = time.time()\n        graph = dgl.add_self_loop(graph)\n        logits = model(graph, graph.ndata['feat'])\n        loss = loss_fcn(logits, graph.ndata['label'])\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        train_time = time.time()"
            },
            {
                "content": ")\n```\n使用DGL进行模型训练：\n```python\ndef train(dataloader, model):\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-2, weight_decay=5e-4)\n    model.train()\n    s = time.time()\n    for graph in dataloader:\n        load_time = time.time()\n        graph = dgl.add_self_loop(graph)\n        logits = model(graph, graph.ndata['feat'])\n        loss = loss_fcn(logits, graph.ndata['label'])\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        train_time = time.time()\n        print('load time', load_time - s, 'train_time', train_time - load_time)\n        s = time.time()\n    return float(loss)\n```"
            },
            {
                "content": "## 3. 全图训练\nGNN（图神经网络）的全图训练是一种涉及一次处理整个训练数据集的训练。它是 GNN 最简单、最直接的训练方法之一，整个图被视为单个实例。 在全图训练中，整个数据集被加载到内存中，模型在整个图上进行训练。这种类型的训练对于中小型图特别有用，并且主要用于不随时间变化的静态图。\n在算子调用时，使用以下方式：\n```python\ngetdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo)\n```\n获取全图数据，然后将全图送入训练框架中进行训练。\n完整代码：请参考learn/examples/train_full_cora.py。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/9.olap%26procedure/3.learn/4.heterogeneous_graph.md",
        "chunks": [
            {
                "content": "# Heterogeneous Graph\n\n> 本文档介绍如何使用异质图进行训练。\n\n## 1. 异质图简介\n异质图（Heterogeneous Graph）是指由不同类型的节点和边构成的图结构。在异质图中，节点和边可以具有多样化的属性和关系，代表了不同实体以及它们之间的复杂关联。\n\n在异质图中，节点类型可以代表不同的实体，如用户、商品、话题等，而边类型表示不同实体之间的关系，如用户之间的关注关系、用户与商品之间的购买关系等。节点和边可以具有不同的属性。\n\n异质图提供了一种强大的图模型，能够更好地表达和分析具有多种类型实体和复杂关系的现实世界系统。在不同领域的数据分析和应用中，异质图具有广泛的应用前景和研究价值。\n\n## 2. 异质图创建\n在TuGraph中，一个异构图由一系列边关系构成。每个关系由一个字符串三元组定义 (源节点类型, 边类型, 目标节点类型) 。异质图的创建方式与同质图类似，只是在创建图时需要指定字符串三元组定义。如下所示。\n    \n```python\n    olapondb = PyOlapOnDB('Empty', db, txn, [(\"node\", \"edge\", \"node\")])\n```\n其中，第四个参数为异质图的边关系定义，可以通过该参数，指定筛选的异质图点边类型。如果不指定该参数，则默认将全部点边类型的数据进行构图训练。\n\n## 3. 异质图查询接口\n为了方便用户使用，当用户给定第四个参数时，TuGraph提供了查询异质图点边类型的接口。示例如下所示：\n\n### 3.1 点类型查询接口\n```python\nolapondb.ntypes()\n```\n返回值为点类型列表，如['node1', 'node2', 'node3']。\n\n### 3.2 边类型查询接口\n```python\nolapondb.etypes()\n```\n返回值为边类型列表，如['edge1', 'edge2', 'edge3']。\n\n### 3.3 点类型和边类型查询接口\n```python\nolapondb.metagraph()\n```\n返回值为字符串三元组定义 (源节点类型, 边类型, 目标节点类型)，如\n[('node1', 'edge1', 'node2'), ('node2', 'edge2', 'node3')]。"
            },
            {
                "content": "## 3. 异质图查询接口\n为了方便用户使用，当用户给定第四个参数时，TuGraph提供了查询异质图点边类型的接口。示例如下所示：\n\n### 3.1 点类型查询接口\n```python\nolapondb.ntypes()\n```\n返回值为点类型列表，如['node1', 'node2', 'node3']。\n\n### 3.2 边类型查询接口\n```python\nolapondb.etypes()\n```\n返回值为边类型列表，如['edge1', 'edge2', 'edge3']。\n\n### 3.3 点类型和边类型查询接口\n```python\nolapondb.metagraph()\n```\n返回值为字符串三元组定义 (源节点类型, 边类型, 目标节点类型)，如\n[('node1', 'edge1', 'node2'), ('node2', 'edge2', 'node3')]。\n\n## 4. 异质图输出格式\n和同质图相同的是，异质图的采样数据结果也存储在NodeInfo和EdgeInfo中。\n可通过如下方式获取输出数据。\n```python\n    NodeInfo = []\n    EdgeInfo = []\n    getdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo)\n```\n其中getdb为获取全图数据的函数，db为图数据库实例，olapondb为图分析类。feature_len为节点特征长度，NodeInfo和EdgeInfo为输出的节点和边信息。\n\n其存储信息结果如下：\n| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 边类型 | EdgeInfo[2] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n| 顶点类型 | NodeInfo[3] |"
            },
            {
                "content": "## 4. 异质图输出格式\n和同质图相同的是，异质图的采样数据结果也存储在NodeInfo和EdgeInfo中。\n可通过如下方式获取输出数据。\n```python\n    NodeInfo = []\n    EdgeInfo = []\n    getdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo)\n```\n其中getdb为获取全图数据的函数，db为图数据库实例，olapondb为图分析类。feature_len为节点特征长度，NodeInfo和EdgeInfo为输出的节点和边信息。\n\n其存储信息结果如下：\n| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 边类型 | EdgeInfo[2] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n| 顶点类型 | NodeInfo[3] |\n\n## 5. 异质图训练\n异构图训练的目标是学习图中节点和边的表示，以便于进行后续的任务，如节点分类、链接预测、图聚类等。为了实现这一目标，研究者们提出了多种基于图神经网络（Graph Neural Networks，GNNs）的模型。这些模型通过聚合邻居节点的信息来更新节点的表示，进而捕捉图结构中的复杂关系。\n\n由于异构图中包含多种类型的节点和边，因此在设计GNN模型时需要考虑如何处理这些不同类型的信息。一种常见的方法是设计不同的聚合函数来分别处理不同类型的邻居节点。此外，还需要考虑如何将这些不同类型的信息整合到一起，以便于模型能够有效地学习到节点和边的表示。\n\nTuGraph 提供了使用裁剪版ogbn-mag数据集进行异质图训练的方法，可供使用者参考。\n\nTuGraph提供的官方docker中暂未提供异质图训练的环境，因此需要用户自行安装相关依赖包。\n在训练之前需要下载ogb和pandas包，具体安装方式如下：\n```shell\npip3 install ogb\npip3 install pandas==0.24.2\n```\n\n训练代码如下所示："
            },
            {
                "content": "TuGraph提供的官方docker中暂未提供异质图训练的环境，因此需要用户自行安装相关依赖包。\n在训练之前需要下载ogb和pandas包，具体安装方式如下：\n```shell\npip3 install ogb\npip3 install pandas==0.24.2\n```\n\n训练代码如下所示：\n\n```python\ndef train(graph, model, model_save_path):\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-2, weight_decay=5e-4)\n    model.train()\n    s = time.time()\n    load_time = time.time()\n    graph = dgl.add_self_loop(graph)\n    logits = model(graph, graph.ndata['feat'])\n    loss = loss_fcn(logits, graph.ndata['label'])\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n    train_time = time.time()\n    current_loss = float(loss)\n    if model_save_path != \"\":\n        if 'min_loss' not in train.__dict__:\n            train.min_loss = current_loss\n        elif current_loss < train.min_loss:\n            train.min_loss = current_loss\n            model_save_path = 'best_model.pth'\n        torch.save(model.state_dict(), model_save_path)\n    return current_loss\n```\n全部训练代码可参考tugraph/learn/examples/train_full_mag.py文件。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/10.permission/1.privilege.md",
        "chunks": [
            {
                "content": "# 用户权限\n\n## 1.介绍\n\n> TuGraph 的权限是基于角色的访问控制进行管理，定义访问控制的权限分配给角色，角色再分配给用户。\n\n## 2.权限层级\n\n- Global 层：即全局权限，对管理、图操作均有权限；\n- Graph 层：即图级别，对每个图的权限；\n- （仅商业化版本支持）Property 层：即属性级别，对某个属性的权限控制\n\n## 3.权限关键字\n\n目前权限的控制较为简洁\n\n- Global 层目前为 admin 权限，并且预置了 admin 用户；\n\n* Graph 层的操作权限分为四种：none，read，write，full\n  - none：无权限，对于图没有任何操作权限\n  - read：只读权限，对于图只具备读取权限\n  - write：读写权限，对于图不仅具备读取权限，还具备了写入的权限\n  - full：所有权限，对于图不仅具备读写权限，同时也具备删除图、修改图、修改 Schema 等权限\n* （仅商业化版本支持）Property 层的权限分别为：none，read，write\n  - none：无权限，对于该属性没有任何操作权限\n  - read：只读权限，对于该属性只具备读取权限\n  - write：读写权限，对于该属性不仅具备读取权限，还具备了写入的权限\n\n## 4.常用权限操作\n\n### 4.1.用户操作\n\n- 创建用户\n\n```cypher\nCALL dbms.security.createUser(user_name::STRING,password::STRING)\n```\n\n- 删除用户\n\n```cypher\nCALL dbms.security.deleteUser(user_name::STRING)\n```\n\n- 修改当前用户密码\n\n```cypher\nCALL dbms.security.changePassword(current_password::STRING,new_password::STRING)\n```\n\n- 修改指定用户密码\n\n```cypher\n\nCALL dbms.security.changeUserPassword(user_name::STRING,new_password::STRING)\n```\n\n- 禁用/启用用户"
            },
            {
                "content": "## 4.常用权限操作\n\n### 4.1.用户操作\n\n- 创建用户\n\n```cypher\nCALL dbms.security.createUser(user_name::STRING,password::STRING)\n```\n\n- 删除用户\n\n```cypher\nCALL dbms.security.deleteUser(user_name::STRING)\n```\n\n- 修改当前用户密码\n\n```cypher\nCALL dbms.security.changePassword(current_password::STRING,new_password::STRING)\n```\n\n- 修改指定用户密码\n\n```cypher\n\nCALL dbms.security.changeUserPassword(user_name::STRING,new_password::STRING)\n```\n\n- 禁用/启用用户\n\n```cypher\nCALL dbms.security.disableUser(user::STRING,disable::BOOLEAN)\n```\n\n- 列出所有用户\n\n```cypher\nCALL dbms.security.listUsers()\n```\n\n- 列出当前用户信息\n\n```cypher\nCALL dbms.security.showCurrentUser()\n```\n\n- 获取用户详情\n\n```cypher\nCALL dbms.security.getUserInfo(user::STRING)\n```\n\n### 4.2.角色操作\n\n- 创建角色\n\n```cypher\nCALL dbms.security.createRole(role_name::STRING,desc::STRING)\n```\n\n- 删除角色\n\n```cypher\nCALL dbms.security.deleteRole(role_name::STRING\n```\n\n- 列出所有角色\n\n```cypher\nCALL dbms.security.listRoles()\n```\n\n- 禁用/启用角色\n\n```cypher\nCALL dbms.security.disableRole(role::STRING,disable::BOOLEAN)\n```\n\n### 4.3.赋予用户角色\n\n- 新增用户与角色的联系"
            },
            {
                "content": "- 列出当前用户信息\n\n```cypher\nCALL dbms.security.showCurrentUser()\n```\n\n- 获取用户详情\n\n```cypher\nCALL dbms.security.getUserInfo(user::STRING)\n```\n\n### 4.2.角色操作\n\n- 创建角色\n\n```cypher\nCALL dbms.security.createRole(role_name::STRING,desc::STRING)\n```\n\n- 删除角色\n\n```cypher\nCALL dbms.security.deleteRole(role_name::STRING\n```\n\n- 列出所有角色\n\n```cypher\nCALL dbms.security.listRoles()\n```\n\n- 禁用/启用角色\n\n```cypher\nCALL dbms.security.disableRole(role::STRING,disable::BOOLEAN)\n```\n\n### 4.3.赋予用户角色\n\n- 新增用户与角色的联系\n\n```cypher\nCALL dbms.security.addUserRoles(user::STRING,roles::LIST)\n```\n\n- 删除用户与角色的联系\n\nCALL dbms.security.deleteUserRoles(user::STRING,roles::LIST)\n\n- 清空用户角色的关系并重建\n\n```cypher\nCALL dbms.security.rebuildUserRoles(user::STRING,roles::LIST)\n```\n\n### 4.4.角色赋权\n\n- 修改角色对指定图的访问权限\n\n```cypher\nCALL dbms.security.modRoleAccessLevel(role::STRING,access_level::MAP)\n```\n\n示例\n\n```cypher\nCALL dbms.security.modRoleAccessLevel(\"test_role\", {test_graph1:\"FULL\", test_graph2:\"NONE\"})\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/10.permission/2.token.md",
        "chunks": [
            {
                "content": "# Token使用说明\n\n## 1.Token介绍\nJWT（JSON Web Token）是一种用于认证和授权的开放标准。它基于JSON（JavaScript Object Notation）格式，并被设计用于在网络应用之间安全地传输声明（claims）信息。\n\nJWT由三部分组成：头部（Header）、负载（Payload）和签名（Signature）。头部包含了JWT的类型以及所使用的签名算法，负载包含了需要传输的信息，而签名用于验证JWT的完整性和真实性。\n\n在TuGraph中，JWT用于实现无状态的认证和授权机制。当用户登录成功后，服务端会生成一个JWT并将其返回给客户端。客户端在后续的请求中将这个JWT作为身份凭证传递给服务端。服务端收到JWT后，通过验证签名和解析负载中的信息，判断用户的身份和权限，并决定是否允许该请求的执行。\n\n## 2. Token有效期\n\n### 2.1. 浏览器Token交互逻辑\n1. 用户打开浏览器，输入账号密码，并点击登录。\n2. 前端调用登录接口，向后端输入账号和密码。\n3. 后端接收到账号密码后，进行校验，校验成功后，返回Token。\n4. 前端将Token存储在浏览器缓存中，后续请求都要携带此Token。\n5. 如果前端，主动点击登出和关闭页面，前端应主动调用登出接口，向后端传递Token。\n6. 后端接收后，将Token失效，返回状态码200，以及“等出成功”。前端接收到信息后，清空浏览器内存中的Token，并将页面退至登录页。\n7. Token失效（初始设置为24小时），需要用户重新登录。\n\n### 2.3. Token有效期刷新机制\n\nToken有效期存在刷新机制，默认关闭。如果打开后，Token的安全性会更高，实现上则存在两个时间戳。\n\n第一个时间戳`refresh_time`用于判定Token是否过期（默认24小时）：过期后可以调用刷新接口获取新的Token，可以设置为更短的时间，比如1小时。\n\n第二个时间戳`expire_time`为强制过期时间戳（默认24小时）：过期后必须重新登陆。\n\n### 2.4. Token有效期修改\n为了方便开发者自行开发，TuGraph提供了两种方式修改有效期，均需要admin权限。"
            },
            {
                "content": "### 2.3. Token有效期刷新机制\n\nToken有效期存在刷新机制，默认关闭。如果打开后，Token的安全性会更高，实现上则存在两个时间戳。\n\n第一个时间戳`refresh_time`用于判定Token是否过期（默认24小时）：过期后可以调用刷新接口获取新的Token，可以设置为更短的时间，比如1小时。\n\n第二个时间戳`expire_time`为强制过期时间戳（默认24小时）：过期后必须重新登陆。\n\n### 2.4. Token有效期修改\n为了方便开发者自行开发，TuGraph提供了两种方式修改有效期，均需要admin权限。\n\n* 通过接口调用设置。涉及有效期修改的接口`update_token_time`和有效期查询接口`get_token_time`。\n具体可查询[REST接口文档](../7.client-tools/9.restful-api-legacy.md)。\n\n* 通过启动参数设置。server端启动时，添加参数`-unlimited_token 1` 参数可以设置为无期限。可参考[服务运行文档](../5.installation&running/7.tugraph-running.md)。\n\n## 3. 客户端发送Token相关请求介绍\n\n客户端会两种协议处理相关请求，一种是REST，一种是RPC。\n\n### 3.1. REST\n如果客户端使用REST协议（包括Browser浏览器），由于是短链接，在每一次请求中都需要携带Token，过期后需要获取新的Token。\n\n对于自行开发的客户端，若采用REST协议则需要考虑Token的逻辑。\n\n### 3.2. RPC\n如果客户端使用RPC协议（包括官方的C++/Java/Python），使用长连接保持，登陆后不涉及Token操作。\n\n## 4. Token上限\nToken上限是指一个用户最多可以同时拥有的Token数量。为防止无限登陆，Token上限默认为10000。由于Token生成逻辑和时间强相关，每登录一次会生成一个Token进行存储，Token有效期默认为24小时，因此建议登录后不使用的Token及时登出。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/10.permission/3.reset_admin_password.md",
        "chunks": [
            {
                "content": "# 忘记'admin'密码\n> TuGraph 提供了重置密码的功能，当用户忘记管理者账号`admin`密码时，可以通过重置密码的方式来修改密码。\n\n## 1.重置密码\n首先，需要停止TuGraph服务端。如果是容器内部署，需要进入容器中执行如下命令：\n\n```bash\nlgraph_server -c /usr/local/etc/lgraph.json -d stop\n```\n\n再次启动TuGraph服务端时，需要添加如下参数：\n\n```bash\n--reset_admin_password 1\n```\n\n如下所示：\n```bash\nlgraph_server -c /usr/local/etc/lgraph.json --reset_admin_password 1 --log_dir \"\"\n```\n\n这一操作可以使得TuGraph服务端在启动时，重置管理者`admin`的密码为默认密码：`73@TuGraph`。\n密码重置成功会给出相关信息“Reset admin password successfully”并关闭当前服务端进程。\n\n## 2.重启服务\n\n用户需要以正常模式重新启动服务端，然后使用默认账号密码进行登录，登录后重新设置密码即可正常使用。\n重新启动TuGraph服务的命令如下：\n\n```bash\nlgraph_server -c /usr/local/etc/lgraph.json -d start\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/10.permission/4.monitoring.md",
        "chunks": [
            {
                "content": "# 运维监控\n\n> 此文档主要介绍 TuGraph 的可视化运维监控\n\n## 1.设计思路\n\n可视化监控并不是TuGraph自身不可或缺的一部分，因此在设计时将可视化监控作为TuGraph周边生态中的一个应用，来减少和TuGraph数据库的耦合度，以及对于TuGraph自身的影响。TuGraph可视化监控采用目前最火热的开源解决方案，TuGraph Monitor + Prometheus + Grafana来实现。其中TuGraph Monitor作为TuGraph服务的客户端，通过TCP链接向TuGraph服务发起Procedure请求，TuGraph服务在接收到请求后收集自身所在机器的cpu，memory，disk，io，以及请求数量等指标的统计结果进行响应。TuGraph Monitor在接收到TuGraph响应的指标数据后，将数据包装成prometheus需要的格式，保存在内存中，等待Prometheus服务通过http请求获取。Prometheus服务会定期通过http请求从TuGraph Monitor获取封装好的请求数据，按照获取的时间保存在自己的时序数据库中。Grafana可以根据用户的配置，从Prometheus处获取某个时间段内的统计数据，并在web界面上绘制浅显易懂的图形来展示最终结果。整个请求链路中，都采用了主动获取，即PULL的模型，好处之一是它能最大限度的避免数据生产者和数据消费者之间的耦合度，使得开发更简单，好处之二是数据生产者不需要考虑数据消费者的数据处理能力，即使某个消费者的数据处理能力较弱，也不会因为生产者生产数据过快而压垮消费者。主动拉取模型的不足之处在于数据的实时性不够，但在这个场景中，数据并没有很高的实时性要求。\n\n### 1.1.TuGraph\n\nTuGraph数据库提供了收集服务所在机器中磁盘，内存，网络IO，以及查询请求等多种数据信息的能力，并通过标准Procedure方式提供查询。收集数据这一动作仅在有用户通过接口查询时才会发生，避免了在用户不需要TuGraph监控服务所在机器的指标时对用户业务查询请求带来的影响。\n\n### 1.2.TuGraph Monitor"
            },
            {
                "content": "### 1.1.TuGraph\n\nTuGraph数据库提供了收集服务所在机器中磁盘，内存，网络IO，以及查询请求等多种数据信息的能力，并通过标准Procedure方式提供查询。收集数据这一动作仅在有用户通过接口查询时才会发生，避免了在用户不需要TuGraph监控服务所在机器的指标时对用户业务查询请求带来的影响。\n\n### 1.2.TuGraph Monitor\n\nTuGraph Monitor是TuGraph周边生态中的一个工具，它作为TuGraph众多用户中的一个，通过C++ RPC Client与TuGraph进行通信，通过Procedure查询接口来查询TuGraph服务所在机器的性能指标，并将TuGraph返回的结果包装成Prometheus需要的数据模型，等待Prometheus获取。用户可以通过设置查询时间间隔来保证获取监控指标对于业务查询的影响最小化。\n\n### 1.3.Prometheus\n\nPrometheus是一个开源的监控平台，并配备有专属的时序数据库，它会定期通过http请求从TuGraph Monitor服务获取统计指标，并保存在自己的时序数据库中。详细信息请参考官网: [https://prometheus.io/docs/introduction/first_steps](https://prometheus.io/docs/introduction/first_steps)\n\n### 1.4.Grafana\n\nGrafana是一个开源的可视化和分析软件，它可以从包含Prometheus在内的多个数据源中获取数据，并且可以将时序数据库中的数据转换为精美图形和可视化效果的工具。具体信息请参考官网: [https://grafana.com/docs/grafana/v7.5/getting-started/](https://grafana.com/docs/grafana/v7.5/getting-started/)\n\n## 2.部署方案\n\n### 2.1.第一步"
            },
            {
                "content": "### 1.3.Prometheus\n\nPrometheus是一个开源的监控平台，并配备有专属的时序数据库，它会定期通过http请求从TuGraph Monitor服务获取统计指标，并保存在自己的时序数据库中。详细信息请参考官网: [https://prometheus.io/docs/introduction/first_steps](https://prometheus.io/docs/introduction/first_steps)\n\n### 1.4.Grafana\n\nGrafana是一个开源的可视化和分析软件，它可以从包含Prometheus在内的多个数据源中获取数据，并且可以将时序数据库中的数据转换为精美图形和可视化效果的工具。具体信息请参考官网: [https://grafana.com/docs/grafana/v7.5/getting-started/](https://grafana.com/docs/grafana/v7.5/getting-started/)\n\n## 2.部署方案\n\n### 2.1.第一步\n\n启动TuGraph服务，详细方法请参考文档: [https://github.com/TuGraph-db/tugraph-db/blob/master/doc/zh-CN/1.guide/3.quick-start.md](https://github.com/TuGraph-db/tugraph-db/blob/master/doc/zh-CN/1.guide/3.quick-start.md)\n\n### 2.2.第二步\n\n启动TuGraph Monitor工具，启动命令如下：\n\n```shell\n./lgraph_monitor --server_host 127.0.0.1:9091 -u admin -p your_password \\\n\t\t\t--monitor_host 127.0.0.1:9999  --sampling_interval_ms 1000\n```\n\n参数含义如下"
            },
            {
                "content": "## 2.部署方案\n\n### 2.1.第一步\n\n启动TuGraph服务，详细方法请参考文档: [https://github.com/TuGraph-db/tugraph-db/blob/master/doc/zh-CN/1.guide/3.quick-start.md](https://github.com/TuGraph-db/tugraph-db/blob/master/doc/zh-CN/1.guide/3.quick-start.md)\n\n### 2.2.第二步\n\n启动TuGraph Monitor工具，启动命令如下：\n\n```shell\n./lgraph_monitor --server_host 127.0.0.1:9091 -u admin -p your_password \\\n\t\t\t--monitor_host 127.0.0.1:9999  --sampling_interval_ms 1000\n```\n\n参数含义如下\n\n```shell\nAvailable command line options:\n    --server_host       Host on which the tugraph rpc server runs.\n                        Default=127.0.0.1:9091.\n    -u, --user          DB username.\n    -p, --password      DB password.\n    --monitor_host      Host on which the monitor restful server runs.\n                        Default=127.0.0.1:9999.\n    --sampling_interval_ms\n                        sampling interval in millisecond. Default=1.5e2.\n    -h, --help          Print this help message. Default=0.\n```\n\n### 2.3.第三步"
            },
            {
                "content": "### 2.3.第三步\n\n+ 下载符合您机器架构以及系统版本的Prometheus tar包，下载地址: [https://prometheus.io/download/](https://prometheus.io/download/)\n\n+ 解压tar包，命令如下\n\n```shell\ntar -zxvf prometheus-2.37.5.linux-amd64.tar.gz\n```\n\n+ 修改配置文件prometheus.yml，新增如下配置，使其可以抓取TuGraph Monitor包装好的性能数据\n\n```yaml\nscrape_configs:\n  # The job name is added as a label `job=` to any timeseries scraped from this config.\n  - job_name: \"tugraph\"\n\n    # metrics_path defaults to '/metrics'\n    # scheme defaults to 'http'.\n\n    static_configs:\n      - targets: [\"localhost:9111\"]\n```\n\n+ 启动prometheus，具体的启动参数可以通过如下命令获取\n\n```shell\n./prometheus -h\n```\n\n+ 验证prometheus服务是否正常，可以通过web端登陆prometheus服务，查询监控指标resources_report是否已经获取到，能成功查询到数据则正确\n\n### 2.4.第四步\n\n+ 下载符合您机器架构以及系统版本的Grafana安装包，下载地址: [https://grafana.com/grafana/download](https://grafana.com/grafana/download)\n\n+ 安装Grafana，细节请参考: [ https://grafana.com/docs/grafana/v7.5/installation/]( https://grafana.com/docs/grafana/v7.5/installation/)"
            },
            {
                "content": "static_configs:\n      - targets: [\"localhost:9111\"]\n```\n\n+ 启动prometheus，具体的启动参数可以通过如下命令获取\n\n```shell\n./prometheus -h\n```\n\n+ 验证prometheus服务是否正常，可以通过web端登陆prometheus服务，查询监控指标resources_report是否已经获取到，能成功查询到数据则正确\n\n### 2.4.第四步\n\n+ 下载符合您机器架构以及系统版本的Grafana安装包，下载地址: [https://grafana.com/grafana/download](https://grafana.com/grafana/download)\n\n+ 安装Grafana，细节请参考: [ https://grafana.com/docs/grafana/v7.5/installation/]( https://grafana.com/docs/grafana/v7.5/installation/)\n\n+ 启动Grafana，细节请参考: [ https://grafana.com/docs/grafana/v7.5/installation/]( https://grafana.com/docs/grafana/v7.5/installation/)\n\n+ 配置Grafana，首先在数据源设置中配置Prometheus的IP地址，配置完成后可以通过测试连接功能，验证是否成功连接数据源。然后，导入如下模版，并在页面中根据实际情况，修改正确的接口IP和端口。最后可以根据实际情况设置刷新时间和监控时间范围"
            },
            {
                "content": "```json\n{\n  \"annotations\": {\n    \"list\": [\n      {\n        \"builtIn\": 1,\n        \"datasource\": {\n          \"type\": \"grafana\"\n        },\n        \"enable\": true,\n        \"hide\": true,\n        \"iconColor\": \"rgba(0, 211, 255, 1)\",\n        \"name\": \"Annotations & Alerts\",\n        \"target\": {\n          \"limit\": 100,\n          \"matchAny\": false,\n          \"tags\": [],\n          \"type\": \"dashboard\"\n        },\n        \"type\": \"dashboard\"\n      }\n    ]\n  },\n  \"editable\": true,\n  \"fiscalYearStartMonth\": 0,\n  \"graphTooltip\": 0,\n  \"id\": 2,\n  \"links\": [],\n  \"liveNow\": false,\n  \"panels\": [\n    {\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            }\n          },\n          \"mappings\": [],\n          \"unit\": \"kbytes\"\n        },\n        \"overrides\": ["
            },
            {
                "content": "\"id\": 2,\n  \"links\": [],\n  \"liveNow\": false,\n  \"panels\": [\n    {\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            }\n          },\n          \"mappings\": [],\n          \"unit\": \"kbytes\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D {instance=\\\"localhost:7010\\\", job=\\\"TuGraph\\\", resouces_type=\\\"memory\\\", type=\\\"available\\\"}\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"displayName\",\n                \"value\": \"others\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\","
            },
            {
                "content": "\"unit\": \"kbytes\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D {instance=\\\"localhost:7010\\\", job=\\\"TuGraph\\\", resouces_type=\\\"memory\\\", type=\\\"available\\\"}\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"displayName\",\n                \"value\": \"others\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D {__name__=\\\"resources_report\\\", instance=\\\"localhost:7010\\\", job=\\\"TuGraph\\\", resouces_type=\\\"memory\\\", type=\\\"available\\\"}\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-green\",\n                  \"mode\": \"fixed\"\n                }\n              },\n              {\n                \"id\": \"displayName\",\n                \"value\": \"others\"\n              }\n            ]\n          },\n          {"
            },
            {
                "content": "},\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-green\",\n                  \"mode\": \"fixed\"\n                }\n              },\n              {\n                \"id\": \"displayName\",\n                \"value\": \"others\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"others\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-blue\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\","
            },
            {
                "content": "{\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-blue\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 6,\n        \"x\": 0,\n        \"y\": 0\n      },\n      \"id\": 14,\n      \"options\": {\n        \"displayLabels\": [\n          \"name\",\n          \"value\"\n        ],\n        \"legend\": {\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\",\n          \"values\": [\n            \"percent\",\n            \"value\"\n          ]\n        },\n        \"pieType\": \"pie\","
            },
            {
                "content": "}\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 6,\n        \"x\": 0,\n        \"y\": 0\n      },\n      \"id\": 14,\n      \"options\": {\n        \"displayLabels\": [\n          \"name\",\n          \"value\"\n        ],\n        \"legend\": {\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\",\n          \"values\": [\n            \"percent\",\n            \"value\"\n          ]\n        },\n        \"pieType\": \"pie\",\n        \"reduceOptions\": {\n          \"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"self\\\"}\",\n          \"legendFormat\": \"{ {type} }\","
            },
            {
                "content": "\"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"self\\\"}\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"available\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"B\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },"
            },
            {
                "content": "\"range\": true,\n          \"refId\": \"A\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"available\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"B\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"total\\\"}\",\n          \"hide\": true,\n          \"legendFormat\": \"{ {label_name} }\",\n          \"range\": true,\n          \"refId\": \"C\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"__expr__\"\n          },\n          \"expression\": \"$C -$A - $B\",\n          \"hide\": false,\n          \"refId\": \"D\",\n          \"type\": \"math\"\n        }\n      ],\n      \"title\": \"内存\","
            },
            {
                "content": "\"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"total\\\"}\",\n          \"hide\": true,\n          \"legendFormat\": \"{ {label_name} }\",\n          \"range\": true,\n          \"refId\": \"C\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"__expr__\"\n          },\n          \"expression\": \"$C -$A - $B\",\n          \"hide\": false,\n          \"refId\": \"D\",\n          \"type\": \"math\"\n        }\n      ],\n      \"title\": \"内存\",\n      \"type\": \"piechart\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                1000\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],"
            },
            {
                "content": "},\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                1000\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\n  QPS超过1000\",\n        \"name\": \"请求统计 alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": []\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\""
            },
            {
                "content": "},\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\n  QPS超过1000\",\n        \"name\": \"请求统计 alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": []\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 7,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"smooth\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\""
            },
            {
                "content": "\"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 7,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"smooth\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\","
            },
            {
                "content": "\"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \" \"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"write\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-blue\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },"
            },
            {
                "content": "\"value\": 80\n              }\n            ]\n          },\n          \"unit\": \" \"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"write\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-blue\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 12,\n        \"x\": 6,\n        \"y\": 0\n      },\n      \"id\": 4,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\""
            },
            {
                "content": "\"h\": 16,\n        \"w\": 12,\n        \"x\": 6,\n        \"y\": 0\n      },\n      \"id\": 4,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"request\\\",type=~\\\"total|write\\\"}\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 1000,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"请求统计\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"datasource\": {"
            },
            {
                "content": "},\n          \"editorMode\": \"code\",\n          \"expr\": \"{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"request\\\",type=~\\\"total|write\\\"}\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 1000,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"请求统计\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            }\n          },\n          \"mappings\": [],\n          \"unit\": \"decbits\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\""
            },
            {
                "content": "},\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            }\n          },\n          \"mappings\": [],\n          \"unit\": \"decbits\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-red\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"available\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\","
            },
            {
                "content": "\"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-red\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"available\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"displayName\",\n                \"value\": \"other\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"other\"\n            },\n            \"properties\": ["
            },
            {
                "content": "\"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"displayName\",\n                \"value\": \"other\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"other\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 6,\n        \"x\": 18,\n        \"y\": 0\n      },\n      \"id\": 12,\n      \"options\": {\n        \"displayLabels\": [\n          \"name\",\n          \"value\"\n        ],\n        \"legend\": {\n          \"displayMode\": \"table\","
            },
            {
                "content": "{\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 6,\n        \"x\": 18,\n        \"y\": 0\n      },\n      \"id\": 12,\n      \"options\": {\n        \"displayLabels\": [\n          \"name\",\n          \"value\"\n        ],\n        \"legend\": {\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\",\n          \"sortBy\": \"Value\",\n          \"sortDesc\": true,\n          \"values\": [\n            \"value\",\n            \"percent\"\n          ]\n        },\n        \"pieType\": \"pie\",\n        \"reduceOptions\": {\n          \"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\""
            },
            {
                "content": "\"sortBy\": \"Value\",\n          \"sortDesc\": true,\n          \"values\": [\n            \"value\",\n            \"percent\"\n          ]\n        },\n        \"pieType\": \"pie\",\n        \"reduceOptions\": {\n          \"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"exemplar\": false,\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"available\\\"}\",\n          \"format\": \"time_series\",\n          \"instant\": false,\n          \"interval\": \"\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\","
            },
            {
                "content": "},\n          \"editorMode\": \"code\",\n          \"exemplar\": false,\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"available\\\"}\",\n          \"format\": \"time_series\",\n          \"instant\": false,\n          \"interval\": \"\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"self\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"B\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"total\\\"}\",\n          \"hide\": true,"
            },
            {
                "content": "\"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"self\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"B\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"total\\\"}\",\n          \"hide\": true,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"C\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"__expr__\"\n          },\n          \"expression\": \"$C - $A - $B\",\n          \"hide\": false,\n          \"refId\": \"D\",\n          \"type\": \"math\"\n        }\n      ],\n      \"title\": \"磁盘\",\n      \"transformations\": [\n        {\n          \"id\": \"configFromData\",\n          \"options\": {\n            \"applyTo\": {\n              \"id\": \"byFrameRefID\"\n            },"
            },
            {
                "content": "\"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"C\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"__expr__\"\n          },\n          \"expression\": \"$C - $A - $B\",\n          \"hide\": false,\n          \"refId\": \"D\",\n          \"type\": \"math\"\n        }\n      ],\n      \"title\": \"磁盘\",\n      \"transformations\": [\n        {\n          \"id\": \"configFromData\",\n          \"options\": {\n            \"applyTo\": {\n              \"id\": \"byFrameRefID\"\n            },\n            \"configRefId\": \"config\",\n            \"mappings\": []\n          }\n        }\n      ],\n      \"type\": \"piechart\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                90\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\","
            },
            {
                "content": "\"configRefId\": \"config\",\n            \"mappings\": []\n          }\n        }\n      ],\n      \"type\": \"piechart\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                90\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\nCPU使用率超过90%\",\n        \"name\": \"CPU使用率 alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": [\n          {\n          }\n        ]\n      },"
            },
            {
                "content": "\"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\nCPU使用率超过90%\",\n        \"name\": \"CPU使用率 alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": [\n          {\n          }\n        ]\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"description\": \"\",\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 4,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,"
            },
            {
                "content": "\"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"description\": \"\",\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 4,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"linear\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],"
            },
            {
                "content": "\"viz\": false\n            },\n            \"lineInterpolation\": \"linear\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \"percent\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {"
            },
            {
                "content": "\"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \"percent\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"total_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }"
            },
            {
                "content": "\"value\": {\n                  \"fixedColor\": \"light-orange\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"total_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"self\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-green\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"total\"\n            },"
            },
            {
                "content": "]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"self\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-green\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"total\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 14,\n        \"w\": 12,\n        \"x\": 0,\n        \"y\": 16\n      },\n      \"id\": 6,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],"
            },
            {
                "content": "{\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 14,\n        \"w\": 12,\n        \"x\": 0,\n        \"y\": 16\n      },\n      \"id\": 6,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"cpu\\\",type=~\\\"total|self\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,"
            },
            {
                "content": "\"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"cpu\\\",type=~\\\"total|self\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 90,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"CPU使用率\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                10000\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\""
            },
            {
                "content": "}\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 90,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"CPU使用率\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                10000\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\n  磁盘IO超过10MB/S\",\n        \"name\": \"磁盘IO alert\","
            },
            {
                "content": "},\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\n  磁盘IO超过10MB/S\",\n        \"name\": \"磁盘IO alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": []\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 7,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {"
            },
            {
                "content": "\"noDataState\": \"no_data\",\n        \"notifications\": []\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 7,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"smooth\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }"
            },
            {
                "content": "\"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"smooth\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \"bps\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"read\"\n            },"
            },
            {
                "content": "},\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \"bps\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"read\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"super-light-green\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"write\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {"
            },
            {
                "content": "},\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"super-light-green\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"write\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"super-light-red\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 14,\n        \"w\": 12,\n        \"x\": 12,\n        \"y\": 16\n      },\n      \"id\": 2,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {"
            },
            {
                "content": "\"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 14,\n        \"w\": 12,\n        \"x\": 12,\n        \"y\": 16\n      },\n      \"id\": 2,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"builder\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk_rate\\\",type=~\\\"read|write\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\","
            },
            {
                "content": "\"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"builder\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk_rate\\\",type=~\\\"read|write\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 10000,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"磁盘IO\",\n      \"type\": \"timeseries\"\n    }\n  ],\n  \"refresh\": \"\",\n  \"schemaVersion\": 36,\n  \"style\": \"dark\",\n  \"tags\": [],\n  \"templating\": {\n    \"list\": []\n  },\n  \"time\": {\n    \"from\": \"now-24h\",\n    \"to\": \"now\"\n  },\n  \"timepicker\": {\n    \"hidden\": false,\n    \"refresh_intervals\": [\n      \"10s\"\n    ]\n  },\n  \"timezone\": \"\",\n  \"title\": \"TuGraph监控页面\",\n  \"version\": 20,\n  \"weekStart\": \"\"\n}\n```"
            },
            {
                "content": "验证效果，刷新浏览器页面。如果正确显示饼图和折线图，则配置完成。\n\n## 3.未来计划\n\n目前可视化监控只支持单机监控，能监控服务所在机器的cpu，磁盘，网络io，请求qps等性能指标，未来将会实现监控ha集群的功能，也会将更多有意义的指标纳入监控范围"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/10.permission/5.log.md",
        "chunks": [
            {
                "content": "# 日志信息\n\n> 此文档主要介绍 TuGraph 的日志功能。\n\n## 1.简介\n\nTuGraph 保留两种类型的日志：服务器日志和审计日志。服务器日志记录人为可读的服务器状态信息，而审核日志维护服务器上执行的每个操作加密后的信息。\n\n## 2.服务器日志\n\n### 2.1.服务器日志配置项\n\n服务器日志的输出位置可以通过`log_dir`配置指定。服务器日志详细程度可通过`verbose`配置项指定。\n\n`log_dir`配置项默认为空。若`log_dir`配置项为空，则所有日志会输出到控制台(daemon模式下若log_dir配置项为空则不会向console输出任何日志)；若手动指定`log_dir`配置项，则日志文件会生成在对应的路径下面。单个日志文件最大大小为256MB。\n\n`verbose`配置项控制日志的详细程度，从粗到细分为`0, 1, 2`三个等级，默认等级为`1`。等级为`2`时，日志记录最详细，服务器将打印`DEBUG`及以上等级的全部日志信息；等级为`1`时，服务器将仅打印`INFO`等级及以上的主要事件的日志；等级为`0`时，服务器将仅打印`ERROR`等级及以上的错误日志。\n\n### 2.2.服务器日志输出宏使用示例\n\n如果开发者在开发过程中希望在代码中添加日志，可以参考如下示例\n\n```\n#include \"tools/lgraph_log.h\" //添加日志依赖"
            },
            {
                "content": "## 2.服务器日志\n\n### 2.1.服务器日志配置项\n\n服务器日志的输出位置可以通过`log_dir`配置指定。服务器日志详细程度可通过`verbose`配置项指定。\n\n`log_dir`配置项默认为空。若`log_dir`配置项为空，则所有日志会输出到控制台(daemon模式下若log_dir配置项为空则不会向console输出任何日志)；若手动指定`log_dir`配置项，则日志文件会生成在对应的路径下面。单个日志文件最大大小为256MB。\n\n`verbose`配置项控制日志的详细程度，从粗到细分为`0, 1, 2`三个等级，默认等级为`1`。等级为`2`时，日志记录最详细，服务器将打印`DEBUG`及以上等级的全部日志信息；等级为`1`时，服务器将仅打印`INFO`等级及以上的主要事件的日志；等级为`0`时，服务器将仅打印`ERROR`等级及以上的错误日志。\n\n### 2.2.服务器日志输出宏使用示例\n\n如果开发者在开发过程中希望在代码中添加日志，可以参考如下示例\n\n```\n#include \"tools/lgraph_log.h\" //添加日志依赖\n\n\nvoid LogExample() {\n    // 数据库启动阶段已经对日志模块进行了初始化，开发者只需直接调用宏即可\n    // 日志等级分为DEBUG, INFO, WARNING, ERROR, FATAL五个等级\n    LOG_DEBUG() << \"This is a debug level log message.\";\n    LOG_INFO() << \"This is a info level log message.\";\n    LOG_WARN() << \"This is a warning level log message.\";\n    LOG_ERROR() << \"This is a error level log message.\";\n    LOG_FATAL() << \"This is a fatal level log message.\";\n}\n```\n更多用法可以参考test/test_lgraph_log.cpp中的日志宏的使用方法\n\n### 2.3.存储过程日志"
            },
            {
                "content": "```\n#include \"tools/lgraph_log.h\" //添加日志依赖\n\n\nvoid LogExample() {\n    // 数据库启动阶段已经对日志模块进行了初始化，开发者只需直接调用宏即可\n    // 日志等级分为DEBUG, INFO, WARNING, ERROR, FATAL五个等级\n    LOG_DEBUG() << \"This is a debug level log message.\";\n    LOG_INFO() << \"This is a info level log message.\";\n    LOG_WARN() << \"This is a warning level log message.\";\n    LOG_ERROR() << \"This is a error level log message.\";\n    LOG_FATAL() << \"This is a fatal level log message.\";\n}\n```\n更多用法可以参考test/test_lgraph_log.cpp中的日志宏的使用方法\n\n### 2.3.存储过程日志\n\n用户在存储过程的编写过程中可以使用日志功能将所需的调试信息输出到日志中进行查看，辅助开发。调试信息会输出到与服务器日志相同的日志文件中(如未指定`log_dir`则同样输出至console)\n\n#### 2.3.1.cpp存储过程\n请使用2.2中提供的log宏输出调试信息，避免使用cout或者printf等输出方式。具体使用方式可参考如下示例代码（详见`procedures/demo/log_demo.cpp`）\n\n```\n#include \n#include \"lgraph/lgraph.h\"\n#include \"tools/lgraph_log.h\"  // add log dependency\nusing namespace lgraph_api;"
            },
            {
                "content": "### 2.3.存储过程日志\n\n用户在存储过程的编写过程中可以使用日志功能将所需的调试信息输出到日志中进行查看，辅助开发。调试信息会输出到与服务器日志相同的日志文件中(如未指定`log_dir`则同样输出至console)\n\n#### 2.3.1.cpp存储过程\n请使用2.2中提供的log宏输出调试信息，避免使用cout或者printf等输出方式。具体使用方式可参考如下示例代码（详见`procedures/demo/log_demo.cpp`）\n\n```\n#include \n#include \"lgraph/lgraph.h\"\n#include \"tools/lgraph_log.h\"  // add log dependency\nusing namespace lgraph_api;\n\nvoid LogExample() {\n    LOG_DEBUG() << \"This is a debug level log message.\";\n    LOG_INFO() << \"This is a info level log message.\";\n    LOG_WARN() << \"This is a warning level log message.\";\n    LOG_ERROR() << \"This is a error level log message.\";\n}\n\nextern \"C\" bool Process(GraphDB& db, const std::string& request, std::string& response) {\n    response = \"TuGraph log demo\";\n    LogExample();\n    return true;\n}\n```\n将以上示例代码作为存储过程插入数据库并运行后，可以在日志文件中看到相应的日志条目。\n\n#### 2.3.1.python存储过程\n请使用python自带的print输出调试信息，调试信息会在存储过程运行结束后合并为一条WARN等级的日志条目输出至日志文件中。\n\n## 3.审计日志\n\n审核日志记录每个请求和响应，以及发送请求的用户以及收到请求的时间。审核日志只能是打开或关闭状态。可以使用 TuGraph 可视化工具和 REST API 查询结果。"
            },
            {
                "content": "extern \"C\" bool Process(GraphDB& db, const std::string& request, std::string& response) {\n    response = \"TuGraph log demo\";\n    LogExample();\n    return true;\n}\n```\n将以上示例代码作为存储过程插入数据库并运行后，可以在日志文件中看到相应的日志条目。\n\n#### 2.3.1.python存储过程\n请使用python自带的print输出调试信息，调试信息会在存储过程运行结束后合并为一条WARN等级的日志条目输出至日志文件中。\n\n## 3.审计日志\n\n审核日志记录每个请求和响应，以及发送请求的用户以及收到请求的时间。审核日志只能是打开或关闭状态。可以使用 TuGraph 可视化工具和 REST API 查询结果。\n\n开启审计日志需要在配置文件中将`enable_audit_log`参数设置为`true`。配置文件和配置参数说明详见：[数据库运行/服务配置](../../5.installation&running/7.tugraph-running.md)。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/11.quality/1.unit-testing.md",
        "chunks": [
            {
                "content": "# 单元测试\n\n> 该文档是TuGraph的单元测试文档\n\n## 1.简介\n\nTuGraph单元测试采用gtest框架，可以选择一次跑全部test或者制定某些test。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/11.quality/2.integration-testing.md",
        "chunks": [
            {
                "content": "# 集成测试\n\n> 此文档主要介绍 TuGraph 的集成测试框架如何使用\n\n## 1.TuGraph集成测试的意义\n\n在单元测试与功能测试中，有部分用例直接开启galaxy或statemachine来进行测试，这并不是一个完整的流程。在完整的cs架构中，用户请求是通过客户端发往服务端，网络通信是必不可少的，为了避免单元测试不完整带来的bug，针对这种情况，使用集成测试框架进行全链路的完整测试。\n\n## 2.TuGraph集成测试框架\n\nTuGraph采用pytest框架作为自己的集成测试框架，pytest框架作为目前使用最广泛的cs端集成测试框架，以其灵活简单，容易上手，并且支持参数化的使用方式而著称，TuGraph基于pytest提供的功能，抽象出了不同的工具，通过参数来控制各个工具的处理逻辑，以方便大家进行高效的测试代码开发。\n\n更多pytest信息请参考官网: [https://docs.pytest.org/en/7.2.x/getting-started.html](https://docs.pytest.org/en/7.2.x/getting-started.html)\n\n### 2.1.组件描述"
            },
            {
                "content": "| 组件名称            | 组件功能                       | 实现方式                                  |\n|-----------------|----------------------------|---------------------------------------|\n| server          | TuGraph单机服务                | 开启子进程并在子进程中启动服务                       |\n| client          | TuGraph Rpc Client         | 当前进程中开启TuGraph Python Rpc Client发送请求  |\n| importor        | TuGraph Importor           | 开启子进程并在子进程中处理导入请求                     |\n| exportor        | TuGraph Exportor           | 开启子进程并在子进程中处理导出请求                     |\n| backup_binlog   | TuGraph Backup Binlog      | 开启子进程并在子进程中处理备份binlog的请求              |\n| backup_copy_dir | TuGraph Backup             | 开启子进程并在子进程中处理备份完整db的请求                |\n| build_so        | 编译c++动态连接库的组件              | 开启子进程并在子进程中处理gcc编译逻辑                  |\n| copy_snapshot   | TuGraph Copy Snapshot      | 当前进程中处理备份snapshot的请求                  |\n| copydir         | 文件夹拷贝                      | 当前进程中处理文件夹拷贝请求                        |"
            },
            {
                "content": "| backup_binlog   | TuGraph Backup Binlog      | 开启子进程并在子进程中处理备份binlog的请求              |\n| backup_copy_dir | TuGraph Backup             | 开启子进程并在子进程中处理备份完整db的请求                |\n| build_so        | 编译c++动态连接库的组件              | 开启子进程并在子进程中处理gcc编译逻辑                  |\n| copy_snapshot   | TuGraph Copy Snapshot      | 当前进程中处理备份snapshot的请求                  |\n| copydir         | 文件夹拷贝                      | 当前进程中处理文件夹拷贝请求                        |\n| exec            | 执行c++/java可执行文件            | 开启子进程并在子进程中启动C++可执行文件                 |\n| algo            | 执行算法                       | 开启子进程并在子进程中执行算法                       |\n| bash            | 执行bash命令                   | 开启子进程并在子进程中执行bash命令                   |\n| rest            | TuGraph Python Rest Client | 当前进程中开启TuGraph Python Rest Client发送请求 |"
            },
            {
                "content": "### 2.2.组件用法\n\n#### 2.2.1.server\n\n##### 2.2.1.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7072 --rpc_port 9092\",\n             \"cleanup_dir\":[\"./testdb\"]}\n```\n\n##### 2.2.1.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制不同的处理逻辑，函数开始执行前会启动server，函数执行完成后会停止server，并清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\ndef test_server(self, server):\n    pass\n```\n\n#### 2.2.2.client\n\n##### 2.2.2.1.启动参数\n采用python字典传入\n+ host是TuGraph Server的ip和端口\n+ user是TuGraph Server的用户名\n+ password是TuGraph Server 中user对应的密码\n\n```python\nCLIENTOPT = {\"host\":\"127.0.0.1:9092\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.2.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制不同的处理逻辑，函数开始执行前会启动客户端，函数执行结束后会结束客户端"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\ndef test_server(self, server):\n    pass\n```\n\n#### 2.2.2.client\n\n##### 2.2.2.1.启动参数\n采用python字典传入\n+ host是TuGraph Server的ip和端口\n+ user是TuGraph Server的用户名\n+ password是TuGraph Server 中user对应的密码\n\n```python\nCLIENTOPT = {\"host\":\"127.0.0.1:9092\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.2.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制不同的处理逻辑，函数开始执行前会启动客户端，函数执行结束后会结束客户端\n\n```python\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"client\", [CLIENTOPT], indirect=True)\ndef test_client(self, server, client):\n    ret = client.callCypher(\"CALL db.createEdgeLabel('followed', '[]', 'address', string, false, 'date', int32, false)\", \"default\")\n    assert ret[0]\n    ret = client.callCypher(\"CALL db.createEdgeLabel('followed', '[]', 'address', string, false, 'date', int32, false)\", \"default\")\n    assert ret[0] == False\n```\n\n#### 2.2.3.importor"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"client\", [CLIENTOPT], indirect=True)\ndef test_client(self, server, client):\n    ret = client.callCypher(\"CALL db.createEdgeLabel('followed', '[]', 'address', string, false, 'date', int32, false)\", \"default\")\n    assert ret[0]\n    ret = client.callCypher(\"CALL db.createEdgeLabel('followed', '[]', 'address', string, false, 'date', int32, false)\", \"default\")\n    assert ret[0] == False\n```\n\n#### 2.2.3.importor\n\n##### 2.2.3.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nIMPORTOPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./testdb\", \"./.import_tmp\"]}\n```\n\n##### 2.2.3.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制导入不同的数据，函数开始执行前会导入数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录"
            },
            {
                "content": "#### 2.2.3.importor\n\n##### 2.2.3.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nIMPORTOPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./testdb\", \"./.import_tmp\"]}\n```\n\n##### 2.2.3.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制导入不同的数据，函数开始执行前会导入数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"importor\", [IMPORTOPT], indirect=True)\ndef test_importor(self, importor):\n    pass\n```\n\n#### 2.2.4.exportor\n\n##### 2.2.4.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nEXPORT_DEF_OPT = {\"cmd\":\"./lgraph_export -d ./testdb -e ./export/default -g default -u admin -p 73@TuGraph\",\n                  \"cleanup_dir\":[\"./export\"]}\n```\n\n##### 2.2.4.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制导出不同的数据，函数开始执行前会导出数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"importor\", [IMPORTOPT], indirect=True)\ndef test_importor(self, importor):\n    pass\n```\n\n#### 2.2.4.exportor\n\n##### 2.2.4.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nEXPORT_DEF_OPT = {\"cmd\":\"./lgraph_export -d ./testdb -e ./export/default -g default -u admin -p 73@TuGraph\",\n                  \"cleanup_dir\":[\"./export\"]}\n```\n\n##### 2.2.4.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制导出不同的数据，函数开始执行前会导出数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"exportor\", [EXPORT_DEF_OPT], indirect=True)\ndef test_exportor(self, exportor):\n    pass\n```\n\n#### 2.2.5.backup_binlog\n\n##### 2.2.5.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nBINLOGOPT = {\"cmd\" : \"./lgraph_binlog -a restore --host 127.0.0.1 --port 9093 -u admin -p 73@TuGraph -f ./testdb/binlog/*\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.5.2.启动命令"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"exportor\", [EXPORT_DEF_OPT], indirect=True)\ndef test_exportor(self, exportor):\n    pass\n```\n\n#### 2.2.5.backup_binlog\n\n##### 2.2.5.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nBINLOGOPT = {\"cmd\" : \"./lgraph_binlog -a restore --host 127.0.0.1 --port 9093 -u admin -p 73@TuGraph -f ./testdb/binlog/*\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.5.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制备份不同的binlog，函数开始执行前会拷贝binlog到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"backup_binlog\", [BINLOGOPT], indirect=True)\ndef test_backup_binlog(self, backup_binlog):\n    pass\n```\n\n#### 2.2.6.backup_copy_dir\n\n##### 2.2.6.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nBACKUPOPT = {\"cmd\" : \"./lgraph_backup --src ./testdb -dst ./testdb1\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.6.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制备份不同的db，函数开始执行前会拷贝db到指定的目录，函数执行完成后会清理cleanup_dir指定的目录"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"backup_binlog\", [BINLOGOPT], indirect=True)\ndef test_backup_binlog(self, backup_binlog):\n    pass\n```\n\n#### 2.2.6.backup_copy_dir\n\n##### 2.2.6.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nBACKUPOPT = {\"cmd\" : \"./lgraph_backup --src ./testdb -dst ./testdb1\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.6.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制备份不同的db，函数开始执行前会拷贝db到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"backup_copy_dir\", [BACKUPOPT], indirect=True)\ndef test_backup_copy_dir(self, backup_copy_dir):\n\tpass\n```\n\n#### 2.2.7.build_so\n\n##### 2.2.7.1.启动参数\n采用python字典传入\n+ cmd是启动命令，采用python列表传入，可以一次编译多个so\n+ so_name是执行完成后需要清理的so，可以是多个，通过python列表传入"
            },
            {
                "content": "```python\nBACKUPOPT = {\"cmd\" : \"./lgraph_backup --src ./testdb -dst ./testdb1\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.6.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制备份不同的db，函数开始执行前会拷贝db到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"backup_copy_dir\", [BACKUPOPT], indirect=True)\ndef test_backup_copy_dir(self, backup_copy_dir):\n\tpass\n```\n\n#### 2.2.7.build_so\n\n##### 2.2.7.1.启动参数\n采用python字典传入\n+ cmd是启动命令，采用python列表传入，可以一次编译多个so\n+ so_name是执行完成后需要清理的so，可以是多个，通过python列表传入\n\n```python\nBUILDOPT = {\"cmd\":[\"g++ -fno-gnu-unique -fPIC -g --std=c++17 -I ../../include -I ../../deps/install/include -rdynamic -O3 -fopenmp -DNDEBUG -o ./scan_graph.so ../../test/test_procedures/scan_graph.cpp ./liblgraph.so -shared\",\n                       \"g++ -fno-gnu-unique -fPIC -g --std=c++17 -I ../../include -I ../../deps/install/include -rdynamic -O3 -fopenmp -DNDEBUG -o ./sortstr.so ../../test/test_procedures/sortstr.cpp ./liblgraph.so -shared\"],\n                \"so_name\":[\"./scan_graph.so\", \"./sortstr.so\"]}\n```"
            },
            {
                "content": "##### 2.2.7.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制编译不同的so，函数开始执行前会生成so到指定的目录，函数执行完成后会清理so_name列表指定的动态库\n\n```python\n@pytest.mark.parametrize(\"build_so\", [BUILDOPT], indirect=True)\ndef test_build_so(self, build_so):\n    pass\n```\n\n#### 2.2.8.copy_snapshot\n\n##### 2.2.8.1.启动参数\n采用python字典传入\n+ src是原db\n+ dst是拷贝后的snapshot\n\n```python\nCOPYSNAPOPT = {\"src\" : \"./testdb\", \"dst\" : \"./testdb1\"}\n```\n\n##### 2.2.8.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制拷贝不同的snapshot，函数开始执行前会拷贝src中的snapshot到dst指定的目录\n\n```python\n@pytest.mark.parametrize(\"copy_snapshot\", [COPYSNAPOPT], indirect=True)\ndef test_copy_snapshot(self, copy_snapshot):\n    pass\n```\n\n#### 2.2.9.copy_dir\n\n##### 2.2.9.1.启动参数\n采用python字典传入\n+ src是原db\n+ dst是拷贝后的snapshot\n\n```python\nCOPYSNAPOPT = {\"src\" : \"./testdb\", \"dst\" : \"./testdb1\"}\n```\n\n##### 2.2.9.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制拷贝不同的目录，函数开始执行前会拷贝src到dst指定的目录\n\n```python\n@pytest.mark.parametrize(\"copy_dir\", [COPYDIR], indirect=True)\ndef test_copy_dir(self, copy_dir):\n    pass\n```\n\n#### 2.2.10.exec"
            },
            {
                "content": "#### 2.2.9.copy_dir\n\n##### 2.2.9.1.启动参数\n采用python字典传入\n+ src是原db\n+ dst是拷贝后的snapshot\n\n```python\nCOPYSNAPOPT = {\"src\" : \"./testdb\", \"dst\" : \"./testdb1\"}\n```\n\n##### 2.2.9.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制拷贝不同的目录，函数开始执行前会拷贝src到dst指定的目录\n\n```python\n@pytest.mark.parametrize(\"copy_dir\", [COPYDIR], indirect=True)\ndef test_copy_dir(self, copy_dir):\n    pass\n```\n\n#### 2.2.10.exec\n\n##### 2.2.10.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n\n```python\nEXECOPT = {\n        \"cmd\" : \"test_rpc_client/cpp/CppClientTest/build/clienttest\"\n    }\n```\n\n##### 2.2.10.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的逻辑，函数开始执行前会开启子进程执行通过cmd参数传入的命令\n\n```python\n@pytest.mark.parametrize(\"exec\", [EXECOPT], indirect=True)\ndef test_exec(self, exec):\n        pass\n```\n\n#### 2.2.11.algo\n\n##### 2.2.11.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ result是算法预期的执行结果，执行完成会通过实际结果与预期结果进行比较，不同则测试失败\n\n```python\nBFSEMBEDOPT = {\n        \"cmd\" : \"algo/bfs_embed ./testdb\",\n        \"result\" : [\"found_vertices = 3829\"]\n    }\n```"
            },
            {
                "content": "##### 2.2.10.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的逻辑，函数开始执行前会开启子进程执行通过cmd参数传入的命令\n\n```python\n@pytest.mark.parametrize(\"exec\", [EXECOPT], indirect=True)\ndef test_exec(self, exec):\n        pass\n```\n\n#### 2.2.11.algo\n\n##### 2.2.11.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ result是算法预期的执行结果，执行完成会通过实际结果与预期结果进行比较，不同则测试失败\n\n```python\nBFSEMBEDOPT = {\n        \"cmd\" : \"algo/bfs_embed ./testdb\",\n        \"result\" : [\"found_vertices = 3829\"]\n    }\n```\n\n##### 2.2.11.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的算法逻辑，函数开始执行前会开启子进程执行通过cmd参数传入的算法，函数主体等待算法执行完成后对比结果\n\n```python\n@pytest.mark.parametrize(\"algo\", [BFSEMBEDOPT], indirect=True)\ndef test_exec_bfs_embed(self, algo):\n    pass\n```\n\n#### 2.2.12.bash\n\n##### 2.2.12.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n\n```python\nBASHOPT = {\n        \"cmd\" : \"sh ./test_rpc_client/cpp/CppClientTest/compile.sh\"\n    }\n```\n\n##### 2.2.12.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的bash命令，函数开始执行前会开启子进程执行通过cmd参数传入的bash命令，函数主体等待算法执行完成"
            },
            {
                "content": "##### 2.2.11.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的算法逻辑，函数开始执行前会开启子进程执行通过cmd参数传入的算法，函数主体等待算法执行完成后对比结果\n\n```python\n@pytest.mark.parametrize(\"algo\", [BFSEMBEDOPT], indirect=True)\ndef test_exec_bfs_embed(self, algo):\n    pass\n```\n\n#### 2.2.12.bash\n\n##### 2.2.12.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n\n```python\nBASHOPT = {\n        \"cmd\" : \"sh ./test_rpc_client/cpp/CppClientTest/compile.sh\"\n    }\n```\n\n##### 2.2.12.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的bash命令，函数开始执行前会开启子进程执行通过cmd参数传入的bash命令，函数主体等待算法执行完成\n\n```python\n@pytest.mark.parametrize(\"bash\", [BASHOPT], indirect=True)\ndef test_bash(self, bash):\n    pass\n```\n\n#### 2.2.13.rest\n\n##### 2.2.13.1.启动参数\n采用python字典传入\n+ port是TuGraph Server的端口\n+ user是TuGraph Server的用户名\n+ password是TuGraph Server 中user对应的密码\n\n\n```python\nRESTTOPT = {\"port\":\"7073\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.13.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来链接不同的TuGraph Rest Server，函数开始执行前会启动客户端，函数执行结束后会结束客户端"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"bash\", [BASHOPT], indirect=True)\ndef test_bash(self, bash):\n    pass\n```\n\n#### 2.2.13.rest\n\n##### 2.2.13.1.启动参数\n采用python字典传入\n+ port是TuGraph Server的端口\n+ user是TuGraph Server的用户名\n+ password是TuGraph Server 中user对应的密码\n\n\n```python\nRESTTOPT = {\"port\":\"7073\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.13.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来链接不同的TuGraph Rest Server，函数开始执行前会启动客户端，函数执行结束后会结束客户端\n\n```python\n@pytest.mark.parametrize(\"rest\", [RESTTOPT], indirect=True)\ndef test_get_info(self, server, rest):\n\tpass\n```\n\n### 2.3.测试样例\n\n#### 2.3.1.rest\n\n样例代码中在test_get_info函数执行之前先启动server，server启动后启动了rest client，进入test_get_info函数后获取server的一些信息，并通过assert判断是否有获取到cpu的信息。"
            },
            {
                "content": "```python\nRESTTOPT = {\"port\":\"7073\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.13.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来链接不同的TuGraph Rest Server，函数开始执行前会启动客户端，函数执行结束后会结束客户端\n\n```python\n@pytest.mark.parametrize(\"rest\", [RESTTOPT], indirect=True)\ndef test_get_info(self, server, rest):\n\tpass\n```\n\n### 2.3.测试样例\n\n#### 2.3.1.rest\n\n样例代码中在test_get_info函数执行之前先启动server，server启动后启动了rest client，进入test_get_info函数后获取server的一些信息，并通过assert判断是否有获取到cpu的信息。\n\n```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7073 --rpc_port 9093\",\n               \"cleanup_dir\":[\"./testdb\"]}\nRESTTOPT = {\"port\":\"7073\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"rest\", [RESTTOPT], indirect=True)\ndef test_get_info(self, server, rest):\n    res = rest.get_server_info()\n    log.info(\"res : %s\", res)\n    assert('cpu' in res)\n```\n\n#### 2.3.2.client"
            },
            {
                "content": "#### 2.3.2.client\n\n样例代码中在test_flushdb函数执行之前先执行了数据离线导入逻辑，并启动server后，通过client创建链接，进入test_flushdb函数后，通过查询点的个数判断导入是否成功，导入成功后执行flushDB操作，再次通过assert判断是否能正常清空db\n\n```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7072 --rpc_port 9092\",\n             \"cleanup_dir\":[\"./testdb\"]}\n\nCLIENTOPT = {\"host\":\"127.0.0.1:9092\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n\nIMPORTOPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./testdb\", \"./.import_tmp\"]}"
            },
            {
                "content": "```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7072 --rpc_port 9092\",\n             \"cleanup_dir\":[\"./testdb\"]}\n\nCLIENTOPT = {\"host\":\"127.0.0.1:9092\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n\nIMPORTOPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./testdb\", \"./.import_tmp\"]}\n\n@pytest.mark.parametrize(\"importor\", [IMPORTOPT], indirect=True)\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"client\", [CLIENTOPT], indirect=True)\ndef test_flushdb(self, importor, server, client):\n    ret = client.callCypher(\"MATCH (n) RETURN n LIMIT 100\", \"default\")\n    assert ret[0]\n    res = json.loads(ret[1])\n    assert len(res) == 21\n    ret = client.callCypher(\"CALL db.flushDB()\", \"default\")\n    assert ret[0]\n    res = json.loads(ret[1])\n     assert res == None\n```"
            },
            {
                "content": "#### 2.3.3.exportor/importor\n\n样例代码中在test_export_default函数执行之前先执行了数据离线导入逻辑，导入成功后将当前db的数据导出，然后再次通过离线导入逻辑将exportor导出的数据导入到新的目录中，以新导入的数据启动db，并且创建链接。在test_export_default函数主体中判断导出后再次导入的数据是否与原始数据一致\n\n```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb1 --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7073 --rpc_port 9093\",\n             \"cleanup_dir\":[\"./testdb1\"]}\n\nCLIENTOPT = {\"host\":\"127.0.0.1:9093\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n\nIMPORT_YAGO_OPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./.import_tmp\", \"./testdb\"]}\n\nIMPORT_DEF_OPT = {\"cmd\":\"./lgraph_import -c ./export/default/import.config -d ./testdb1\",\n             \"cleanup_dir\":[\"./.import_tmp\", \"./testdb1\"]}\n\nEXPORT_DEF_OPT = {\"cmd\":\"./lgraph_export -d ./testdb -e ./export/default -g default -u admin -p 73@TuGraph\",\n                  \"cleanup_dir\":[\"./export\"]}"
            },
            {
                "content": "IMPORT_DEF_OPT = {\"cmd\":\"./lgraph_import -c ./export/default/import.config -d ./testdb1\",\n             \"cleanup_dir\":[\"./.import_tmp\", \"./testdb1\"]}\n\nEXPORT_DEF_OPT = {\"cmd\":\"./lgraph_export -d ./testdb -e ./export/default -g default -u admin -p 73@TuGraph\",\n                  \"cleanup_dir\":[\"./export\"]}\n\n@pytest.mark.parametrize(\"importor\", [IMPORT_YAGO_OPT], indirect=True)\n@pytest.mark.parametrize(\"exportor\", [EXPORT_DEF_OPT], indirect=True)\n@pytest.mark.parametrize(\"importor_1\", [IMPORT_DEF_OPT], indirect=True)\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"client\", [CLIENTOPT], indirect=True)\ndef test_export_default(self, importor, exportor, importor_1, server, client):\n    ret = client.callCypher(\"MATCH (n) RETURN n LIMIT 100\", \"default\")\n    assert ret[0]\n    res = json.loads(ret[1])\n    log.info(\"res : %s\", res)\n    assert len(res) == 21\n```"
            },
            {
                "content": "#### 2.3.4.其他测试\n更多用例请参考集成测试代码 [https://github.com/TuGraph-family/tugraph-db/tree/master/test/integration](https://github.com/TuGraph-family/tugraph-db/tree/master/test/integration)"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/12.contributor-manual/1.contributing.md",
        "chunks": [
            {
                "content": "# 如何贡献\n\n## 1. 前言\n感谢您为TuGraph做出贡献，我们由衷地希望有更多社区的同学加入进来，一起建设一个更好的图数据库项目。\n\n对于优秀社区贡献者，我们将颁发TuGraph优秀社区贡献者证书。\n\n## 2. 贡献什么\n我们随时都欢迎任何贡献，无论是简单的错别字修正，BUG 修复还是增加新功能。请踊跃提出问题或发起 PR。我们同样重视文档以及与其它开源项目的整合，欢迎在这方面做出贡献。\n对于任何修改，尤其是较为复杂的修改，建议新建一个issue ，按照BUG或者PR的模板填写。\n\n## 3. 准备工作\n\n### 3.1. 了解TuGraph\n\n建议您从[文档地图](../1.guide.md)开始，了解TuGraph的特性和接口。\n\n### 3.2. 准备环境\n\n对于文档贡献，可以直接通过[文档](https://tugraph-db.readthedocs.io/zh_CN/latest)，点击右上角的\"在GitHub上编译\"直接修改并提PR。\n\n对于代码贡献，通常需要在搭建编译执行的环境，可以采用[Docker部署](../5.installation&running/3.docker-deployment.md)或[本地部署](../5.installation&running/4.local-package-deployment.md)。\n\n### 3.3. 许可协议\n\n在贡献代码之前，请您稍微花一些时间了解为TuGraph贡献代码的流程，并阅读 [个人贡献者许可协议](3.individual-cla.md) 或 [公司贡献者许可协议](4.corporate-cla.md)，参与贡献则视为同意上述协议。\n\n## 4. 贡献代码流程\n### 4.1. 提交issue\n不论您是修复 TuGraph 的 bug 还是新增 TuGraph 的功能，在您提交代码之前，请在 TuGraph 的 GitHub 上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:"
            },
            {
                "content": "对于代码贡献，通常需要在搭建编译执行的环境，可以采用[Docker部署](../5.installation&running/3.docker-deployment.md)或[本地部署](../5.installation&running/4.local-package-deployment.md)。\n\n### 3.3. 许可协议\n\n在贡献代码之前，请您稍微花一些时间了解为TuGraph贡献代码的流程，并阅读 [个人贡献者许可协议](3.individual-cla.md) 或 [公司贡献者许可协议](4.corporate-cla.md)，参与贡献则视为同意上述协议。\n\n## 4. 贡献代码流程\n### 4.1. 提交issue\n不论您是修复 TuGraph 的 bug 还是新增 TuGraph 的功能，在您提交代码之前，请在 TuGraph 的 GitHub 上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:\n\n- 不会与其它开发者或是他们对这个项目的计划发生冲突，产生重复工作。\n- TuGraph 的维护人员会对您提的 bug 或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。\n- 在达成一致后再开发，并提交代码，减少双方沟通成本，也减少 pull request 被拒绝的情况。\n### 4.2. 获取源码\n要修改或新增功能，在提交 issue 后，fork一份 TuGraph  Master代码到您的代码仓库。\n### 4.3. 拉分支\nTuGraph 所有修改都在分支上进行，修改完成后提交 pull request，在 Code Review 后由项目维护人员 Merge 到 Master。 因此，在获取源码步骤介绍后，您需要:"
            },
            {
                "content": "- 不会与其它开发者或是他们对这个项目的计划发生冲突，产生重复工作。\n- TuGraph 的维护人员会对您提的 bug 或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。\n- 在达成一致后再开发，并提交代码，减少双方沟通成本，也减少 pull request 被拒绝的情况。\n### 4.2. 获取源码\n要修改或新增功能，在提交 issue 后，fork一份 TuGraph  Master代码到您的代码仓库。\n### 4.3. 拉分支\nTuGraph 所有修改都在分支上进行，修改完成后提交 pull request，在 Code Review 后由项目维护人员 Merge 到 Master。 因此，在获取源码步骤介绍后，您需要:\n\n1. 下载代码到本地，这一步您可以选择git/https方式，近年github的权限要求更加严格，比如git方式需要更复杂的ssh key([https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent))，https方式不能直接使用用户名密码验证，请按照指引授权。 git clone https://github.com/您的账号名/tugraph-db\n2. 拉分支准备修改代码:\ngit branch add_xxx_feature \n3. 执行完上述命令后，您的代码仓库就切换到相应分支了。执行如下命令可以看到您当前分支: git branch -a \n4. 如果您想切换回 Master，执行下面命令: git checkout -b master\n5. 如果您想切换回分支，执行下面命令: git checkout -b \"branchName\"\n\n### 4.4. 编译运行"
            },
            {
                "content": "### 4.4. 编译运行\n\n代码的编译运行流程可以参考[ci脚本](https://github.com/TuGraph-family/tugraph-db/blob/master/ci/github_ci.sh)\n\n### 4.5. 配置 Github 信息\n在您的机器执行 git config  --list ，查看 git 的全局用户名和邮箱。检查显示的 user.name 和 user.email 是不是与自己 github 的用户名和邮箱相匹配。\n\n如果公司内部有自己的 gitlab 或者使用了其他商业化的 gitlab，则可能会出现不匹配的情况。这时候，您需要为 TuGraph DB 项目单独设置用户名和邮箱。设置用户名和邮箱的方式请参考 github 官方文档。\n\n### 4.6. 修改代码提交到本地\n\n拉完分支后，就可以修改代码了。\n\n**修改代码注意事项 **\n\n代码⻛格保持一致：TuGraph 通过 cpplint 来保持代码格式一致，IDE可以通过.clang来配置风格。在提交代码前，务必本地检查代码风格，否则ACI将报错。\n\n补充单元测试代码：新有修改应该通过已有的单元测试,应该提供新的单元测试来证明以前的代码存在 bug，而新的代码已经解决了这些 bug ,您可以用如下命令运行所有测试: ./unit_test\n也可以通过IDE来辅助运行。\n\n**其它注意事项 **\n\n请保持您编辑的代码的原有⻛格，尤其是空格、换行等。 对于无用的注释，请直接删除。 对逻辑和功能不容易被理解的地方添加注释。 及时更新文档。 修改完代码后，请按照如下格式执行命令提交所有的修改到本地:\ngit commit -am '(feat) 添加xx功能' git commit -am '(fix) 修复xx问题'`\n\n### 4.7. 提交代码到远程仓库\n在代码提交到本地后，接下来就可以与远程仓库同步代码了，执行如下命令提交本地修改到 github 上: git push origin \"branchname\"\n\n如果前面您是通过 fork 来做的，那么这里的 origin 是 push 到您的代码仓库，而不是 TuGraph 的代码仓库。"
            },
            {
                "content": "补充单元测试代码：新有修改应该通过已有的单元测试,应该提供新的单元测试来证明以前的代码存在 bug，而新的代码已经解决了这些 bug ,您可以用如下命令运行所有测试: ./unit_test\n也可以通过IDE来辅助运行。\n\n**其它注意事项 **\n\n请保持您编辑的代码的原有⻛格，尤其是空格、换行等。 对于无用的注释，请直接删除。 对逻辑和功能不容易被理解的地方添加注释。 及时更新文档。 修改完代码后，请按照如下格式执行命令提交所有的修改到本地:\ngit commit -am '(feat) 添加xx功能' git commit -am '(fix) 修复xx问题'`\n\n### 4.7. 提交代码到远程仓库\n在代码提交到本地后，接下来就可以与远程仓库同步代码了，执行如下命令提交本地修改到 github 上: git push origin \"branchname\"\n\n如果前面您是通过 fork 来做的，那么这里的 origin 是 push 到您的代码仓库，而不是 TuGraph 的代码仓库。\n\n提交合并代码到 Master 的请求 在的代码提交到 GitHub 后，您就可以发送请求来把您改好的代码合入 TuGraph Master 代码了。此时您需要进入您在 GitHub 上的对应仓库，按右上⻆的 pull request 按钮。选择目标分支，一般就是 master，系统会通知 TuGraph 的人员， TuGraph 人员会 Review 您的代码，符合要求后就会合入主干，成为 TuGraph 的一部分。 \n\n请注意会自动检查CI，以及所有Commits中的贡献者是否签署了cla，通过后会有绿色的标识。\n\n### 4.8. 代码 Review\n\n在您提交代码后，您的代码会被指派给维护人员 Review，请耐心等待。如果两个工作日后，仍然没有人对您的提交给予任何回复，可以在 PR 下面留言，并 @ 对应的人员。\n\n对于代码 Review 的意⻅会直接备注到到对应 PR 或者 Issue。如果觉得建议是合理的，也请您把这些建议更新到您的代码中。\n\n### 4.9. 合并代码到Master\n\n在代码 Review 通过后，就由 TuGraph 维护人员操作合入 Master，在此过程中维护人员可能会指定新的Reviewer，提出新的意见需要修改。一般这一步不用参与，代码合并之后，您会收到合并成功的提示。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/12.contributor-manual/2.community-roles.md",
        "chunks": [
            {
                "content": "# 社区角色\n\n## 1. 前言\n本文档描述 TuGraph 社区中成员身份的⻆色，对每种⻆色的要求及权限。 \n\n## 2. ⻆色摘要\n\n这是 TuGraph 社区的⻆色划分，描述了每种⻆色的职责，成为某种⻆色并保持该⻆色的要求，以及相应⻆色的权限。\n\nTuGraph 社区参照 Apache 规范划分为以下三种⻆色：\n\n- Contributor \n- Maintainer \n- PMC \n\n以下描述了每种⻆色的要求、职责和权限。 \t\t \t\t\t\t\t\t \t\t\t\t\t\n## 3. Contributor\n### 3.1. 要求\n在 TuGraph 的任何一个正式项目中成功提交一个 PR 并合并。 \n### 3.2. 职责\n\n- 积极响应指派给您的 Issue 或 PR\n- 一起帮忙回复 Issue 或 PR，把 Issue 分配给对应模块的负责人\n### 3.3. 权限\n\n- 加入 TuGraph GitHub 组织，成为 TuGraph 开源社区的一员。 \n## 4. Maintainer\n### 4.1. 要求\n新的 Committer 由已有的 PMC 推荐，并通过 2/3 以上投票通过，Committer 至少满足以下一个条件：\n\n- 成为社区成员时间超过三个月 \n- 超过 10 个 PMC approve 的 PR \n- 完成重大功能 \n- 修复严重 Bug \n- 长期关注项目发展并参与社区讨论\n### 4.2. 职责\n\n- 社区咨询支持\n- 积极响应指派给您的 Issue 或 PR\n- 对于社区重大决定的投票权\n- Review 社区的 PR \n### 4.3. 权限\n\n- Pull Request review 权限 \n## 5. PMC\n### 5.1. 要求\n\n- 暂不开放，如有强烈愿望请联系PMC\n### 5.2. 职责\n\n- 积极参与社区讨论，对社区重大决策给予指导 \n- 负责保证开源项目的社区活动都能运转良好 \n### 5.3. 权限\n\n- Pull Request review 权限 \n- Pull Request approve 权限 \n- 社区角色成员管理"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/12.contributor-manual/3.individual-cla.md",
        "chunks": [
            {
                "content": "# 个人贡献者许可协议\n\nAnt_Group_Open_Source_Individual_CLA_English_Chinese_2021\n\nAnt Group\n\nIndividual Contributor License Agreement\n\n蚂蚁集团\n\n个人贡献者许可协议\n\nThank you for your interest in contributing documentation and related software code to a project hosted or managed by Ant Group, or any of its affiliates. In order to clarify the intellectual property license granted with Contributions from any person or entity, Ant Group must have a Contributor License Agreement (\"CLA\") on file that has been signed by each Contributor, indicating agreement to the license terms below.  This version of the Contributor License Agreement allows an individual to submit Contributions to the applicable project.  If you are making a submission on behalf of a legal entity, then you should sign the separation Corporate Contributor License Agreement.\n\n感谢您对向蚂蚁集团或其任何关联方主办或管理的项目贡献文档和相关软件代码的兴趣。为厘清就个人或实体贡献内容而授予的知识产权许可，蚂蚁集团必须对每位贡献者签署的贡献者许可协议（“CLA”）进行归档，以证明就以下许可条件达成的一致。此版本的贡献者许可协议允许个人向相应项目提交贡献内容。如果您是以公司名义进行提交，您应当另行签署一份公司贡献者许可协议。"
            },
            {
                "content": "感谢您对向蚂蚁集团或其任何关联方主办或管理的项目贡献文档和相关软件代码的兴趣。为厘清就个人或实体贡献内容而授予的知识产权许可，蚂蚁集团必须对每位贡献者签署的贡献者许可协议（“CLA”）进行归档，以证明就以下许可条件达成的一致。此版本的贡献者许可协议允许个人向相应项目提交贡献内容。如果您是以公司名义进行提交，您应当另行签署一份公司贡献者许可协议。\n\nYou accept and agree to the following terms and conditions for Your present and future Contributions submitted to Ant Group. Except for the license granted herein to Ant Group and recipients of documentation and software distributed by Ant Group, You reserve all right, title, and interest in and to Your Contributions.\n\n就您目前和将来向蚂蚁集团提交的贡献内容，您接受并同意以下条款和条件。除了根据本协议向蚂蚁集团和蚂蚁集团发布文档和软件的接收方授予的许可，您对于您的贡献内容保留所有权利、所有权和利益。\n\n1. Definitions.\n1. 定义。"
            },
            {
                "content": "就您目前和将来向蚂蚁集团提交的贡献内容，您接受并同意以下条款和条件。除了根据本协议向蚂蚁集团和蚂蚁集团发布文档和软件的接收方授予的许可，您对于您的贡献内容保留所有权利、所有权和利益。\n\n1. Definitions.\n1. 定义。\n\n   \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is making this Agreement with Ant Group. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\n   “您”（或“您的”）系指与蚂蚁集团签署本协议的著作权人或经著作权人授权的法律实体。对于法律实体而言，提交贡献内容的实体以及其他任何控制该实体、受其控制或与其受到同一主体控制的实体被视为单个贡献者。为本定义之目的，“控制” 系指（i）通过合同或其他方式，直接或间接对该实体进行指导和管理的权力，（ii）持有该实体百分之五十（50%）或更多的已发行股份，或（iii）间接持有该实体权益。"
            },
            {
                "content": "“您”（或“您的”）系指与蚂蚁集团签署本协议的著作权人或经著作权人授权的法律实体。对于法律实体而言，提交贡献内容的实体以及其他任何控制该实体、受其控制或与其受到同一主体控制的实体被视为单个贡献者。为本定义之目的，“控制” 系指（i）通过合同或其他方式，直接或间接对该实体进行指导和管理的权力，（ii）持有该实体百分之五十（50%）或更多的已发行股份，或（iii）间接持有该实体权益。\n\n   \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to Ant Group for inclusion in, or documentation of, any of the products or projects owned or managed by Ant Group (the \"Work\"), including without limitation any Work described in Schedule A. For the purposes of this definition, \"submitted\" means any form of electronic or written communication sent to Ant Group or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Ant Group for the purpose of discussing and improving the Work."
            },
            {
                "content": "“贡献内容”系指由您有意地向蚂蚁集团提交，以便被包含或记载在任何蚂蚁集团拥有或管理的产品或项目（“作品”，包括但不限于任何在附录A中列举的作品）中的任何原创作品，包括对既存作品的任何修改和增加。为本定义之目的，“提交”系指向蚂蚁集团或其代表进行的任何形式的电子或书面交流，包括但不限于为讨论和改善作品为目的，通过蚂蚁集团管理的（或以蚂蚁集团名义管理的）电子邮件列表、源代码控制系统和问题跟踪系统进行的交流。\n\n2. Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to Ant Group and to recipients of documentation and software distributed by Ant Group a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works.\n2. 著作权许可的授予。受限于本协议的条款和条件，您在此授予蚂蚁集团以及蚂蚁集团发布文档和软件的接收方永久性的、全球范围内的、非排他的、完全无须许可费的、完全无须版权费的和不可撤销的著作权许可，以复制、衍生、公开展示、公开执行、转授权和发布您的贡献内容和该等衍生作品。"
            },
            {
                "content": "3. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to Ant Group and to recipients of documentation and software distributed by Ant Group a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the"
            },
            {
                "content": "Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed."
            },
            {
                "content": "3. 专利许可的授予。  受限于本协议的条款和条件，您在此授予蚂蚁集团以及蚂蚁集团发布文档和软件的接收方永久性的、全球范围内的、非排他的、完全无须许可费的、完全无须版权费的和不可撤销（本节规定的情形除外）的专利许可，以开发、利用、要约出售、出售、导入或以其他方式转让作品，但该许可仅适用于您有权许可的，且必然会被您的贡献内容侵权（贡献内容单独构成侵权、或与贡献内容的相关作品一同构成侵权）的专利申请范围。如果任何实体针对您或其他实体提起专利诉讼（包括诉讼中的交叉请求或反诉），主张您的贡献内容（或您参与贡献的作品）造成了直接性或辅助性的专利侵权，则任何根据本协议针对该贡献内容或作品授予该实体的专利许可应当在起诉之日终止。"
            },
            {
                "content": "4. You represent that you are legally entitled to grant the above license.\n4. 您保证您依法有权授予上述许可。\n\n5. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others).  You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which you are personally aware and which are associated with any part of Your Contributions.\n5. 您保证您所有的贡献内容均为您的原创作品（关于为他人提交作品的规定，可参见第7节）。您保证您提交的贡献内容包括任何第三方许可或其他限制（包括但不限于相关专利或商标）的全部细节，只要该等许可或其他限制为您个人所知悉且与您的贡献内容的任何部分相关。"
            },
            {
                "content": "6. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.\n6. 在您自愿提供支持的范围之外，您无需对您的贡献内容提供支持。您可以提供免费支持或收费支持，也可以完全不提供支持。除非适用法律另有规定或另有书面约定，您“按照现状”提供您的贡献内容，而不对其提供任何类型的保证或条件，无论明示还是默示，包括但不限于为任何特定目的对所有权、无侵权、适销性或适当性的保证或条件。"
            },
            {
                "content": "7. Should You wish to submit work that is not Your original creation, You may submit it to Ant Group separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which you are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here]\".\n7. 如果您希望提交并非您原创的作品，您可以在任何贡献内容之外单独向蚂蚁集团提交，标注关于其来源和您个人所知悉的任何许可或其他限制（包括但不限于相关专利、商标和许可协议）的完整信息，并以显著方式标明该作品属于“以第三方名义提交：【填写姓名】”。\n\n8. You agree to notify Ant Group of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect.\n8. 您同意在您获悉任何可能导致上述保证在任何方面不准确的事实或情况之时通知蚂蚁集团。"
            },
            {
                "content": "8. You agree to notify Ant Group of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect.\n8. 您同意在您获悉任何可能导致上述保证在任何方面不准确的事实或情况之时通知蚂蚁集团。\n\n9. This Agreement will be governed by and construed in accordance with the laws of the People's Republic of China excluding that body of laws known as conflict of laws.  The parties expressly agree that the United Nations Convention on Contracts for the International Sale of Goods will not apply.  Any legal action or proceeding arising under this Agreement will be brought exclusively in the courts located in Hangzhou, China, and the parties hereby irrevocably consent to the personal jurisdiction and venue therein.\n9. 本协议受中华人民共和国法律管辖，并依据其进行解释，但冲突法规则除外。协议各方明确同意排除《联合国国际货物销售合同公约》的适用。任何由本协议产生的法律诉讼或程序均应排他性地提交至中国杭州的法院进行审理，且各方在此不可撤销地同意该等关于属人管辖和法院地的安排。"
            },
            {
                "content": "10. For your reading convenience, this Agreement is written in parallel English and Chinese sections. To the extent there is a conflict between the English and Chinese sections, the English sections shall govern.\n10. 为了您的阅读方便，本协议同时提供了英文和中文段落。如果英文和中文段落有矛盾，则以英文段落为准。   \n\nPlease sign请签署: __________________________________ Date日期: ____________\n\nFull name全名: _____________________________________________________\n\nMailing Address信件地址: ________________________________________________\n\nTelephone电话: _____________________________________________________\n\nE-Mail电子邮箱:    ______________________________________________________\n\nSchedule A附录A:\n\nDescription of Initial Contribution:\n\n描述初始贡献内容："
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/12.contributor-manual/4.corporate-cla.md",
        "chunks": [
            {
                "content": "# 公司贡献者许可协议\n\nAnt_Group_Open_Source_Corporate_CLA_English_Chinese_2021\n\nAnt Group\n\nCorporate Contributor License Agreement\n\n蚂蚁集团\n\n公司贡献者许可协议\n\nThank you for your interest in contributing documentation and related software code to a project hosted or managed by Ant Group, or any of its affiliates. In order to clarify the intellectual property license granted with Contributions from any person or entity, Ant Group must have a Contributor License Agreement (\"CLA\") on file that has been signed by each Contributor, indicating agreement to the license terms below.  This version of the Contributor License Agreement allows a legal entity (the \"Corporation\") to submit Contributions to the applicable project.  If you are an individual making a submission on your own behalf, then you should sign the separation Individual Contributor License Agreement."
            },
            {
                "content": "感谢您对向蚂蚁集团或其任何关联方主办或管理的项目贡献文档和相关软件代码的兴趣。为厘清就个人或实体贡献内容而授予的知识产权许可，蚂蚁集团必须对每位贡献者签署的贡献者许可协议（“CLA”）进行归档，以证明就以下许可条件达成的一致。此版本的贡献者许可协议允许法人实体（“公司”）向相应项目提交贡献内容。如果您是以自身名义进行提交的个人，您应当另行签署一份个人贡献者许可协议。\n\nYou accept and agree to the following terms and conditions for Your present and future Contributions submitted to Ant Group. Except for the license granted herein to Ant Group and recipients of documentation and software distributed by Ant Group, You reserve all right, title, and interest in and to Your Contributions.\n\n就您目前和将来向蚂蚁集团提交的贡献内容，您接受并同意以下条款和条件。除了根据本协议向蚂蚁集团和蚂蚁集团发布文档和软件的接收方授予的许可，您对于您的贡献内容保留所有权利、所有权和利益。\n1. Definitions.\n1. 定义。"
            },
            {
                "content": "就您目前和将来向蚂蚁集团提交的贡献内容，您接受并同意以下条款和条件。除了根据本协议向蚂蚁集团和蚂蚁集团发布文档和软件的接收方授予的许可，您对于您的贡献内容保留所有权利、所有权和利益。\n1. Definitions.\n1. 定义。\n\n\"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is making this Agreement with Ant Group. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\n“您”（或“您的”）系指与蚂蚁集团签署本协议的著作权人或经著作权人授权的法律实体。对于法律实体而言，提交贡献内容的实体以及其他任何控制该实体、受其控制或与其受到同一主体控制的实体被视为单个贡献者。为本定义之目的，“控制” 系指（i）通过合同或其他方式，直接或间接对该实体进行指导和管理的权力，（ii）持有该实体百分之五十（50%）或更多的已发行股份，或（iii）间接持有该实体权益。"
            },
            {
                "content": "“您”（或“您的”）系指与蚂蚁集团签署本协议的著作权人或经著作权人授权的法律实体。对于法律实体而言，提交贡献内容的实体以及其他任何控制该实体、受其控制或与其受到同一主体控制的实体被视为单个贡献者。为本定义之目的，“控制” 系指（i）通过合同或其他方式，直接或间接对该实体进行指导和管理的权力，（ii）持有该实体百分之五十（50%）或更多的已发行股份，或（iii）间接持有该实体权益。\n\n\"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to Ant Group for inclusion in, or documentation of, any of the products or projects owned or managed by Ant Group (the \"Work\"), including without limitation any Work described in Schedule B. For the purposes of this definition, \"submitted\" means any form of electronic or written communication sent to Ant Group or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Ant Group for the purpose of discussing and improving the Work."
            },
            {
                "content": "“贡献内容”系指由您有意地向蚂蚁集团提交，以便被包含或记载在任何蚂蚁集团拥有或管理的产品或项目（“作品”，包括但不限于任何在附录B中列举的作品）中的任何原创作品，包括对既存作品的任何修改和增加。为本定义之目的，“提交”系指向蚂蚁集团或其代表进行的任何形式的电子或书面交流，包括但不限于为讨论和改善作品为目的，通过蚂蚁集团管理的（或以蚂蚁集团名义管理的）电子邮件列表、源代码控制系统和问题跟踪系统进行的交流。\n\n2. Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to Ant Group and to recipients of documentation and software distributed by Ant Group a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works.\n2. 著作权许可的授予。受限于本协议的条款和条件，您在此授予蚂蚁集团以及蚂蚁集团发布文档和软件的接收方永久性的、全球范围内的、非排他的、完全无须许可费的、完全无须版权费的和不可撤销的著作权许可，以复制、衍生、公开展示、公开执行、转授权和发布您的贡献内容和该等衍生作品。"
            },
            {
                "content": "3. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to Ant Group and to recipients of documentation and software distributed by Ant Group a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the"
            },
            {
                "content": "Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed."
            },
            {
                "content": "3. 专利许可的授予。  受限于本协议的条款和条件，您在此授予蚂蚁集团以及蚂蚁集团发布文档和软件的接收方永久性的、全球范围内的、非排他的、完全无须许可费的、完全无须版权费的和不可撤销（本节规定的情形除外）的专利许可，以开发、利用、要约出售、出售、导入或以其他方式转让作品，但该许可仅适用于您有权许可的，且必然会被您的贡献内容侵权（贡献内容单独构成侵权、或与贡献内容的相关作品一同构成侵权）的专利申请范围。如果任何实体针对您或其他实体提起专利诉讼（包括诉讼中的交叉请求或反诉），主张您的贡献内容（或您参与贡献的作品）造成了直接性或辅助性的专利侵权，则任何根据本协议针对该贡献内容或作品授予该实体的专利许可应当在起诉之日终止。"
            },
            {
                "content": "4. You represent that you are legally entitled to grant the above license. You represent further that each employee of the Corporation designated on Schedule A below (or in a subsequent written modification to that Schedule) is authorized to submit Contributions on behalf of the Corporation.\n4. 您保证您依法有权授予上述许可。您进一步保证下文附表A（该附表可通过书面方式进行后续更改）所指定的任意公司员工均有权以公司名义提交贡献内容。\n\n5. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others).  You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which you are personally aware and which are associated with any part of Your Contributions.\n5. 您保证您所有的贡献内容均为您的原创作品（关于为他人提交作品的规定，可参见第7节）。您保证您提交的贡献内容包括任何第三方许可或其他限制（包括但不限于相关专利或商标）的全部细节，只要该等许可或其他限制为您个人所知悉且与您的贡献内容的任何部分相关。"
            },
            {
                "content": "6. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.\n6. 在您自愿提供支持的范围之外，您无需对您的贡献内容提供支持。您可以提供免费支持或收费支持，也可以完全不提供支持。除非适用法律另有规定或另有书面约定，您“按照现状”提供您的贡献内容，而不对其提供任何类型的保证或条件，无论明示还是默示，包括但不限于为任何特定目的对所有权、无侵权、适销性或适当性的保证或条件。"
            },
            {
                "content": "7. Should You wish to submit work that is not Your original creation, You may submit it to Ant Group separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which you are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here]\".\n7. 如果您希望提交并非您原创的作品，您可以在任何贡献内容之外单独向蚂蚁集团提交，标注关于其来源和您个人所知悉的任何许可或其他限制（包括但不限于相关专利、商标和许可协议）的完整信息，并以显著方式标明该作品属于“以第三方名义提交：【填写姓名】”。\n\n8. You agree to notify Ant Group of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect.\n8. 您同意在您获悉任何可能导致上述保证在任何方面不准确的事实或情况之时通知蚂蚁集团。"
            },
            {
                "content": "8. You agree to notify Ant Group of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect.\n8. 您同意在您获悉任何可能导致上述保证在任何方面不准确的事实或情况之时通知蚂蚁集团。\n\n9. This Agreement will be governed by and construed in accordance with the laws of the People's Republic of China excluding that body of laws known as conflict of laws.  The parties expressly agree that the United Nations Convention on Contracts for the International Sale of Goods will not apply.  Any legal action or proceeding arising under this Agreement will be brought exclusively in the courts located in Hangzhou, China, and the parties hereby irrevocably consent to the personal jurisdiction and venue therein.\n9. 本协议受中华人民共和国法律管辖，并依据其进行解释，但冲突法规则除外。协议各方明确同意排除《联合国国际货物销售合同公约》的适用。任何由本协议产生的法律诉讼或程序均应排他性地提交至中国杭州的法院进行审理，且各方在此不可撤销地同意该等关于属人管辖和法院地的安排。"
            },
            {
                "content": "10. For your reading convenience, this Agreement is written in parallel English and Chinese sections. To the extent there is a conflict between the English and Chinese sections, the English sections shall govern.\n10. 为了您的阅读方便，本协议同时提供了英文和中文段落。如果英文和中文段落有矛盾，则以英文段落为准。\n\nPlease sign请签署: __________________________________ Date日期: ____________\n\nCompany Name公司名称: ________________________________________________\n\nFull name全名: _____________________________________________________\n\nTitle职务: _____________________________________________________\n\nMailing Address信件地址: ________________________________________________\n\nCountry国家: _____________________________________________________\n\nTelephone电话: _____________________________________________________\n\nE-Mail电子邮箱:    ______________________________________________________\n\nSchedule A附录A:\n\nPlease provide an initial list of designated employees authorized to submit Contributions on behalf of the Corporation:\n\n请提供一份有权以公司名义提交贡献内容的指定员工的初始名单：\n\nSchedule B 附录B:"
            },
            {
                "content": "Mailing Address信件地址: ________________________________________________\n\nCountry国家: _____________________________________________________\n\nTelephone电话: _____________________________________________________\n\nE-Mail电子邮箱:    ______________________________________________________\n\nSchedule A附录A:\n\nPlease provide an initial list of designated employees authorized to submit Contributions on behalf of the Corporation:\n\n请提供一份有权以公司名义提交贡献内容的指定员工的初始名单：\n\nSchedule B 附录B:\n\nDescription of Initial Contribution:\n\n描述初始贡献内容："
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/12.contributor-manual/5.roadmap.md",
        "chunks": [
            {
                "content": "# 技术规划\n\n## 1. 简介\n\n该文档是 TuGraph-DB 未来开发的规划，包括正在开发中、不在开发计划里、已经开发完成但不在开源版本里的功能等。\n\nTuGraph-DB定位开源高性能图数据库，图数据采用集中存储的方式，短期 **不会** 考虑基于分片（Sharding）的数据切分，\n而将支持主备复制的模式来解决高并发读的场景，采用云上存储解决存储容量的问题。\n\n## 2. 已完成功能\n\nTuGraph-DB于2022年9月1日开源，TuGraph-DB在社区的反馈声中，进行日常BUG修复，自身能力得到了完善。"
            },
            {
                "content": "TuGraph-DB定位开源高性能图数据库，图数据采用集中存储的方式，短期 **不会** 考虑基于分片（Sharding）的数据切分，\n而将支持主备复制的模式来解决高并发读的场景，采用云上存储解决存储容量的问题。\n\n## 2. 已完成功能\n\nTuGraph-DB于2022年9月1日开源，TuGraph-DB在社区的反馈声中，进行日常BUG修复，自身能力得到了完善。\n\n| 版本号   | 功能                               | 时间         |\n|-------|----------------------------------|------------|\n| 3.3.0 | 开源初版                             | 2022.9.1   |\n| 3.3.1 | 图分析引擎重构，多模式支持                    | 2022.10.14 |\n| 3.3.2 | OGM支持，UT覆盖率提升                    | 2022.11.21 |\n| 3.3.3 | 链接认证机制迭代，加入英文文档                  | 2022.12.23 |\n| 3.3.4 | 支持上云，梳理LDBC SNB Audit流程          | 2023.1.28  |\n| 3.4.0 | 支持OLAP Python API, 离线导入升级        | 2023.3.11  |\n| 3.5.0 | 支持POG，前端升级，文档梳理                  | 2023.6.5   |\n| 3.5.1 | 图学习引擎，Procedure Rust API，存储属性分离  | 2023.7.14  |\n| 3.6.0 | 高可用开源，日志系统升级                     | 2023.8.11  |\n| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |\n| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |\n| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |"
            },
            {
                "content": "除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。\n\n更详细的描述可以在源码目录在的 \"[root]/release/CHANGELOG.md\" 文件查看。\n\n## 3. 2024年功能更新\n\n在2024年度，我们计划的功能更新包括：\n\n| 版本号   | 功能                 | 计划时间    |\n|-------|--------------------|---------|\n| 4.2.x | HA支持Witness角色和管理工具 | 2024.3  |\n| 4.2.x | Bolt支持流处理和参数化查询    | 2024.3  |\n| x.x.x | GeaX支持Cypher       | 2024.6  |\n| x.x.x | 支持组合索引             | 2024.6  |\n| x.x.x | 数据导入功能优化           | 2024.6  |\n| x.x.x | 【社区功能】支持地理数据类型使用   | 2024.6  |\n| x.x.x | Cypher能力提升         | 2024.9  |\n| x.x.x | 支持Schema快速变更       | 2024.9  |\n| x.x.x | 向量化支持              | 2024.12 |\n| x.x.x | RPQ支持              | 2024.12 |\n| x.x.x | 【可选】查询引擎升级         | 2024.12 |\n| x.x.x | 【社区功能】支持GraphAr    | 2024.12 |\n\n## 4. 期望社区共创的功能\n\n目前团队研发精力并不能实现我们对TuGraph-DB的全部期望，在功能的梳理中，我们发现有一系列值得挖掘的想法，\n团队也有一些初步的探索，期望下面功能能够在社区中共同研发。"
            },
            {
                "content": "## 4. 期望社区共创的功能\n\n目前团队研发精力并不能实现我们对TuGraph-DB的全部期望，在功能的梳理中，我们发现有一系列值得挖掘的想法，\n团队也有一些初步的探索，期望下面功能能够在社区中共同研发。\n\n| 版本号   | 功能                      | 计划时间   |\n|-------|-------------------------|--------|\n| x.x.x | 图算法库丰富                  | 2024.x |\n| x.x.x | 属性默认值支持                 | 2024.x |\n| x.x.x | Embedded TuGraph-DB最佳实践 | 2024.x |\n| x.x.x | Bolt显式事务支持              | 2024.x |\n| x.x.x | List、Map和Decimal等数据类型扩展 | 2024.x |\n| x.x.x | 探索多存储引擎                 | 2024.x |\n\n一些更加简单的功能，我们会在github的issue中打上 good first issue 的标签，欢迎对图数据库感兴趣的技术爱好者共同研讨。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/6.utility-tools/7.tugraph-datax.md",
        "chunks": [
            {
                "content": "# TuGraph-DataX\n\n> 此文档主要介绍 TuGraph DataX 的安装编译和使用示例\n\n## 1.简介\n\nTuGraph 在阿里开源的 DataX 基础上添加了 TuGraph 的写插件以及 TuGraph jsonline 数据格式的支持，其他数据源可以通过 DataX 往 TuGraph 里面写数据。\nTuGraph DataX 介绍 [https://github.com/TuGraph-family/DataX](https://github.com/TuGraph-family/DataX)，支持的功能包括：\n\n- 从 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源导入 TuGraph\n- 将 TuGraph 导入相应的目标源 （待开发）\n\n![导入导出](../../../images/tugraph-datax.png)\n\nDataX 原始项目介绍参考 [https://github.com/alibaba/DataX](https://github.com/alibaba/DataX)\n\n## 2.编译安装\n\n```bash\ngit clone https://github.com/TuGraph-family/DataX.git\nyum install maven\nmvn -U clean package assembly:assembly -Dmaven.test.skip=true\n```\n\n编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`"
            },
            {
                "content": "DataX 原始项目介绍参考 [https://github.com/alibaba/DataX](https://github.com/alibaba/DataX)\n\n## 2.编译安装\n\n```bash\ngit clone https://github.com/TuGraph-family/DataX.git\nyum install maven\nmvn -U clean package assembly:assembly -Dmaven.test.skip=true\n```\n\n编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`\n\n```\ntt0188766,King of Comedy,1999,7.3\ntt0286112,Shaolin Soccer,2001,7.3\ntt4701660,The Mermaid,2016,6.3\n```\n\n`roles.csv`\n\n```\nnm015950,Tianchou Yin,tt0188766\nnm015950,Steel Leg,tt0286112\nnm0628806,,tt0188766\nnm0628806,coach,tt0286112\nnm0156444,PiaoPiao Liu,tt0188766\nnm2514879,Ruolan Li,tt4701660\n```\n\n然后建三个 DataX 的 job 配置文件：\n`job_actors.json`"
            },
            {
                "content": "然后建三个 DataX 的 job 配置文件：\n`job_actors.json`\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"actors.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"actor\",\n            \"batchNum\": 1000,\n            \"properties\": [\"aid\", \"name\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`job_movies.json`"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"movies.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\","
            },
            {
                "content": "\"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`job_roles.json`"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"roles.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,"
            },
            {
                "content": "{\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,\n            \"properties\": [\"SRC_ID\", \"role\", \"DST_ID\"],\n            \"startLabel\": {\"type\": \"actor\", \"key\": \"SRC_ID\"},\n            \"endLabel\": {\"type\": \"movie\", \"key\": \"DST_ID\"}\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后依次执行如下三个命令：\n\n```\npython3 datax/bin/datax.py  job_actors.json\n```\n\n```\npython3 datax/bin/datax.py  job_movies.json\n```\n\n```\npython3 datax/bin/datax.py  job_roles.json\n```\n\n### 3.2.MySQL数据通过DataX导入TuGraph\n\n我们在 `test` database 下建立如下电影 `movies` 表\n\n```sql\nCREATE TABLE `movies` (\n  `mid`  varchar(200) NOT NULL,\n  `name` varchar(100) NOT NULL,\n  `year` int(11) NOT NULL,\n  `rate` float(5,2) unsigned NOT NULL,\n  PRIMARY KEY (`mid`)\n);\n```\n\n往表中插入几条数据\n\n```sql\ninsert into\ntest.movies (mid, name, year, rate)\nvalues\n('tt0188766', 'King of Comedy', 1999, 7.3),\n('tt0286112', 'Shaolin Soccer', 2001, 7.3),\n('tt4701660', 'The Mermaid',   2016,  6.3);\n```\n\n建立一个 DataX 的 job 配置文件\n\n`job_mysql_to_tugraph.json`\n\n**配置字段方式**"
            },
            {
                "content": "**配置字段方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"column\": [\"mid\", \"name\", \"year\", \"rate\"],\n            \"splitPk\": \"mid\",\n            \"connection\": [\n              {\n                \"table\": [\"movies\"],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n**写简单 sql 方式**"
            },
            {
                "content": "**写简单 sql 方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"connection\": [\n              {\n                \"querySql\": [\n                  \"select mid, name, year, rate from test.movies where year > 2000;\"\n                ],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后执行如下命令：\n\n```shell\npython3 datax/bin/datax.py  job_mysql_to_tugraph.json\n```\n\n## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中"
            },
            {
                "content": "## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中\n\n```json\n{\n    \"job\": {\n        \"setting\": {\n            \"speed\": {\n                 \"channel\":1\n            }\n        },\n        \"content\": [\n            {\n                \"reader\": {\n                    \"name\": \"tugraphreader\",\n                    \"parameter\": {\n                        \"username\": \"admin\",\n                        \"password\": \"73@TuGraph\",\n                        \"graphName\": \"Movie_8C5C\",\n                        \"queryCypher\": \"match (n:person) return n.id,n.name,n.born;\",\n                        \"url\": \"bolt://127.0.0.1:27687\"\n                    }\n                },\n                \"writer\": {\n                    \"name\": \"txtfilewriter\",\n                    \"parameter\": {\n                        \"path\": \"./result\",\n                        \"fileName\": \"luohw\",\n                        \"writeMode\": \"truncate\"\n                    }\n                }\n            }\n        ]\n    }\n}\n```"
            },
            {
                "content": "使用这个配置文件，可以把TuGraph Movie_8C5C子图中person节点的id,name和born属性全部导出出来，\n导出到当前目录下的result目录中，文件名称为luohw+随机后缀。\n\n### 4.2.参数说明\n\n在使用DataX导出TuGraph数据时，需要将reader设置为tugraphreader并配置以下5个参数：\n\n* **url**\n    * 描述：TuGraph的bolt server地址 \n    * 必选：是 \n    * 默认值：无 \n\n* **username**\n    * 描述：TuGraph的用户名 \n    * 必选：是 \n    * 默认值：无 \n\n* **password**\n    * 描述：TuGraph的密码 \n    * 必选：是 \n    * 默认值：无 \n\n* **graphName**\n    * 描述：所选取的需要同步的TuGraph子图 \n    * 必选：是 \n    * 默认值：无 \n\n* **queryCypher**\n    * 描述：通过cypher语句读取TuGraph中的数据 \n    * 必选：否 \n    * 默认值：无"
            },
            {
                "content": "# TuGraph-DataX\n\n> 此文档主要介绍 TuGraph DataX 的安装编译和使用示例\n\n## 1.简介\n\nTuGraph 在阿里开源的 DataX 基础上添加了 TuGraph 的写插件以及 TuGraph jsonline 数据格式的支持，其他数据源可以通过 DataX 往 TuGraph 里面写数据。\nTuGraph DataX 介绍 [https://github.com/TuGraph-family/DataX](https://github.com/TuGraph-family/DataX)，支持的功能包括：\n\n- 从 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源导入 TuGraph\n- 将 TuGraph 导入相应的目标源 （待开发）\n\n![导入导出](../../../images/tugraph-datax.png)\n\nDataX 原始项目介绍参考 [https://github.com/alibaba/DataX](https://github.com/alibaba/DataX)\n\n## 2.编译安装\n\n```bash\ngit clone https://github.com/TuGraph-family/DataX.git\nyum install maven\nmvn -U clean package assembly:assembly -Dmaven.test.skip=true\n```\n\n编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`"
            },
            {
                "content": "DataX 原始项目介绍参考 [https://github.com/alibaba/DataX](https://github.com/alibaba/DataX)\n\n## 2.编译安装\n\n```bash\ngit clone https://github.com/TuGraph-family/DataX.git\nyum install maven\nmvn -U clean package assembly:assembly -Dmaven.test.skip=true\n```\n\n编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`\n\n```\ntt0188766,King of Comedy,1999,7.3\ntt0286112,Shaolin Soccer,2001,7.3\ntt4701660,The Mermaid,2016,6.3\n```\n\n`roles.csv`\n\n```\nnm015950,Tianchou Yin,tt0188766\nnm015950,Steel Leg,tt0286112\nnm0628806,,tt0188766\nnm0628806,coach,tt0286112\nnm0156444,PiaoPiao Liu,tt0188766\nnm2514879,Ruolan Li,tt4701660\n```\n\n然后建三个 DataX 的 job 配置文件：\n`job_actors.json`"
            },
            {
                "content": "然后建三个 DataX 的 job 配置文件：\n`job_actors.json`\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"actors.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"actor\",\n            \"batchNum\": 1000,\n            \"properties\": [\"aid\", \"name\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`job_movies.json`"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"movies.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\","
            },
            {
                "content": "\"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`job_roles.json`"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"roles.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,"
            },
            {
                "content": "{\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,\n            \"properties\": [\"SRC_ID\", \"role\", \"DST_ID\"],\n            \"startLabel\": {\"type\": \"actor\", \"key\": \"SRC_ID\"},\n            \"endLabel\": {\"type\": \"movie\", \"key\": \"DST_ID\"}\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后依次执行如下三个命令：\n\n```\npython3 datax/bin/datax.py  job_actors.json\n```\n\n```\npython3 datax/bin/datax.py  job_movies.json\n```\n\n```\npython3 datax/bin/datax.py  job_roles.json\n```\n\n### 3.2.MySQL数据通过DataX导入TuGraph\n\n我们在 `test` database 下建立如下电影 `movies` 表\n\n```sql\nCREATE TABLE `movies` (\n  `mid`  varchar(200) NOT NULL,\n  `name` varchar(100) NOT NULL,\n  `year` int(11) NOT NULL,\n  `rate` float(5,2) unsigned NOT NULL,\n  PRIMARY KEY (`mid`)\n);\n```\n\n往表中插入几条数据\n\n```sql\ninsert into\ntest.movies (mid, name, year, rate)\nvalues\n('tt0188766', 'King of Comedy', 1999, 7.3),\n('tt0286112', 'Shaolin Soccer', 2001, 7.3),\n('tt4701660', 'The Mermaid',   2016,  6.3);\n```\n\n建立一个 DataX 的 job 配置文件\n\n`job_mysql_to_tugraph.json`\n\n**配置字段方式**"
            },
            {
                "content": "**配置字段方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"column\": [\"mid\", \"name\", \"year\", \"rate\"],\n            \"splitPk\": \"mid\",\n            \"connection\": [\n              {\n                \"table\": [\"movies\"],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n**写简单 sql 方式**"
            },
            {
                "content": "**写简单 sql 方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"connection\": [\n              {\n                \"querySql\": [\n                  \"select mid, name, year, rate from test.movies where year > 2000;\"\n                ],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后执行如下命令：\n\n```shell\npython3 datax/bin/datax.py  job_mysql_to_tugraph.json\n```\n\n## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中"
            },
            {
                "content": "## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中\n\n```json\n{\n    \"job\": {\n        \"setting\": {\n            \"speed\": {\n                 \"channel\":1\n            }\n        },\n        \"content\": [\n            {\n                \"reader\": {\n                    \"name\": \"tugraphreader\",\n                    \"parameter\": {\n                        \"username\": \"admin\",\n                        \"password\": \"73@TuGraph\",\n                        \"graphName\": \"Movie_8C5C\",\n                        \"queryCypher\": \"match (n:person) return n.id,n.name,n.born;\",\n                        \"url\": \"bolt://127.0.0.1:27687\"\n                    }\n                },\n                \"writer\": {\n                    \"name\": \"txtfilewriter\",\n                    \"parameter\": {\n                        \"path\": \"./result\",\n                        \"fileName\": \"luohw\",\n                        \"writeMode\": \"truncate\"\n                    }\n                }\n            }\n        ]\n    }\n}\n```"
            },
            {
                "content": "使用这个配置文件，可以把TuGraph Movie_8C5C子图中person节点的id,name和born属性全部导出出来，\n导出到当前目录下的result目录中，文件名称为luohw+随机后缀。\n\n### 4.2.参数说明\n\n在使用DataX导出TuGraph数据时，需要将reader设置为tugraphreader并配置以下5个参数：\n\n* **url**\n    * 描述：TuGraph的bolt server地址 \n    * 必选：是 \n    * 默认值：无 \n\n* **username**\n    * 描述：TuGraph的用户名 \n    * 必选：是 \n    * 默认值：无 \n\n* **password**\n    * 描述：TuGraph的密码 \n    * 必选：是 \n    * 默认值：无 \n\n* **graphName**\n    * 描述：所选取的需要同步的TuGraph子图 \n    * 必选：是 \n    * 默认值：无 \n\n* **queryCypher**\n    * 描述：通过cypher语句读取TuGraph中的数据 \n    * 必选：否 \n    * 默认值：无"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/13.best-practices/2.learn_practices.md",
        "chunks": [
            {
                "content": "# 使用 TuGraph 图学习模块进行点分类\n\n## 1.简介\nGNN 是许多图上机器学习任务的强大工具。在本介绍性教程中，您将学习使用 GNN 进行点分类的基本工作流程，即预测图中点的类别。\n\n此文档将展示如何构建一个 GNN 用于在 Cora 数据集上仅使用少量标签进行半监督点分类，这是一个以论文为点、引文为边的引文网络。任务是预测给定论文的类别。\n\n通过完成本教程，您可以\n\n使用 TuGraph 加载 cora 数据集。\n\n使用 TuGraph 提供的采样算子采样，并构建 GNN 模型。\n\n在 CPU 或 GPU 上训练用于点分类的 GNN 模型。\n\n此文档需要对图神经网络、DGL等使用有一定经验。\n\n## 2. 前置条件\n\nTuGraph图学习模块需要TuGraph-db 3.5.1及以上版本。\n\nTuGraph部署推荐采用Docker镜像tugraph-compile 1.2.4及以上版本:\n\ntugraph / tugraph-compile-ubuntu18.04:latest\n\ntugraph / tugraph-compile-centos7:latest\n\ntugraph / tugraph-compile-centos8:latest\n\n以上镜像均可在DockerHub上获取。\n具体操作请参考[快速上手](../3.quick-start/1.preparation.md)。\n\n## 3. Cora 数据集导入TuGraph数据库\n### 3.1. Cora 数据集介绍\nCora 数据集由 2708 篇论文组成，分为 7 个类别。每篇论文由一个 1433 维的词袋表示，表示论文中的单词是否出现。这些词袋特征已经预处理，以从 0 到 1 的范围归一化。边表示论文之间的引用关系。\n\nTuGraph中已经提供了Cora数据集的导入工具，用户可以直接使用。\n\n### 3.2. 数据导入\nCora数据集在test/integration/data/algo目录下，包含点集cora_vertices和边集cora_edge。\n\n首先需要将Cora数据集导入到TuGraph数据库中，详细操作可参考[数据导入](../6.utility-tools/1.data-import.md)。"
            },
            {
                "content": "tugraph / tugraph-compile-centos7:latest\n\ntugraph / tugraph-compile-centos8:latest\n\n以上镜像均可在DockerHub上获取。\n具体操作请参考[快速上手](../3.quick-start/1.preparation.md)。\n\n## 3. Cora 数据集导入TuGraph数据库\n### 3.1. Cora 数据集介绍\nCora 数据集由 2708 篇论文组成，分为 7 个类别。每篇论文由一个 1433 维的词袋表示，表示论文中的单词是否出现。这些词袋特征已经预处理，以从 0 到 1 的范围归一化。边表示论文之间的引用关系。\n\nTuGraph中已经提供了Cora数据集的导入工具，用户可以直接使用。\n\n### 3.2. 数据导入\nCora数据集在test/integration/data/algo目录下，包含点集cora_vertices和边集cora_edge。\n\n首先需要将Cora数据集导入到TuGraph数据库中，详细操作可参考[数据导入](../6.utility-tools/1.data-import.md)。\n\n在build/output目录下执行：\n```bash\ncp -r ../../test/integration/data/ ./ && cp -r ../../learn/examples/* ./\n```\n\n该指令将数据集相关文件拷贝到build/output目录下。\n\n然后进行数据导入：\n```bash\n./lgraph_import -c ./data/algo/cora.conf --dir ./coradb --overwrite 1\n```\n其中cora.conf为图schema文件，代表图数据的格式,可参考test/integration/data/algo/cora.conf。coradb为导入后的图数据文件名称，代表图数据的存储位置。\n\n## 4. feature特征转换\n由于Cora数据集中的feature特征为长度为1433的float类型数组，TuGraph暂不支持float数组类型加载，因此可将其按照string类型导入后，转换成char*方便后续存取，具体实现可参考feature_float.cpp文件。\n具体执行过程如下："
            },
            {
                "content": "在build/output目录下执行：\n```bash\ncp -r ../../test/integration/data/ ./ && cp -r ../../learn/examples/* ./\n```\n\n该指令将数据集相关文件拷贝到build/output目录下。\n\n然后进行数据导入：\n```bash\n./lgraph_import -c ./data/algo/cora.conf --dir ./coradb --overwrite 1\n```\n其中cora.conf为图schema文件，代表图数据的格式,可参考test/integration/data/algo/cora.conf。coradb为导入后的图数据文件名称，代表图数据的存储位置。\n\n## 4. feature特征转换\n由于Cora数据集中的feature特征为长度为1433的float类型数组，TuGraph暂不支持float数组类型加载，因此可将其按照string类型导入后，转换成char*方便后续存取，具体实现可参考feature_float.cpp文件。\n具体执行过程如下：\n\n在build目录下编译导入plugin(如果TuGraph已编译可跳过)：\n`make feature_float_embed`\n\n在build/output目录下执行\n`./algo/feature_float_embed ./coradb`\n即可进行转换。\n\n## 5. 编译采样算子\n采样算子用于从数据库中获取图数据并转换成所需数据结构，具体执行过程如下(如果TuGraph已编译，可跳过此步骤)：\n在tugraph-db/build文件夹下执行\n`make -j2`\n\n或在tugraph-db/learn/procedures文件夹下执行\n`python3 setup.py build_ext -i`"
            },
            {
                "content": "## 4. feature特征转换\n由于Cora数据集中的feature特征为长度为1433的float类型数组，TuGraph暂不支持float数组类型加载，因此可将其按照string类型导入后，转换成char*方便后续存取，具体实现可参考feature_float.cpp文件。\n具体执行过程如下：\n\n在build目录下编译导入plugin(如果TuGraph已编译可跳过)：\n`make feature_float_embed`\n\n在build/output目录下执行\n`./algo/feature_float_embed ./coradb`\n即可进行转换。\n\n## 5. 编译采样算子\n采样算子用于从数据库中获取图数据并转换成所需数据结构，具体执行过程如下(如果TuGraph已编译，可跳过此步骤)：\n在tugraph-db/build文件夹下执行\n`make -j2`\n\n或在tugraph-db/learn/procedures文件夹下执行\n`python3 setup.py build_ext -i`\n\n```python\nfrom lgraph_db_python import *  # 导入tugraph-db的python接口模块\nimport importlib  # 导入importlib模块\ngetdb = importlib.import_module(\"getdb\")  #获取getdb算子\ngetdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo) #调用getdb算子\n```\n\n如代码所示，得到算子so文件后，import 导入使用。\n\n## 6. 模型训练及保存\nTuGraph在python层调用cython层的算子，实现图学习模型的训练。\n使用 TuGraph 图学习模块使用方式介绍如下:\n在build/output文件夹下执行\n`python3 train_full_cora.py --model_save_path ./cora_model`\n即可进行训练。\n最终打印loss数值小于0.9，即为训练成功。至此，图模型训练完成，模型保存在cora_model文件。"
            },
            {
                "content": "```python\nfrom lgraph_db_python import *  # 导入tugraph-db的python接口模块\nimport importlib  # 导入importlib模块\ngetdb = importlib.import_module(\"getdb\")  #获取getdb算子\ngetdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo) #调用getdb算子\n```\n\n如代码所示，得到算子so文件后，import 导入使用。\n\n## 6. 模型训练及保存\nTuGraph在python层调用cython层的算子，实现图学习模型的训练。\n使用 TuGraph 图学习模块使用方式介绍如下:\n在build/output文件夹下执行\n`python3 train_full_cora.py --model_save_path ./cora_model`\n即可进行训练。\n最终打印loss数值小于0.9，即为训练成功。至此，图模型训练完成，模型保存在cora_model文件。\n\n训练详细过程如下：\n### 6.1.数据加载\n```python\ngalaxy = PyGalaxy(args.db_path)\ngalaxy.SetCurrentUser(args.username, args.password)\ndb = galaxy.OpenGraph(args.graph_name, False)\n```\n如代码所示，根据图数据路径、用户名、密码和子图名称将数据加载到内存中。TuGraph可以载入多个子图用于图训练，在此处我们只载入一个子图。\n\n### 6.2.构建采样器\n训练过程中，首先使用GetDB算子从数据库中获取图数据并转换成所需数据结构，具体代码如下：\n```python\n    GetDB.Process(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n如代码所示，结果存储在NodeInfo和EdgeInfo中。NodeInfo和EdgeInfo是python list结果，其存储的信息结果如下："
            },
            {
                "content": "### 6.2.构建采样器\n训练过程中，首先使用GetDB算子从数据库中获取图数据并转换成所需数据结构，具体代码如下：\n```python\n    GetDB.Process(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n如代码所示，结果存储在NodeInfo和EdgeInfo中。NodeInfo和EdgeInfo是python list结果，其存储的信息结果如下：\n\n| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n\n然后构建采样器\n```python\n    batch_size = 5\n    count = 2708\n    sampler = TugraphSample(args)\n    dataloader = dgl.dataloading.DataLoader(fake_g,\n        torch.arange(count),\n        sampler,\n        batch_size=batch_size,\n        num_workers=0,\n        )\n```"
            },
            {
                "content": "| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n\n然后构建采样器\n```python\n    batch_size = 5\n    count = 2708\n    sampler = TugraphSample(args)\n    dataloader = dgl.dataloading.DataLoader(fake_g,\n        torch.arange(count),\n        sampler,\n        batch_size=batch_size,\n        num_workers=0,\n        )\n```\n\n### 6.3.对结果进行格式转换\n```python\n    src = EdgeInfo[0].astype('int64')\n    dst = EdgeInfo[1].astype('int64')\n    nodes_idx = NodeInfo[0].astype('int64')\n    remap(src, dst, nodes_idx)\n    features = NodeInfo[1].astype('float32')\n    labels = NodeInfo[2].astype('int64')\n    g = dgl.graph((src, dst))\n    g.ndata['feat'] = torch.tensor(features)\n    g.ndata['label'] = torch.tensor(labels)\n    return g\n```\n对结果进行格式转换，使之符合训练格式"
            },
            {
                "content": "### 6.3.对结果进行格式转换\n```python\n    src = EdgeInfo[0].astype('int64')\n    dst = EdgeInfo[1].astype('int64')\n    nodes_idx = NodeInfo[0].astype('int64')\n    remap(src, dst, nodes_idx)\n    features = NodeInfo[1].astype('float32')\n    labels = NodeInfo[2].astype('int64')\n    g = dgl.graph((src, dst))\n    g.ndata['feat'] = torch.tensor(features)\n    g.ndata['label'] = torch.tensor(labels)\n    return g\n```\n对结果进行格式转换，使之符合训练格式\n\n### 6.4.构建GCN模型\n```python\nclass GCN(nn.Module):\n    def __init__(self, in_size, hid_size, out_size):\n        super().__init__()\n        self.layers = nn.ModuleList()\n        # two-layer GCN\n        self.layers.append(dgl.nn.GraphConv(in_size, hid_size, activation=F.relu))\n        self.layers.append(dgl.nn.GraphConv(hid_size, out_size))\n        self.dropout = nn.Dropout(0.5)\n\n    def forward(self, g, features):\n        h = features\n        for i, layer in enumerate(self.layers):\n            if i != 0:\n                h = self.dropout(h)\n            h = layer(g, h)\n        return h"
            },
            {
                "content": "def forward(self, g, features):\n        h = features\n        for i, layer in enumerate(self.layers):\n            if i != 0:\n                h = self.dropout(h)\n            h = layer(g, h)\n        return h\n\ndef build_model():\n    in_size = feature_len  #feature_len为feature的长度，在此处为1433\n    out_size = classes  #classes为类别数，在此处为7\n    model = GCN(in_size, 16, out_size)  #16为隐藏层大小\n    return model\n```\n本教程将构建一个两层图卷积网络（GCN）。每层通过聚合邻居信息来计算新的点表示。"
            },
            {
                "content": "### 6.5.训练GCN模型\n```python\nloss_fcn = nn.CrossEntropyLoss()\ndef train(graph, model, model_save_path):\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-2, weight_decay=5e-4)\n    model.train()\n    s = time.time()\n    load_time = time.time()\n    graph = dgl.add_self_loop(graph)\n    logits = model(graph, graph.ndata['feat'])\n    loss = loss_fcn(logits, graph.ndata['label'])\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n    train_time = time.time()\n    current_loss = float(loss)\n    if model_save_path != \"\":   #如果需要保存模型，则给出模型保存路径\n        if 'min_loss' not in train.__dict__:\n            train.min_loss = current_loss\n        elif current_loss < train.min_loss:\n            train.min_loss = current_loss\n            model_save_path = 'best_model.pth'\n        torch.save(model.state_dict(), model_save_path)\n    return current_loss"
            },
            {
                "content": "for epoch in range(50):\n    model.train()\n    total_loss = 0\n    loss = train(g, model)\n    if epoch % 5 == 0:\n        print('In epoch', epoch, ', loss', loss)\n    sys.stdout.flush()\n```\n如代码所示，根据定义好的采样器、优化器和模型进行迭代训练50次，训练后的模型保存至model_save_path路径中。\n\n输出结果如下：\n```bash\nIn epoch 0 , loss 1.9586775302886963\nIn epoch 5 , loss 1.543689250946045\nIn epoch 10 , loss 1.160698413848877\nIn epoch 15 , loss 0.8862786889076233\nIn epoch 20 , loss 0.6973256468772888\nIn epoch 25 , loss 0.5770673751831055\nIn epoch 30 , loss 0.5271289348602295\nIn epoch 35 , loss 0.45514997839927673\nIn epoch 40 , loss 0.43748989701271057\nIn epoch 45 , loss 0.3906335234642029\n```\n\n同时，图学习模块可采用GPU进行加速，用户如果需要再GPU上运行，需要用户自行安装相应的GPU驱动和环境。具体可参考learn/README.md。\n\n完整代码可参考learn/examples/train_full_cora.py"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/13.best-practices/3.data_migration.md",
        "chunks": [
            {
                "content": "# 数据迁移\n\n## 1. 简介\n   数据迁移是指将数据从一个系统、存储介质或应用程序迁移到另一个系统、存储介质或应用程序的过程。当TuGraph要升级或者系统硬件环境发生变化时，\n需要对原TuGraph服务中的数据进行迁移。以系统硬件环境和软件版本为依据进行划分，本文将数据迁移分为三种方案：\n1. 兼容迁移：当迁移前后系统环境一致且TuGraph软件兼容时，可以直接使用备份恢复的方式迁移数据；\n2. 升级迁移：当迁移前后系统环境不一致或TuGraph软件不兼容时，需要使用先导出数据再重新导入的方式迁移数据；\n3. 在线迁移：当对高可用集群进行数据迁移且集群网络环境良好时，可以使用增删节点的的方式将原集群平滑切换到新集群。\n接下来本文将详细介绍这三种方案。\n\n## 2. 兼容迁移\n兼容迁移指的是在系统环境不变，且TuGraph软件版本兼容时，原服务的数据和存储过程可以在新服务中使用，所以可以直接迁移。\n用户可以先使用`lgraph_backup`工具备份数据，然后将数据传输到新机器中并重启服务。具体迁移步骤如下：\n\n### 2.1. 备份数据\n使用`lgraph_backup`工具备份数据\n```bash\n  lgraph_backup -s db -d db.bck\n```\n本步骤也可以直接使用`cp`命令，不过`cp`命令会拷贝一些多余的元数据，HA模式下也会拷贝raft的元数据导致迁移之后集群重启失败，\n因此建议数据迁移时使用`lgraph_backup`工具替代`cp`命令。\n\n### 2.2. 启动新服务\n使用如下命令启动新服务，存储过程会自动加载到新服务中\n```bash\n  lgraph_server -c /usr/local/etc/lgraph.json --directory db.bck -d start\n```\n\n### 2.3. 停止原服务\n使用如下命令停止原服务\n```bash\n  lgraph_server -c /usr/local/etc/lgraph.json --directory db.bck -d stop\n```"
            },
            {
                "content": "### 2.1. 备份数据\n使用`lgraph_backup`工具备份数据\n```bash\n  lgraph_backup -s db -d db.bck\n```\n本步骤也可以直接使用`cp`命令，不过`cp`命令会拷贝一些多余的元数据，HA模式下也会拷贝raft的元数据导致迁移之后集群重启失败，\n因此建议数据迁移时使用`lgraph_backup`工具替代`cp`命令。\n\n### 2.2. 启动新服务\n使用如下命令启动新服务，存储过程会自动加载到新服务中\n```bash\n  lgraph_server -c /usr/local/etc/lgraph.json --directory db.bck -d start\n```\n\n### 2.3. 停止原服务\n使用如下命令停止原服务\n```bash\n  lgraph_server -c /usr/local/etc/lgraph.json --directory db.bck -d stop\n```\n\n## 3. 升级迁移\n当用户要把原始服务迁移到一个差异化环境中（比如从centos7迁移到ubuntu18.04），或者TuGraph版本变化较大前后不兼容时（如3.4.0和3.6.0），\n用户可以先使用`lgraph_export`工具将数据导出成文件，传输到新机器中，再使用`lgraph_import`工具重新导入并重启集群。\n这样可以保证在新环境上能够使用，但是效率较低，存储过程也需要重新加载。具体的迁移步骤如下：\n\n### 3.1. 导出数据\n使用`lgraph_export`工具导出数据，并将数据传输到新机器上\n```bash\n  lgraph_export -d db -e db.export\n```\n\n### 3.2. 导入数据\n使用`lgraph_import`工具导入数据，并手动加载存储过程（详见[client操作步骤](../7.client-tools/2.cpp-client.md)）\n```bash\n  lgraph_import -c db.export/import.config -d db\n```\n\n### 3.3. 启动新服务\n使用如下命令启动新服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d start\n```"
            },
            {
                "content": "### 3.1. 导出数据\n使用`lgraph_export`工具导出数据，并将数据传输到新机器上\n```bash\n  lgraph_export -d db -e db.export\n```\n\n### 3.2. 导入数据\n使用`lgraph_import`工具导入数据，并手动加载存储过程（详见[client操作步骤](../7.client-tools/2.cpp-client.md)）\n```bash\n  lgraph_import -c db.export/import.config -d db\n```\n\n### 3.3. 启动新服务\n使用如下命令启动新服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d start\n```\n\n### 3.4. 停止原服务\n使用如下命令停止原服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d stop\n```\n\n## 4. 在线迁移\n当对TuGraph高可用版本部署的服务器集群进行数据迁移时，如果网络带宽充足，可以直接使用增删节点的方式对服务进行在线迁移。具体迁移步骤如下所示："
            },
            {
                "content": "### 3.2. 导入数据\n使用`lgraph_import`工具导入数据，并手动加载存储过程（详见[client操作步骤](../7.client-tools/2.cpp-client.md)）\n```bash\n  lgraph_import -c db.export/import.config -d db\n```\n\n### 3.3. 启动新服务\n使用如下命令启动新服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d start\n```\n\n### 3.4. 停止原服务\n使用如下命令停止原服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d stop\n```\n\n## 4. 在线迁移\n当对TuGraph高可用版本部署的服务器集群进行数据迁移时，如果网络带宽充足，可以直接使用增删节点的方式对服务进行在线迁移。具体迁移步骤如下所示：\n\n### 4.1. 拷贝数据\n使用如下命令拷贝leader节点上的数据，并且传输到新集群的机器节点上。由于leader节点上有最完整的raft日志，拷贝leader的数据可以最大程度地减少\n日志追赶的时间。\n```bash\n  cp -r db db.cp\n```\n### 4.2. 启动新节点\n使用如下命令将新节点加入集群，加入集群后，增量数据自动同步到新节点\n```bash\n  lgraph_server -c /usr/local/etc/lgraph_ha.json --directory db.cp --ha_conf 192.168.0.1:9090,192.168.0.2:9090,192.168.0.3:9090 -d start\n```\n### 4.3. 停止原节点\n停止原节点服务，后续应用请求直接发给新集群\n```bash\n  lgraph_server -c /usr/local/etc/lgraph_ha.json --directory db.cp --ha_conf 192.168.0.1:9090,192.168.0.2:9090,192.168.0.3:9090 -d stop\n```"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/13.best-practices/4.selection.md",
        "chunks": [
            {
                "content": "# 环境和版本选择\n\n> 该文档介绍如何选择系统环境，以及部署方式\n\n## 1. 简介\n\nTuGraph为不同需求的用户提供了差异化的系统环境和部署方式，来满足新手、系统开发者、生产运维人员、研究人员等不同用户的需求。\n\n## 2. 环境能力选择\n\n用户可以根据实际使用场景，来选择不同的环境。编译环境的能力最完备，所需的第三方软件也越多。与其相对应的，精简运行环境几乎不需要安装任何依赖库，能运行TuGraph除存储过程外的基础功能。\n\n| 环境     | 用途             | 备注        |\n|--------|----------------|-----------|\n| 编译环境   | 从源码编译TuGraph   | 适用于开发人员   |\n| 运行环境   | 运行TuGraph安装包   | 适用于大部分用户  |\n| 精简运行环境 | 运行精简TuGraph安装包 | 对系运行统依赖较小 |\n\n不同环境的具体介绍参见 [链接](../5.installation&running/2.environment-mode.md)。\n\n## 3. 部署方式选择\n\nTuGraph部署仅需一台服务器（高可用模式需要多台），可根据实际资源情况和使用场景，选择适合的部署方式。"
            },
            {
                "content": "| 环境     | 用途             | 备注        |\n|--------|----------------|-----------|\n| 编译环境   | 从源码编译TuGraph   | 适用于开发人员   |\n| 运行环境   | 运行TuGraph安装包   | 适用于大部分用户  |\n| 精简运行环境 | 运行精简TuGraph安装包 | 对系运行统依赖较小 |\n\n不同环境的具体介绍参见 [链接](../5.installation&running/2.environment-mode.md)。\n\n## 3. 部署方式选择\n\nTuGraph部署仅需一台服务器（高可用模式需要多台），可根据实际资源情况和使用场景，选择适合的部署方式。\n\n| 部署方式     | 描述                   | 备注                                                                                      |\n|----------|----------------------|-----------------------------------------------------------------------------------------|\n| 云部署      | 阿里云计算巢一键部署，免费试用      | 新手适用，流程参考 [链接](../5.installation&running/5.cloud-deployment.md)              |\n| Docker部署 | 通过预先准备的Docker镜像跨平台部署 | 对硬件有要求的用户，比如性能测试，流程参考 [链接](../5.installation&running/3.docker-deployment.md) |\n| 本地部署     | 在现有系统紧耦合部署           | 指定生产环境适用，流程参考 [链接](../5.installation&running/4.local-package-deployment.md)  |\n\n## 4. 后续步骤"
            },
            {
                "content": "## 4. 后续步骤\n\n部署完成后，后续可以进行[启动服务](../5.installation&running/7.tugraph-running.md)、[数据导入](../6.utility-tools/1.data-import.md)等操作，也可以通过[样例数据](../3.quick-start/2.demo/1.movie.md)来体验整个流程。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/13.best-practices/5.spatial.md",
        "chunks": [
            {
                "content": "# 地理空间数据类型使用示例\n\n## 1. 简介\n\nTuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群。近年来，地理空间功能在图数据库中的应用价值显著，它不仅增强了数据的表达能力，还促进了跨领域数据的融合分析，尤其在社交网络、地图探索、城市规划等关键领域展现了强大的实用价值。TuGraph也正在逐步支持地理空间功能。\n\n## 2. 预备知识\n\nEPSG([EPSG.io: Coordinate Systems Worldwide](https://epsg.io/)) 是一个标准化的地理空间参考系统标识符集合， 用于标识不同的地理空间参考系统，包括坐标系统、地理坐标系、投影坐标系等。我们常用EPSG编码表示数据的坐标系，这里我们介绍两种最常见的空间地理坐标系，也是大部分数据库支持的坐标系类型。\n\n### 2.1 WGS84坐标系 EPSG: 4326\n\n全球GPS定位系统: WGS84是全球定位系统(GPS)的基础，允许全球的GPS接收器确定精确位置。几乎所有现代GPS设备都是基于WGS84坐标系来提供位置信息。地图制作和地理信息系统(GIS): 在地图制作和GIS领域，WGS84被广泛用于定义地球上的位置。这包括各种类型的地图创建、空间数据分析和管理等。![image.png](../../../images/spatail/EPSG_4326.png)\n\n### 2.2 Cartesian(笛卡尔)坐标系 EPSG: 7203\n\n直角坐标系，是一种最基本、最广泛应用的坐标系统。它通过两条数轴定义一个平面，三条数轴定义一个空间，这些轴互相垂直，在数学、物理、工程、天文和许多其他领域中有着广泛的应用。![image.png](../../../images/spatail/EPSG_7203.png)\n\n### 2.3 数据存储格式\n\nOGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为WKT与WKB格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。其中WKT(well-kown text)格式, 是一种文本标记语言,易于人类阅读和编写，而WKB(Well-Known Binary)格式采用一系列字节来编码空间数据，更适合在计算机中存储;\n\n**WKT:**"
            },
            {
                "content": "### 2.2 Cartesian(笛卡尔)坐标系 EPSG: 7203\n\n直角坐标系，是一种最基本、最广泛应用的坐标系统。它通过两条数轴定义一个平面，三条数轴定义一个空间，这些轴互相垂直，在数学、物理、工程、天文和许多其他领域中有着广泛的应用。![image.png](../../../images/spatail/EPSG_7203.png)\n\n### 2.3 数据存储格式\n\nOGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为WKT与WKB格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。其中WKT(well-kown text)格式, 是一种文本标记语言,易于人类阅读和编写，而WKB(Well-Known Binary)格式采用一系列字节来编码空间数据，更适合在计算机中存储;\n\n**WKT:**\n\n```\nPOINT( )\nLINESTRING( , , ...)\n```\n\nWKT格式的数据如上例所示，先指定空间数据类型，再在括号内指定具体的坐标，一个坐标对表示一个点，每个坐标对之间用逗号隔开。对于Polygon类型的数据，第一个坐标对需要与最后一个坐标对相同，形成闭合的面。\n\n**WKB:**\n\n![image.png](../../../images/spatail/WKB.png)\n\n\n针对EWKB格式的编码，说明如下:\n\n- 第0 - 1位: 编码方式;\n- 第2 - 5位: 空间数据类型;\n    - 0100: point\n    - 0200: linestring\n    - 0300: polygon\n- 第6 - 9位: 数据维度;\n    - 0020: 二维\n    - 0030: 三维\n- 第10 - 17位: 坐标系的EPSG编码;\n- 第18 - n位: double类型的坐标对的16进制表示。\n\n### 2.4 常用函数"
            },
            {
                "content": "### 2.4 常用函数\n\n| Name                 | Description           | Signature                                                                 |\n|----------------------|-----------------------|---------------------------------------------------------------------------|\n| `dbms.graph.createGraph` | 创建子图           | `dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)` |\n| `db.createVertexLabel`  | 创建Vertex Label      | `db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)`      |\n| `db.getLabelSchema`     | 列出label schema      | `db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)` |\n| `db.deleteLabel`        | 删除Vertex            | `db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)`         |\n\n更完整详细的函数使用以及插入数据的语句，可以参考 [Cypher API](../8.query/1.cypher.md)\n\n## 3. 数据类型\n\n目前在TuGraph中，我们已经支持了Point, Linestring与Polygon三种类型:"
            },
            {
                "content": "更完整详细的函数使用以及插入数据的语句，可以参考 [Cypher API](../8.query/1.cypher.md)\n\n## 3. 数据类型\n\n目前在TuGraph中，我们已经支持了Point, Linestring与Polygon三种类型:\n\n- Point：点    point(2.0, 2.0, 7203)\n- Linestring：折线 LINESTRING(0 2,1 1,2 0)\n- Polygon：多边形  POLYGON((0 0,0 7,4 2,2 0,0 0))\n\n其中坐标点都是double型，创建图模型和插入数据示例如下：\n\n**创建标记美食位置的点模型**\n\n```\nCALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true) \n```\n\n![image.png](../../../images/spatail/createVertexLabel.png)\n\n**插入标记美食点的数据**\n\n```\n CREATE (n:food {id:10001, name: 'aco Bell',pointTest:point(3.0,4.0,7203)}) RETURN n\n```\n\n![image.png](../../../images/spatail/createFoodData.png)\n\n**创建具有折线属性的点模型**\n\n```\nCALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)\n```\n\n![image.png](../../../images/spatail/createVertexLabel_lineTest.png)\n\n**插入具有折线属性的点数据**\n\n```\nCREATE (n:lineTest {id:102, name: 'Tom',linestringTest:linestringwkt('LINESTRING(0 2,1 1,2 0)', 7203)}) RETURN n\n```"
            },
            {
                "content": "```\n CREATE (n:food {id:10001, name: 'aco Bell',pointTest:point(3.0,4.0,7203)}) RETURN n\n```\n\n![image.png](../../../images/spatail/createFoodData.png)\n\n**创建具有折线属性的点模型**\n\n```\nCALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)\n```\n\n![image.png](../../../images/spatail/createVertexLabel_lineTest.png)\n\n**插入具有折线属性的点数据**\n\n```\nCREATE (n:lineTest {id:102, name: 'Tom',linestringTest:linestringwkt('LINESTRING(0 2,1 1,2 0)', 7203)}) RETURN n\n```\n\n![image.png](../../../images/spatail/createLineTestData.png)\n\n**创建具有多边型属性的点模型**\n\n```\nCALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)\n```\n\n![image.png](../../../images/spatail/createVertexLabel_PolygonTest.png)\n\n**插入具有多边型属性的点数据**\n\n```\nCREATE (n:polygonTest {id:103, name: 'polygonTest',polygonTest:polygonwkt('POLYGON((0 0,0 7,4 2,2 0,0 0))', 7203)}) RETURN n\n```\n\n## 4. 函数介绍"
            },
            {
                "content": "![image.png](../../../images/spatail/createLineTestData.png)\n\n**创建具有多边型属性的点模型**\n\n```\nCALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)\n```\n\n![image.png](../../../images/spatail/createVertexLabel_PolygonTest.png)\n\n**插入具有多边型属性的点数据**\n\n```\nCREATE (n:polygonTest {id:103, name: 'polygonTest',polygonTest:polygonwkt('POLYGON((0 0,0 7,4 2,2 0,0 0))', 7203)}) RETURN n\n```\n\n## 4. 函数介绍\n\n| 函数名  | 描述 | 输入参数                         | 返回值类型 |\n| --- | --- |------------------------------| --- |\n| Distance() | 计算两个空间数据间的距离(要求坐标系相同) | Spatial data1, Spatial data2 | double |\n| Disjoint()  |  判断两个空间数据是否相交（开发中） | Spatial data1, Spatial data2 | bool |\n| WithinBBox() | 判断某个空间数据是否在给定的长方形区域内（开发中） | Spatial data, Point1         | bool |\n\n## 5. 美食探索\n### 5.1 基于地理位置的个性化推荐\n\n在本章节中，我们将探索如何利用Tugraph图数据库的地理空间功能，构建一个生动有趣的美食探索应用，将“人”与“美食”通过地理位置紧密相连，实现个性化美食推荐。想象一下，无论身处何方，只需轻轻一点，周围诱人美食便尽收眼底，这正是我们即将构建的场景魅力所在。\n\n### 5.2 数据模型设计\n我们首先定义两种核心节点类型："
            },
            {
                "content": "## 5. 美食探索\n### 5.1 基于地理位置的个性化推荐\n\n在本章节中，我们将探索如何利用Tugraph图数据库的地理空间功能，构建一个生动有趣的美食探索应用，将“人”与“美食”通过地理位置紧密相连，实现个性化美食推荐。想象一下，无论身处何方，只需轻轻一点，周围诱人美食便尽收眼底，这正是我们即将构建的场景魅力所在。\n\n### 5.2 数据模型设计\n我们首先定义两种核心节点类型：\n\n- Food（美食）节点：每一家餐厅或小吃店都可以作为一个Food节点，其属性包括但不限于名称、地址、评分、美食类别等。特别地，我们将在每个Food节点上附加地理坐标信息，用以精确记录其地理位置。\n\n```\n CALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true,'mark',double,true)\n```\n\n准备数据："
            },
            {
                "content": "### 5.2 数据模型设计\n我们首先定义两种核心节点类型：\n\n- Food（美食）节点：每一家餐厅或小吃店都可以作为一个Food节点，其属性包括但不限于名称、地址、评分、美食类别等。特别地，我们将在每个Food节点上附加地理坐标信息，用以精确记录其地理位置。\n\n```\n CALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true,'mark',double,true)\n```\n\n准备数据：\n\n```\nCREATE (n:food {id:10001, name: 'Starbucks',pointTest:point(1.0,1.0,7203),mark:4.8}) RETURN n\nCREATE (n:food {id:10002, name: 'KFC',pointTest:point(2.0,1.0,7203),mark:4.5}) RETURN n\nCREATE (n:food {id:10003, name: 'Pizza Hut',pointTest:point(2.0,5.0,7203),mark:4.5}) RETURN n\nCREATE (n:food {id:10004, name: 'Taco Bell',pointTest:point(3.0,4.0,7203),mark:4.7}) RETURN n\nCREATE (n:food {id:10005, name: 'Pizza Fusion',pointTest:point(5.0,3.0,7203),mark:4.9}) RETURN n\nCREATE (n:food {id:10006, name: 'HaiDiLao Hot Pot',pointTest:point(2.0,2.0,7203),mark:4.8}) RETURN n\nCREATE (n:food {id:10007, name: 'Lao Sze Chuan',pointTest:point(4.0,3.0,7203),mark:4.7}) RETURN n\n```\n\n- Person（人物）节点：代表应用的用户，属性包含用户名、当前位置等。用户的当前位置同样通过地理坐标表示，便于后续的地理空间查询。"
            },
            {
                "content": "- Person（人物）节点：代表应用的用户，属性包含用户名、当前位置等。用户的当前位置同样通过地理坐标表示，便于后续的地理空间查询。\n\n```\n CALL db.createVertexLabel('person', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true)\n```\n\n准备数据：\n\n```\n CREATE (n:person {id:1, name: 'Tom',pointTest:point(3.0,3.0,7203)}) RETURN n\n```\n\n### 5.3 构建美食探索查询\n\n能够根据用户的当前位置，寻找距离2.5以内的美食,根据距离进行升序排列。返回距离和评分让用户得倒更好的体验。\n\n**查询语句**\n\n```\nmatch (n:person{id:1}),(m:food) with n.pointTest as p1,m.pointTest as p2,m.name as food,m.mark as mark\nCALL spatial.distance(p1,p2) YIELD distance \nWHERE distance<2.5\nRETURN food,distance,mark ORDER by distance\n```\n\n![image.png](../../../images/spatail/querryFood.png)\n\n此查询首先匹配特定的Person节点（以用户名“Tom”为例），然后找到所有Food节点，利用自定义的distance函数，计算Person节点当前位置与每个Food节点之间的直线距离，筛选出距离在2.5之内的美食。最后，按照美食的距离升序排列结果，附带评分参考，为用户提供最优质的推荐。\n\n## 6. 展望\n\n通过上述章节，我们不仅展示了TuGraph在地理空间数据处理的能力，也描绘了一个富有吸引力的美食探索场景，证明了图数据库在结合地理位置信息进行个性化服务方面具有巨大潜力。无论是寻找周末的休闲去处，还是探索旅行途中的特色美食，这样的应用都将极大地丰富人们的生活体验。\n\nTuGraph将来会继续实现Disjoint() 、WithinBBox()，会丰富更多使用场景。当然，也欢迎大家一起参与，共同开发地理空间功能。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/TuGraph-family/tugraph-db/refs/heads/master/docs/zh-CN/source/15.contacts.md",
        "chunks": [
            {
                "content": "# 联系方式\n\n您有任何对产品的意见和建议，欢迎通过以下联系方式加入讨论，或提出建议。\n\n官网: [tugraph.tech](https://tugraph.tech)\n\nGithub Issue (错误反馈、功能讨论)\n[Issue](https://github.com/TuGraph-db/tugraph-db/issues)\n\nGithub Discussions (技术讨论)\n[Discussions](https://github.com/TuGraph-db/tugraph-db/discussions)\n\nSlack (在线开发沟通):\n[TuGraph.slack](https://join.slack.com/t/tugraph/shared_invite/zt-1hha8nuli-bqdkwn~w4zH1vlk0QvqIfg)\n\n通过钉钉群、微信群、微信公众号、邮箱和电话联系我们:\n![contacts](../../images/contact-zh.png)"
            }
        ]
    }
]